contract main {




// =====================  Runtime code  =====================


#
#  - transferFrom(address arg1, address arg2, uint256 arg3)
#  - _fallback()
#
const decimals = 18


address owner;
mapping of uint256 balanceOf;
mapping of uint256 allowance;
uint256 totalSupply;
array of struct stor4;
array of struct stor5;
address uniswapV2RouterAddress;
address uniswapV2PairAddress;
address sub_dc4e5c71Address;
address sub_8230af5aAddress;
uint8 stor10; offset 160
address dogeAddress;
uint256 swapTokensAtAmount;
address stor12;
address stor13;
mapping of uint8 stor14;
mapping of uint8 stor15;
uint8 swapAndLiquifyEnabled;
uint256 startTime;
uint256 minBuyAmount;
mapping of uint8 stor20;

function uniswapV2Router() {
    return uniswapV2RouterAddress
}

function totalSupply() {
    return totalSupply
}

function doge() {
    return dogeAddress
}

function uniswapV2Pair() {
    return uniswapV2PairAddress
}

function swapAndLiquifyEnabled() {
    return bool(swapAndLiquifyEnabled)
}

function isExcludedFromFees(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return bool(stor14[address(arg1)])
}

function balanceOf(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return balanceOf[address(arg1)]
}

function startTime() {
    return startTime
}

function sub_8230af5a(?) {
    return sub_8230af5aAddress
}

function owner() {
    return owner
}

function sub_910a8747(?) {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    return bool(stor20[arg1])
}

function automatedMarketMakerPairs(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return bool(stor15[arg1])
}

function sub_dc4e5c71(?) {
    return sub_dc4e5c71Address
}

function allowance(address arg1, address arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    return allowance[address(arg1)][address(arg2)]
}

function sub_dfe0c28e(?) {
    return stor19.length
}

function swapTokensAtAmount() {
    return swapTokensAtAmount
}

function minBuyAmount() {
    return minBuyAmount
}

function renounceOwnership() {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    emit OwnershipTransferred(owner, 0);
    owner = 0
}

function setSwapTokensAtAmount(uint256 arg1) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    swapTokensAtAmount = arg1
}

function sub_ef5bd939(?) {
    if startTime > -181:
        revert with 0, 17
    if startTime + 180 < startTime:
        revert with 0, 'SafeMath: addition overflow'
    return (startTime + 180 > block.timestamp)
}

function setSwapAndLiquifyEnabled(bool arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    swapAndLiquifyEnabled = uint8(arg1)
}

function updateUniswapV2Router(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    emit UpdateUniswapV2Router(arg1, uniswapV2RouterAddress);
    uniswapV2RouterAddress = arg1
}

function excludeFromFees(address arg1, bool arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    stor14[address(arg1)] = uint8(arg2)
    emit ExcludeFromFees(arg2, arg1);
}

function transferOwnership(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Ownable: new owner is the zero address'
    emit OwnershipTransferred(owner, arg1);
    owner = arg1
}

function approve(address arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if not msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve from the zero address'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve to the zero address'
    allowance[address(msg.sender)][address(arg1)] = arg2
    emit Approval(arg2, msg.sender, arg1);
    return 1
}

function rescueToken(address arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    require ext_code.size(arg1)
    call arg1.0xa9059cbb with:
         gas gas_remaining wei
        args msg.sender, arg2
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    return bool(ext_call.return_data[0])
}

function decreaseAllowance(address arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if arg2 > allowance[msg.sender][address(arg1)]:
        revert with 0, 32, 37, 0x6545524332303a2064656372656173656420616c6c6f77616e63652062656c6f77207a6572, mem[165 len 27] >> 40, 0
    if allowance[msg.sender][address(arg1)] < arg2:
        revert with 0, 17
    if not msg.sender:
        revert with 0, 'ERC20: approve from the zero address'
    if not arg1:
        revert with 0, 'ERC20: approve to the zero address'
    allowance[address(msg.sender)][address(arg1)] = allowance[msg.sender][address(arg1)] - arg2
    emit Approval((allowance[msg.sender][address(arg1)] - arg2), msg.sender, arg1);
    return 1
}

function increaseAllowance(address arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if allowance[msg.sender][address(arg1)] > !arg2:
        revert with 0, 17
    if allowance[msg.sender][address(arg1)] + arg2 < allowance[msg.sender][address(arg1)]:
        revert with 0, 'SafeMath: addition overflow'
    if not msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve from the zero address'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve to the zero address'
    allowance[address(msg.sender)][address(arg1)] = allowance[msg.sender][address(arg1)] + arg2
    emit Approval((allowance[msg.sender][address(arg1)] + arg2), msg.sender, arg1);
    return 1
}

function excludeMultipleAccountsFromFees(address[] arg1, bool arg2) {
    require calldata.size - 4 >= 64
    require arg1 <= test266151307()
    require arg1 + 35 < calldata.size
    require arg1.length <= test266151307()
    require arg1 + (32 * arg1.length) + 36 <= calldata.size
    require arg2 == arg2
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    idx = 0
    while idx < arg1.length:
        require cd[((32 * idx) + arg1 + 36)] == address(cd[((32 * idx) + arg1 + 36)])
        mem[0] = address(cd[((32 * idx) + arg1 + 36)])
        mem[32] = 14
        stor14[address(cd[((32 * idx) + arg1 + 36)])] = uint8(arg2)
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        continue 
    idx = 0
    s = 192
    t = arg1 + 36
    while idx < arg1.length:
        require cd[t] == address(cd[t])
        mem[s] = address(cd[t])
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    emit ExcludeMultipleAccountsFromFees(Array(len=arg1.length, data=mem[192 len 32 * arg1.length]), arg2);
}

function sub_6ad50b35(?) {
    mem[128] = this.address
    require ext_code.size(uniswapV2RouterAddress)
    staticcall uniswapV2RouterAddress.WETH() with:
            gas gas_remaining wei
    mem[224] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    mem[160] = ext_call.return_data[12 len 20]
    mem[192] = 0x7130d2a12b9bcbfae4f2634d864a1ee1ce3ead9c
    mem[ceil32(return_data.size) + 224] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
    mem[ceil32(return_data.size) + 228] = swapTokensAtAmount
    idx = 0
    s = ceil32(return_data.size) + 420
    t = 128
    while idx < 3:
        mem[s] = mem[t + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ext_code.size(uniswapV2RouterAddress)
    call uniswapV2RouterAddress.swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
         gas gas_remaining wei
        args swapTokensAtAmount, 0, 160, address(this.address), block.timestamp, 3, mem[ceil32(return_data.size) + 420 len 96]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}

function sub_7ece5056(?) {
    require calldata.size - 4 >= 32
    mem[128] = this.address
    require ext_code.size(uniswapV2RouterAddress)
    staticcall uniswapV2RouterAddress.WETH() with:
            gas gas_remaining wei
    mem[224] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    mem[160] = ext_call.return_data[12 len 20]
    mem[192] = 0x7130d2a12b9bcbfae4f2634d864a1ee1ce3ead9c
    mem[ceil32(return_data.size) + 224] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
    mem[ceil32(return_data.size) + 228] = arg1
    idx = 0
    s = ceil32(return_data.size) + 420
    t = 128
    while idx < 3:
        mem[s] = mem[t + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ext_code.size(uniswapV2RouterAddress)
    call uniswapV2RouterAddress.swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
         gas gas_remaining wei
        args arg1, 0, 160, address(this.address), block.timestamp, 3, mem[ceil32(return_data.size) + 420 len 96]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}

function sub_dccea26f(?) {
    require calldata.size - 4 >= 32
    mem[128] = this.address
    require ext_code.size(uniswapV2RouterAddress)
    staticcall uniswapV2RouterAddress.WETH() with:
            gas gas_remaining wei
    mem[192] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    mem[160] = ext_call.return_data[12 len 20]
    mem[ceil32(return_data.size) + 192] = 0x791ac94700000000000000000000000000000000000000000000000000000000
    mem[ceil32(return_data.size) + 196] = arg1
    idx = 0
    s = ceil32(return_data.size) + 388
    t = 128
    while idx < 2:
        mem[s] = mem[t + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ext_code.size(uniswapV2RouterAddress)
    call uniswapV2RouterAddress.swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
         gas gas_remaining wei
        args arg1, 0, 160, address(this.address), block.timestamp, 2, mem[ceil32(return_data.size) + 388 len 64]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    call stor12 with:
       value eth.balance(this.address) wei
         gas 2300 * is_zero(value) wei
}

function name() {
    if bool(stor4.length):
        if bool(stor4.length) == uint255(stor4.length) * 0.5 < 32:
            revert with 0, 34
        if bool(stor4.length):
            if bool(stor4.length) == uint255(stor4.length) * 0.5 < 32:
                revert with 0, 34
            if Mask(256, -1, stor4.length):
                if 31 < uint255(stor4.length) * 0.5:
                    mem[128] = uint256(stor4.field_0)
                    idx = 128
                    s = 0
                    while (uint255(stor4.length) * 0.5) + 96 > idx:
                        mem[idx + 32] = stor4[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor4.length), data=mem[128 len ceil32(uint255(stor4.length) * 0.5)])
                mem[128] = 256 * stor4.length.field_8
        else:
            if bool(stor4.length) == stor4.length.field_1 < 32:
                revert with 0, 34
            if stor4.length.field_1:
                if 31 < stor4.length.field_1:
                    mem[128] = uint256(stor4.field_0)
                    idx = 128
                    s = 0
                    while stor4.length.field_1 + 96 > idx:
                        mem[idx + 32] = stor4[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor4.length), data=mem[128 len ceil32(uint255(stor4.length) * 0.5)])
                mem[128] = 256 * stor4.length.field_8
        mem[ceil32(uint255(stor4.length) * 0.5) + 192 len ceil32(uint255(stor4.length) * 0.5)] = mem[128 len ceil32(uint255(stor4.length) * 0.5)]
        if ceil32(uint255(stor4.length) * 0.5) > uint255(stor4.length) * 0.5:
            mem[ceil32(uint255(stor4.length) * 0.5) + (uint255(stor4.length) * 0.5) + 192] = 0
        return Array(len=2 * Mask(256, -1, stor4.length), data=mem[128 len ceil32(uint255(stor4.length) * 0.5)], mem[(2 * ceil32(uint255(stor4.length) * 0.5)) + 192 len 2 * ceil32(uint255(stor4.length) * 0.5)]), 
    if bool(stor4.length) == stor4.length.field_1 < 32:
        revert with 0, 34
    if bool(stor4.length):
        if bool(stor4.length) == uint255(stor4.length) * 0.5 < 32:
            revert with 0, 34
        if Mask(256, -1, stor4.length):
            if 31 < uint255(stor4.length) * 0.5:
                mem[128] = uint256(stor4.field_0)
                idx = 128
                s = 0
                while (uint255(stor4.length) * 0.5) + 96 > idx:
                    mem[idx + 32] = stor4[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor4.length % 128, data=mem[128 len ceil32(stor4.length.field_1)])
            mem[128] = 256 * stor4.length.field_8
    else:
        if bool(stor4.length) == stor4.length.field_1 < 32:
            revert with 0, 34
        if stor4.length.field_1:
            if 31 < stor4.length.field_1:
                mem[128] = uint256(stor4.field_0)
                idx = 128
                s = 0
                while stor4.length.field_1 + 96 > idx:
                    mem[idx + 32] = stor4[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor4.length % 128, data=mem[128 len ceil32(stor4.length.field_1)])
            mem[128] = 256 * stor4.length.field_8
    mem[ceil32(stor4.length.field_1) + 192 len ceil32(stor4.length.field_1)] = mem[128 len ceil32(stor4.length.field_1)]
    if ceil32(stor4.length.field_1) > stor4.length.field_1:
        mem[ceil32(stor4.length.field_1) + stor4.length.field_1 + 192] = 0
    return Array(len=stor4.length % 128, data=mem[128 len ceil32(stor4.length.field_1)], mem[(2 * ceil32(stor4.length.field_1)) + 192 len 2 * ceil32(stor4.length.field_1)]), 
}

function symbol() {
    if bool(stor5.length):
        if bool(stor5.length) == uint255(stor5.length) * 0.5 < 32:
            revert with 0, 34
        if bool(stor5.length):
            if bool(stor5.length) == uint255(stor5.length) * 0.5 < 32:
                revert with 0, 34
            if Mask(256, -1, stor5.length):
                if 31 < uint255(stor5.length) * 0.5:
                    mem[128] = uint256(stor5.field_0)
                    idx = 128
                    s = 0
                    while (uint255(stor5.length) * 0.5) + 96 > idx:
                        mem[idx + 32] = stor5[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor5.length), data=mem[128 len ceil32(uint255(stor5.length) * 0.5)])
                mem[128] = 256 * stor5.length.field_8
        else:
            if bool(stor5.length) == stor5.length.field_1 < 32:
                revert with 0, 34
            if stor5.length.field_1:
                if 31 < stor5.length.field_1:
                    mem[128] = uint256(stor5.field_0)
                    idx = 128
                    s = 0
                    while stor5.length.field_1 + 96 > idx:
                        mem[idx + 32] = stor5[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor5.length), data=mem[128 len ceil32(uint255(stor5.length) * 0.5)])
                mem[128] = 256 * stor5.length.field_8
        mem[ceil32(uint255(stor5.length) * 0.5) + 192 len ceil32(uint255(stor5.length) * 0.5)] = mem[128 len ceil32(uint255(stor5.length) * 0.5)]
        if ceil32(uint255(stor5.length) * 0.5) > uint255(stor5.length) * 0.5:
            mem[ceil32(uint255(stor5.length) * 0.5) + (uint255(stor5.length) * 0.5) + 192] = 0
        return Array(len=2 * Mask(256, -1, stor5.length), data=mem[128 len ceil32(uint255(stor5.length) * 0.5)], mem[(2 * ceil32(uint255(stor5.length) * 0.5)) + 192 len 2 * ceil32(uint255(stor5.length) * 0.5)]), 
    if bool(stor5.length) == stor5.length.field_1 < 32:
        revert with 0, 34
    if bool(stor5.length):
        if bool(stor5.length) == uint255(stor5.length) * 0.5 < 32:
            revert with 0, 34
        if Mask(256, -1, stor5.length):
            if 31 < uint255(stor5.length) * 0.5:
                mem[128] = uint256(stor5.field_0)
                idx = 128
                s = 0
                while (uint255(stor5.length) * 0.5) + 96 > idx:
                    mem[idx + 32] = stor5[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor5.length % 128, data=mem[128 len ceil32(stor5.length.field_1)])
            mem[128] = 256 * stor5.length.field_8
    else:
        if bool(stor5.length) == stor5.length.field_1 < 32:
            revert with 0, 34
        if stor5.length.field_1:
            if 31 < stor5.length.field_1:
                mem[128] = uint256(stor5.field_0)
                idx = 128
                s = 0
                while stor5.length.field_1 + 96 > idx:
                    mem[idx + 32] = stor5[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor5.length % 128, data=mem[128 len ceil32(stor5.length.field_1)])
            mem[128] = 256 * stor5.length.field_8
    mem[ceil32(stor5.length.field_1) + 192 len ceil32(stor5.length.field_1)] = mem[128 len ceil32(stor5.length.field_1)]
    if ceil32(stor5.length.field_1) > stor5.length.field_1:
        mem[ceil32(stor5.length.field_1) + stor5.length.field_1 + 192] = 0
    return Array(len=stor5.length % 128, data=mem[128 len ceil32(stor5.length.field_1)], mem[(2 * ceil32(stor5.length.field_1)) + 192 len 2 * ceil32(stor5.length.field_1)]), 
}

function sub_c1315e61(?) {
    mem[100] = this.address
    require ext_code.size(dogeAddress)
    staticcall dogeAddress.0x70a08231 with:
            gas gas_remaining wei
           args this.address
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[0] >= 10^12:
        if not ext_call.return_data[0]:
            mem[64] = ceil32(return_data.size) + 160
            mem[ceil32(return_data.size) + 96] = 26
            mem[ceil32(return_data.size) + 128] = 'SafeMath: division by zero'
            if stor19.length:
                if stor19.length <= 9:
                    idx = 0
                    s = 0
                    t = 0
                    while idx < stor19.length:
                        mem[0] = stor19[idx]
                        mem[32] = 1
                        if s > !balanceOf[stor19[idx]]:
                            revert with 0, 17
                        if s + balanceOf[stor19[idx]] < s:
                            revert with 0, 'SafeMath: addition overflow'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + balanceOf[stor19[idx]]
                        t = stor19[idx]
                        continue 
                    if stor19.length <= 9:
                        idx = 0
                        t = 0
                        u = 160 * stor19.length
                        while idx < stor19.length:
                            mem[0] = stor19[idx]
                            mem[32] = 1
                            if balanceOf[stor19[idx]] < 10000000000 * 10^18:
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                t = t
                                u = stor19[idx]
                                continue 
                            mem[0] = stor19[idx]
                            mem[32] = 1
                            if not balanceOf[stor19[idx]]:
                                _425 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_425] = 26
                                mem[_425 + 32] = 'SafeMath: division by zero'
                                if not s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                    _429 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _429 + 68] = mem[idx + _425 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_429 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _429 + -mem[64] + 100
                                if 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                    _520 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_520] = 26
                                    mem[_520 + 32] = 'SafeMath: division by zero'
                                    mem[mem[64] + 4] = stor19[idx]
                                    mem[mem[64] + 36] = 0
                                    require ext_code.size(dogeAddress)
                                    call dogeAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args stor19[idx], 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _571 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_571] == bool(mem[_571])
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                t = 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length
                                u = stor19[idx]
                                continue 
                            if balanceOf[stor19[idx]] and 10000 > -1 / balanceOf[stor19[idx]]:
                                revert with 0, 17
                            if not balanceOf[stor19[idx]]:
                                revert with 0, 18
                            if 10000 * balanceOf[stor19[idx]] / balanceOf[stor19[idx]] != 10000:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _459 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_459] = 26
                            mem[_459 + 32] = 'SafeMath: division by zero'
                            if not s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                _479 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _479 + 68] = mem[idx + _459 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_479 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _479 + -mem[64] + 100
                            if 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                _551 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_551] = 26
                                mem[_551 + 32] = 'SafeMath: division by zero'
                                mem[mem[64] + 4] = stor19[idx]
                                mem[mem[64] + 36] = 0
                                require ext_code.size(dogeAddress)
                                call dogeAddress.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args stor19[idx], 0
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _623 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_623] == bool(mem[_623])
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            t = 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length
                            u = stor19[idx]
                            continue 
                    else:
                        idx = 0
                        t = 0
                        u = 160 * stor19.length
                        while idx < 9:
                            if 0 > !idx:
                                revert with 0, 17
                            if idx >= stor19.length:
                                revert with 0, 50
                            mem[0] = stor19[idx]
                            mem[32] = 1
                            if balanceOf[stor19[idx]] < 10000000000 * 10^18:
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                t = t
                                u = stor19[idx]
                                continue 
                            mem[0] = stor19[idx]
                            mem[32] = 1
                            if not balanceOf[stor19[idx]]:
                                _436 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_436] = 26
                                mem[_436 + 32] = 'SafeMath: division by zero'
                                if not s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                    _451 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _451 + 68] = mem[idx + _436 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_451 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _451 + -mem[64] + 100
                                if 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                    _536 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_536] = 26
                                    mem[_536 + 32] = 'SafeMath: division by zero'
                                    mem[mem[64] + 4] = stor19[idx]
                                    mem[mem[64] + 36] = 0
                                    require ext_code.size(dogeAddress)
                                    call dogeAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args stor19[idx], 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _595 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_595] == bool(mem[_595])
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                t = 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length
                                u = stor19[idx]
                                continue 
                            if balanceOf[stor19[idx]] and 10000 > -1 / balanceOf[stor19[idx]]:
                                revert with 0, 17
                            if not balanceOf[stor19[idx]]:
                                revert with 0, 18
                            if 10000 * balanceOf[stor19[idx]] / balanceOf[stor19[idx]] != 10000:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _492 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_492] = 26
                            mem[_492 + 32] = 'SafeMath: division by zero'
                            if not s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                _506 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _506 + 68] = mem[idx + _492 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_506 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _506 + -mem[64] + 100
                            if 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                _572 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_572] = 26
                                mem[_572 + 32] = 'SafeMath: division by zero'
                                mem[mem[64] + 4] = stor19[idx]
                                mem[mem[64] + 36] = 0
                                require ext_code.size(dogeAddress)
                                call dogeAddress.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args stor19[idx], 0
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _647 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_647] == bool(mem[_647])
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            t = 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length
                            u = stor19[idx]
                            continue 
                else:
                    if stor19.length < 9:
                        revert with 0, 17
                    mem[64] = ceil32(return_data.size) + 224
                    mem[ceil32(return_data.size) + 160] = 24
                    mem[ceil32(return_data.size) + 192] = 'SafeMath: modulo by zero'
                    if not stor19.length - 9:
                        revert with 0, 'SafeMath: modulo by zero', 0
                    idx = 0
                    s = 0
                    t = 0
                    while idx < 9:
                        if block.timestamp % stor19.length - 9 > !idx:
                            revert with 0, 17
                        if (block.timestamp % stor19.length - 9) + idx >= stor19.length:
                            revert with 0, 50
                        mem[0] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                        mem[32] = 1
                        if s > !balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]]:
                            revert with 0, 17
                        if s + balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] < s:
                            revert with 0, 'SafeMath: addition overflow'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]]
                        t = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                        continue 
                    if stor19.length <= 9:
                        idx = 0
                        t = 0
                        u = 1440
                        while idx < stor19.length:
                            mem[0] = stor19[idx]
                            mem[32] = 1
                            if balanceOf[stor19[idx]] < 10000000000 * 10^18:
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                t = t
                                u = stor19[idx]
                                continue 
                            mem[0] = stor19[idx]
                            mem[32] = 1
                            if not balanceOf[stor19[idx]]:
                                _426 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_426] = 26
                                mem[_426 + 32] = 'SafeMath: division by zero'
                                if not 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                    _430 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _430 + 68] = mem[idx + _426 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_430 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _430 + -mem[64] + 100
                                if 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                    _522 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_522] = 26
                                    mem[_522 + 32] = 'SafeMath: division by zero'
                                    mem[mem[64] + 4] = stor19[idx]
                                    mem[mem[64] + 36] = 0
                                    require ext_code.size(dogeAddress)
                                    call dogeAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args stor19[idx], 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _573 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_573] == bool(mem[_573])
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                t = 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s
                                u = stor19[idx]
                                continue 
                            if balanceOf[stor19[idx]] and 10000 > -1 / balanceOf[stor19[idx]]:
                                revert with 0, 17
                            if not balanceOf[stor19[idx]]:
                                revert with 0, 18
                            if 10000 * balanceOf[stor19[idx]] / balanceOf[stor19[idx]] != 10000:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _461 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_461] = 26
                            mem[_461 + 32] = 'SafeMath: division by zero'
                            if not 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                _483 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _483 + 68] = mem[idx + _461 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_483 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _483 + -mem[64] + 100
                            if 10000 * balanceOf[stor19[idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                _552 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_552] = 26
                                mem[_552 + 32] = 'SafeMath: division by zero'
                                mem[mem[64] + 4] = stor19[idx]
                                mem[mem[64] + 36] = 0
                                require ext_code.size(dogeAddress)
                                call dogeAddress.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args stor19[idx], 0
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _624 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_624] == bool(mem[_624])
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            t = 10000 * balanceOf[stor19[idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s
                            u = stor19[idx]
                            continue 
                    else:
                        idx = 0
                        t = 0
                        u = 1440
                        while idx < 9:
                            if block.timestamp % stor19.length - 9 > !idx:
                                revert with 0, 17
                            if (block.timestamp % stor19.length - 9) + idx >= stor19.length:
                                revert with 0, 50
                            mem[0] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                            mem[32] = 1
                            if balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] < 10000000000 * 10^18:
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                t = t
                                u = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                continue 
                            mem[0] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                            mem[32] = 1
                            if not balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]]:
                                _438 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_438] = 26
                                mem[_438 + 32] = 'SafeMath: division by zero'
                                if not 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                    _454 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _454 + 68] = mem[idx + _438 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_454 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _454 + -mem[64] + 100
                                if 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                    _538 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_538] = 26
                                    mem[_538 + 32] = 'SafeMath: division by zero'
                                    mem[mem[64] + 4] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                    mem[mem[64] + 36] = 0
                                    require ext_code.size(dogeAddress)
                                    call dogeAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx], 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _596 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_596] == bool(mem[_596])
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                t = 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s
                                u = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                continue 
                            if balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] and 10000 > -1 / balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]]:
                                revert with 0, 17
                            if not balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]]:
                                revert with 0, 18
                            if 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] != 10000:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _494 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_494] = 26
                            mem[_494 + 32] = 'SafeMath: division by zero'
                            if not 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                _509 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _509 + 68] = mem[idx + _494 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_509 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _509 + -mem[64] + 100
                            if 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                _574 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_574] = 26
                                mem[_574 + 32] = 'SafeMath: division by zero'
                                mem[mem[64] + 4] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                mem[mem[64] + 36] = 0
                                require ext_code.size(dogeAddress)
                                call dogeAddress.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx], 0
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _648 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_648] == bool(mem[_648])
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            t = 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s
                            u = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                            continue 
        else:
            if ext_call.return_data[0] and 4 > -1 / ext_call.return_data[0]:
                revert with 0, 17
            if not ext_call.return_data[0]:
                revert with 0, 18
            if 4 * ext_call.return_data[0] / ext_call.return_data[0] != 4:
                revert with 0, 'SafeMath: multiplication overflow'
            mem[64] = ceil32(return_data.size) + 160
            mem[ceil32(return_data.size) + 96] = 26
            mem[ceil32(return_data.size) + 128] = 'SafeMath: division by zero'
            if stor19.length:
                if stor19.length <= 9:
                    idx = 0
                    s = 0
                    t = 0
                    while idx < stor19.length:
                        mem[0] = stor19[idx]
                        mem[32] = 1
                        if s > !balanceOf[stor19[idx]]:
                            revert with 0, 17
                        if s + balanceOf[stor19[idx]] < s:
                            revert with 0, 'SafeMath: addition overflow'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + balanceOf[stor19[idx]]
                        t = stor19[idx]
                        continue 
                    if stor19.length <= 9:
                        idx = 0
                        t = 0
                        u = 160 * stor19.length
                        while idx < stor19.length:
                            mem[0] = stor19[idx]
                            mem[32] = 1
                            if balanceOf[stor19[idx]] < 10000000000 * 10^18:
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                t = t
                                u = stor19[idx]
                                continue 
                            mem[0] = stor19[idx]
                            mem[32] = 1
                            if not balanceOf[stor19[idx]]:
                                _423 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_423] = 26
                                mem[_423 + 32] = 'SafeMath: division by zero'
                                if not s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                    _427 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _427 + 68] = mem[idx + _423 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_427 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _427 + -mem[64] + 100
                                if 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                    if not 4 * ext_call.return_data[0] / 5:
                                        _516 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_516] = 26
                                        mem[_516 + 32] = 'SafeMath: division by zero'
                                        mem[mem[64] + 4] = stor19[idx]
                                        mem[mem[64] + 36] = 0
                                        require ext_code.size(dogeAddress)
                                        call dogeAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args stor19[idx], 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _565 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_565] == bool(mem[_565])
                                    else:
                                        if 4 * ext_call.return_data[0] / 5 and 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length > -1 / 4 * ext_call.return_data[0] / 5:
                                            revert with 0, 17
                                        if not 4 * ext_call.return_data[0] / 5:
                                            revert with 0, 18
                                        if 4 * ext_call.return_data[0] / 5 * 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 4 * ext_call.return_data[0] / 5 != 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _548 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_548] = 26
                                        mem[_548 + 32] = 'SafeMath: division by zero'
                                        mem[mem[64] + 4] = stor19[idx]
                                        mem[mem[64] + 36] = 4 * ext_call.return_data[0] / 5 * 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 10000
                                        require ext_code.size(dogeAddress)
                                        call dogeAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args stor19[idx], 4 * ext_call.return_data[0] / 5 * 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 10000
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _618 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_618] == bool(mem[_618])
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                t = 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length
                                u = stor19[idx]
                                continue 
                            if balanceOf[stor19[idx]] and 10000 > -1 / balanceOf[stor19[idx]]:
                                revert with 0, 17
                            if not balanceOf[stor19[idx]]:
                                revert with 0, 18
                            if 10000 * balanceOf[stor19[idx]] / balanceOf[stor19[idx]] != 10000:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _455 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_455] = 26
                            mem[_455 + 32] = 'SafeMath: division by zero'
                            if not s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                _471 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _471 + 68] = mem[idx + _455 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_471 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _471 + -mem[64] + 100
                            if 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                if not 4 * ext_call.return_data[0] / 5:
                                    _547 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_547] = 26
                                    mem[_547 + 32] = 'SafeMath: division by zero'
                                    mem[mem[64] + 4] = stor19[idx]
                                    mem[mem[64] + 36] = 0
                                    require ext_code.size(dogeAddress)
                                    call dogeAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args stor19[idx], 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _617 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_617] == bool(mem[_617])
                                else:
                                    if 4 * ext_call.return_data[0] / 5 and 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length > -1 / 4 * ext_call.return_data[0] / 5:
                                        revert with 0, 17
                                    if not 4 * ext_call.return_data[0] / 5:
                                        revert with 0, 18
                                    if 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 4 * ext_call.return_data[0] / 5 != 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _591 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_591] = 26
                                    mem[_591 + 32] = 'SafeMath: division by zero'
                                    mem[mem[64] + 4] = stor19[idx]
                                    mem[mem[64] + 36] = 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 10000
                                    require ext_code.size(dogeAddress)
                                    call dogeAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args stor19[idx], 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 10000
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _659 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_659] == bool(mem[_659])
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            t = 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length
                            u = stor19[idx]
                            continue 
                    else:
                        idx = 0
                        t = 0
                        u = 160 * stor19.length
                        while idx < 9:
                            if 0 > !idx:
                                revert with 0, 17
                            if idx >= stor19.length:
                                revert with 0, 50
                            mem[0] = stor19[idx]
                            mem[32] = 1
                            if balanceOf[stor19[idx]] < 10000000000 * 10^18:
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                t = t
                                u = stor19[idx]
                                continue 
                            mem[0] = stor19[idx]
                            mem[32] = 1
                            if not balanceOf[stor19[idx]]:
                                _432 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_432] = 26
                                mem[_432 + 32] = 'SafeMath: division by zero'
                                if not s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                    _445 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _445 + 68] = mem[idx + _432 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_445 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _445 + -mem[64] + 100
                                if 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                    if not 4 * ext_call.return_data[0] / 5:
                                        _532 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_532] = 26
                                        mem[_532 + 32] = 'SafeMath: division by zero'
                                        mem[mem[64] + 4] = stor19[idx]
                                        mem[mem[64] + 36] = 0
                                        require ext_code.size(dogeAddress)
                                        call dogeAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args stor19[idx], 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _592 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_592] == bool(mem[_592])
                                    else:
                                        if 4 * ext_call.return_data[0] / 5 and 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length > -1 / 4 * ext_call.return_data[0] / 5:
                                            revert with 0, 17
                                        if not 4 * ext_call.return_data[0] / 5:
                                            revert with 0, 18
                                        if 4 * ext_call.return_data[0] / 5 * 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 4 * ext_call.return_data[0] / 5 != 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _567 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_567] = 26
                                        mem[_567 + 32] = 'SafeMath: division by zero'
                                        mem[mem[64] + 4] = stor19[idx]
                                        mem[mem[64] + 36] = 4 * ext_call.return_data[0] / 5 * 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 10000
                                        require ext_code.size(dogeAddress)
                                        call dogeAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args stor19[idx], 4 * ext_call.return_data[0] / 5 * 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 10000
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _644 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_644] == bool(mem[_644])
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                t = 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length
                                u = stor19[idx]
                                continue 
                            if balanceOf[stor19[idx]] and 10000 > -1 / balanceOf[stor19[idx]]:
                                revert with 0, 17
                            if not balanceOf[stor19[idx]]:
                                revert with 0, 18
                            if 10000 * balanceOf[stor19[idx]] / balanceOf[stor19[idx]] != 10000:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _488 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_488] = 26
                            mem[_488 + 32] = 'SafeMath: division by zero'
                            if not s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                _500 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _500 + 68] = mem[idx + _488 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_500 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _500 + -mem[64] + 100
                            if 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                if not 4 * ext_call.return_data[0] / 5:
                                    _566 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_566] = 26
                                    mem[_566 + 32] = 'SafeMath: division by zero'
                                    mem[mem[64] + 4] = stor19[idx]
                                    mem[mem[64] + 36] = 0
                                    require ext_code.size(dogeAddress)
                                    call dogeAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args stor19[idx], 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _643 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_643] == bool(mem[_643])
                                else:
                                    if 4 * ext_call.return_data[0] / 5 and 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length > -1 / 4 * ext_call.return_data[0] / 5:
                                        revert with 0, 17
                                    if not 4 * ext_call.return_data[0] / 5:
                                        revert with 0, 18
                                    if 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 4 * ext_call.return_data[0] / 5 != 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _619 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_619] = 26
                                    mem[_619 + 32] = 'SafeMath: division by zero'
                                    mem[mem[64] + 4] = stor19[idx]
                                    mem[mem[64] + 36] = 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 10000
                                    require ext_code.size(dogeAddress)
                                    call dogeAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args stor19[idx], 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 10000
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _667 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_667] == bool(mem[_667])
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            t = 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length
                            u = stor19[idx]
                            continue 
                else:
                    if stor19.length < 9:
                        revert with 0, 17
                    mem[64] = ceil32(return_data.size) + 224
                    mem[ceil32(return_data.size) + 160] = 24
                    mem[ceil32(return_data.size) + 192] = 'SafeMath: modulo by zero'
                    if not stor19.length - 9:
                        revert with 0, 'SafeMath: modulo by zero', 0
                    idx = 0
                    s = 0
                    t = 0
                    while idx < 9:
                        if block.timestamp % stor19.length - 9 > !idx:
                            revert with 0, 17
                        if (block.timestamp % stor19.length - 9) + idx >= stor19.length:
                            revert with 0, 50
                        mem[0] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                        mem[32] = 1
                        if s > !balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]]:
                            revert with 0, 17
                        if s + balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] < s:
                            revert with 0, 'SafeMath: addition overflow'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]]
                        t = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                        continue 
                    if stor19.length <= 9:
                        idx = 0
                        t = 0
                        u = 1440
                        while idx < stor19.length:
                            mem[0] = stor19[idx]
                            mem[32] = 1
                            if balanceOf[stor19[idx]] < 10000000000 * 10^18:
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                t = t
                                u = stor19[idx]
                                continue 
                            mem[0] = stor19[idx]
                            mem[32] = 1
                            if not balanceOf[stor19[idx]]:
                                _424 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_424] = 26
                                mem[_424 + 32] = 'SafeMath: division by zero'
                                if not 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                    _428 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _428 + 68] = mem[idx + _424 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_428 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _428 + -mem[64] + 100
                                if 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                    if not 4 * ext_call.return_data[0] / 5:
                                        _518 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_518] = 26
                                        mem[_518 + 32] = 'SafeMath: division by zero'
                                        mem[mem[64] + 4] = stor19[idx]
                                        mem[mem[64] + 36] = 0
                                        require ext_code.size(dogeAddress)
                                        call dogeAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args stor19[idx], 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _568 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_568] == bool(mem[_568])
                                    else:
                                        if 4 * ext_call.return_data[0] / 5 and 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s > -1 / 4 * ext_call.return_data[0] / 5:
                                            revert with 0, 17
                                        if not 4 * ext_call.return_data[0] / 5:
                                            revert with 0, 18
                                        if 4 * ext_call.return_data[0] / 5 * 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 4 * ext_call.return_data[0] / 5 != 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _550 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_550] = 26
                                        mem[_550 + 32] = 'SafeMath: division by zero'
                                        mem[mem[64] + 4] = stor19[idx]
                                        mem[mem[64] + 36] = 4 * ext_call.return_data[0] / 5 * 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 10000
                                        require ext_code.size(dogeAddress)
                                        call dogeAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args stor19[idx], 4 * ext_call.return_data[0] / 5 * 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 10000
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _621 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_621] == bool(mem[_621])
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                t = 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s
                                u = stor19[idx]
                                continue 
                            if balanceOf[stor19[idx]] and 10000 > -1 / balanceOf[stor19[idx]]:
                                revert with 0, 17
                            if not balanceOf[stor19[idx]]:
                                revert with 0, 18
                            if 10000 * balanceOf[stor19[idx]] / balanceOf[stor19[idx]] != 10000:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _457 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_457] = 26
                            mem[_457 + 32] = 'SafeMath: division by zero'
                            if not 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                _475 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _475 + 68] = mem[idx + _457 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_475 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _475 + -mem[64] + 100
                            if 10000 * balanceOf[stor19[idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                if not 4 * ext_call.return_data[0] / 5:
                                    _549 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_549] = 26
                                    mem[_549 + 32] = 'SafeMath: division by zero'
                                    mem[mem[64] + 4] = stor19[idx]
                                    mem[mem[64] + 36] = 0
                                    require ext_code.size(dogeAddress)
                                    call dogeAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args stor19[idx], 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _620 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_620] == bool(mem[_620])
                                else:
                                    if 4 * ext_call.return_data[0] / 5 and 10000 * balanceOf[stor19[idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s > -1 / 4 * ext_call.return_data[0] / 5:
                                        revert with 0, 17
                                    if not 4 * ext_call.return_data[0] / 5:
                                        revert with 0, 18
                                    if 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor19[idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 4 * ext_call.return_data[0] / 5 != 10000 * balanceOf[stor19[idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _593 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_593] = 26
                                    mem[_593 + 32] = 'SafeMath: division by zero'
                                    mem[mem[64] + 4] = stor19[idx]
                                    mem[mem[64] + 36] = 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor19[idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 10000
                                    require ext_code.size(dogeAddress)
                                    call dogeAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args stor19[idx], 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor19[idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 10000
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _660 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_660] == bool(mem[_660])
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            t = 10000 * balanceOf[stor19[idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s
                            u = stor19[idx]
                            continue 
                    else:
                        idx = 0
                        t = 0
                        u = 1440
                        while idx < 9:
                            if block.timestamp % stor19.length - 9 > !idx:
                                revert with 0, 17
                            if (block.timestamp % stor19.length - 9) + idx >= stor19.length:
                                revert with 0, 50
                            mem[0] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                            mem[32] = 1
                            if balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] < 10000000000 * 10^18:
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                t = t
                                u = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                continue 
                            mem[0] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                            mem[32] = 1
                            if not balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]]:
                                _434 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_434] = 26
                                mem[_434 + 32] = 'SafeMath: division by zero'
                                if not 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                    _448 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _448 + 68] = mem[idx + _434 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_448 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _448 + -mem[64] + 100
                                if 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                    if not 4 * ext_call.return_data[0] / 5:
                                        _534 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_534] = 26
                                        mem[_534 + 32] = 'SafeMath: division by zero'
                                        mem[mem[64] + 4] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                        mem[mem[64] + 36] = 0
                                        require ext_code.size(dogeAddress)
                                        call dogeAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx], 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _594 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_594] == bool(mem[_594])
                                    else:
                                        if 4 * ext_call.return_data[0] / 5 and 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s > -1 / 4 * ext_call.return_data[0] / 5:
                                            revert with 0, 17
                                        if not 4 * ext_call.return_data[0] / 5:
                                            revert with 0, 18
                                        if 4 * ext_call.return_data[0] / 5 * 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 4 * ext_call.return_data[0] / 5 != 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _570 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_570] = 26
                                        mem[_570 + 32] = 'SafeMath: division by zero'
                                        mem[mem[64] + 4] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                        mem[mem[64] + 36] = 4 * ext_call.return_data[0] / 5 * 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 10000
                                        require ext_code.size(dogeAddress)
                                        call dogeAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx], 4 * ext_call.return_data[0] / 5 * 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 10000
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _646 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_646] == bool(mem[_646])
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                t = 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s
                                u = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                continue 
                            if balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] and 10000 > -1 / balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]]:
                                revert with 0, 17
                            if not balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]]:
                                revert with 0, 18
                            if 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] != 10000:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _490 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_490] = 26
                            mem[_490 + 32] = 'SafeMath: division by zero'
                            if not 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                _503 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _503 + 68] = mem[idx + _490 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_503 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _503 + -mem[64] + 100
                            if 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                if not 4 * ext_call.return_data[0] / 5:
                                    _569 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_569] = 26
                                    mem[_569 + 32] = 'SafeMath: division by zero'
                                    mem[mem[64] + 4] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                    mem[mem[64] + 36] = 0
                                    require ext_code.size(dogeAddress)
                                    call dogeAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx], 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _645 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_645] == bool(mem[_645])
                                else:
                                    if 4 * ext_call.return_data[0] / 5 and 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s > -1 / 4 * ext_call.return_data[0] / 5:
                                        revert with 0, 17
                                    if not 4 * ext_call.return_data[0] / 5:
                                        revert with 0, 18
                                    if 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 4 * ext_call.return_data[0] / 5 != 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _622 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_622] = 26
                                    mem[_622 + 32] = 'SafeMath: division by zero'
                                    mem[mem[64] + 4] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                    mem[mem[64] + 36] = 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 10000
                                    require ext_code.size(dogeAddress)
                                    call dogeAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx], 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 10000
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _668 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_668] == bool(mem[_668])
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            t = 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s
                            u = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                            continue 
}

function transfer(address arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if not msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer from the zero address'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer to the zero address'
    mem[0] = this.address
    mem[32] = 1
    if balanceOf[address(this.address)] <= 0:
        mem[100] = this.address
        require ext_code.size(dogeAddress)
        staticcall dogeAddress.0x70a08231 with:
                gas gas_remaining wei
               args this.address
        mem[96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[0] < 10^12:
            if not msg.sender:
                revert with 0, 'ERC20: transfer from the zero address'
            if stor14[address(msg.sender)]:
                if not arg1:
                    revert with 0, 'ERC20: transfer to the zero address'
                if arg2 > balanceOf[address(msg.sender)]:
                    revert with 0, 
                                32,
                                38,
                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 166 len 26] >> 48,
                                0
                if balanceOf[address(msg.sender)] < arg2:
                    revert with 0, 17
                balanceOf[address(msg.sender)] -= arg2
                if balanceOf[arg1] > !arg2:
                    revert with 0, 17
                if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                    revert with 0, 'SafeMath: addition overflow'
                balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                emit Transfer(arg2, msg.sender, arg1);
            else:
                if stor14[address(arg1)]:
                    if not arg1:
                        revert with 0, 'ERC20: transfer to the zero address'
                    if arg2 > balanceOf[address(msg.sender)]:
                        revert with 0, 
                                    32,
                                    38,
                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 166 len 26] >> 48,
                                    0
                    if balanceOf[address(msg.sender)] < arg2:
                        revert with 0, 17
                    balanceOf[address(msg.sender)] -= arg2
                    if balanceOf[arg1] > !arg2:
                        revert with 0, 17
                    if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                        revert with 0, 'SafeMath: addition overflow'
                    balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                    emit Transfer(arg2, msg.sender, arg1);
                else:
                    if stor10:
                        if not arg1:
                            revert with 0, 'ERC20: transfer to the zero address'
                        if arg2 > balanceOf[address(msg.sender)]:
                            revert with 0, 
                                        32,
                                        38,
                                        0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 166 len 26] >> 48,
                                        0
                        if balanceOf[address(msg.sender)] < arg2:
                            revert with 0, 17
                        balanceOf[address(msg.sender)] -= arg2
                        if balanceOf[arg1] > !arg2:
                            revert with 0, 17
                        if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                            revert with 0, 'SafeMath: addition overflow'
                        balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                        emit Transfer(arg2, msg.sender, arg1);
                    else:
                        if not stor13:
                            revert with 0, 'ERC20: transfer to the zero address'
                        if arg2 / 100 > balanceOf[address(msg.sender)]:
                            revert with 0, 
                                        32,
                                        38,
                                        0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 230 len 26] >> 48,
                                        0
                        if balanceOf[address(msg.sender)] < arg2 / 100:
                            revert with 0, 17
                        balanceOf[address(msg.sender)] -= arg2 / 100
                        if balanceOf[stor13] > !(arg2 / 100):
                            revert with 0, 17
                        if balanceOf[stor13] + (arg2 / 100) < balanceOf[stor13]:
                            revert with 0, 'SafeMath: addition overflow'
                        balanceOf[stor13] += arg2 / 100
                        emit Transfer((arg2 / 100), msg.sender, stor13);
                        if not msg.sender:
                            revert with 0, 'ERC20: transfer from the zero address'
                        if not sub_8230af5aAddress:
                            revert with 0, 'ERC20: transfer to the zero address'
                        if arg2 / 100 > balanceOf[address(msg.sender)]:
                            revert with 0, 
                                        32,
                                        38,
                                        0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 390 len 26] >> 48,
                                        0
                        if balanceOf[address(msg.sender)] < arg2 / 100:
                            revert with 0, 17
                        balanceOf[address(msg.sender)] -= arg2 / 100
                        if balanceOf[stor9] > !(arg2 / 100):
                            revert with 0, 17
                        if balanceOf[stor9] + (arg2 / 100) < balanceOf[stor9]:
                            revert with 0, 'SafeMath: addition overflow'
                        balanceOf[stor9] += arg2 / 100
                        emit Transfer((arg2 / 100), msg.sender, sub_8230af5aAddress);
                        if not msg.sender:
                            revert with 0, 'ERC20: transfer from the zero address'
                        if not uniswapV2PairAddress:
                            revert with 0, 'ERC20: transfer to the zero address'
                        if arg2 / 100 > balanceOf[address(msg.sender)]:
                            revert with 0, 
                                        32,
                                        38,
                                        0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 550 len 26] >> 48,
                                        0
                        if balanceOf[address(msg.sender)] < arg2 / 100:
                            revert with 0, 17
                        balanceOf[address(msg.sender)] -= arg2 / 100
                        if balanceOf[stor7] > !(arg2 / 100):
                            revert with 0, 17
                        if balanceOf[stor7] + (arg2 / 100) < balanceOf[stor7]:
                            revert with 0, 'SafeMath: addition overflow'
                        balanceOf[stor7] += arg2 / 100
                        emit Transfer((arg2 / 100), msg.sender, uniswapV2PairAddress);
                        if not msg.sender:
                            revert with 0, 'ERC20: transfer from the zero address'
                        if not this.address:
                            revert with 0, 'ERC20: transfer to the zero address'
                        if arg2 / 10 > balanceOf[address(msg.sender)]:
                            revert with 0, 
                                        32,
                                        38,
                                        0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 710 len 26] >> 48,
                                        0
                        if balanceOf[address(msg.sender)] < arg2 / 10:
                            revert with 0, 17
                        balanceOf[address(msg.sender)] -= arg2 / 10
                        if balanceOf[this.address] > !(arg2 / 10):
                            revert with 0, 17
                        if balanceOf[this.address] + (arg2 / 10) < balanceOf[this.address]:
                            revert with 0, 'SafeMath: addition overflow'
                        balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 10)
                        emit Transfer((arg2 / 10), msg.sender, this.address);
                        if not arg2 / 100:
                            if not msg.sender:
                                revert with 0, 'ERC20: transfer from the zero address'
                            if not arg1:
                                revert with 0, 'ERC20: transfer to the zero address'
                            if 0 > balanceOf[address(msg.sender)]:
                                revert with 0, 
                                            32,
                                            38,
                                            0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 870 len 26] >> 48,
                                            0
                            if balanceOf[address(msg.sender)] < 0:
                                revert with 0, 17
                            if balanceOf[arg1] > -1:
                                revert with 0, 17
                            if balanceOf[arg1] < balanceOf[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            balanceOf[address(arg1)] = balanceOf[arg1]
                            emit Transfer(0, msg.sender, arg1);
                        else:
                            if arg2 / 100 and 87 > -1 / arg2 / 100:
                                revert with 0, 17
                            if not arg2 / 100:
                                revert with 0, 18
                            if 87 * arg2 / 100 / arg2 / 100 != 87:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not msg.sender:
                                revert with 0, 'ERC20: transfer from the zero address'
                            if not arg1:
                                revert with 0, 'ERC20: transfer to the zero address'
                            if 87 * arg2 / 100 > balanceOf[address(msg.sender)]:
                                revert with 0, 
                                            32,
                                            38,
                                            0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 870 len 26] >> 48,
                                            0
                            if balanceOf[address(msg.sender)] < 87 * arg2 / 100:
                                revert with 0, 17
                            balanceOf[address(msg.sender)] += -87 * arg2 / 100
                            if balanceOf[arg1] > !(87 * arg2 / 100):
                                revert with 0, 17
                            if balanceOf[arg1] + (87 * arg2 / 100) < balanceOf[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            balanceOf[address(arg1)] = balanceOf[arg1] + (87 * arg2 / 100)
                            emit Transfer((87 * arg2 / 100), msg.sender, arg1);
        else:
            if not ext_call.return_data[0]:
                mem[64] = ceil32(return_data.size) + 160
                mem[ceil32(return_data.size) + 96] = 26
                mem[ceil32(return_data.size) + 128] = 'SafeMath: division by zero'
                if not stor19.length:
                    if not msg.sender:
                        revert with 0, 'ERC20: transfer from the zero address'
                    if stor14[address(msg.sender)]:
                        if not arg1:
                            revert with 0, 'ERC20: transfer to the zero address'
                        if arg2 > balanceOf[address(msg.sender)]:
                            revert with 0, 
                                        32,
                                        38,
                                        0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 230 len 26] >> 48,
                                        0
                        if balanceOf[address(msg.sender)] < arg2:
                            revert with 0, 17
                        balanceOf[address(msg.sender)] -= arg2
                        if balanceOf[arg1] > !arg2:
                            revert with 0, 17
                        if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                            revert with 0, 'SafeMath: addition overflow'
                        balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                        emit Transfer(arg2, msg.sender, arg1);
                    else:
                        if stor14[address(arg1)]:
                            if not arg1:
                                revert with 0, 'ERC20: transfer to the zero address'
                            if arg2 > balanceOf[address(msg.sender)]:
                                revert with 0, 
                                            32,
                                            38,
                                            0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 230 len 26] >> 48,
                                            0
                            if balanceOf[address(msg.sender)] < arg2:
                                revert with 0, 17
                            balanceOf[address(msg.sender)] -= arg2
                            if balanceOf[arg1] > !arg2:
                                revert with 0, 17
                            if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                            emit Transfer(arg2, msg.sender, arg1);
                        else:
                            if stor10:
                                if not arg1:
                                    revert with 0, 'ERC20: transfer to the zero address'
                                if arg2 > balanceOf[address(msg.sender)]:
                                    revert with 0, 
                                                32,
                                                38,
                                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 230 len 26] >> 48,
                                                0
                                if balanceOf[address(msg.sender)] < arg2:
                                    revert with 0, 17
                                balanceOf[address(msg.sender)] -= arg2
                                if balanceOf[arg1] > !arg2:
                                    revert with 0, 17
                                if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                emit Transfer(arg2, msg.sender, arg1);
                            else:
                                if not stor13:
                                    revert with 0, 'ERC20: transfer to the zero address'
                                if arg2 / 100 > balanceOf[address(msg.sender)]:
                                    revert with 0, 
                                                32,
                                                38,
                                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 294 len 26] >> 48,
                                                0
                                if balanceOf[address(msg.sender)] < arg2 / 100:
                                    revert with 0, 17
                                balanceOf[address(msg.sender)] -= arg2 / 100
                                if balanceOf[stor13] > !(arg2 / 100):
                                    revert with 0, 17
                                if balanceOf[stor13] + (arg2 / 100) < balanceOf[stor13]:
                                    revert with 0, 'SafeMath: addition overflow'
                                balanceOf[stor13] += arg2 / 100
                                emit Transfer((arg2 / 100), msg.sender, stor13);
                                if not msg.sender:
                                    revert with 0, 'ERC20: transfer from the zero address'
                                if not sub_8230af5aAddress:
                                    revert with 0, 'ERC20: transfer to the zero address'
                                if arg2 / 100 > balanceOf[address(msg.sender)]:
                                    revert with 0, 
                                                32,
                                                38,
                                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 454 len 26] >> 48,
                                                0
                                if balanceOf[address(msg.sender)] < arg2 / 100:
                                    revert with 0, 17
                                balanceOf[address(msg.sender)] -= arg2 / 100
                                if balanceOf[stor9] > !(arg2 / 100):
                                    revert with 0, 17
                                if balanceOf[stor9] + (arg2 / 100) < balanceOf[stor9]:
                                    revert with 0, 'SafeMath: addition overflow'
                                balanceOf[stor9] += arg2 / 100
                                emit Transfer((arg2 / 100), msg.sender, sub_8230af5aAddress);
                                if not msg.sender:
                                    revert with 0, 'ERC20: transfer from the zero address'
                                if not uniswapV2PairAddress:
                                    revert with 0, 'ERC20: transfer to the zero address'
                                if arg2 / 100 > balanceOf[address(msg.sender)]:
                                    revert with 0, 
                                                32,
                                                38,
                                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 614 len 26] >> 48,
                                                0
                                if balanceOf[address(msg.sender)] < arg2 / 100:
                                    revert with 0, 17
                                balanceOf[address(msg.sender)] -= arg2 / 100
                                if balanceOf[stor7] > !(arg2 / 100):
                                    revert with 0, 17
                                if balanceOf[stor7] + (arg2 / 100) < balanceOf[stor7]:
                                    revert with 0, 'SafeMath: addition overflow'
                                balanceOf[stor7] += arg2 / 100
                                emit Transfer((arg2 / 100), msg.sender, uniswapV2PairAddress);
                                if not msg.sender:
                                    revert with 0, 'ERC20: transfer from the zero address'
                                if not this.address:
                                    revert with 0, 'ERC20: transfer to the zero address'
                                if arg2 / 10 > balanceOf[address(msg.sender)]:
                                    revert with 0, 
                                                32,
                                                38,
                                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 774 len 26] >> 48,
                                                0
                                if balanceOf[address(msg.sender)] < arg2 / 10:
                                    revert with 0, 17
                                balanceOf[address(msg.sender)] -= arg2 / 10
                                if balanceOf[this.address] > !(arg2 / 10):
                                    revert with 0, 17
                                if balanceOf[this.address] + (arg2 / 10) < balanceOf[this.address]:
                                    revert with 0, 'SafeMath: addition overflow'
                                balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 10)
                                emit Transfer((arg2 / 10), msg.sender, this.address);
                                if not arg2 / 100:
                                    if not msg.sender:
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if not arg1:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    if 0 > balanceOf[address(msg.sender)]:
                                        revert with 0, 
                                                    32,
                                                    38,
                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 934 len 26] >> 48,
                                                    0
                                    if balanceOf[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if balanceOf[arg1] > -1:
                                        revert with 0, 17
                                    if balanceOf[arg1] < balanceOf[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(arg1)] = balanceOf[arg1]
                                    emit Transfer(0, msg.sender, arg1);
                                else:
                                    if arg2 / 100 and 87 > -1 / arg2 / 100:
                                        revert with 0, 17
                                    if not arg2 / 100:
                                        revert with 0, 18
                                    if 87 * arg2 / 100 / arg2 / 100 != 87:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if not arg1:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    if 87 * arg2 / 100 > balanceOf[address(msg.sender)]:
                                        revert with 0, 
                                                    32,
                                                    38,
                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 934 len 26] >> 48,
                                                    0
                                    if balanceOf[address(msg.sender)] < 87 * arg2 / 100:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)] += -87 * arg2 / 100
                                    if balanceOf[arg1] > !(87 * arg2 / 100):
                                        revert with 0, 17
                                    if balanceOf[arg1] + (87 * arg2 / 100) < balanceOf[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(arg1)] = balanceOf[arg1] + (87 * arg2 / 100)
                                    emit Transfer((87 * arg2 / 100), msg.sender, arg1);
                else:
                    if stor19.length <= 9:
                        idx = 0
                        s = 0
                        t = 0
                        while idx < stor19.length:
                            mem[0] = stor19[idx]
                            mem[32] = 1
                            if s > !balanceOf[stor19[idx]]:
                                revert with 0, 17
                            if s + balanceOf[stor19[idx]] < s:
                                revert with 0, 'SafeMath: addition overflow'
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + balanceOf[stor19[idx]]
                            t = stor19[idx]
                            continue 
                        if stor19.length <= 9:
                            idx = 0
                            t = 0
                            u = 160 * stor19.length
                            while idx < stor19.length:
                                mem[0] = stor19[idx]
                                mem[32] = 1
                                if balanceOf[stor19[idx]] < 10000000000 * 10^18:
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    t = t
                                    u = stor19[idx]
                                    continue 
                                mem[0] = stor19[idx]
                                mem[32] = 1
                                if not balanceOf[stor19[idx]]:
                                    _16860 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16860] = 26
                                    mem[_16860 + 32] = 'SafeMath: division by zero'
                                    if not s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                        _17452 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _17452 + 68] = mem[idx + _16860 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17452 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _17452 + -mem[64] + 100
                                    if 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                        _20106 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_20106] = 26
                                        mem[_20106 + 32] = 'SafeMath: division by zero'
                                        mem[mem[64] + 4] = stor19[idx]
                                        mem[mem[64] + 36] = 0
                                        require ext_code.size(dogeAddress)
                                        call dogeAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args stor19[idx], 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _21965 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_21965] == bool(mem[_21965])
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    t = 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length
                                    u = stor19[idx]
                                    continue 
                                if balanceOf[stor19[idx]] and 10000 > -1 / balanceOf[stor19[idx]]:
                                    revert with 0, 17
                                if not balanceOf[stor19[idx]]:
                                    revert with 0, 18
                                if 10000 * balanceOf[stor19[idx]] / balanceOf[stor19[idx]] != 10000:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _18141 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18141] = 26
                                mem[_18141 + 32] = 'SafeMath: division by zero'
                                if not s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                    _18805 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _18805 + 68] = mem[idx + _18141 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18805 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _18805 + -mem[64] + 100
                                if 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                    _21177 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21177] = 26
                                    mem[_21177 + 32] = 'SafeMath: division by zero'
                                    mem[mem[64] + 4] = stor19[idx]
                                    mem[mem[64] + 36] = 0
                                    require ext_code.size(dogeAddress)
                                    call dogeAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args stor19[idx], 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _22963 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_22963] == bool(mem[_22963])
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                t = 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length
                                u = stor19[idx]
                                continue 
                            mem[0] = msg.sender
                            mem[32] = 14
                            if stor14[address(msg.sender)]:
                                if not msg.sender:
                                    revert with 0, 'ERC20: transfer from the zero address'
                                if not arg1:
                                    revert with 0, 'ERC20: transfer to the zero address'
                                _16853 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_16853] = 38
                                mem[_16853 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                if arg2 > balanceOf[address(msg.sender)]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 38
                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_16853 + 70 len 26]
                                    var61001 = 64
                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                if balanceOf[address(msg.sender)] < arg2:
                                    revert with 0, 17
                                balanceOf[address(msg.sender)] -= arg2
                                if balanceOf[arg1] > !arg2:
                                    revert with 0, 17
                                if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                emit Transfer(arg2, msg.sender, arg1);
                            else:
                                mem[0] = arg1
                                mem[32] = 14
                                if stor14[address(arg1)]:
                                    if not msg.sender:
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if not arg1:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    _17207 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_17207] = 38
                                    mem[_17207 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                    if arg2 > balanceOf[address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 38
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17207 + 70 len 26]
                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                    if balanceOf[address(msg.sender)] < arg2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)] -= arg2
                                    if balanceOf[arg1] > !arg2:
                                        revert with 0, 17
                                    if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                    emit Transfer(arg2, msg.sender, arg1);
                                else:
                                    if stor10:
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not arg1:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        _16856 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_16856] = 38
                                        mem[_16856 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                        if arg2 > balanceOf[address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 38
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_16856 + 70 len 26]
                                            var61001 = 64
                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                        if balanceOf[address(msg.sender)] < arg2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2
                                        if balanceOf[arg1] > !arg2:
                                            revert with 0, 17
                                        if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                        emit Transfer(arg2, msg.sender, arg1);
                                    else:
                                        _16497 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16497] = 26
                                        mem[_16497 + 32] = 'SafeMath: division by zero'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not stor13:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        _18801 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_18801] = 38
                                        mem[_18801 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                        if arg2 / 100 > balanceOf[address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 38
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_18801 + 70 len 26]
                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                        if balanceOf[address(msg.sender)] < arg2 / 100:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2 / 100
                                        if balanceOf[stor13] > !(arg2 / 100):
                                            revert with 0, 17
                                        if balanceOf[stor13] + (arg2 / 100) < balanceOf[stor13]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = stor13
                                        mem[32] = 1
                                        balanceOf[stor13] += arg2 / 100
                                        emit Transfer((arg2 / 100), msg.sender, stor13);
                                        _22565 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22565] = 26
                                        mem[_22565 + 32] = 'SafeMath: division by zero'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not sub_8230af5aAddress:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        _23399 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_23399] = 38
                                        mem[_23399 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                        if arg2 / 100 > balanceOf[address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 38
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_23399 + 70 len 26]
                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                        if balanceOf[address(msg.sender)] < arg2 / 100:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2 / 100
                                        if balanceOf[stor9] > !(arg2 / 100):
                                            revert with 0, 17
                                        if balanceOf[stor9] + (arg2 / 100) < balanceOf[stor9]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = sub_8230af5aAddress
                                        mem[32] = 1
                                        balanceOf[stor9] += arg2 / 100
                                        emit Transfer((arg2 / 100), msg.sender, sub_8230af5aAddress);
                                        _24299 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_24299] = 26
                                        mem[_24299 + 32] = 'SafeMath: division by zero'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not uniswapV2PairAddress:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        _24471 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_24471] = 38
                                        mem[_24471 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                        if arg2 / 100 > balanceOf[address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 38
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_24471 + 70 len 26]
                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                        if balanceOf[address(msg.sender)] < arg2 / 100:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2 / 100
                                        if balanceOf[stor7] > !(arg2 / 100):
                                            revert with 0, 17
                                        if balanceOf[stor7] + (arg2 / 100) < balanceOf[stor7]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = uniswapV2PairAddress
                                        mem[32] = 1
                                        balanceOf[stor7] += arg2 / 100
                                        emit Transfer((arg2 / 100), msg.sender, uniswapV2PairAddress);
                                        _25287 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_25287] = 26
                                        mem[_25287 + 32] = 'SafeMath: division by zero'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not this.address:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        _25459 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_25459] = 38
                                        mem[_25459 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                        if arg2 / 10 > balanceOf[address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 38
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_25459 + 70 len 26]
                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                        if balanceOf[address(msg.sender)] < arg2 / 10:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2 / 10
                                        if balanceOf[this.address] > !(arg2 / 10):
                                            revert with 0, 17
                                        if balanceOf[this.address] + (arg2 / 10) < balanceOf[this.address]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = this.address
                                        mem[32] = 1
                                        balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 10)
                                        emit Transfer((arg2 / 10), msg.sender, this.address);
                                        _26275 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26275] = 26
                                        mem[_26275 + 32] = 'SafeMath: division by zero'
                                        if not arg2 / 100:
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not arg1:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            _26452 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_26452] = 38
                                            mem[_26452 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                            if 0 > balanceOf[address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 38
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_26452 + 70 len 26]
                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                            if balanceOf[address(msg.sender)] < 0:
                                                revert with 0, 17
                                            if balanceOf[arg1] > -1:
                                                revert with 0, 17
                                            if balanceOf[arg1] < balanceOf[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(arg1)] = balanceOf[arg1]
                                            emit Transfer(0, msg.sender, arg1);
                                        else:
                                            if arg2 / 100 and 87 > -1 / arg2 / 100:
                                                revert with 0, 17
                                            if not arg2 / 100:
                                                revert with 0, 18
                                            if 87 * arg2 / 100 / arg2 / 100 != 87:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not arg1:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            _27015 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_27015] = 38
                                            mem[_27015 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                            if 87 * arg2 / 100 > balanceOf[address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 38
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_27015 + 70 len 26]
                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                            if balanceOf[address(msg.sender)] < 87 * arg2 / 100:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] += -87 * arg2 / 100
                                            if balanceOf[arg1] > !(87 * arg2 / 100):
                                                revert with 0, 17
                                            if balanceOf[arg1] + (87 * arg2 / 100) < balanceOf[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(arg1)] = balanceOf[arg1] + (87 * arg2 / 100)
                                            emit Transfer((87 * arg2 / 100), msg.sender, arg1);
                        else:
                            idx = 0
                            t = 0
                            u = 160 * stor19.length
                            while idx < 9:
                                if 0 > !idx:
                                    revert with 0, 17
                                if idx >= stor19.length:
                                    revert with 0, 50
                                mem[0] = stor19[idx]
                                mem[32] = 1
                                if balanceOf[stor19[idx]] < 10000000000 * 10^18:
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    t = t
                                    u = stor19[idx]
                                    continue 
                                mem[0] = stor19[idx]
                                mem[32] = 1
                                if not balanceOf[stor19[idx]]:
                                    _17634 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17634] = 26
                                    mem[_17634 + 32] = 'SafeMath: division by zero'
                                    if not s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                        _17939 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _17939 + 68] = mem[idx + _17634 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17939 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _17939 + -mem[64] + 100
                                    if 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                        _20808 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_20808] = 26
                                        mem[_20808 + 32] = 'SafeMath: division by zero'
                                        mem[mem[64] + 4] = stor19[idx]
                                        mem[mem[64] + 36] = 0
                                        require ext_code.size(dogeAddress)
                                        call dogeAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args stor19[idx], 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _22719 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_22719] == bool(mem[_22719])
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    t = 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length
                                    u = stor19[idx]
                                    continue 
                                if balanceOf[stor19[idx]] and 10000 > -1 / balanceOf[stor19[idx]]:
                                    revert with 0, 17
                                if not balanceOf[stor19[idx]]:
                                    revert with 0, 18
                                if 10000 * balanceOf[stor19[idx]] / balanceOf[stor19[idx]] != 10000:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _19176 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19176] = 26
                                mem[_19176 + 32] = 'SafeMath: division by zero'
                                if not s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                    _19452 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _19452 + 68] = mem[idx + _19176 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19452 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19452 + -mem[64] + 100
                                if 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                    _21972 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21972] = 26
                                    mem[_21972 + 32] = 'SafeMath: division by zero'
                                    mem[mem[64] + 4] = stor19[idx]
                                    mem[mem[64] + 36] = 0
                                    require ext_code.size(dogeAddress)
                                    call dogeAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args stor19[idx], 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _23151 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_23151] == bool(mem[_23151])
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                t = 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length
                                u = stor19[idx]
                                continue 
                            mem[0] = msg.sender
                            mem[32] = 14
                            if stor14[address(msg.sender)]:
                                if not msg.sender:
                                    revert with 0, 'ERC20: transfer from the zero address'
                                if not arg1:
                                    revert with 0, 'ERC20: transfer to the zero address'
                                _16861 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_16861] = 38
                                mem[_16861 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                if arg2 > balanceOf[address(msg.sender)]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 38
                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_16861 + 70 len 26]
                                    var61001 = 64
                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                if balanceOf[address(msg.sender)] < arg2:
                                    revert with 0, 17
                                balanceOf[address(msg.sender)] -= arg2
                                if balanceOf[arg1] > !arg2:
                                    revert with 0, 17
                                if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                emit Transfer(arg2, msg.sender, arg1);
                            else:
                                mem[0] = arg1
                                mem[32] = 14
                                if stor14[address(arg1)]:
                                    if not msg.sender:
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if not arg1:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    _17212 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_17212] = 38
                                    mem[_17212 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                    if arg2 > balanceOf[address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 38
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17212 + 70 len 26]
                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                    if balanceOf[address(msg.sender)] < arg2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)] -= arg2
                                    if balanceOf[arg1] > !arg2:
                                        revert with 0, 17
                                    if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                    emit Transfer(arg2, msg.sender, arg1);
                                else:
                                    if stor10:
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not arg1:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        _16864 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_16864] = 38
                                        mem[_16864 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                        if arg2 > balanceOf[address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 38
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_16864 + 70 len 26]
                                            var61001 = 64
                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                        if balanceOf[address(msg.sender)] < arg2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2
                                        if balanceOf[arg1] > !arg2:
                                            revert with 0, 17
                                        if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                        emit Transfer(arg2, msg.sender, arg1);
                                    else:
                                        _16498 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16498] = 26
                                        mem[_16498 + 32] = 'SafeMath: division by zero'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not stor13:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        _18809 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_18809] = 38
                                        mem[_18809 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                        if arg2 / 100 > balanceOf[address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 38
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_18809 + 70 len 26]
                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                        if balanceOf[address(msg.sender)] < arg2 / 100:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2 / 100
                                        if balanceOf[stor13] > !(arg2 / 100):
                                            revert with 0, 17
                                        if balanceOf[stor13] + (arg2 / 100) < balanceOf[stor13]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = stor13
                                        mem[32] = 1
                                        balanceOf[stor13] += arg2 / 100
                                        emit Transfer((arg2 / 100), msg.sender, stor13);
                                        _22568 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22568] = 26
                                        mem[_22568 + 32] = 'SafeMath: division by zero'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not sub_8230af5aAddress:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        _23402 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_23402] = 38
                                        mem[_23402 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                        if arg2 / 100 > balanceOf[address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 38
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_23402 + 70 len 26]
                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                        if balanceOf[address(msg.sender)] < arg2 / 100:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2 / 100
                                        if balanceOf[stor9] > !(arg2 / 100):
                                            revert with 0, 17
                                        if balanceOf[stor9] + (arg2 / 100) < balanceOf[stor9]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = sub_8230af5aAddress
                                        mem[32] = 1
                                        balanceOf[stor9] += arg2 / 100
                                        emit Transfer((arg2 / 100), msg.sender, sub_8230af5aAddress);
                                        _24300 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_24300] = 26
                                        mem[_24300 + 32] = 'SafeMath: division by zero'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not uniswapV2PairAddress:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        _24474 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_24474] = 38
                                        mem[_24474 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                        if arg2 / 100 > balanceOf[address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 38
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_24474 + 70 len 26]
                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                        if balanceOf[address(msg.sender)] < arg2 / 100:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2 / 100
                                        if balanceOf[stor7] > !(arg2 / 100):
                                            revert with 0, 17
                                        if balanceOf[stor7] + (arg2 / 100) < balanceOf[stor7]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = uniswapV2PairAddress
                                        mem[32] = 1
                                        balanceOf[stor7] += arg2 / 100
                                        emit Transfer((arg2 / 100), msg.sender, uniswapV2PairAddress);
                                        _25288 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_25288] = 26
                                        mem[_25288 + 32] = 'SafeMath: division by zero'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not this.address:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        _25462 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_25462] = 38
                                        mem[_25462 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                        if arg2 / 10 > balanceOf[address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 38
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_25462 + 70 len 26]
                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                        if balanceOf[address(msg.sender)] < arg2 / 10:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2 / 10
                                        if balanceOf[this.address] > !(arg2 / 10):
                                            revert with 0, 17
                                        if balanceOf[this.address] + (arg2 / 10) < balanceOf[this.address]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = this.address
                                        mem[32] = 1
                                        balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 10)
                                        emit Transfer((arg2 / 10), msg.sender, this.address);
                                        _26276 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26276] = 26
                                        mem[_26276 + 32] = 'SafeMath: division by zero'
                                        if not arg2 / 100:
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not arg1:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            _26456 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_26456] = 38
                                            mem[_26456 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                            if 0 > balanceOf[address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 38
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_26456 + 70 len 26]
                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                            if balanceOf[address(msg.sender)] < 0:
                                                revert with 0, 17
                                            if balanceOf[arg1] > -1:
                                                revert with 0, 17
                                            if balanceOf[arg1] < balanceOf[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(arg1)] = balanceOf[arg1]
                                            emit Transfer(0, msg.sender, arg1);
                                        else:
                                            if arg2 / 100 and 87 > -1 / arg2 / 100:
                                                revert with 0, 17
                                            if not arg2 / 100:
                                                revert with 0, 18
                                            if 87 * arg2 / 100 / arg2 / 100 != 87:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not arg1:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            _27020 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_27020] = 38
                                            mem[_27020 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                            if 87 * arg2 / 100 > balanceOf[address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 38
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_27020 + 70 len 26]
                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                            if balanceOf[address(msg.sender)] < 87 * arg2 / 100:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] += -87 * arg2 / 100
                                            if balanceOf[arg1] > !(87 * arg2 / 100):
                                                revert with 0, 17
                                            if balanceOf[arg1] + (87 * arg2 / 100) < balanceOf[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(arg1)] = balanceOf[arg1] + (87 * arg2 / 100)
                                            emit Transfer((87 * arg2 / 100), msg.sender, arg1);
                    else:
                        if stor19.length < 9:
                            revert with 0, 17
                        mem[64] = ceil32(return_data.size) + 224
                        mem[ceil32(return_data.size) + 160] = 24
                        mem[ceil32(return_data.size) + 192] = 'SafeMath: modulo by zero'
                        if not stor19.length - 9:
                            revert with 0, 'SafeMath: modulo by zero', 0
                        idx = 0
                        s = 0
                        t = 0
                        while idx < 9:
                            if block.timestamp % stor19.length - 9 > !idx:
                                revert with 0, 17
                            if (block.timestamp % stor19.length - 9) + idx >= stor19.length:
                                revert with 0, 50
                            mem[0] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                            mem[32] = 1
                            if s > !balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]]:
                                revert with 0, 17
                            if s + balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] < s:
                                revert with 0, 'SafeMath: addition overflow'
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]]
                            t = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                            continue 
                        if stor19.length <= 9:
                            idx = 0
                            t = 0
                            u = 1440
                            while idx < stor19.length:
                                mem[0] = stor19[idx]
                                mem[32] = 1
                                if balanceOf[stor19[idx]] < 10000000000 * 10^18:
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    t = t
                                    u = stor19[idx]
                                    continue 
                                mem[0] = stor19[idx]
                                mem[32] = 1
                                if not balanceOf[stor19[idx]]:
                                    _16875 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16875] = 26
                                    mem[_16875 + 32] = 'SafeMath: division by zero'
                                    if not 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                        _17459 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _17459 + 68] = mem[idx + _16875 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17459 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _17459 + -mem[64] + 100
                                    if 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                        _20120 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_20120] = 26
                                        mem[_20120 + 32] = 'SafeMath: division by zero'
                                        mem[mem[64] + 4] = stor19[idx]
                                        mem[mem[64] + 36] = 0
                                        require ext_code.size(dogeAddress)
                                        call dogeAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args stor19[idx], 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _21979 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_21979] == bool(mem[_21979])
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    t = 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s
                                    u = stor19[idx]
                                    continue 
                                if balanceOf[stor19[idx]] and 10000 > -1 / balanceOf[stor19[idx]]:
                                    revert with 0, 17
                                if not balanceOf[stor19[idx]]:
                                    revert with 0, 18
                                if 10000 * balanceOf[stor19[idx]] / balanceOf[stor19[idx]] != 10000:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _18155 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18155] = 26
                                mem[_18155 + 32] = 'SafeMath: division by zero'
                                if not 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                    _18821 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _18821 + 68] = mem[idx + _18155 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18821 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _18821 + -mem[64] + 100
                                if 10000 * balanceOf[stor19[idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                    _21182 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21182] = 26
                                    mem[_21182 + 32] = 'SafeMath: division by zero'
                                    mem[mem[64] + 4] = stor19[idx]
                                    mem[mem[64] + 36] = 0
                                    require ext_code.size(dogeAddress)
                                    call dogeAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args stor19[idx], 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _22964 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_22964] == bool(mem[_22964])
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                t = 10000 * balanceOf[stor19[idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s
                                u = stor19[idx]
                                continue 
                            mem[0] = msg.sender
                            mem[32] = 14
                            if stor14[address(msg.sender)]:
                                if not msg.sender:
                                    revert with 0, 'ERC20: transfer from the zero address'
                                if not arg1:
                                    revert with 0, 'ERC20: transfer to the zero address'
                                _16868 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_16868] = 38
                                mem[_16868 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                if arg2 > balanceOf[address(msg.sender)]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 38
                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_16868 + 70 len 26]
                                    var72001 = 64
                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                if balanceOf[address(msg.sender)] < arg2:
                                    revert with 0, 17
                                balanceOf[address(msg.sender)] -= arg2
                                if balanceOf[arg1] > !arg2:
                                    revert with 0, 17
                                if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                emit Transfer(arg2, msg.sender, arg1);
                            else:
                                mem[0] = arg1
                                mem[32] = 14
                                if stor14[address(arg1)]:
                                    if not msg.sender:
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if not arg1:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    _17217 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_17217] = 38
                                    mem[_17217 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                    if arg2 > balanceOf[address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 38
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17217 + 70 len 26]
                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                    if balanceOf[address(msg.sender)] < arg2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)] -= arg2
                                    if balanceOf[arg1] > !arg2:
                                        revert with 0, 17
                                    if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                    emit Transfer(arg2, msg.sender, arg1);
                                else:
                                    if stor10:
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not arg1:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        _16871 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_16871] = 38
                                        mem[_16871 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                        if arg2 > balanceOf[address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 38
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_16871 + 70 len 26]
                                            var72001 = 64
                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                        if balanceOf[address(msg.sender)] < arg2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2
                                        if balanceOf[arg1] > !arg2:
                                            revert with 0, 17
                                        if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                        emit Transfer(arg2, msg.sender, arg1);
                                    else:
                                        _16500 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16500] = 26
                                        mem[_16500 + 32] = 'SafeMath: division by zero'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not stor13:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        _18817 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_18817] = 38
                                        mem[_18817 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                        if arg2 / 100 > balanceOf[address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 38
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_18817 + 70 len 26]
                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                        if balanceOf[address(msg.sender)] < arg2 / 100:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2 / 100
                                        if balanceOf[stor13] > !(arg2 / 100):
                                            revert with 0, 17
                                        if balanceOf[stor13] + (arg2 / 100) < balanceOf[stor13]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = stor13
                                        mem[32] = 1
                                        balanceOf[stor13] += arg2 / 100
                                        emit Transfer((arg2 / 100), msg.sender, stor13);
                                        _22570 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22570] = 26
                                        mem[_22570 + 32] = 'SafeMath: division by zero'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not sub_8230af5aAddress:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        _23405 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_23405] = 38
                                        mem[_23405 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                        if arg2 / 100 > balanceOf[address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 38
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_23405 + 70 len 26]
                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                        if balanceOf[address(msg.sender)] < arg2 / 100:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2 / 100
                                        if balanceOf[stor9] > !(arg2 / 100):
                                            revert with 0, 17
                                        if balanceOf[stor9] + (arg2 / 100) < balanceOf[stor9]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = sub_8230af5aAddress
                                        mem[32] = 1
                                        balanceOf[stor9] += arg2 / 100
                                        emit Transfer((arg2 / 100), msg.sender, sub_8230af5aAddress);
                                        _24301 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_24301] = 26
                                        mem[_24301 + 32] = 'SafeMath: division by zero'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not uniswapV2PairAddress:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        _24477 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_24477] = 38
                                        mem[_24477 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                        if arg2 / 100 > balanceOf[address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 38
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_24477 + 70 len 26]
                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                        if balanceOf[address(msg.sender)] < arg2 / 100:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2 / 100
                                        if balanceOf[stor7] > !(arg2 / 100):
                                            revert with 0, 17
                                        if balanceOf[stor7] + (arg2 / 100) < balanceOf[stor7]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = uniswapV2PairAddress
                                        mem[32] = 1
                                        balanceOf[stor7] += arg2 / 100
                                        emit Transfer((arg2 / 100), msg.sender, uniswapV2PairAddress);
                                        _25289 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_25289] = 26
                                        mem[_25289 + 32] = 'SafeMath: division by zero'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not this.address:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        _25465 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_25465] = 38
                                        mem[_25465 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                        if arg2 / 10 > balanceOf[address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 38
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_25465 + 70 len 26]
                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                        if balanceOf[address(msg.sender)] < arg2 / 10:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2 / 10
                                        if balanceOf[this.address] > !(arg2 / 10):
                                            revert with 0, 17
                                        if balanceOf[this.address] + (arg2 / 10) < balanceOf[this.address]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = this.address
                                        mem[32] = 1
                                        balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 10)
                                        emit Transfer((arg2 / 10), msg.sender, this.address);
                                        _26277 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26277] = 26
                                        mem[_26277 + 32] = 'SafeMath: division by zero'
                                        if not arg2 / 100:
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not arg1:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            _26460 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_26460] = 38
                                            mem[_26460 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                            if 0 > balanceOf[address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 38
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_26460 + 70 len 26]
                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                            if balanceOf[address(msg.sender)] < 0:
                                                revert with 0, 17
                                            if balanceOf[arg1] > -1:
                                                revert with 0, 17
                                            if balanceOf[arg1] < balanceOf[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(arg1)] = balanceOf[arg1]
                                            emit Transfer(0, msg.sender, arg1);
                                        else:
                                            if arg2 / 100 and 87 > -1 / arg2 / 100:
                                                revert with 0, 17
                                            if not arg2 / 100:
                                                revert with 0, 18
                                            if 87 * arg2 / 100 / arg2 / 100 != 87:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not arg1:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            _27025 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_27025] = 38
                                            mem[_27025 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                            if 87 * arg2 / 100 > balanceOf[address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 38
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_27025 + 70 len 26]
                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                            if balanceOf[address(msg.sender)] < 87 * arg2 / 100:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] += -87 * arg2 / 100
                                            if balanceOf[arg1] > !(87 * arg2 / 100):
                                                revert with 0, 17
                                            if balanceOf[arg1] + (87 * arg2 / 100) < balanceOf[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(arg1)] = balanceOf[arg1] + (87 * arg2 / 100)
                                            emit Transfer((87 * arg2 / 100), msg.sender, arg1);
                        else:
                            idx = 0
                            t = 0
                            u = 1440
                            while idx < 9:
                                if block.timestamp % stor19.length - 9 > !idx:
                                    revert with 0, 17
                                if (block.timestamp % stor19.length - 9) + idx >= stor19.length:
                                    revert with 0, 50
                                mem[0] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                mem[32] = 1
                                if balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] < 10000000000 * 10^18:
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    t = t
                                    u = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                    continue 
                                mem[0] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                mem[32] = 1
                                if not balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]]:
                                    _17642 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17642] = 26
                                    mem[_17642 + 32] = 'SafeMath: division by zero'
                                    if not 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                        _17946 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _17946 + 68] = mem[idx + _17642 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17946 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _17946 + -mem[64] + 100
                                    if 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                        _20814 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_20814] = 26
                                        mem[_20814 + 32] = 'SafeMath: division by zero'
                                        mem[mem[64] + 4] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                        mem[mem[64] + 36] = 0
                                        require ext_code.size(dogeAddress)
                                        call dogeAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx], 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _22720 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_22720] == bool(mem[_22720])
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    t = 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s
                                    u = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                    continue 
                                if balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] and 10000 > -1 / balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]]:
                                    revert with 0, 17
                                if not balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]]:
                                    revert with 0, 18
                                if 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] != 10000:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _19182 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19182] = 26
                                mem[_19182 + 32] = 'SafeMath: division by zero'
                                if not 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                    _19461 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _19461 + 68] = mem[idx + _19182 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19461 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19461 + -mem[64] + 100
                                if 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                    _21986 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21986] = 26
                                    mem[_21986 + 32] = 'SafeMath: division by zero'
                                    mem[mem[64] + 4] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                    mem[mem[64] + 36] = 0
                                    require ext_code.size(dogeAddress)
                                    call dogeAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx], 0
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _23152 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_23152] == bool(mem[_23152])
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                t = 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s
                                u = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                continue 
                            mem[0] = msg.sender
                            mem[32] = 14
                            if stor14[address(msg.sender)]:
                                if not msg.sender:
                                    revert with 0, 'ERC20: transfer from the zero address'
                                if not arg1:
                                    revert with 0, 'ERC20: transfer to the zero address'
                                _16876 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_16876] = 38
                                mem[_16876 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                if arg2 > balanceOf[address(msg.sender)]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 38
                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_16876 + 70 len 26]
                                    var72001 = 64
                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                if balanceOf[address(msg.sender)] < arg2:
                                    revert with 0, 17
                                balanceOf[address(msg.sender)] -= arg2
                                if balanceOf[arg1] > !arg2:
                                    revert with 0, 17
                                if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                emit Transfer(arg2, msg.sender, arg1);
                            else:
                                mem[0] = arg1
                                mem[32] = 14
                                if stor14[address(arg1)]:
                                    if not msg.sender:
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if not arg1:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    _17222 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_17222] = 38
                                    mem[_17222 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                    if arg2 > balanceOf[address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 38
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17222 + 70 len 26]
                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                    if balanceOf[address(msg.sender)] < arg2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)] -= arg2
                                    if balanceOf[arg1] > !arg2:
                                        revert with 0, 17
                                    if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                    emit Transfer(arg2, msg.sender, arg1);
                                else:
                                    if stor10:
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not arg1:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        _16879 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_16879] = 38
                                        mem[_16879 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                        if arg2 > balanceOf[address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 38
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_16879 + 70 len 26]
                                            var72001 = 64
                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                        if balanceOf[address(msg.sender)] < arg2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2
                                        if balanceOf[arg1] > !arg2:
                                            revert with 0, 17
                                        if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                        emit Transfer(arg2, msg.sender, arg1);
                                    else:
                                        _16501 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16501] = 26
                                        mem[_16501 + 32] = 'SafeMath: division by zero'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not stor13:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        _18825 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_18825] = 38
                                        mem[_18825 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                        if arg2 / 100 > balanceOf[address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 38
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_18825 + 70 len 26]
                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                        if balanceOf[address(msg.sender)] < arg2 / 100:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2 / 100
                                        if balanceOf[stor13] > !(arg2 / 100):
                                            revert with 0, 17
                                        if balanceOf[stor13] + (arg2 / 100) < balanceOf[stor13]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = stor13
                                        mem[32] = 1
                                        balanceOf[stor13] += arg2 / 100
                                        emit Transfer((arg2 / 100), msg.sender, stor13);
                                        _22573 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22573] = 26
                                        mem[_22573 + 32] = 'SafeMath: division by zero'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not sub_8230af5aAddress:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        _23408 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_23408] = 38
                                        mem[_23408 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                        if arg2 / 100 > balanceOf[address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 38
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_23408 + 70 len 26]
                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                        if balanceOf[address(msg.sender)] < arg2 / 100:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2 / 100
                                        if balanceOf[stor9] > !(arg2 / 100):
                                            revert with 0, 17
                                        if balanceOf[stor9] + (arg2 / 100) < balanceOf[stor9]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = sub_8230af5aAddress
                                        mem[32] = 1
                                        balanceOf[stor9] += arg2 / 100
                                        emit Transfer((arg2 / 100), msg.sender, sub_8230af5aAddress);
                                        _24302 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_24302] = 26
                                        mem[_24302 + 32] = 'SafeMath: division by zero'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not uniswapV2PairAddress:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        _24480 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_24480] = 38
                                        mem[_24480 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                        if arg2 / 100 > balanceOf[address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 38
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_24480 + 70 len 26]
                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                        if balanceOf[address(msg.sender)] < arg2 / 100:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2 / 100
                                        if balanceOf[stor7] > !(arg2 / 100):
                                            revert with 0, 17
                                        if balanceOf[stor7] + (arg2 / 100) < balanceOf[stor7]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = uniswapV2PairAddress
                                        mem[32] = 1
                                        balanceOf[stor7] += arg2 / 100
                                        emit Transfer((arg2 / 100), msg.sender, uniswapV2PairAddress);
                                        _25290 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_25290] = 26
                                        mem[_25290 + 32] = 'SafeMath: division by zero'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not this.address:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        _25468 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_25468] = 38
                                        mem[_25468 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                        if arg2 / 10 > balanceOf[address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 38
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_25468 + 70 len 26]
                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                        if balanceOf[address(msg.sender)] < arg2 / 10:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2 / 10
                                        if balanceOf[this.address] > !(arg2 / 10):
                                            revert with 0, 17
                                        if balanceOf[this.address] + (arg2 / 10) < balanceOf[this.address]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = this.address
                                        mem[32] = 1
                                        balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 10)
                                        emit Transfer((arg2 / 10), msg.sender, this.address);
                                        _26278 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26278] = 26
                                        mem[_26278 + 32] = 'SafeMath: division by zero'
                                        if not arg2 / 100:
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not arg1:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            _26464 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_26464] = 38
                                            mem[_26464 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                            if 0 > balanceOf[address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 38
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_26464 + 70 len 26]
                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                            if balanceOf[address(msg.sender)] < 0:
                                                revert with 0, 17
                                            if balanceOf[arg1] > -1:
                                                revert with 0, 17
                                            if balanceOf[arg1] < balanceOf[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(arg1)] = balanceOf[arg1]
                                            emit Transfer(0, msg.sender, arg1);
                                        else:
                                            if arg2 / 100 and 87 > -1 / arg2 / 100:
                                                revert with 0, 17
                                            if not arg2 / 100:
                                                revert with 0, 18
                                            if 87 * arg2 / 100 / arg2 / 100 != 87:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not arg1:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            _27030 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_27030] = 38
                                            mem[_27030 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                            if 87 * arg2 / 100 > balanceOf[address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 38
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_27030 + 70 len 26]
                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                            if balanceOf[address(msg.sender)] < 87 * arg2 / 100:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] += -87 * arg2 / 100
                                            if balanceOf[arg1] > !(87 * arg2 / 100):
                                                revert with 0, 17
                                            if balanceOf[arg1] + (87 * arg2 / 100) < balanceOf[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(arg1)] = balanceOf[arg1] + (87 * arg2 / 100)
                                            emit Transfer((87 * arg2 / 100), msg.sender, arg1);
            else:
                if ext_call.return_data[0] and 4 > -1 / ext_call.return_data[0]:
                    revert with 0, 17
                if not ext_call.return_data[0]:
                    revert with 0, 18
                if 4 * ext_call.return_data[0] / ext_call.return_data[0] != 4:
                    revert with 0, 'SafeMath: multiplication overflow'
                mem[64] = ceil32(return_data.size) + 160
                mem[ceil32(return_data.size) + 96] = 26
                mem[ceil32(return_data.size) + 128] = 'SafeMath: division by zero'
                if not stor19.length:
                    if not msg.sender:
                        revert with 0, 'ERC20: transfer from the zero address'
                    if stor14[address(msg.sender)]:
                        if not arg1:
                            revert with 0, 'ERC20: transfer to the zero address'
                        if arg2 > balanceOf[address(msg.sender)]:
                            revert with 0, 
                                        32,
                                        38,
                                        0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 230 len 26] >> 48,
                                        0
                        if balanceOf[address(msg.sender)] < arg2:
                            revert with 0, 17
                        balanceOf[address(msg.sender)] -= arg2
                        if balanceOf[arg1] > !arg2:
                            revert with 0, 17
                        if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                            revert with 0, 'SafeMath: addition overflow'
                        balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                        emit Transfer(arg2, msg.sender, arg1);
                    else:
                        if stor14[address(arg1)]:
                            if not arg1:
                                revert with 0, 'ERC20: transfer to the zero address'
                            if arg2 > balanceOf[address(msg.sender)]:
                                revert with 0, 
                                            32,
                                            38,
                                            0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 230 len 26] >> 48,
                                            0
                            if balanceOf[address(msg.sender)] < arg2:
                                revert with 0, 17
                            balanceOf[address(msg.sender)] -= arg2
                            if balanceOf[arg1] > !arg2:
                                revert with 0, 17
                            if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                            emit Transfer(arg2, msg.sender, arg1);
                        else:
                            if stor10:
                                if not arg1:
                                    revert with 0, 'ERC20: transfer to the zero address'
                                if arg2 > balanceOf[address(msg.sender)]:
                                    revert with 0, 
                                                32,
                                                38,
                                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 230 len 26] >> 48,
                                                0
                                if balanceOf[address(msg.sender)] < arg2:
                                    revert with 0, 17
                                balanceOf[address(msg.sender)] -= arg2
                                if balanceOf[arg1] > !arg2:
                                    revert with 0, 17
                                if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                emit Transfer(arg2, msg.sender, arg1);
                            else:
                                if not stor13:
                                    revert with 0, 'ERC20: transfer to the zero address'
                                if arg2 / 100 > balanceOf[address(msg.sender)]:
                                    revert with 0, 
                                                32,
                                                38,
                                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 294 len 26] >> 48,
                                                0
                                if balanceOf[address(msg.sender)] < arg2 / 100:
                                    revert with 0, 17
                                balanceOf[address(msg.sender)] -= arg2 / 100
                                if balanceOf[stor13] > !(arg2 / 100):
                                    revert with 0, 17
                                if balanceOf[stor13] + (arg2 / 100) < balanceOf[stor13]:
                                    revert with 0, 'SafeMath: addition overflow'
                                balanceOf[stor13] += arg2 / 100
                                emit Transfer((arg2 / 100), msg.sender, stor13);
                                if not msg.sender:
                                    revert with 0, 'ERC20: transfer from the zero address'
                                if not sub_8230af5aAddress:
                                    revert with 0, 'ERC20: transfer to the zero address'
                                if arg2 / 100 > balanceOf[address(msg.sender)]:
                                    revert with 0, 
                                                32,
                                                38,
                                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 454 len 26] >> 48,
                                                0
                                if balanceOf[address(msg.sender)] < arg2 / 100:
                                    revert with 0, 17
                                balanceOf[address(msg.sender)] -= arg2 / 100
                                if balanceOf[stor9] > !(arg2 / 100):
                                    revert with 0, 17
                                if balanceOf[stor9] + (arg2 / 100) < balanceOf[stor9]:
                                    revert with 0, 'SafeMath: addition overflow'
                                balanceOf[stor9] += arg2 / 100
                                emit Transfer((arg2 / 100), msg.sender, sub_8230af5aAddress);
                                if not msg.sender:
                                    revert with 0, 'ERC20: transfer from the zero address'
                                if not uniswapV2PairAddress:
                                    revert with 0, 'ERC20: transfer to the zero address'
                                if arg2 / 100 > balanceOf[address(msg.sender)]:
                                    revert with 0, 
                                                32,
                                                38,
                                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 614 len 26] >> 48,
                                                0
                                if balanceOf[address(msg.sender)] < arg2 / 100:
                                    revert with 0, 17
                                balanceOf[address(msg.sender)] -= arg2 / 100
                                if balanceOf[stor7] > !(arg2 / 100):
                                    revert with 0, 17
                                if balanceOf[stor7] + (arg2 / 100) < balanceOf[stor7]:
                                    revert with 0, 'SafeMath: addition overflow'
                                balanceOf[stor7] += arg2 / 100
                                emit Transfer((arg2 / 100), msg.sender, uniswapV2PairAddress);
                                if not msg.sender:
                                    revert with 0, 'ERC20: transfer from the zero address'
                                if not this.address:
                                    revert with 0, 'ERC20: transfer to the zero address'
                                if arg2 / 10 > balanceOf[address(msg.sender)]:
                                    revert with 0, 
                                                32,
                                                38,
                                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 774 len 26] >> 48,
                                                0
                                if balanceOf[address(msg.sender)] < arg2 / 10:
                                    revert with 0, 17
                                balanceOf[address(msg.sender)] -= arg2 / 10
                                if balanceOf[this.address] > !(arg2 / 10):
                                    revert with 0, 17
                                if balanceOf[this.address] + (arg2 / 10) < balanceOf[this.address]:
                                    revert with 0, 'SafeMath: addition overflow'
                                balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 10)
                                emit Transfer((arg2 / 10), msg.sender, this.address);
                                if not arg2 / 100:
                                    if not msg.sender:
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if not arg1:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    if 0 > balanceOf[address(msg.sender)]:
                                        revert with 0, 
                                                    32,
                                                    38,
                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 934 len 26] >> 48,
                                                    0
                                    if balanceOf[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if balanceOf[arg1] > -1:
                                        revert with 0, 17
                                    if balanceOf[arg1] < balanceOf[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(arg1)] = balanceOf[arg1]
                                    emit Transfer(0, msg.sender, arg1);
                                else:
                                    if arg2 / 100 and 87 > -1 / arg2 / 100:
                                        revert with 0, 17
                                    if not arg2 / 100:
                                        revert with 0, 18
                                    if 87 * arg2 / 100 / arg2 / 100 != 87:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if not arg1:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    if 87 * arg2 / 100 > balanceOf[address(msg.sender)]:
                                        revert with 0, 
                                                    32,
                                                    38,
                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 934 len 26] >> 48,
                                                    0
                                    if balanceOf[address(msg.sender)] < 87 * arg2 / 100:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)] += -87 * arg2 / 100
                                    if balanceOf[arg1] > !(87 * arg2 / 100):
                                        revert with 0, 17
                                    if balanceOf[arg1] + (87 * arg2 / 100) < balanceOf[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(arg1)] = balanceOf[arg1] + (87 * arg2 / 100)
                                    emit Transfer((87 * arg2 / 100), msg.sender, arg1);
                else:
                    if stor19.length <= 9:
                        idx = 0
                        s = 0
                        t = 0
                        while idx < stor19.length:
                            mem[0] = stor19[idx]
                            mem[32] = 1
                            if s > !balanceOf[stor19[idx]]:
                                revert with 0, 17
                            if s + balanceOf[stor19[idx]] < s:
                                revert with 0, 'SafeMath: addition overflow'
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + balanceOf[stor19[idx]]
                            t = stor19[idx]
                            continue 
                        if stor19.length <= 9:
                            idx = 0
                            t = 0
                            u = 160 * stor19.length
                            while idx < stor19.length:
                                mem[0] = stor19[idx]
                                mem[32] = 1
                                if balanceOf[stor19[idx]] < 10000000000 * 10^18:
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    t = t
                                    u = stor19[idx]
                                    continue 
                                mem[0] = stor19[idx]
                                mem[32] = 1
                                if not balanceOf[stor19[idx]]:
                                    _16830 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16830] = 26
                                    mem[_16830 + 32] = 'SafeMath: division by zero'
                                    if not s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                        _17438 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _17438 + 68] = mem[idx + _16830 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17438 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _17438 + -mem[64] + 100
                                    if 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                        if not 4 * ext_call.return_data[0] / 5:
                                            _20078 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_20078] = 26
                                            mem[_20078 + 32] = 'SafeMath: division by zero'
                                            mem[mem[64] + 4] = stor19[idx]
                                            mem[mem[64] + 36] = 0
                                            require ext_code.size(dogeAddress)
                                            call dogeAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args stor19[idx], 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _21935 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_21935] == bool(mem[_21935])
                                        else:
                                            if 4 * ext_call.return_data[0] / 5 and 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length > -1 / 4 * ext_call.return_data[0] / 5:
                                                revert with 0, 17
                                            if not 4 * ext_call.return_data[0] / 5:
                                                revert with 0, 18
                                            if 4 * ext_call.return_data[0] / 5 * 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 4 * ext_call.return_data[0] / 5 != 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _21166 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_21166] = 26
                                            mem[_21166 + 32] = 'SafeMath: division by zero'
                                            mem[mem[64] + 4] = stor19[idx]
                                            mem[mem[64] + 36] = 4 * ext_call.return_data[0] / 5 * 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 10000
                                            require ext_code.size(dogeAddress)
                                            call dogeAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args stor19[idx], 4 * ext_call.return_data[0] / 5 * 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 10000
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _22958 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_22958] == bool(mem[_22958])
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    t = 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length
                                    u = stor19[idx]
                                    continue 
                                if balanceOf[stor19[idx]] and 10000 > -1 / balanceOf[stor19[idx]]:
                                    revert with 0, 17
                                if not balanceOf[stor19[idx]]:
                                    revert with 0, 18
                                if 10000 * balanceOf[stor19[idx]] / balanceOf[stor19[idx]] != 10000:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _18113 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18113] = 26
                                mem[_18113 + 32] = 'SafeMath: division by zero'
                                if not s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                    _18773 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _18773 + 68] = mem[idx + _18113 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18773 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _18773 + -mem[64] + 100
                                if 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                    if not 4 * ext_call.return_data[0] / 5:
                                        _21165 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_21165] = 26
                                        mem[_21165 + 32] = 'SafeMath: division by zero'
                                        mem[mem[64] + 4] = stor19[idx]
                                        mem[mem[64] + 36] = 0
                                        require ext_code.size(dogeAddress)
                                        call dogeAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args stor19[idx], 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _22957 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_22957] == bool(mem[_22957])
                                    else:
                                        if 4 * ext_call.return_data[0] / 5 and 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length > -1 / 4 * ext_call.return_data[0] / 5:
                                            revert with 0, 17
                                        if not 4 * ext_call.return_data[0] / 5:
                                            revert with 0, 18
                                        if 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 4 * ext_call.return_data[0] / 5 != 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _22715 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22715] = 26
                                        mem[_22715 + 32] = 'SafeMath: division by zero'
                                        mem[mem[64] + 4] = stor19[idx]
                                        mem[mem[64] + 36] = 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 10000
                                        require ext_code.size(dogeAddress)
                                        call dogeAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args stor19[idx], 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 10000
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _23318 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_23318] == bool(mem[_23318])
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                t = 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length
                                u = stor19[idx]
                                continue 
                            mem[0] = msg.sender
                            mem[32] = 14
                            if stor14[address(msg.sender)]:
                                if not msg.sender:
                                    revert with 0, 'ERC20: transfer from the zero address'
                                if not arg1:
                                    revert with 0, 'ERC20: transfer to the zero address'
                                _16823 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_16823] = 38
                                mem[_16823 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                if arg2 > balanceOf[address(msg.sender)]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 38
                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_16823 + 70 len 26]
                                    var67001 = 64
                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                if balanceOf[address(msg.sender)] < arg2:
                                    revert with 0, 17
                                balanceOf[address(msg.sender)] -= arg2
                                if balanceOf[arg1] > !arg2:
                                    revert with 0, 17
                                if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                emit Transfer(arg2, msg.sender, arg1);
                            else:
                                mem[0] = arg1
                                mem[32] = 14
                                if stor14[address(arg1)]:
                                    if not msg.sender:
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if not arg1:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    _17187 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_17187] = 38
                                    mem[_17187 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                    if arg2 > balanceOf[address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 38
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17187 + 70 len 26]
                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                    if balanceOf[address(msg.sender)] < arg2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)] -= arg2
                                    if balanceOf[arg1] > !arg2:
                                        revert with 0, 17
                                    if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                    emit Transfer(arg2, msg.sender, arg1);
                                else:
                                    if stor10:
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not arg1:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        _16826 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_16826] = 38
                                        mem[_16826 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                        if arg2 > balanceOf[address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 38
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_16826 + 70 len 26]
                                            var67001 = 64
                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                        if balanceOf[address(msg.sender)] < arg2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2
                                        if balanceOf[arg1] > !arg2:
                                            revert with 0, 17
                                        if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                        emit Transfer(arg2, msg.sender, arg1);
                                    else:
                                        _16491 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16491] = 26
                                        mem[_16491 + 32] = 'SafeMath: division by zero'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not stor13:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        _18769 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_18769] = 38
                                        mem[_18769 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                        if arg2 / 100 > balanceOf[address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 38
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_18769 + 70 len 26]
                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                        if balanceOf[address(msg.sender)] < arg2 / 100:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2 / 100
                                        if balanceOf[stor13] > !(arg2 / 100):
                                            revert with 0, 17
                                        if balanceOf[stor13] + (arg2 / 100) < balanceOf[stor13]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = stor13
                                        mem[32] = 1
                                        balanceOf[stor13] += arg2 / 100
                                        emit Transfer((arg2 / 100), msg.sender, stor13);
                                        _22553 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22553] = 26
                                        mem[_22553 + 32] = 'SafeMath: division by zero'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not sub_8230af5aAddress:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        _23383 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_23383] = 38
                                        mem[_23383 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                        if arg2 / 100 > balanceOf[address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 38
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_23383 + 70 len 26]
                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                        if balanceOf[address(msg.sender)] < arg2 / 100:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2 / 100
                                        if balanceOf[stor9] > !(arg2 / 100):
                                            revert with 0, 17
                                        if balanceOf[stor9] + (arg2 / 100) < balanceOf[stor9]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = sub_8230af5aAddress
                                        mem[32] = 1
                                        balanceOf[stor9] += arg2 / 100
                                        emit Transfer((arg2 / 100), msg.sender, sub_8230af5aAddress);
                                        _24295 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_24295] = 26
                                        mem[_24295 + 32] = 'SafeMath: division by zero'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not uniswapV2PairAddress:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        _24459 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_24459] = 38
                                        mem[_24459 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                        if arg2 / 100 > balanceOf[address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 38
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_24459 + 70 len 26]
                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                        if balanceOf[address(msg.sender)] < arg2 / 100:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2 / 100
                                        if balanceOf[stor7] > !(arg2 / 100):
                                            revert with 0, 17
                                        if balanceOf[stor7] + (arg2 / 100) < balanceOf[stor7]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = uniswapV2PairAddress
                                        mem[32] = 1
                                        balanceOf[stor7] += arg2 / 100
                                        emit Transfer((arg2 / 100), msg.sender, uniswapV2PairAddress);
                                        _25283 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_25283] = 26
                                        mem[_25283 + 32] = 'SafeMath: division by zero'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not this.address:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        _25447 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_25447] = 38
                                        mem[_25447 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                        if arg2 / 10 > balanceOf[address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 38
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_25447 + 70 len 26]
                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                        if balanceOf[address(msg.sender)] < arg2 / 10:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2 / 10
                                        if balanceOf[this.address] > !(arg2 / 10):
                                            revert with 0, 17
                                        if balanceOf[this.address] + (arg2 / 10) < balanceOf[this.address]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = this.address
                                        mem[32] = 1
                                        balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 10)
                                        emit Transfer((arg2 / 10), msg.sender, this.address);
                                        _26271 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26271] = 26
                                        mem[_26271 + 32] = 'SafeMath: division by zero'
                                        if not arg2 / 100:
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not arg1:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            _26436 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_26436] = 38
                                            mem[_26436 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                            if 0 > balanceOf[address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 38
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_26436 + 70 len 26]
                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                            if balanceOf[address(msg.sender)] < 0:
                                                revert with 0, 17
                                            if balanceOf[arg1] > -1:
                                                revert with 0, 17
                                            if balanceOf[arg1] < balanceOf[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(arg1)] = balanceOf[arg1]
                                            emit Transfer(0, msg.sender, arg1);
                                        else:
                                            if arg2 / 100 and 87 > -1 / arg2 / 100:
                                                revert with 0, 17
                                            if not arg2 / 100:
                                                revert with 0, 18
                                            if 87 * arg2 / 100 / arg2 / 100 != 87:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not arg1:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            _26995 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_26995] = 38
                                            mem[_26995 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                            if 87 * arg2 / 100 > balanceOf[address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 38
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_26995 + 70 len 26]
                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                            if balanceOf[address(msg.sender)] < 87 * arg2 / 100:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] += -87 * arg2 / 100
                                            if balanceOf[arg1] > !(87 * arg2 / 100):
                                                revert with 0, 17
                                            if balanceOf[arg1] + (87 * arg2 / 100) < balanceOf[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(arg1)] = balanceOf[arg1] + (87 * arg2 / 100)
                                            emit Transfer((87 * arg2 / 100), msg.sender, arg1);
                        else:
                            idx = 0
                            t = 0
                            u = 160 * stor19.length
                            while idx < 9:
                                if 0 > !idx:
                                    revert with 0, 17
                                if idx >= stor19.length:
                                    revert with 0, 50
                                mem[0] = stor19[idx]
                                mem[32] = 1
                                if balanceOf[stor19[idx]] < 10000000000 * 10^18:
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    t = t
                                    u = stor19[idx]
                                    continue 
                                mem[0] = stor19[idx]
                                mem[32] = 1
                                if not balanceOf[stor19[idx]]:
                                    _17618 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17618] = 26
                                    mem[_17618 + 32] = 'SafeMath: division by zero'
                                    if not s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                        _17925 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _17925 + 68] = mem[idx + _17618 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17925 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _17925 + -mem[64] + 100
                                    if 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                        if not 4 * ext_call.return_data[0] / 5:
                                            _20796 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_20796] = 26
                                            mem[_20796 + 32] = 'SafeMath: division by zero'
                                            mem[mem[64] + 4] = stor19[idx]
                                            mem[mem[64] + 36] = 0
                                            require ext_code.size(dogeAddress)
                                            call dogeAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args stor19[idx], 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _22716 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_22716] == bool(mem[_22716])
                                        else:
                                            if 4 * ext_call.return_data[0] / 5 and 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length > -1 / 4 * ext_call.return_data[0] / 5:
                                                revert with 0, 17
                                            if not 4 * ext_call.return_data[0] / 5:
                                                revert with 0, 18
                                            if 4 * ext_call.return_data[0] / 5 * 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 4 * ext_call.return_data[0] / 5 != 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _21943 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_21943] = 26
                                            mem[_21943 + 32] = 'SafeMath: division by zero'
                                            mem[mem[64] + 4] = stor19[idx]
                                            mem[mem[64] + 36] = 4 * ext_call.return_data[0] / 5 * 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 10000
                                            require ext_code.size(dogeAddress)
                                            call dogeAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args stor19[idx], 4 * ext_call.return_data[0] / 5 * 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 10000
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _23148 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_23148] == bool(mem[_23148])
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    t = 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length
                                    u = stor19[idx]
                                    continue 
                                if balanceOf[stor19[idx]] and 10000 > -1 / balanceOf[stor19[idx]]:
                                    revert with 0, 17
                                if not balanceOf[stor19[idx]]:
                                    revert with 0, 18
                                if 10000 * balanceOf[stor19[idx]] / balanceOf[stor19[idx]] != 10000:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _19164 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19164] = 26
                                mem[_19164 + 32] = 'SafeMath: division by zero'
                                if not s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                    _19434 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _19434 + 68] = mem[idx + _19164 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19434 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19434 + -mem[64] + 100
                                if 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                    if not 4 * ext_call.return_data[0] / 5:
                                        _21942 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_21942] = 26
                                        mem[_21942 + 32] = 'SafeMath: division by zero'
                                        mem[mem[64] + 4] = stor19[idx]
                                        mem[mem[64] + 36] = 0
                                        require ext_code.size(dogeAddress)
                                        call dogeAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args stor19[idx], 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _23147 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_23147] == bool(mem[_23147])
                                    else:
                                        if 4 * ext_call.return_data[0] / 5 and 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length > -1 / 4 * ext_call.return_data[0] / 5:
                                            revert with 0, 17
                                        if not 4 * ext_call.return_data[0] / 5:
                                            revert with 0, 18
                                        if 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 4 * ext_call.return_data[0] / 5 != 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _22959 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22959] = 26
                                        mem[_22959 + 32] = 'SafeMath: division by zero'
                                        mem[mem[64] + 4] = stor19[idx]
                                        mem[mem[64] + 36] = 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 10000
                                        require ext_code.size(dogeAddress)
                                        call dogeAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args stor19[idx], 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 10000
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _23623 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_23623] == bool(mem[_23623])
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                t = 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length
                                u = stor19[idx]
                                continue 
                            mem[0] = msg.sender
                            mem[32] = 14
                            if stor14[address(msg.sender)]:
                                if not msg.sender:
                                    revert with 0, 'ERC20: transfer from the zero address'
                                if not arg1:
                                    revert with 0, 'ERC20: transfer to the zero address'
                                _16831 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_16831] = 38
                                mem[_16831 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                if arg2 > balanceOf[address(msg.sender)]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 38
                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_16831 + 70 len 26]
                                    var67001 = 64
                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                if balanceOf[address(msg.sender)] < arg2:
                                    revert with 0, 17
                                balanceOf[address(msg.sender)] -= arg2
                                if balanceOf[arg1] > !arg2:
                                    revert with 0, 17
                                if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                emit Transfer(arg2, msg.sender, arg1);
                            else:
                                mem[0] = arg1
                                mem[32] = 14
                                if stor14[address(arg1)]:
                                    if not msg.sender:
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if not arg1:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    _17192 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_17192] = 38
                                    mem[_17192 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                    if arg2 > balanceOf[address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 38
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17192 + 70 len 26]
                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                    if balanceOf[address(msg.sender)] < arg2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)] -= arg2
                                    if balanceOf[arg1] > !arg2:
                                        revert with 0, 17
                                    if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                    emit Transfer(arg2, msg.sender, arg1);
                                else:
                                    if stor10:
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not arg1:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        _16834 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_16834] = 38
                                        mem[_16834 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                        if arg2 > balanceOf[address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 38
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_16834 + 70 len 26]
                                            var67001 = 64
                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                        if balanceOf[address(msg.sender)] < arg2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2
                                        if balanceOf[arg1] > !arg2:
                                            revert with 0, 17
                                        if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                        emit Transfer(arg2, msg.sender, arg1);
                                    else:
                                        _16492 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16492] = 26
                                        mem[_16492 + 32] = 'SafeMath: division by zero'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not stor13:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        _18777 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_18777] = 38
                                        mem[_18777 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                        if arg2 / 100 > balanceOf[address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 38
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_18777 + 70 len 26]
                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                        if balanceOf[address(msg.sender)] < arg2 / 100:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2 / 100
                                        if balanceOf[stor13] > !(arg2 / 100):
                                            revert with 0, 17
                                        if balanceOf[stor13] + (arg2 / 100) < balanceOf[stor13]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = stor13
                                        mem[32] = 1
                                        balanceOf[stor13] += arg2 / 100
                                        emit Transfer((arg2 / 100), msg.sender, stor13);
                                        _22557 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22557] = 26
                                        mem[_22557 + 32] = 'SafeMath: division by zero'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not sub_8230af5aAddress:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        _23386 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_23386] = 38
                                        mem[_23386 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                        if arg2 / 100 > balanceOf[address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 38
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_23386 + 70 len 26]
                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                        if balanceOf[address(msg.sender)] < arg2 / 100:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2 / 100
                                        if balanceOf[stor9] > !(arg2 / 100):
                                            revert with 0, 17
                                        if balanceOf[stor9] + (arg2 / 100) < balanceOf[stor9]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = sub_8230af5aAddress
                                        mem[32] = 1
                                        balanceOf[stor9] += arg2 / 100
                                        emit Transfer((arg2 / 100), msg.sender, sub_8230af5aAddress);
                                        _24296 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_24296] = 26
                                        mem[_24296 + 32] = 'SafeMath: division by zero'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not uniswapV2PairAddress:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        _24462 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_24462] = 38
                                        mem[_24462 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                        if arg2 / 100 > balanceOf[address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 38
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_24462 + 70 len 26]
                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                        if balanceOf[address(msg.sender)] < arg2 / 100:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2 / 100
                                        if balanceOf[stor7] > !(arg2 / 100):
                                            revert with 0, 17
                                        if balanceOf[stor7] + (arg2 / 100) < balanceOf[stor7]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = uniswapV2PairAddress
                                        mem[32] = 1
                                        balanceOf[stor7] += arg2 / 100
                                        emit Transfer((arg2 / 100), msg.sender, uniswapV2PairAddress);
                                        _25284 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_25284] = 26
                                        mem[_25284 + 32] = 'SafeMath: division by zero'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not this.address:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        _25450 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_25450] = 38
                                        mem[_25450 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                        if arg2 / 10 > balanceOf[address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 38
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_25450 + 70 len 26]
                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                        if balanceOf[address(msg.sender)] < arg2 / 10:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2 / 10
                                        if balanceOf[this.address] > !(arg2 / 10):
                                            revert with 0, 17
                                        if balanceOf[this.address] + (arg2 / 10) < balanceOf[this.address]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = this.address
                                        mem[32] = 1
                                        balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 10)
                                        emit Transfer((arg2 / 10), msg.sender, this.address);
                                        _26272 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26272] = 26
                                        mem[_26272 + 32] = 'SafeMath: division by zero'
                                        if not arg2 / 100:
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not arg1:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            _26440 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_26440] = 38
                                            mem[_26440 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                            if 0 > balanceOf[address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 38
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_26440 + 70 len 26]
                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                            if balanceOf[address(msg.sender)] < 0:
                                                revert with 0, 17
                                            if balanceOf[arg1] > -1:
                                                revert with 0, 17
                                            if balanceOf[arg1] < balanceOf[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(arg1)] = balanceOf[arg1]
                                            emit Transfer(0, msg.sender, arg1);
                                        else:
                                            if arg2 / 100 and 87 > -1 / arg2 / 100:
                                                revert with 0, 17
                                            if not arg2 / 100:
                                                revert with 0, 18
                                            if 87 * arg2 / 100 / arg2 / 100 != 87:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not arg1:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            _27000 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_27000] = 38
                                            mem[_27000 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                            if 87 * arg2 / 100 > balanceOf[address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 38
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_27000 + 70 len 26]
                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                            if balanceOf[address(msg.sender)] < 87 * arg2 / 100:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] += -87 * arg2 / 100
                                            if balanceOf[arg1] > !(87 * arg2 / 100):
                                                revert with 0, 17
                                            if balanceOf[arg1] + (87 * arg2 / 100) < balanceOf[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(arg1)] = balanceOf[arg1] + (87 * arg2 / 100)
                                            emit Transfer((87 * arg2 / 100), msg.sender, arg1);
                    else:
                        if stor19.length < 9:
                            revert with 0, 17
                        mem[64] = ceil32(return_data.size) + 224
                        mem[ceil32(return_data.size) + 160] = 24
                        mem[ceil32(return_data.size) + 192] = 'SafeMath: modulo by zero'
                        if not stor19.length - 9:
                            revert with 0, 'SafeMath: modulo by zero', 0
                        idx = 0
                        s = 0
                        t = 0
                        while idx < 9:
                            if block.timestamp % stor19.length - 9 > !idx:
                                revert with 0, 17
                            if (block.timestamp % stor19.length - 9) + idx >= stor19.length:
                                revert with 0, 50
                            mem[0] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                            mem[32] = 1
                            if s > !balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]]:
                                revert with 0, 17
                            if s + balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] < s:
                                revert with 0, 'SafeMath: addition overflow'
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]]
                            t = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                            continue 
                        if stor19.length <= 9:
                            idx = 0
                            t = 0
                            u = 1440
                            while idx < stor19.length:
                                mem[0] = stor19[idx]
                                mem[32] = 1
                                if balanceOf[stor19[idx]] < 10000000000 * 10^18:
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    t = t
                                    u = stor19[idx]
                                    continue 
                                mem[0] = stor19[idx]
                                mem[32] = 1
                                if not balanceOf[stor19[idx]]:
                                    _16845 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16845] = 26
                                    mem[_16845 + 32] = 'SafeMath: division by zero'
                                    if not 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                        _17445 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _17445 + 68] = mem[idx + _16845 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17445 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _17445 + -mem[64] + 100
                                    if 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                        if not 4 * ext_call.return_data[0] / 5:
                                            _20092 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_20092] = 26
                                            mem[_20092 + 32] = 'SafeMath: division by zero'
                                            mem[mem[64] + 4] = stor19[idx]
                                            mem[mem[64] + 36] = 0
                                            require ext_code.size(dogeAddress)
                                            call dogeAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args stor19[idx], 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _21950 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_21950] == bool(mem[_21950])
                                        else:
                                            if 4 * ext_call.return_data[0] / 5 and 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s > -1 / 4 * ext_call.return_data[0] / 5:
                                                revert with 0, 17
                                            if not 4 * ext_call.return_data[0] / 5:
                                                revert with 0, 18
                                            if 4 * ext_call.return_data[0] / 5 * 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 4 * ext_call.return_data[0] / 5 != 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _21172 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_21172] = 26
                                            mem[_21172 + 32] = 'SafeMath: division by zero'
                                            mem[mem[64] + 4] = stor19[idx]
                                            mem[mem[64] + 36] = 4 * ext_call.return_data[0] / 5 * 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 10000
                                            require ext_code.size(dogeAddress)
                                            call dogeAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args stor19[idx], 4 * ext_call.return_data[0] / 5 * 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 10000
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _22961 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_22961] == bool(mem[_22961])
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    t = 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s
                                    u = stor19[idx]
                                    continue 
                                if balanceOf[stor19[idx]] and 10000 > -1 / balanceOf[stor19[idx]]:
                                    revert with 0, 17
                                if not balanceOf[stor19[idx]]:
                                    revert with 0, 18
                                if 10000 * balanceOf[stor19[idx]] / balanceOf[stor19[idx]] != 10000:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _18127 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18127] = 26
                                mem[_18127 + 32] = 'SafeMath: division by zero'
                                if not 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                    _18789 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _18789 + 68] = mem[idx + _18127 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18789 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _18789 + -mem[64] + 100
                                if 10000 * balanceOf[stor19[idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                    if not 4 * ext_call.return_data[0] / 5:
                                        _21171 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_21171] = 26
                                        mem[_21171 + 32] = 'SafeMath: division by zero'
                                        mem[mem[64] + 4] = stor19[idx]
                                        mem[mem[64] + 36] = 0
                                        require ext_code.size(dogeAddress)
                                        call dogeAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args stor19[idx], 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _22960 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_22960] == bool(mem[_22960])
                                    else:
                                        if 4 * ext_call.return_data[0] / 5 and 10000 * balanceOf[stor19[idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s > -1 / 4 * ext_call.return_data[0] / 5:
                                            revert with 0, 17
                                        if not 4 * ext_call.return_data[0] / 5:
                                            revert with 0, 18
                                        if 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor19[idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 4 * ext_call.return_data[0] / 5 != 10000 * balanceOf[stor19[idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _22717 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22717] = 26
                                        mem[_22717 + 32] = 'SafeMath: division by zero'
                                        mem[mem[64] + 4] = stor19[idx]
                                        mem[mem[64] + 36] = 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor19[idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 10000
                                        require ext_code.size(dogeAddress)
                                        call dogeAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args stor19[idx], 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor19[idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 10000
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _23321 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_23321] == bool(mem[_23321])
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                t = 10000 * balanceOf[stor19[idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s
                                u = stor19[idx]
                                continue 
                            mem[0] = msg.sender
                            mem[32] = 14
                            if stor14[address(msg.sender)]:
                                if not msg.sender:
                                    revert with 0, 'ERC20: transfer from the zero address'
                                if not arg1:
                                    revert with 0, 'ERC20: transfer to the zero address'
                                _16838 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_16838] = 38
                                mem[_16838 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                if arg2 > balanceOf[address(msg.sender)]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 38
                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_16838 + 70 len 26]
                                    var78001 = 64
                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                if balanceOf[address(msg.sender)] < arg2:
                                    revert with 0, 17
                                balanceOf[address(msg.sender)] -= arg2
                                if balanceOf[arg1] > !arg2:
                                    revert with 0, 17
                                if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                emit Transfer(arg2, msg.sender, arg1);
                            else:
                                mem[0] = arg1
                                mem[32] = 14
                                if stor14[address(arg1)]:
                                    if not msg.sender:
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if not arg1:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    _17197 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_17197] = 38
                                    mem[_17197 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                    if arg2 > balanceOf[address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 38
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17197 + 70 len 26]
                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                    if balanceOf[address(msg.sender)] < arg2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)] -= arg2
                                    if balanceOf[arg1] > !arg2:
                                        revert with 0, 17
                                    if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                    emit Transfer(arg2, msg.sender, arg1);
                                else:
                                    if stor10:
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not arg1:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        _16841 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_16841] = 38
                                        mem[_16841 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                        if arg2 > balanceOf[address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 38
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_16841 + 70 len 26]
                                            var78001 = 64
                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                        if balanceOf[address(msg.sender)] < arg2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2
                                        if balanceOf[arg1] > !arg2:
                                            revert with 0, 17
                                        if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                        emit Transfer(arg2, msg.sender, arg1);
                                    else:
                                        _16494 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16494] = 26
                                        mem[_16494 + 32] = 'SafeMath: division by zero'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not stor13:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        _18785 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_18785] = 38
                                        mem[_18785 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                        if arg2 / 100 > balanceOf[address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 38
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_18785 + 70 len 26]
                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                        if balanceOf[address(msg.sender)] < arg2 / 100:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2 / 100
                                        if balanceOf[stor13] > !(arg2 / 100):
                                            revert with 0, 17
                                        if balanceOf[stor13] + (arg2 / 100) < balanceOf[stor13]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = stor13
                                        mem[32] = 1
                                        balanceOf[stor13] += arg2 / 100
                                        emit Transfer((arg2 / 100), msg.sender, stor13);
                                        _22559 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22559] = 26
                                        mem[_22559 + 32] = 'SafeMath: division by zero'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not sub_8230af5aAddress:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        _23391 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_23391] = 38
                                        mem[_23391 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                        if arg2 / 100 > balanceOf[address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 38
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_23391 + 70 len 26]
                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                        if balanceOf[address(msg.sender)] < arg2 / 100:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2 / 100
                                        if balanceOf[stor9] > !(arg2 / 100):
                                            revert with 0, 17
                                        if balanceOf[stor9] + (arg2 / 100) < balanceOf[stor9]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = sub_8230af5aAddress
                                        mem[32] = 1
                                        balanceOf[stor9] += arg2 / 100
                                        emit Transfer((arg2 / 100), msg.sender, sub_8230af5aAddress);
                                        _24297 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_24297] = 26
                                        mem[_24297 + 32] = 'SafeMath: division by zero'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not uniswapV2PairAddress:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        _24465 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_24465] = 38
                                        mem[_24465 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                        if arg2 / 100 > balanceOf[address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 38
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_24465 + 70 len 26]
                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                        if balanceOf[address(msg.sender)] < arg2 / 100:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2 / 100
                                        if balanceOf[stor7] > !(arg2 / 100):
                                            revert with 0, 17
                                        if balanceOf[stor7] + (arg2 / 100) < balanceOf[stor7]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = uniswapV2PairAddress
                                        mem[32] = 1
                                        balanceOf[stor7] += arg2 / 100
                                        emit Transfer((arg2 / 100), msg.sender, uniswapV2PairAddress);
                                        _25285 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_25285] = 26
                                        mem[_25285 + 32] = 'SafeMath: division by zero'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not this.address:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        _25453 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_25453] = 38
                                        mem[_25453 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                        if arg2 / 10 > balanceOf[address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 38
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_25453 + 70 len 26]
                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                        if balanceOf[address(msg.sender)] < arg2 / 10:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2 / 10
                                        if balanceOf[this.address] > !(arg2 / 10):
                                            revert with 0, 17
                                        if balanceOf[this.address] + (arg2 / 10) < balanceOf[this.address]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = this.address
                                        mem[32] = 1
                                        balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 10)
                                        emit Transfer((arg2 / 10), msg.sender, this.address);
                                        _26273 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26273] = 26
                                        mem[_26273 + 32] = 'SafeMath: division by zero'
                                        if not arg2 / 100:
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not arg1:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            _26444 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_26444] = 38
                                            mem[_26444 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                            if 0 > balanceOf[address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 38
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_26444 + 70 len 26]
                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                            if balanceOf[address(msg.sender)] < 0:
                                                revert with 0, 17
                                            if balanceOf[arg1] > -1:
                                                revert with 0, 17
                                            if balanceOf[arg1] < balanceOf[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(arg1)] = balanceOf[arg1]
                                            emit Transfer(0, msg.sender, arg1);
                                        else:
                                            if arg2 / 100 and 87 > -1 / arg2 / 100:
                                                revert with 0, 17
                                            if not arg2 / 100:
                                                revert with 0, 18
                                            if 87 * arg2 / 100 / arg2 / 100 != 87:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not arg1:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            _27005 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_27005] = 38
                                            mem[_27005 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                            if 87 * arg2 / 100 > balanceOf[address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 38
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_27005 + 70 len 26]
                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                            if balanceOf[address(msg.sender)] < 87 * arg2 / 100:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] += -87 * arg2 / 100
                                            if balanceOf[arg1] > !(87 * arg2 / 100):
                                                revert with 0, 17
                                            if balanceOf[arg1] + (87 * arg2 / 100) < balanceOf[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(arg1)] = balanceOf[arg1] + (87 * arg2 / 100)
                                            emit Transfer((87 * arg2 / 100), msg.sender, arg1);
                        else:
                            idx = 0
                            t = 0
                            u = 1440
                            while idx < 9:
                                if block.timestamp % stor19.length - 9 > !idx:
                                    revert with 0, 17
                                if (block.timestamp % stor19.length - 9) + idx >= stor19.length:
                                    revert with 0, 50
                                mem[0] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                mem[32] = 1
                                if balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] < 10000000000 * 10^18:
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    t = t
                                    u = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                    continue 
                                mem[0] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                mem[32] = 1
                                if not balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]]:
                                    _17626 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17626] = 26
                                    mem[_17626 + 32] = 'SafeMath: division by zero'
                                    if not 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                        _17932 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _17932 + 68] = mem[idx + _17626 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17932 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _17932 + -mem[64] + 100
                                    if 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                        if not 4 * ext_call.return_data[0] / 5:
                                            _20802 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_20802] = 26
                                            mem[_20802 + 32] = 'SafeMath: division by zero'
                                            mem[mem[64] + 4] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                            mem[mem[64] + 36] = 0
                                            require ext_code.size(dogeAddress)
                                            call dogeAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx], 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _22718 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_22718] == bool(mem[_22718])
                                        else:
                                            if 4 * ext_call.return_data[0] / 5 and 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s > -1 / 4 * ext_call.return_data[0] / 5:
                                                revert with 0, 17
                                            if not 4 * ext_call.return_data[0] / 5:
                                                revert with 0, 18
                                            if 4 * ext_call.return_data[0] / 5 * 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 4 * ext_call.return_data[0] / 5 != 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _21958 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_21958] = 26
                                            mem[_21958 + 32] = 'SafeMath: division by zero'
                                            mem[mem[64] + 4] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                            mem[mem[64] + 36] = 4 * ext_call.return_data[0] / 5 * 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 10000
                                            require ext_code.size(dogeAddress)
                                            call dogeAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx], 4 * ext_call.return_data[0] / 5 * 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 10000
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _23150 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_23150] == bool(mem[_23150])
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    t = 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s
                                    u = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                    continue 
                                if balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] and 10000 > -1 / balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]]:
                                    revert with 0, 17
                                if not balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]]:
                                    revert with 0, 18
                                if 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] != 10000:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _19170 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19170] = 26
                                mem[_19170 + 32] = 'SafeMath: division by zero'
                                if not 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                    _19443 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _19443 + 68] = mem[idx + _19170 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19443 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19443 + -mem[64] + 100
                                if 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                    if not 4 * ext_call.return_data[0] / 5:
                                        _21957 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_21957] = 26
                                        mem[_21957 + 32] = 'SafeMath: division by zero'
                                        mem[mem[64] + 4] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                        mem[mem[64] + 36] = 0
                                        require ext_code.size(dogeAddress)
                                        call dogeAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx], 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _23149 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_23149] == bool(mem[_23149])
                                    else:
                                        if 4 * ext_call.return_data[0] / 5 and 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s > -1 / 4 * ext_call.return_data[0] / 5:
                                            revert with 0, 17
                                        if not 4 * ext_call.return_data[0] / 5:
                                            revert with 0, 18
                                        if 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 4 * ext_call.return_data[0] / 5 != 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _22962 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22962] = 26
                                        mem[_22962 + 32] = 'SafeMath: division by zero'
                                        mem[mem[64] + 4] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                        mem[mem[64] + 36] = 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 10000
                                        require ext_code.size(dogeAddress)
                                        call dogeAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx], 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 10000
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _23626 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_23626] == bool(mem[_23626])
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                t = 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s
                                u = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                continue 
                            mem[0] = msg.sender
                            mem[32] = 14
                            if stor14[address(msg.sender)]:
                                if not msg.sender:
                                    revert with 0, 'ERC20: transfer from the zero address'
                                if not arg1:
                                    revert with 0, 'ERC20: transfer to the zero address'
                                _16846 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_16846] = 38
                                mem[_16846 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                if arg2 > balanceOf[address(msg.sender)]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 38
                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_16846 + 70 len 26]
                                    var78001 = 64
                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                if balanceOf[address(msg.sender)] < arg2:
                                    revert with 0, 17
                                balanceOf[address(msg.sender)] -= arg2
                                if balanceOf[arg1] > !arg2:
                                    revert with 0, 17
                                if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                emit Transfer(arg2, msg.sender, arg1);
                            else:
                                mem[0] = arg1
                                mem[32] = 14
                                if stor14[address(arg1)]:
                                    if not msg.sender:
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if not arg1:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    _17202 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_17202] = 38
                                    mem[_17202 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                    if arg2 > balanceOf[address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 38
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17202 + 70 len 26]
                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                    if balanceOf[address(msg.sender)] < arg2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)] -= arg2
                                    if balanceOf[arg1] > !arg2:
                                        revert with 0, 17
                                    if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                    emit Transfer(arg2, msg.sender, arg1);
                                else:
                                    if stor10:
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not arg1:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        _16849 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_16849] = 38
                                        mem[_16849 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                        if arg2 > balanceOf[address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 38
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_16849 + 70 len 26]
                                            var78001 = 64
                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                        if balanceOf[address(msg.sender)] < arg2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2
                                        if balanceOf[arg1] > !arg2:
                                            revert with 0, 17
                                        if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                        emit Transfer(arg2, msg.sender, arg1);
                                    else:
                                        _16495 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16495] = 26
                                        mem[_16495 + 32] = 'SafeMath: division by zero'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not stor13:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        _18793 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_18793] = 38
                                        mem[_18793 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                        if arg2 / 100 > balanceOf[address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 38
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_18793 + 70 len 26]
                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                        if balanceOf[address(msg.sender)] < arg2 / 100:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2 / 100
                                        if balanceOf[stor13] > !(arg2 / 100):
                                            revert with 0, 17
                                        if balanceOf[stor13] + (arg2 / 100) < balanceOf[stor13]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = stor13
                                        mem[32] = 1
                                        balanceOf[stor13] += arg2 / 100
                                        emit Transfer((arg2 / 100), msg.sender, stor13);
                                        _22563 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22563] = 26
                                        mem[_22563 + 32] = 'SafeMath: division by zero'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not sub_8230af5aAddress:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        _23394 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_23394] = 38
                                        mem[_23394 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                        if arg2 / 100 > balanceOf[address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 38
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_23394 + 70 len 26]
                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                        if balanceOf[address(msg.sender)] < arg2 / 100:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2 / 100
                                        if balanceOf[stor9] > !(arg2 / 100):
                                            revert with 0, 17
                                        if balanceOf[stor9] + (arg2 / 100) < balanceOf[stor9]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = sub_8230af5aAddress
                                        mem[32] = 1
                                        balanceOf[stor9] += arg2 / 100
                                        emit Transfer((arg2 / 100), msg.sender, sub_8230af5aAddress);
                                        _24298 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_24298] = 26
                                        mem[_24298 + 32] = 'SafeMath: division by zero'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not uniswapV2PairAddress:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        _24468 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_24468] = 38
                                        mem[_24468 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                        if arg2 / 100 > balanceOf[address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 38
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_24468 + 70 len 26]
                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                        if balanceOf[address(msg.sender)] < arg2 / 100:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2 / 100
                                        if balanceOf[stor7] > !(arg2 / 100):
                                            revert with 0, 17
                                        if balanceOf[stor7] + (arg2 / 100) < balanceOf[stor7]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = uniswapV2PairAddress
                                        mem[32] = 1
                                        balanceOf[stor7] += arg2 / 100
                                        emit Transfer((arg2 / 100), msg.sender, uniswapV2PairAddress);
                                        _25286 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_25286] = 26
                                        mem[_25286 + 32] = 'SafeMath: division by zero'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not this.address:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        _25456 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_25456] = 38
                                        mem[_25456 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                        if arg2 / 10 > balanceOf[address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 38
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_25456 + 70 len 26]
                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                        if balanceOf[address(msg.sender)] < arg2 / 10:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2 / 10
                                        if balanceOf[this.address] > !(arg2 / 10):
                                            revert with 0, 17
                                        if balanceOf[this.address] + (arg2 / 10) < balanceOf[this.address]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = this.address
                                        mem[32] = 1
                                        balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 10)
                                        emit Transfer((arg2 / 10), msg.sender, this.address);
                                        _26274 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26274] = 26
                                        mem[_26274 + 32] = 'SafeMath: division by zero'
                                        if not arg2 / 100:
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not arg1:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            _26448 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_26448] = 38
                                            mem[_26448 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                            if 0 > balanceOf[address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 38
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_26448 + 70 len 26]
                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                            if balanceOf[address(msg.sender)] < 0:
                                                revert with 0, 17
                                            if balanceOf[arg1] > -1:
                                                revert with 0, 17
                                            if balanceOf[arg1] < balanceOf[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(arg1)] = balanceOf[arg1]
                                            emit Transfer(0, msg.sender, arg1);
                                        else:
                                            if arg2 / 100 and 87 > -1 / arg2 / 100:
                                                revert with 0, 17
                                            if not arg2 / 100:
                                                revert with 0, 18
                                            if 87 * arg2 / 100 / arg2 / 100 != 87:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not arg1:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            _27010 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_27010] = 38
                                            mem[_27010 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                            if 87 * arg2 / 100 > balanceOf[address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 38
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_27010 + 70 len 26]
                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                            if balanceOf[address(msg.sender)] < 87 * arg2 / 100:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] += -87 * arg2 / 100
                                            if balanceOf[arg1] > !(87 * arg2 / 100):
                                                revert with 0, 17
                                            if balanceOf[arg1] + (87 * arg2 / 100) < balanceOf[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(arg1)] = balanceOf[arg1] + (87 * arg2 / 100)
                                            emit Transfer((87 * arg2 / 100), msg.sender, arg1);
    else:
        if stor10:
            mem[100] = this.address
            require ext_code.size(dogeAddress)
            staticcall dogeAddress.0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            mem[96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if ext_call.return_data[0] < 10^12:
                if not msg.sender:
                    revert with 0, 'ERC20: transfer from the zero address'
                if stor14[address(msg.sender)]:
                    if not arg1:
                        revert with 0, 'ERC20: transfer to the zero address'
                    if arg2 > balanceOf[address(msg.sender)]:
                        revert with 0, 
                                    32,
                                    38,
                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 166 len 26] >> 48,
                                    0
                    if balanceOf[address(msg.sender)] < arg2:
                        revert with 0, 17
                    balanceOf[address(msg.sender)] -= arg2
                    if balanceOf[arg1] > !arg2:
                        revert with 0, 17
                    if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                        revert with 0, 'SafeMath: addition overflow'
                    balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                    emit Transfer(arg2, msg.sender, arg1);
                else:
                    if stor14[address(arg1)]:
                        if not arg1:
                            revert with 0, 'ERC20: transfer to the zero address'
                        if arg2 > balanceOf[address(msg.sender)]:
                            revert with 0, 
                                        32,
                                        38,
                                        0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 166 len 26] >> 48,
                                        0
                        if balanceOf[address(msg.sender)] < arg2:
                            revert with 0, 17
                        balanceOf[address(msg.sender)] -= arg2
                        if balanceOf[arg1] > !arg2:
                            revert with 0, 17
                        if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                            revert with 0, 'SafeMath: addition overflow'
                        balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                        emit Transfer(arg2, msg.sender, arg1);
                    else:
                        if stor10:
                            if not arg1:
                                revert with 0, 'ERC20: transfer to the zero address'
                            if arg2 > balanceOf[address(msg.sender)]:
                                revert with 0, 
                                            32,
                                            38,
                                            0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 166 len 26] >> 48,
                                            0
                            if balanceOf[address(msg.sender)] < arg2:
                                revert with 0, 17
                            balanceOf[address(msg.sender)] -= arg2
                            if balanceOf[arg1] > !arg2:
                                revert with 0, 17
                            if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                            emit Transfer(arg2, msg.sender, arg1);
                        else:
                            if not stor13:
                                revert with 0, 'ERC20: transfer to the zero address'
                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                revert with 0, 
                                            32,
                                            38,
                                            0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 230 len 26] >> 48,
                                            0
                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                revert with 0, 17
                            balanceOf[address(msg.sender)] -= arg2 / 100
                            if balanceOf[stor13] > !(arg2 / 100):
                                revert with 0, 17
                            if balanceOf[stor13] + (arg2 / 100) < balanceOf[stor13]:
                                revert with 0, 'SafeMath: addition overflow'
                            balanceOf[stor13] += arg2 / 100
                            emit Transfer((arg2 / 100), msg.sender, stor13);
                            if not msg.sender:
                                revert with 0, 'ERC20: transfer from the zero address'
                            if not sub_8230af5aAddress:
                                revert with 0, 'ERC20: transfer to the zero address'
                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                revert with 0, 
                                            32,
                                            38,
                                            0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 390 len 26] >> 48,
                                            0
                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                revert with 0, 17
                            balanceOf[address(msg.sender)] -= arg2 / 100
                            if balanceOf[stor9] > !(arg2 / 100):
                                revert with 0, 17
                            if balanceOf[stor9] + (arg2 / 100) < balanceOf[stor9]:
                                revert with 0, 'SafeMath: addition overflow'
                            balanceOf[stor9] += arg2 / 100
                            emit Transfer((arg2 / 100), msg.sender, sub_8230af5aAddress);
                            if not msg.sender:
                                revert with 0, 'ERC20: transfer from the zero address'
                            if not uniswapV2PairAddress:
                                revert with 0, 'ERC20: transfer to the zero address'
                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                revert with 0, 
                                            32,
                                            38,
                                            0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 550 len 26] >> 48,
                                            0
                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                revert with 0, 17
                            balanceOf[address(msg.sender)] -= arg2 / 100
                            if balanceOf[stor7] > !(arg2 / 100):
                                revert with 0, 17
                            if balanceOf[stor7] + (arg2 / 100) < balanceOf[stor7]:
                                revert with 0, 'SafeMath: addition overflow'
                            balanceOf[stor7] += arg2 / 100
                            emit Transfer((arg2 / 100), msg.sender, uniswapV2PairAddress);
                            if not msg.sender:
                                revert with 0, 'ERC20: transfer from the zero address'
                            if not this.address:
                                revert with 0, 'ERC20: transfer to the zero address'
                            if arg2 / 10 > balanceOf[address(msg.sender)]:
                                revert with 0, 
                                            32,
                                            38,
                                            0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 710 len 26] >> 48,
                                            0
                            if balanceOf[address(msg.sender)] < arg2 / 10:
                                revert with 0, 17
                            balanceOf[address(msg.sender)] -= arg2 / 10
                            if balanceOf[this.address] > !(arg2 / 10):
                                revert with 0, 17
                            if balanceOf[this.address] + (arg2 / 10) < balanceOf[this.address]:
                                revert with 0, 'SafeMath: addition overflow'
                            balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 10)
                            emit Transfer((arg2 / 10), msg.sender, this.address);
                            if not arg2 / 100:
                                if not msg.sender:
                                    revert with 0, 'ERC20: transfer from the zero address'
                                if not arg1:
                                    revert with 0, 'ERC20: transfer to the zero address'
                                if 0 > balanceOf[address(msg.sender)]:
                                    revert with 0, 
                                                32,
                                                38,
                                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 870 len 26] >> 48,
                                                0
                                if balanceOf[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if balanceOf[arg1] > -1:
                                    revert with 0, 17
                                if balanceOf[arg1] < balanceOf[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                balanceOf[address(arg1)] = balanceOf[arg1]
                                emit Transfer(0, msg.sender, arg1);
                            else:
                                if arg2 / 100 and 87 > -1 / arg2 / 100:
                                    revert with 0, 17
                                if not arg2 / 100:
                                    revert with 0, 18
                                if 87 * arg2 / 100 / arg2 / 100 != 87:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not msg.sender:
                                    revert with 0, 'ERC20: transfer from the zero address'
                                if not arg1:
                                    revert with 0, 'ERC20: transfer to the zero address'
                                if 87 * arg2 / 100 > balanceOf[address(msg.sender)]:
                                    revert with 0, 
                                                32,
                                                38,
                                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 870 len 26] >> 48,
                                                0
                                if balanceOf[address(msg.sender)] < 87 * arg2 / 100:
                                    revert with 0, 17
                                balanceOf[address(msg.sender)] += -87 * arg2 / 100
                                if balanceOf[arg1] > !(87 * arg2 / 100):
                                    revert with 0, 17
                                if balanceOf[arg1] + (87 * arg2 / 100) < balanceOf[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                balanceOf[address(arg1)] = balanceOf[arg1] + (87 * arg2 / 100)
                                emit Transfer((87 * arg2 / 100), msg.sender, arg1);
            else:
                if not ext_call.return_data[0]:
                    mem[64] = ceil32(return_data.size) + 160
                    mem[ceil32(return_data.size) + 96] = 26
                    mem[ceil32(return_data.size) + 128] = 'SafeMath: division by zero'
                    if not stor19.length:
                        if not msg.sender:
                            revert with 0, 'ERC20: transfer from the zero address'
                        if stor14[address(msg.sender)]:
                            if not arg1:
                                revert with 0, 'ERC20: transfer to the zero address'
                            if arg2 > balanceOf[address(msg.sender)]:
                                revert with 0, 
                                            32,
                                            38,
                                            0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 230 len 26] >> 48,
                                            0
                            if balanceOf[address(msg.sender)] < arg2:
                                revert with 0, 17
                            balanceOf[address(msg.sender)] -= arg2
                            if balanceOf[arg1] > !arg2:
                                revert with 0, 17
                            if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                            emit Transfer(arg2, msg.sender, arg1);
                        else:
                            if stor14[address(arg1)]:
                                if not arg1:
                                    revert with 0, 'ERC20: transfer to the zero address'
                                if arg2 > balanceOf[address(msg.sender)]:
                                    revert with 0, 
                                                32,
                                                38,
                                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 230 len 26] >> 48,
                                                0
                                if balanceOf[address(msg.sender)] < arg2:
                                    revert with 0, 17
                                balanceOf[address(msg.sender)] -= arg2
                                if balanceOf[arg1] > !arg2:
                                    revert with 0, 17
                                if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                emit Transfer(arg2, msg.sender, arg1);
                            else:
                                if stor10:
                                    if not arg1:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    if arg2 > balanceOf[address(msg.sender)]:
                                        revert with 0, 
                                                    32,
                                                    38,
                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 230 len 26] >> 48,
                                                    0
                                    if balanceOf[address(msg.sender)] < arg2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)] -= arg2
                                    if balanceOf[arg1] > !arg2:
                                        revert with 0, 17
                                    if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                    emit Transfer(arg2, msg.sender, arg1);
                                else:
                                    if not stor13:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    if arg2 / 100 > balanceOf[address(msg.sender)]:
                                        revert with 0, 
                                                    32,
                                                    38,
                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 294 len 26] >> 48,
                                                    0
                                    if balanceOf[address(msg.sender)] < arg2 / 100:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)] -= arg2 / 100
                                    if balanceOf[stor13] > !(arg2 / 100):
                                        revert with 0, 17
                                    if balanceOf[stor13] + (arg2 / 100) < balanceOf[stor13]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[stor13] += arg2 / 100
                                    emit Transfer((arg2 / 100), msg.sender, stor13);
                                    if not msg.sender:
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if not sub_8230af5aAddress:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    if arg2 / 100 > balanceOf[address(msg.sender)]:
                                        revert with 0, 
                                                    32,
                                                    38,
                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 454 len 26] >> 48,
                                                    0
                                    if balanceOf[address(msg.sender)] < arg2 / 100:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)] -= arg2 / 100
                                    if balanceOf[stor9] > !(arg2 / 100):
                                        revert with 0, 17
                                    if balanceOf[stor9] + (arg2 / 100) < balanceOf[stor9]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[stor9] += arg2 / 100
                                    emit Transfer((arg2 / 100), msg.sender, sub_8230af5aAddress);
                                    if not msg.sender:
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if not uniswapV2PairAddress:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    if arg2 / 100 > balanceOf[address(msg.sender)]:
                                        revert with 0, 
                                                    32,
                                                    38,
                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 614 len 26] >> 48,
                                                    0
                                    if balanceOf[address(msg.sender)] < arg2 / 100:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)] -= arg2 / 100
                                    if balanceOf[stor7] > !(arg2 / 100):
                                        revert with 0, 17
                                    if balanceOf[stor7] + (arg2 / 100) < balanceOf[stor7]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[stor7] += arg2 / 100
                                    emit Transfer((arg2 / 100), msg.sender, uniswapV2PairAddress);
                                    if not msg.sender:
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if not this.address:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    if arg2 / 10 > balanceOf[address(msg.sender)]:
                                        revert with 0, 
                                                    32,
                                                    38,
                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 774 len 26] >> 48,
                                                    0
                                    if balanceOf[address(msg.sender)] < arg2 / 10:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)] -= arg2 / 10
                                    if balanceOf[this.address] > !(arg2 / 10):
                                        revert with 0, 17
                                    if balanceOf[this.address] + (arg2 / 10) < balanceOf[this.address]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 10)
                                    emit Transfer((arg2 / 10), msg.sender, this.address);
                                    if not arg2 / 100:
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not arg1:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        if 0 > balanceOf[address(msg.sender)]:
                                            revert with 0, 
                                                        32,
                                                        38,
                                                        0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 934 len 26] >> 48,
                                                        0
                                        if balanceOf[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if balanceOf[arg1] > -1:
                                            revert with 0, 17
                                        if balanceOf[arg1] < balanceOf[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(arg1)] = balanceOf[arg1]
                                        emit Transfer(0, msg.sender, arg1);
                                    else:
                                        if arg2 / 100 and 87 > -1 / arg2 / 100:
                                            revert with 0, 17
                                        if not arg2 / 100:
                                            revert with 0, 18
                                        if 87 * arg2 / 100 / arg2 / 100 != 87:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not arg1:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        if 87 * arg2 / 100 > balanceOf[address(msg.sender)]:
                                            revert with 0, 
                                                        32,
                                                        38,
                                                        0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 934 len 26] >> 48,
                                                        0
                                        if balanceOf[address(msg.sender)] < 87 * arg2 / 100:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] += -87 * arg2 / 100
                                        if balanceOf[arg1] > !(87 * arg2 / 100):
                                            revert with 0, 17
                                        if balanceOf[arg1] + (87 * arg2 / 100) < balanceOf[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(arg1)] = balanceOf[arg1] + (87 * arg2 / 100)
                                        emit Transfer((87 * arg2 / 100), msg.sender, arg1);
                    else:
                        if stor19.length <= 9:
                            idx = 0
                            s = 0
                            t = 0
                            while idx < stor19.length:
                                mem[0] = stor19[idx]
                                mem[32] = 1
                                if s > !balanceOf[stor19[idx]]:
                                    revert with 0, 17
                                if s + balanceOf[stor19[idx]] < s:
                                    revert with 0, 'SafeMath: addition overflow'
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + balanceOf[stor19[idx]]
                                t = stor19[idx]
                                continue 
                            if stor19.length <= 9:
                                idx = 0
                                t = 0
                                u = 160 * stor19.length
                                while idx < stor19.length:
                                    mem[0] = stor19[idx]
                                    mem[32] = 1
                                    if balanceOf[stor19[idx]] < 10000000000 * 10^18:
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        t = t
                                        u = stor19[idx]
                                        continue 
                                    mem[0] = stor19[idx]
                                    mem[32] = 1
                                    if not balanceOf[stor19[idx]]:
                                        _16920 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16920] = 26
                                        mem[_16920 + 32] = 'SafeMath: division by zero'
                                        if not s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                            _17480 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _17480 + 68] = mem[idx + _16920 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_17480 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _17480 + -mem[64] + 100
                                        if 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                            _20162 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_20162] = 26
                                            mem[_20162 + 32] = 'SafeMath: division by zero'
                                            mem[mem[64] + 4] = stor19[idx]
                                            mem[mem[64] + 36] = 0
                                            require ext_code.size(dogeAddress)
                                            call dogeAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args stor19[idx], 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _22023 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_22023] == bool(mem[_22023])
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        t = 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length
                                        u = stor19[idx]
                                        continue 
                                    if balanceOf[stor19[idx]] and 10000 > -1 / balanceOf[stor19[idx]]:
                                        revert with 0, 17
                                    if not balanceOf[stor19[idx]]:
                                        revert with 0, 18
                                    if 10000 * balanceOf[stor19[idx]] / balanceOf[stor19[idx]] != 10000:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _18197 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18197] = 26
                                    mem[_18197 + 32] = 'SafeMath: division by zero'
                                    if not s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                        _18869 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _18869 + 68] = mem[idx + _18197 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18869 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _18869 + -mem[64] + 100
                                    if 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                        _21199 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_21199] = 26
                                        mem[_21199 + 32] = 'SafeMath: division by zero'
                                        mem[mem[64] + 4] = stor19[idx]
                                        mem[mem[64] + 36] = 0
                                        require ext_code.size(dogeAddress)
                                        call dogeAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args stor19[idx], 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _22971 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_22971] == bool(mem[_22971])
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    t = 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length
                                    u = stor19[idx]
                                    continue 
                                mem[0] = msg.sender
                                mem[32] = 14
                                if stor14[address(msg.sender)]:
                                    if not msg.sender:
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if not arg1:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    _16913 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_16913] = 38
                                    mem[_16913 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                    if arg2 > balanceOf[address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 38
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_16913 + 70 len 26]
                                        var66001 = 64
                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                    if balanceOf[address(msg.sender)] < arg2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)] -= arg2
                                    if balanceOf[arg1] > !arg2:
                                        revert with 0, 17
                                    if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                    emit Transfer(arg2, msg.sender, arg1);
                                else:
                                    mem[0] = arg1
                                    mem[32] = 14
                                    if stor14[address(arg1)]:
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not arg1:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        _17247 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_17247] = 38
                                        mem[_17247 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                        if arg2 > balanceOf[address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 38
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17247 + 70 len 26]
                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                        if balanceOf[address(msg.sender)] < arg2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2
                                        if balanceOf[arg1] > !arg2:
                                            revert with 0, 17
                                        if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                        emit Transfer(arg2, msg.sender, arg1);
                                    else:
                                        if stor10:
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not arg1:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            _16916 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_16916] = 38
                                            mem[_16916 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                            if arg2 > balanceOf[address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 38
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_16916 + 70 len 26]
                                                var66001 = 64
                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                            if balanceOf[address(msg.sender)] < arg2:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2
                                            if balanceOf[arg1] > !arg2:
                                                revert with 0, 17
                                            if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                            emit Transfer(arg2, msg.sender, arg1);
                                        else:
                                            _16509 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_16509] = 26
                                            mem[_16509 + 32] = 'SafeMath: division by zero'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not stor13:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            _18865 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_18865] = 38
                                            mem[_18865 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 38
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_18865 + 70 len 26]
                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                            if balanceOf[stor13] > !(arg2 / 100):
                                                revert with 0, 17
                                            if balanceOf[stor13] + (arg2 / 100) < balanceOf[stor13]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = stor13
                                            mem[32] = 1
                                            balanceOf[stor13] += arg2 / 100
                                            emit Transfer((arg2 / 100), msg.sender, stor13);
                                            _22587 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_22587] = 26
                                            mem[_22587 + 32] = 'SafeMath: division by zero'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not sub_8230af5aAddress:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            _23427 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_23427] = 38
                                            mem[_23427 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 38
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_23427 + 70 len 26]
                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                            if balanceOf[stor9] > !(arg2 / 100):
                                                revert with 0, 17
                                            if balanceOf[stor9] + (arg2 / 100) < balanceOf[stor9]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = sub_8230af5aAddress
                                            mem[32] = 1
                                            balanceOf[stor9] += arg2 / 100
                                            emit Transfer((arg2 / 100), msg.sender, sub_8230af5aAddress);
                                            _24307 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_24307] = 26
                                            mem[_24307 + 32] = 'SafeMath: division by zero'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not uniswapV2PairAddress:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            _24495 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_24495] = 38
                                            mem[_24495 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 38
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_24495 + 70 len 26]
                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                            if balanceOf[stor7] > !(arg2 / 100):
                                                revert with 0, 17
                                            if balanceOf[stor7] + (arg2 / 100) < balanceOf[stor7]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = uniswapV2PairAddress
                                            mem[32] = 1
                                            balanceOf[stor7] += arg2 / 100
                                            emit Transfer((arg2 / 100), msg.sender, uniswapV2PairAddress);
                                            _25295 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_25295] = 26
                                            mem[_25295 + 32] = 'SafeMath: division by zero'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not this.address:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            _25483 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_25483] = 38
                                            mem[_25483 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                            if arg2 / 10 > balanceOf[address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 38
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_25483 + 70 len 26]
                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                            if balanceOf[address(msg.sender)] < arg2 / 10:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2 / 10
                                            if balanceOf[this.address] > !(arg2 / 10):
                                                revert with 0, 17
                                            if balanceOf[this.address] + (arg2 / 10) < balanceOf[this.address]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = this.address
                                            mem[32] = 1
                                            balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 10)
                                            emit Transfer((arg2 / 10), msg.sender, this.address);
                                            _26283 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_26283] = 26
                                            mem[_26283 + 32] = 'SafeMath: division by zero'
                                            if not arg2 / 100:
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not arg1:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _26484 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_26484] = 38
                                                mem[_26484 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if 0 > balanceOf[address(msg.sender)]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_26484 + 70 len 26]
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(msg.sender)] < 0:
                                                    revert with 0, 17
                                                if balanceOf[arg1] > -1:
                                                    revert with 0, 17
                                                if balanceOf[arg1] < balanceOf[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(arg1)] = balanceOf[arg1]
                                                emit Transfer(0, msg.sender, arg1);
                                            else:
                                                if arg2 / 100 and 87 > -1 / arg2 / 100:
                                                    revert with 0, 17
                                                if not arg2 / 100:
                                                    revert with 0, 18
                                                if 87 * arg2 / 100 / arg2 / 100 != 87:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not arg1:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _27055 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_27055] = 38
                                                mem[_27055 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if 87 * arg2 / 100 > balanceOf[address(msg.sender)]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_27055 + 70 len 26]
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(msg.sender)] < 87 * arg2 / 100:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] += -87 * arg2 / 100
                                                if balanceOf[arg1] > !(87 * arg2 / 100):
                                                    revert with 0, 17
                                                if balanceOf[arg1] + (87 * arg2 / 100) < balanceOf[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(arg1)] = balanceOf[arg1] + (87 * arg2 / 100)
                                                emit Transfer((87 * arg2 / 100), msg.sender, arg1);
                            else:
                                idx = 0
                                t = 0
                                u = 160 * stor19.length
                                while idx < 9:
                                    if 0 > !idx:
                                        revert with 0, 17
                                    if idx >= stor19.length:
                                        revert with 0, 50
                                    mem[0] = stor19[idx]
                                    mem[32] = 1
                                    if balanceOf[stor19[idx]] < 10000000000 * 10^18:
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        t = t
                                        u = stor19[idx]
                                        continue 
                                    mem[0] = stor19[idx]
                                    mem[32] = 1
                                    if not balanceOf[stor19[idx]]:
                                        _17666 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17666] = 26
                                        mem[_17666 + 32] = 'SafeMath: division by zero'
                                        if not s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                            _17967 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _17967 + 68] = mem[idx + _17666 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_17967 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _17967 + -mem[64] + 100
                                        if 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                            _20832 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_20832] = 26
                                            mem[_20832 + 32] = 'SafeMath: division by zero'
                                            mem[mem[64] + 4] = stor19[idx]
                                            mem[mem[64] + 36] = 0
                                            require ext_code.size(dogeAddress)
                                            call dogeAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args stor19[idx], 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _22725 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_22725] == bool(mem[_22725])
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        t = 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length
                                        u = stor19[idx]
                                        continue 
                                    if balanceOf[stor19[idx]] and 10000 > -1 / balanceOf[stor19[idx]]:
                                        revert with 0, 17
                                    if not balanceOf[stor19[idx]]:
                                        revert with 0, 18
                                    if 10000 * balanceOf[stor19[idx]] / balanceOf[stor19[idx]] != 10000:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _19200 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19200] = 26
                                    mem[_19200 + 32] = 'SafeMath: division by zero'
                                    if not s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                        _19488 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _19488 + 68] = mem[idx + _19200 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19488 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19488 + -mem[64] + 100
                                    if 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                        _22030 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22030] = 26
                                        mem[_22030 + 32] = 'SafeMath: division by zero'
                                        mem[mem[64] + 4] = stor19[idx]
                                        mem[mem[64] + 36] = 0
                                        require ext_code.size(dogeAddress)
                                        call dogeAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args stor19[idx], 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _23157 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_23157] == bool(mem[_23157])
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    t = 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length
                                    u = stor19[idx]
                                    continue 
                                mem[0] = msg.sender
                                mem[32] = 14
                                if stor14[address(msg.sender)]:
                                    if not msg.sender:
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if not arg1:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    _16921 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_16921] = 38
                                    mem[_16921 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                    if arg2 > balanceOf[address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 38
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_16921 + 70 len 26]
                                        var66001 = 64
                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                    if balanceOf[address(msg.sender)] < arg2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)] -= arg2
                                    if balanceOf[arg1] > !arg2:
                                        revert with 0, 17
                                    if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                    emit Transfer(arg2, msg.sender, arg1);
                                else:
                                    mem[0] = arg1
                                    mem[32] = 14
                                    if stor14[address(arg1)]:
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not arg1:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        _17252 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_17252] = 38
                                        mem[_17252 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                        if arg2 > balanceOf[address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 38
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17252 + 70 len 26]
                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                        if balanceOf[address(msg.sender)] < arg2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2
                                        if balanceOf[arg1] > !arg2:
                                            revert with 0, 17
                                        if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                        emit Transfer(arg2, msg.sender, arg1);
                                    else:
                                        if stor10:
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not arg1:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            _16924 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_16924] = 38
                                            mem[_16924 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                            if arg2 > balanceOf[address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 38
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_16924 + 70 len 26]
                                                var66001 = 64
                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                            if balanceOf[address(msg.sender)] < arg2:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2
                                            if balanceOf[arg1] > !arg2:
                                                revert with 0, 17
                                            if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                            emit Transfer(arg2, msg.sender, arg1);
                                        else:
                                            _16510 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_16510] = 26
                                            mem[_16510 + 32] = 'SafeMath: division by zero'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not stor13:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            _18873 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_18873] = 38
                                            mem[_18873 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 38
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_18873 + 70 len 26]
                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                            if balanceOf[stor13] > !(arg2 / 100):
                                                revert with 0, 17
                                            if balanceOf[stor13] + (arg2 / 100) < balanceOf[stor13]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = stor13
                                            mem[32] = 1
                                            balanceOf[stor13] += arg2 / 100
                                            emit Transfer((arg2 / 100), msg.sender, stor13);
                                            _22590 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_22590] = 26
                                            mem[_22590 + 32] = 'SafeMath: division by zero'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not sub_8230af5aAddress:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            _23430 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_23430] = 38
                                            mem[_23430 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 38
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_23430 + 70 len 26]
                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                            if balanceOf[stor9] > !(arg2 / 100):
                                                revert with 0, 17
                                            if balanceOf[stor9] + (arg2 / 100) < balanceOf[stor9]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = sub_8230af5aAddress
                                            mem[32] = 1
                                            balanceOf[stor9] += arg2 / 100
                                            emit Transfer((arg2 / 100), msg.sender, sub_8230af5aAddress);
                                            _24308 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_24308] = 26
                                            mem[_24308 + 32] = 'SafeMath: division by zero'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not uniswapV2PairAddress:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            _24498 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_24498] = 38
                                            mem[_24498 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 38
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_24498 + 70 len 26]
                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                            if balanceOf[stor7] > !(arg2 / 100):
                                                revert with 0, 17
                                            if balanceOf[stor7] + (arg2 / 100) < balanceOf[stor7]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = uniswapV2PairAddress
                                            mem[32] = 1
                                            balanceOf[stor7] += arg2 / 100
                                            emit Transfer((arg2 / 100), msg.sender, uniswapV2PairAddress);
                                            _25296 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_25296] = 26
                                            mem[_25296 + 32] = 'SafeMath: division by zero'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not this.address:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            _25486 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_25486] = 38
                                            mem[_25486 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                            if arg2 / 10 > balanceOf[address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 38
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_25486 + 70 len 26]
                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                            if balanceOf[address(msg.sender)] < arg2 / 10:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2 / 10
                                            if balanceOf[this.address] > !(arg2 / 10):
                                                revert with 0, 17
                                            if balanceOf[this.address] + (arg2 / 10) < balanceOf[this.address]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = this.address
                                            mem[32] = 1
                                            balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 10)
                                            emit Transfer((arg2 / 10), msg.sender, this.address);
                                            _26284 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_26284] = 26
                                            mem[_26284 + 32] = 'SafeMath: division by zero'
                                            if not arg2 / 100:
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not arg1:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _26488 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_26488] = 38
                                                mem[_26488 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if 0 > balanceOf[address(msg.sender)]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_26488 + 70 len 26]
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(msg.sender)] < 0:
                                                    revert with 0, 17
                                                if balanceOf[arg1] > -1:
                                                    revert with 0, 17
                                                if balanceOf[arg1] < balanceOf[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(arg1)] = balanceOf[arg1]
                                                emit Transfer(0, msg.sender, arg1);
                                            else:
                                                if arg2 / 100 and 87 > -1 / arg2 / 100:
                                                    revert with 0, 17
                                                if not arg2 / 100:
                                                    revert with 0, 18
                                                if 87 * arg2 / 100 / arg2 / 100 != 87:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not arg1:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _27060 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_27060] = 38
                                                mem[_27060 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if 87 * arg2 / 100 > balanceOf[address(msg.sender)]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_27060 + 70 len 26]
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(msg.sender)] < 87 * arg2 / 100:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] += -87 * arg2 / 100
                                                if balanceOf[arg1] > !(87 * arg2 / 100):
                                                    revert with 0, 17
                                                if balanceOf[arg1] + (87 * arg2 / 100) < balanceOf[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(arg1)] = balanceOf[arg1] + (87 * arg2 / 100)
                                                emit Transfer((87 * arg2 / 100), msg.sender, arg1);
                        else:
                            if stor19.length < 9:
                                revert with 0, 17
                            mem[64] = ceil32(return_data.size) + 224
                            mem[ceil32(return_data.size) + 160] = 24
                            mem[ceil32(return_data.size) + 192] = 'SafeMath: modulo by zero'
                            if not stor19.length - 9:
                                revert with 0, 'SafeMath: modulo by zero', 0
                            idx = 0
                            s = 0
                            t = 0
                            while idx < 9:
                                if block.timestamp % stor19.length - 9 > !idx:
                                    revert with 0, 17
                                if (block.timestamp % stor19.length - 9) + idx >= stor19.length:
                                    revert with 0, 50
                                mem[0] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                mem[32] = 1
                                if s > !balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]]:
                                    revert with 0, 17
                                if s + balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] < s:
                                    revert with 0, 'SafeMath: addition overflow'
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]]
                                t = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                continue 
                            if stor19.length <= 9:
                                idx = 0
                                t = 0
                                u = 1440
                                while idx < stor19.length:
                                    mem[0] = stor19[idx]
                                    mem[32] = 1
                                    if balanceOf[stor19[idx]] < 10000000000 * 10^18:
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        t = t
                                        u = stor19[idx]
                                        continue 
                                    mem[0] = stor19[idx]
                                    mem[32] = 1
                                    if not balanceOf[stor19[idx]]:
                                        _16935 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16935] = 26
                                        mem[_16935 + 32] = 'SafeMath: division by zero'
                                        if not 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                            _17487 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _17487 + 68] = mem[idx + _16935 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_17487 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _17487 + -mem[64] + 100
                                        if 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                            _20176 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_20176] = 26
                                            mem[_20176 + 32] = 'SafeMath: division by zero'
                                            mem[mem[64] + 4] = stor19[idx]
                                            mem[mem[64] + 36] = 0
                                            require ext_code.size(dogeAddress)
                                            call dogeAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args stor19[idx], 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _22037 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_22037] == bool(mem[_22037])
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        t = 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s
                                        u = stor19[idx]
                                        continue 
                                    if balanceOf[stor19[idx]] and 10000 > -1 / balanceOf[stor19[idx]]:
                                        revert with 0, 17
                                    if not balanceOf[stor19[idx]]:
                                        revert with 0, 18
                                    if 10000 * balanceOf[stor19[idx]] / balanceOf[stor19[idx]] != 10000:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _18211 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18211] = 26
                                    mem[_18211 + 32] = 'SafeMath: division by zero'
                                    if not 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                        _18885 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _18885 + 68] = mem[idx + _18211 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18885 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _18885 + -mem[64] + 100
                                    if 10000 * balanceOf[stor19[idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                        _21204 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_21204] = 26
                                        mem[_21204 + 32] = 'SafeMath: division by zero'
                                        mem[mem[64] + 4] = stor19[idx]
                                        mem[mem[64] + 36] = 0
                                        require ext_code.size(dogeAddress)
                                        call dogeAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args stor19[idx], 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _22972 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_22972] == bool(mem[_22972])
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    t = 10000 * balanceOf[stor19[idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s
                                    u = stor19[idx]
                                    continue 
                                mem[0] = msg.sender
                                mem[32] = 14
                                if stor14[address(msg.sender)]:
                                    if not msg.sender:
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if not arg1:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    _16928 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_16928] = 38
                                    mem[_16928 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                    if arg2 > balanceOf[address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 38
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_16928 + 70 len 26]
                                        var77001 = 64
                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                    if balanceOf[address(msg.sender)] < arg2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)] -= arg2
                                    if balanceOf[arg1] > !arg2:
                                        revert with 0, 17
                                    if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                    emit Transfer(arg2, msg.sender, arg1);
                                else:
                                    mem[0] = arg1
                                    mem[32] = 14
                                    if stor14[address(arg1)]:
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not arg1:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        _17257 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_17257] = 38
                                        mem[_17257 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                        if arg2 > balanceOf[address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 38
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17257 + 70 len 26]
                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                        if balanceOf[address(msg.sender)] < arg2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2
                                        if balanceOf[arg1] > !arg2:
                                            revert with 0, 17
                                        if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                        emit Transfer(arg2, msg.sender, arg1);
                                    else:
                                        if stor10:
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not arg1:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            _16931 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_16931] = 38
                                            mem[_16931 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                            if arg2 > balanceOf[address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 38
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_16931 + 70 len 26]
                                                var77001 = 64
                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                            if balanceOf[address(msg.sender)] < arg2:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2
                                            if balanceOf[arg1] > !arg2:
                                                revert with 0, 17
                                            if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                            emit Transfer(arg2, msg.sender, arg1);
                                        else:
                                            _16512 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_16512] = 26
                                            mem[_16512 + 32] = 'SafeMath: division by zero'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not stor13:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            _18881 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_18881] = 38
                                            mem[_18881 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 38
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_18881 + 70 len 26]
                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                            if balanceOf[stor13] > !(arg2 / 100):
                                                revert with 0, 17
                                            if balanceOf[stor13] + (arg2 / 100) < balanceOf[stor13]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = stor13
                                            mem[32] = 1
                                            balanceOf[stor13] += arg2 / 100
                                            emit Transfer((arg2 / 100), msg.sender, stor13);
                                            _22592 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_22592] = 26
                                            mem[_22592 + 32] = 'SafeMath: division by zero'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not sub_8230af5aAddress:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            _23433 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_23433] = 38
                                            mem[_23433 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 38
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_23433 + 70 len 26]
                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                            if balanceOf[stor9] > !(arg2 / 100):
                                                revert with 0, 17
                                            if balanceOf[stor9] + (arg2 / 100) < balanceOf[stor9]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = sub_8230af5aAddress
                                            mem[32] = 1
                                            balanceOf[stor9] += arg2 / 100
                                            emit Transfer((arg2 / 100), msg.sender, sub_8230af5aAddress);
                                            _24309 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_24309] = 26
                                            mem[_24309 + 32] = 'SafeMath: division by zero'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not uniswapV2PairAddress:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            _24501 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_24501] = 38
                                            mem[_24501 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 38
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_24501 + 70 len 26]
                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                            if balanceOf[stor7] > !(arg2 / 100):
                                                revert with 0, 17
                                            if balanceOf[stor7] + (arg2 / 100) < balanceOf[stor7]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = uniswapV2PairAddress
                                            mem[32] = 1
                                            balanceOf[stor7] += arg2 / 100
                                            emit Transfer((arg2 / 100), msg.sender, uniswapV2PairAddress);
                                            _25297 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_25297] = 26
                                            mem[_25297 + 32] = 'SafeMath: division by zero'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not this.address:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            _25489 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_25489] = 38
                                            mem[_25489 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                            if arg2 / 10 > balanceOf[address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 38
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_25489 + 70 len 26]
                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                            if balanceOf[address(msg.sender)] < arg2 / 10:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2 / 10
                                            if balanceOf[this.address] > !(arg2 / 10):
                                                revert with 0, 17
                                            if balanceOf[this.address] + (arg2 / 10) < balanceOf[this.address]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = this.address
                                            mem[32] = 1
                                            balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 10)
                                            emit Transfer((arg2 / 10), msg.sender, this.address);
                                            _26285 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_26285] = 26
                                            mem[_26285 + 32] = 'SafeMath: division by zero'
                                            if not arg2 / 100:
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not arg1:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _26492 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_26492] = 38
                                                mem[_26492 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if 0 > balanceOf[address(msg.sender)]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_26492 + 70 len 26]
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(msg.sender)] < 0:
                                                    revert with 0, 17
                                                if balanceOf[arg1] > -1:
                                                    revert with 0, 17
                                                if balanceOf[arg1] < balanceOf[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(arg1)] = balanceOf[arg1]
                                                emit Transfer(0, msg.sender, arg1);
                                            else:
                                                if arg2 / 100 and 87 > -1 / arg2 / 100:
                                                    revert with 0, 17
                                                if not arg2 / 100:
                                                    revert with 0, 18
                                                if 87 * arg2 / 100 / arg2 / 100 != 87:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not arg1:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _27065 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_27065] = 38
                                                mem[_27065 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if 87 * arg2 / 100 > balanceOf[address(msg.sender)]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_27065 + 70 len 26]
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(msg.sender)] < 87 * arg2 / 100:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] += -87 * arg2 / 100
                                                if balanceOf[arg1] > !(87 * arg2 / 100):
                                                    revert with 0, 17
                                                if balanceOf[arg1] + (87 * arg2 / 100) < balanceOf[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(arg1)] = balanceOf[arg1] + (87 * arg2 / 100)
                                                emit Transfer((87 * arg2 / 100), msg.sender, arg1);
                            else:
                                idx = 0
                                t = 0
                                u = 1440
                                while idx < 9:
                                    if block.timestamp % stor19.length - 9 > !idx:
                                        revert with 0, 17
                                    if (block.timestamp % stor19.length - 9) + idx >= stor19.length:
                                        revert with 0, 50
                                    mem[0] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                    mem[32] = 1
                                    if balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] < 10000000000 * 10^18:
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        t = t
                                        u = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                        continue 
                                    mem[0] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                    mem[32] = 1
                                    if not balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]]:
                                        _17674 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17674] = 26
                                        mem[_17674 + 32] = 'SafeMath: division by zero'
                                        if not 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                            _17974 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _17974 + 68] = mem[idx + _17674 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_17974 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _17974 + -mem[64] + 100
                                        if 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                            _20838 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_20838] = 26
                                            mem[_20838 + 32] = 'SafeMath: division by zero'
                                            mem[mem[64] + 4] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                            mem[mem[64] + 36] = 0
                                            require ext_code.size(dogeAddress)
                                            call dogeAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx], 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _22726 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_22726] == bool(mem[_22726])
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        t = 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s
                                        u = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                        continue 
                                    if balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] and 10000 > -1 / balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]]:
                                        revert with 0, 17
                                    if not balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]]:
                                        revert with 0, 18
                                    if 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] != 10000:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _19206 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19206] = 26
                                    mem[_19206 + 32] = 'SafeMath: division by zero'
                                    if not 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                        _19497 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _19497 + 68] = mem[idx + _19206 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19497 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19497 + -mem[64] + 100
                                    if 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                        _22044 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22044] = 26
                                        mem[_22044 + 32] = 'SafeMath: division by zero'
                                        mem[mem[64] + 4] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                        mem[mem[64] + 36] = 0
                                        require ext_code.size(dogeAddress)
                                        call dogeAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx], 0
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _23158 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_23158] == bool(mem[_23158])
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    t = 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s
                                    u = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                    continue 
                                mem[0] = msg.sender
                                mem[32] = 14
                                if stor14[address(msg.sender)]:
                                    if not msg.sender:
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if not arg1:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    _16936 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_16936] = 38
                                    mem[_16936 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                    if arg2 > balanceOf[address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 38
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_16936 + 70 len 26]
                                        var77001 = 64
                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                    if balanceOf[address(msg.sender)] < arg2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)] -= arg2
                                    if balanceOf[arg1] > !arg2:
                                        revert with 0, 17
                                    if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                    emit Transfer(arg2, msg.sender, arg1);
                                else:
                                    mem[0] = arg1
                                    mem[32] = 14
                                    if stor14[address(arg1)]:
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not arg1:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        _17262 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_17262] = 38
                                        mem[_17262 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                        if arg2 > balanceOf[address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 38
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17262 + 70 len 26]
                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                        if balanceOf[address(msg.sender)] < arg2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2
                                        if balanceOf[arg1] > !arg2:
                                            revert with 0, 17
                                        if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                        emit Transfer(arg2, msg.sender, arg1);
                                    else:
                                        if stor10:
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not arg1:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            _16939 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_16939] = 38
                                            mem[_16939 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                            if arg2 > balanceOf[address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 38
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_16939 + 70 len 26]
                                                var77001 = 64
                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                            if balanceOf[address(msg.sender)] < arg2:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2
                                            if balanceOf[arg1] > !arg2:
                                                revert with 0, 17
                                            if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                            emit Transfer(arg2, msg.sender, arg1);
                                        else:
                                            _16513 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_16513] = 26
                                            mem[_16513 + 32] = 'SafeMath: division by zero'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not stor13:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            _18889 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_18889] = 38
                                            mem[_18889 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 38
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_18889 + 70 len 26]
                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                            if balanceOf[stor13] > !(arg2 / 100):
                                                revert with 0, 17
                                            if balanceOf[stor13] + (arg2 / 100) < balanceOf[stor13]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = stor13
                                            mem[32] = 1
                                            balanceOf[stor13] += arg2 / 100
                                            emit Transfer((arg2 / 100), msg.sender, stor13);
                                            _22595 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_22595] = 26
                                            mem[_22595 + 32] = 'SafeMath: division by zero'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not sub_8230af5aAddress:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            _23436 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_23436] = 38
                                            mem[_23436 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 38
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_23436 + 70 len 26]
                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                            if balanceOf[stor9] > !(arg2 / 100):
                                                revert with 0, 17
                                            if balanceOf[stor9] + (arg2 / 100) < balanceOf[stor9]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = sub_8230af5aAddress
                                            mem[32] = 1
                                            balanceOf[stor9] += arg2 / 100
                                            emit Transfer((arg2 / 100), msg.sender, sub_8230af5aAddress);
                                            _24310 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_24310] = 26
                                            mem[_24310 + 32] = 'SafeMath: division by zero'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not uniswapV2PairAddress:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            _24504 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_24504] = 38
                                            mem[_24504 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 38
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_24504 + 70 len 26]
                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                            if balanceOf[stor7] > !(arg2 / 100):
                                                revert with 0, 17
                                            if balanceOf[stor7] + (arg2 / 100) < balanceOf[stor7]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = uniswapV2PairAddress
                                            mem[32] = 1
                                            balanceOf[stor7] += arg2 / 100
                                            emit Transfer((arg2 / 100), msg.sender, uniswapV2PairAddress);
                                            _25298 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_25298] = 26
                                            mem[_25298 + 32] = 'SafeMath: division by zero'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not this.address:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            _25492 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_25492] = 38
                                            mem[_25492 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                            if arg2 / 10 > balanceOf[address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 38
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_25492 + 70 len 26]
                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                            if balanceOf[address(msg.sender)] < arg2 / 10:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2 / 10
                                            if balanceOf[this.address] > !(arg2 / 10):
                                                revert with 0, 17
                                            if balanceOf[this.address] + (arg2 / 10) < balanceOf[this.address]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = this.address
                                            mem[32] = 1
                                            balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 10)
                                            emit Transfer((arg2 / 10), msg.sender, this.address);
                                            _26286 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_26286] = 26
                                            mem[_26286 + 32] = 'SafeMath: division by zero'
                                            if not arg2 / 100:
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not arg1:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _26496 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_26496] = 38
                                                mem[_26496 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if 0 > balanceOf[address(msg.sender)]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_26496 + 70 len 26]
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(msg.sender)] < 0:
                                                    revert with 0, 17
                                                if balanceOf[arg1] > -1:
                                                    revert with 0, 17
                                                if balanceOf[arg1] < balanceOf[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(arg1)] = balanceOf[arg1]
                                                emit Transfer(0, msg.sender, arg1);
                                            else:
                                                if arg2 / 100 and 87 > -1 / arg2 / 100:
                                                    revert with 0, 17
                                                if not arg2 / 100:
                                                    revert with 0, 18
                                                if 87 * arg2 / 100 / arg2 / 100 != 87:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not arg1:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _27070 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_27070] = 38
                                                mem[_27070 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if 87 * arg2 / 100 > balanceOf[address(msg.sender)]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_27070 + 70 len 26]
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(msg.sender)] < 87 * arg2 / 100:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] += -87 * arg2 / 100
                                                if balanceOf[arg1] > !(87 * arg2 / 100):
                                                    revert with 0, 17
                                                if balanceOf[arg1] + (87 * arg2 / 100) < balanceOf[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(arg1)] = balanceOf[arg1] + (87 * arg2 / 100)
                                                emit Transfer((87 * arg2 / 100), msg.sender, arg1);
                else:
                    if ext_call.return_data[0] and 4 > -1 / ext_call.return_data[0]:
                        revert with 0, 17
                    if not ext_call.return_data[0]:
                        revert with 0, 18
                    if 4 * ext_call.return_data[0] / ext_call.return_data[0] != 4:
                        revert with 0, 'SafeMath: multiplication overflow'
                    mem[64] = ceil32(return_data.size) + 160
                    mem[ceil32(return_data.size) + 96] = 26
                    mem[ceil32(return_data.size) + 128] = 'SafeMath: division by zero'
                    if not stor19.length:
                        if not msg.sender:
                            revert with 0, 'ERC20: transfer from the zero address'
                        if stor14[address(msg.sender)]:
                            if not arg1:
                                revert with 0, 'ERC20: transfer to the zero address'
                            if arg2 > balanceOf[address(msg.sender)]:
                                revert with 0, 
                                            32,
                                            38,
                                            0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 230 len 26] >> 48,
                                            0
                            if balanceOf[address(msg.sender)] < arg2:
                                revert with 0, 17
                            balanceOf[address(msg.sender)] -= arg2
                            if balanceOf[arg1] > !arg2:
                                revert with 0, 17
                            if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                            emit Transfer(arg2, msg.sender, arg1);
                        else:
                            if stor14[address(arg1)]:
                                if not arg1:
                                    revert with 0, 'ERC20: transfer to the zero address'
                                if arg2 > balanceOf[address(msg.sender)]:
                                    revert with 0, 
                                                32,
                                                38,
                                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 230 len 26] >> 48,
                                                0
                                if balanceOf[address(msg.sender)] < arg2:
                                    revert with 0, 17
                                balanceOf[address(msg.sender)] -= arg2
                                if balanceOf[arg1] > !arg2:
                                    revert with 0, 17
                                if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                emit Transfer(arg2, msg.sender, arg1);
                            else:
                                if stor10:
                                    if not arg1:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    if arg2 > balanceOf[address(msg.sender)]:
                                        revert with 0, 
                                                    32,
                                                    38,
                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 230 len 26] >> 48,
                                                    0
                                    if balanceOf[address(msg.sender)] < arg2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)] -= arg2
                                    if balanceOf[arg1] > !arg2:
                                        revert with 0, 17
                                    if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                    emit Transfer(arg2, msg.sender, arg1);
                                else:
                                    if not stor13:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    if arg2 / 100 > balanceOf[address(msg.sender)]:
                                        revert with 0, 
                                                    32,
                                                    38,
                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 294 len 26] >> 48,
                                                    0
                                    if balanceOf[address(msg.sender)] < arg2 / 100:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)] -= arg2 / 100
                                    if balanceOf[stor13] > !(arg2 / 100):
                                        revert with 0, 17
                                    if balanceOf[stor13] + (arg2 / 100) < balanceOf[stor13]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[stor13] += arg2 / 100
                                    emit Transfer((arg2 / 100), msg.sender, stor13);
                                    if not msg.sender:
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if not sub_8230af5aAddress:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    if arg2 / 100 > balanceOf[address(msg.sender)]:
                                        revert with 0, 
                                                    32,
                                                    38,
                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 454 len 26] >> 48,
                                                    0
                                    if balanceOf[address(msg.sender)] < arg2 / 100:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)] -= arg2 / 100
                                    if balanceOf[stor9] > !(arg2 / 100):
                                        revert with 0, 17
                                    if balanceOf[stor9] + (arg2 / 100) < balanceOf[stor9]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[stor9] += arg2 / 100
                                    emit Transfer((arg2 / 100), msg.sender, sub_8230af5aAddress);
                                    if not msg.sender:
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if not uniswapV2PairAddress:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    if arg2 / 100 > balanceOf[address(msg.sender)]:
                                        revert with 0, 
                                                    32,
                                                    38,
                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 614 len 26] >> 48,
                                                    0
                                    if balanceOf[address(msg.sender)] < arg2 / 100:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)] -= arg2 / 100
                                    if balanceOf[stor7] > !(arg2 / 100):
                                        revert with 0, 17
                                    if balanceOf[stor7] + (arg2 / 100) < balanceOf[stor7]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[stor7] += arg2 / 100
                                    emit Transfer((arg2 / 100), msg.sender, uniswapV2PairAddress);
                                    if not msg.sender:
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if not this.address:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    if arg2 / 10 > balanceOf[address(msg.sender)]:
                                        revert with 0, 
                                                    32,
                                                    38,
                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 774 len 26] >> 48,
                                                    0
                                    if balanceOf[address(msg.sender)] < arg2 / 10:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)] -= arg2 / 10
                                    if balanceOf[this.address] > !(arg2 / 10):
                                        revert with 0, 17
                                    if balanceOf[this.address] + (arg2 / 10) < balanceOf[this.address]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 10)
                                    emit Transfer((arg2 / 10), msg.sender, this.address);
                                    if not arg2 / 100:
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not arg1:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        if 0 > balanceOf[address(msg.sender)]:
                                            revert with 0, 
                                                        32,
                                                        38,
                                                        0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 934 len 26] >> 48,
                                                        0
                                        if balanceOf[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if balanceOf[arg1] > -1:
                                            revert with 0, 17
                                        if balanceOf[arg1] < balanceOf[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(arg1)] = balanceOf[arg1]
                                        emit Transfer(0, msg.sender, arg1);
                                    else:
                                        if arg2 / 100 and 87 > -1 / arg2 / 100:
                                            revert with 0, 17
                                        if not arg2 / 100:
                                            revert with 0, 18
                                        if 87 * arg2 / 100 / arg2 / 100 != 87:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not arg1:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        if 87 * arg2 / 100 > balanceOf[address(msg.sender)]:
                                            revert with 0, 
                                                        32,
                                                        38,
                                                        0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 934 len 26] >> 48,
                                                        0
                                        if balanceOf[address(msg.sender)] < 87 * arg2 / 100:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] += -87 * arg2 / 100
                                        if balanceOf[arg1] > !(87 * arg2 / 100):
                                            revert with 0, 17
                                        if balanceOf[arg1] + (87 * arg2 / 100) < balanceOf[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(arg1)] = balanceOf[arg1] + (87 * arg2 / 100)
                                        emit Transfer((87 * arg2 / 100), msg.sender, arg1);
                    else:
                        if stor19.length <= 9:
                            idx = 0
                            s = 0
                            t = 0
                            while idx < stor19.length:
                                mem[0] = stor19[idx]
                                mem[32] = 1
                                if s > !balanceOf[stor19[idx]]:
                                    revert with 0, 17
                                if s + balanceOf[stor19[idx]] < s:
                                    revert with 0, 'SafeMath: addition overflow'
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + balanceOf[stor19[idx]]
                                t = stor19[idx]
                                continue 
                            if stor19.length <= 9:
                                idx = 0
                                t = 0
                                u = 160 * stor19.length
                                while idx < stor19.length:
                                    mem[0] = stor19[idx]
                                    mem[32] = 1
                                    if balanceOf[stor19[idx]] < 10000000000 * 10^18:
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        t = t
                                        u = stor19[idx]
                                        continue 
                                    mem[0] = stor19[idx]
                                    mem[32] = 1
                                    if not balanceOf[stor19[idx]]:
                                        _16890 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16890] = 26
                                        mem[_16890 + 32] = 'SafeMath: division by zero'
                                        if not s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                            _17466 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _17466 + 68] = mem[idx + _16890 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_17466 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _17466 + -mem[64] + 100
                                        if 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                            if not 4 * ext_call.return_data[0] / 5:
                                                _20134 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_20134] = 26
                                                mem[_20134 + 32] = 'SafeMath: division by zero'
                                                mem[mem[64] + 4] = stor19[idx]
                                                mem[mem[64] + 36] = 0
                                                require ext_code.size(dogeAddress)
                                                call dogeAddress.0xa9059cbb with:
                                                     gas gas_remaining wei
                                                    args stor19[idx], 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _21993 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_21993] == bool(mem[_21993])
                                            else:
                                                if 4 * ext_call.return_data[0] / 5 and 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length > -1 / 4 * ext_call.return_data[0] / 5:
                                                    revert with 0, 17
                                                if not 4 * ext_call.return_data[0] / 5:
                                                    revert with 0, 18
                                                if 4 * ext_call.return_data[0] / 5 * 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 4 * ext_call.return_data[0] / 5 != 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _21188 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_21188] = 26
                                                mem[_21188 + 32] = 'SafeMath: division by zero'
                                                mem[mem[64] + 4] = stor19[idx]
                                                mem[mem[64] + 36] = 4 * ext_call.return_data[0] / 5 * 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 10000
                                                require ext_code.size(dogeAddress)
                                                call dogeAddress.0xa9059cbb with:
                                                     gas gas_remaining wei
                                                    args stor19[idx], 4 * ext_call.return_data[0] / 5 * 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 10000
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _22966 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_22966] == bool(mem[_22966])
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        t = 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length
                                        u = stor19[idx]
                                        continue 
                                    if balanceOf[stor19[idx]] and 10000 > -1 / balanceOf[stor19[idx]]:
                                        revert with 0, 17
                                    if not balanceOf[stor19[idx]]:
                                        revert with 0, 18
                                    if 10000 * balanceOf[stor19[idx]] / balanceOf[stor19[idx]] != 10000:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _18169 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18169] = 26
                                    mem[_18169 + 32] = 'SafeMath: division by zero'
                                    if not s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                        _18837 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _18837 + 68] = mem[idx + _18169 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18837 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _18837 + -mem[64] + 100
                                    if 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                        if not 4 * ext_call.return_data[0] / 5:
                                            _21187 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_21187] = 26
                                            mem[_21187 + 32] = 'SafeMath: division by zero'
                                            mem[mem[64] + 4] = stor19[idx]
                                            mem[mem[64] + 36] = 0
                                            require ext_code.size(dogeAddress)
                                            call dogeAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args stor19[idx], 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _22965 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_22965] == bool(mem[_22965])
                                        else:
                                            if 4 * ext_call.return_data[0] / 5 and 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length > -1 / 4 * ext_call.return_data[0] / 5:
                                                revert with 0, 17
                                            if not 4 * ext_call.return_data[0] / 5:
                                                revert with 0, 18
                                            if 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 4 * ext_call.return_data[0] / 5 != 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _22721 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_22721] = 26
                                            mem[_22721 + 32] = 'SafeMath: division by zero'
                                            mem[mem[64] + 4] = stor19[idx]
                                            mem[mem[64] + 36] = 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 10000
                                            require ext_code.size(dogeAddress)
                                            call dogeAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args stor19[idx], 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 10000
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _23328 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_23328] == bool(mem[_23328])
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    t = 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length
                                    u = stor19[idx]
                                    continue 
                                mem[0] = msg.sender
                                mem[32] = 14
                                if stor14[address(msg.sender)]:
                                    if not msg.sender:
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if not arg1:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    _16883 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_16883] = 38
                                    mem[_16883 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                    if arg2 > balanceOf[address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 38
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_16883 + 70 len 26]
                                        var72001 = 64
                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                    if balanceOf[address(msg.sender)] < arg2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)] -= arg2
                                    if balanceOf[arg1] > !arg2:
                                        revert with 0, 17
                                    if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                    emit Transfer(arg2, msg.sender, arg1);
                                else:
                                    mem[0] = arg1
                                    mem[32] = 14
                                    if stor14[address(arg1)]:
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not arg1:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        _17227 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_17227] = 38
                                        mem[_17227 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                        if arg2 > balanceOf[address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 38
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17227 + 70 len 26]
                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                        if balanceOf[address(msg.sender)] < arg2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2
                                        if balanceOf[arg1] > !arg2:
                                            revert with 0, 17
                                        if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                        emit Transfer(arg2, msg.sender, arg1);
                                    else:
                                        if stor10:
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not arg1:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            _16886 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_16886] = 38
                                            mem[_16886 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                            if arg2 > balanceOf[address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 38
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_16886 + 70 len 26]
                                                var72001 = 64
                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                            if balanceOf[address(msg.sender)] < arg2:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2
                                            if balanceOf[arg1] > !arg2:
                                                revert with 0, 17
                                            if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                            emit Transfer(arg2, msg.sender, arg1);
                                        else:
                                            _16503 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_16503] = 26
                                            mem[_16503 + 32] = 'SafeMath: division by zero'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not stor13:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            _18833 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_18833] = 38
                                            mem[_18833 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 38
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_18833 + 70 len 26]
                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                            if balanceOf[stor13] > !(arg2 / 100):
                                                revert with 0, 17
                                            if balanceOf[stor13] + (arg2 / 100) < balanceOf[stor13]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = stor13
                                            mem[32] = 1
                                            balanceOf[stor13] += arg2 / 100
                                            emit Transfer((arg2 / 100), msg.sender, stor13);
                                            _22575 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_22575] = 26
                                            mem[_22575 + 32] = 'SafeMath: division by zero'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not sub_8230af5aAddress:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            _23411 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_23411] = 38
                                            mem[_23411 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 38
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_23411 + 70 len 26]
                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                            if balanceOf[stor9] > !(arg2 / 100):
                                                revert with 0, 17
                                            if balanceOf[stor9] + (arg2 / 100) < balanceOf[stor9]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = sub_8230af5aAddress
                                            mem[32] = 1
                                            balanceOf[stor9] += arg2 / 100
                                            emit Transfer((arg2 / 100), msg.sender, sub_8230af5aAddress);
                                            _24303 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_24303] = 26
                                            mem[_24303 + 32] = 'SafeMath: division by zero'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not uniswapV2PairAddress:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            _24483 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_24483] = 38
                                            mem[_24483 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 38
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_24483 + 70 len 26]
                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                            if balanceOf[stor7] > !(arg2 / 100):
                                                revert with 0, 17
                                            if balanceOf[stor7] + (arg2 / 100) < balanceOf[stor7]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = uniswapV2PairAddress
                                            mem[32] = 1
                                            balanceOf[stor7] += arg2 / 100
                                            emit Transfer((arg2 / 100), msg.sender, uniswapV2PairAddress);
                                            _25291 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_25291] = 26
                                            mem[_25291 + 32] = 'SafeMath: division by zero'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not this.address:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            _25471 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_25471] = 38
                                            mem[_25471 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                            if arg2 / 10 > balanceOf[address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 38
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_25471 + 70 len 26]
                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                            if balanceOf[address(msg.sender)] < arg2 / 10:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2 / 10
                                            if balanceOf[this.address] > !(arg2 / 10):
                                                revert with 0, 17
                                            if balanceOf[this.address] + (arg2 / 10) < balanceOf[this.address]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = this.address
                                            mem[32] = 1
                                            balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 10)
                                            emit Transfer((arg2 / 10), msg.sender, this.address);
                                            _26279 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_26279] = 26
                                            mem[_26279 + 32] = 'SafeMath: division by zero'
                                            if not arg2 / 100:
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not arg1:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _26468 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_26468] = 38
                                                mem[_26468 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if 0 > balanceOf[address(msg.sender)]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_26468 + 70 len 26]
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(msg.sender)] < 0:
                                                    revert with 0, 17
                                                if balanceOf[arg1] > -1:
                                                    revert with 0, 17
                                                if balanceOf[arg1] < balanceOf[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(arg1)] = balanceOf[arg1]
                                                emit Transfer(0, msg.sender, arg1);
                                            else:
                                                if arg2 / 100 and 87 > -1 / arg2 / 100:
                                                    revert with 0, 17
                                                if not arg2 / 100:
                                                    revert with 0, 18
                                                if 87 * arg2 / 100 / arg2 / 100 != 87:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not arg1:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _27035 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_27035] = 38
                                                mem[_27035 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if 87 * arg2 / 100 > balanceOf[address(msg.sender)]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_27035 + 70 len 26]
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(msg.sender)] < 87 * arg2 / 100:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] += -87 * arg2 / 100
                                                if balanceOf[arg1] > !(87 * arg2 / 100):
                                                    revert with 0, 17
                                                if balanceOf[arg1] + (87 * arg2 / 100) < balanceOf[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(arg1)] = balanceOf[arg1] + (87 * arg2 / 100)
                                                emit Transfer((87 * arg2 / 100), msg.sender, arg1);
                            else:
                                idx = 0
                                t = 0
                                u = 160 * stor19.length
                                while idx < 9:
                                    if 0 > !idx:
                                        revert with 0, 17
                                    if idx >= stor19.length:
                                        revert with 0, 50
                                    mem[0] = stor19[idx]
                                    mem[32] = 1
                                    if balanceOf[stor19[idx]] < 10000000000 * 10^18:
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        t = t
                                        u = stor19[idx]
                                        continue 
                                    mem[0] = stor19[idx]
                                    mem[32] = 1
                                    if not balanceOf[stor19[idx]]:
                                        _17650 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17650] = 26
                                        mem[_17650 + 32] = 'SafeMath: division by zero'
                                        if not s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                            _17953 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _17953 + 68] = mem[idx + _17650 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_17953 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _17953 + -mem[64] + 100
                                        if 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                            if not 4 * ext_call.return_data[0] / 5:
                                                _20820 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_20820] = 26
                                                mem[_20820 + 32] = 'SafeMath: division by zero'
                                                mem[mem[64] + 4] = stor19[idx]
                                                mem[mem[64] + 36] = 0
                                                require ext_code.size(dogeAddress)
                                                call dogeAddress.0xa9059cbb with:
                                                     gas gas_remaining wei
                                                    args stor19[idx], 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _22722 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_22722] == bool(mem[_22722])
                                            else:
                                                if 4 * ext_call.return_data[0] / 5 and 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length > -1 / 4 * ext_call.return_data[0] / 5:
                                                    revert with 0, 17
                                                if not 4 * ext_call.return_data[0] / 5:
                                                    revert with 0, 18
                                                if 4 * ext_call.return_data[0] / 5 * 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 4 * ext_call.return_data[0] / 5 != 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _22001 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_22001] = 26
                                                mem[_22001 + 32] = 'SafeMath: division by zero'
                                                mem[mem[64] + 4] = stor19[idx]
                                                mem[mem[64] + 36] = 4 * ext_call.return_data[0] / 5 * 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 10000
                                                require ext_code.size(dogeAddress)
                                                call dogeAddress.0xa9059cbb with:
                                                     gas gas_remaining wei
                                                    args stor19[idx], 4 * ext_call.return_data[0] / 5 * 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 10000
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _23154 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_23154] == bool(mem[_23154])
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        t = 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length
                                        u = stor19[idx]
                                        continue 
                                    if balanceOf[stor19[idx]] and 10000 > -1 / balanceOf[stor19[idx]]:
                                        revert with 0, 17
                                    if not balanceOf[stor19[idx]]:
                                        revert with 0, 18
                                    if 10000 * balanceOf[stor19[idx]] / balanceOf[stor19[idx]] != 10000:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _19188 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19188] = 26
                                    mem[_19188 + 32] = 'SafeMath: division by zero'
                                    if not s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                        _19470 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _19470 + 68] = mem[idx + _19188 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19470 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19470 + -mem[64] + 100
                                    if 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                        if not 4 * ext_call.return_data[0] / 5:
                                            _22000 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_22000] = 26
                                            mem[_22000 + 32] = 'SafeMath: division by zero'
                                            mem[mem[64] + 4] = stor19[idx]
                                            mem[mem[64] + 36] = 0
                                            require ext_code.size(dogeAddress)
                                            call dogeAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args stor19[idx], 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _23153 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_23153] == bool(mem[_23153])
                                        else:
                                            if 4 * ext_call.return_data[0] / 5 and 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length > -1 / 4 * ext_call.return_data[0] / 5:
                                                revert with 0, 17
                                            if not 4 * ext_call.return_data[0] / 5:
                                                revert with 0, 18
                                            if 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 4 * ext_call.return_data[0] / 5 != 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _22967 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_22967] = 26
                                            mem[_22967 + 32] = 'SafeMath: division by zero'
                                            mem[mem[64] + 4] = stor19[idx]
                                            mem[mem[64] + 36] = 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 10000
                                            require ext_code.size(dogeAddress)
                                            call dogeAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args stor19[idx], 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 10000
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _23633 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_23633] == bool(mem[_23633])
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    t = 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length
                                    u = stor19[idx]
                                    continue 
                                mem[0] = msg.sender
                                mem[32] = 14
                                if stor14[address(msg.sender)]:
                                    if not msg.sender:
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if not arg1:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    _16891 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_16891] = 38
                                    mem[_16891 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                    if arg2 > balanceOf[address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 38
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_16891 + 70 len 26]
                                        var72001 = 64
                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                    if balanceOf[address(msg.sender)] < arg2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)] -= arg2
                                    if balanceOf[arg1] > !arg2:
                                        revert with 0, 17
                                    if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                    emit Transfer(arg2, msg.sender, arg1);
                                else:
                                    mem[0] = arg1
                                    mem[32] = 14
                                    if stor14[address(arg1)]:
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not arg1:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        _17232 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_17232] = 38
                                        mem[_17232 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                        if arg2 > balanceOf[address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 38
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17232 + 70 len 26]
                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                        if balanceOf[address(msg.sender)] < arg2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2
                                        if balanceOf[arg1] > !arg2:
                                            revert with 0, 17
                                        if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                        emit Transfer(arg2, msg.sender, arg1);
                                    else:
                                        if stor10:
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not arg1:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            _16894 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_16894] = 38
                                            mem[_16894 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                            if arg2 > balanceOf[address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 38
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_16894 + 70 len 26]
                                                var72001 = 64
                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                            if balanceOf[address(msg.sender)] < arg2:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2
                                            if balanceOf[arg1] > !arg2:
                                                revert with 0, 17
                                            if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                            emit Transfer(arg2, msg.sender, arg1);
                                        else:
                                            _16504 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_16504] = 26
                                            mem[_16504 + 32] = 'SafeMath: division by zero'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not stor13:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            _18841 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_18841] = 38
                                            mem[_18841 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 38
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_18841 + 70 len 26]
                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                            if balanceOf[stor13] > !(arg2 / 100):
                                                revert with 0, 17
                                            if balanceOf[stor13] + (arg2 / 100) < balanceOf[stor13]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = stor13
                                            mem[32] = 1
                                            balanceOf[stor13] += arg2 / 100
                                            emit Transfer((arg2 / 100), msg.sender, stor13);
                                            _22579 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_22579] = 26
                                            mem[_22579 + 32] = 'SafeMath: division by zero'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not sub_8230af5aAddress:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            _23414 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_23414] = 38
                                            mem[_23414 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 38
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_23414 + 70 len 26]
                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                            if balanceOf[stor9] > !(arg2 / 100):
                                                revert with 0, 17
                                            if balanceOf[stor9] + (arg2 / 100) < balanceOf[stor9]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = sub_8230af5aAddress
                                            mem[32] = 1
                                            balanceOf[stor9] += arg2 / 100
                                            emit Transfer((arg2 / 100), msg.sender, sub_8230af5aAddress);
                                            _24304 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_24304] = 26
                                            mem[_24304 + 32] = 'SafeMath: division by zero'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not uniswapV2PairAddress:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            _24486 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_24486] = 38
                                            mem[_24486 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 38
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_24486 + 70 len 26]
                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                            if balanceOf[stor7] > !(arg2 / 100):
                                                revert with 0, 17
                                            if balanceOf[stor7] + (arg2 / 100) < balanceOf[stor7]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = uniswapV2PairAddress
                                            mem[32] = 1
                                            balanceOf[stor7] += arg2 / 100
                                            emit Transfer((arg2 / 100), msg.sender, uniswapV2PairAddress);
                                            _25292 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_25292] = 26
                                            mem[_25292 + 32] = 'SafeMath: division by zero'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not this.address:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            _25474 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_25474] = 38
                                            mem[_25474 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                            if arg2 / 10 > balanceOf[address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 38
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_25474 + 70 len 26]
                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                            if balanceOf[address(msg.sender)] < arg2 / 10:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2 / 10
                                            if balanceOf[this.address] > !(arg2 / 10):
                                                revert with 0, 17
                                            if balanceOf[this.address] + (arg2 / 10) < balanceOf[this.address]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = this.address
                                            mem[32] = 1
                                            balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 10)
                                            emit Transfer((arg2 / 10), msg.sender, this.address);
                                            _26280 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_26280] = 26
                                            mem[_26280 + 32] = 'SafeMath: division by zero'
                                            if not arg2 / 100:
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not arg1:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _26472 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_26472] = 38
                                                mem[_26472 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if 0 > balanceOf[address(msg.sender)]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_26472 + 70 len 26]
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(msg.sender)] < 0:
                                                    revert with 0, 17
                                                if balanceOf[arg1] > -1:
                                                    revert with 0, 17
                                                if balanceOf[arg1] < balanceOf[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(arg1)] = balanceOf[arg1]
                                                emit Transfer(0, msg.sender, arg1);
                                            else:
                                                if arg2 / 100 and 87 > -1 / arg2 / 100:
                                                    revert with 0, 17
                                                if not arg2 / 100:
                                                    revert with 0, 18
                                                if 87 * arg2 / 100 / arg2 / 100 != 87:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not arg1:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _27040 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_27040] = 38
                                                mem[_27040 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if 87 * arg2 / 100 > balanceOf[address(msg.sender)]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_27040 + 70 len 26]
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(msg.sender)] < 87 * arg2 / 100:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] += -87 * arg2 / 100
                                                if balanceOf[arg1] > !(87 * arg2 / 100):
                                                    revert with 0, 17
                                                if balanceOf[arg1] + (87 * arg2 / 100) < balanceOf[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(arg1)] = balanceOf[arg1] + (87 * arg2 / 100)
                                                emit Transfer((87 * arg2 / 100), msg.sender, arg1);
                        else:
                            if stor19.length < 9:
                                revert with 0, 17
                            mem[64] = ceil32(return_data.size) + 224
                            mem[ceil32(return_data.size) + 160] = 24
                            mem[ceil32(return_data.size) + 192] = 'SafeMath: modulo by zero'
                            if not stor19.length - 9:
                                revert with 0, 'SafeMath: modulo by zero', 0
                            idx = 0
                            s = 0
                            t = 0
                            while idx < 9:
                                if block.timestamp % stor19.length - 9 > !idx:
                                    revert with 0, 17
                                if (block.timestamp % stor19.length - 9) + idx >= stor19.length:
                                    revert with 0, 50
                                mem[0] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                mem[32] = 1
                                if s > !balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]]:
                                    revert with 0, 17
                                if s + balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] < s:
                                    revert with 0, 'SafeMath: addition overflow'
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]]
                                t = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                continue 
                            if stor19.length <= 9:
                                idx = 0
                                t = 0
                                u = 1440
                                while idx < stor19.length:
                                    mem[0] = stor19[idx]
                                    mem[32] = 1
                                    if balanceOf[stor19[idx]] < 10000000000 * 10^18:
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        t = t
                                        u = stor19[idx]
                                        continue 
                                    mem[0] = stor19[idx]
                                    mem[32] = 1
                                    if not balanceOf[stor19[idx]]:
                                        _16905 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16905] = 26
                                        mem[_16905 + 32] = 'SafeMath: division by zero'
                                        if not 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                            _17473 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _17473 + 68] = mem[idx + _16905 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_17473 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _17473 + -mem[64] + 100
                                        if 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                            if not 4 * ext_call.return_data[0] / 5:
                                                _20148 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_20148] = 26
                                                mem[_20148 + 32] = 'SafeMath: division by zero'
                                                mem[mem[64] + 4] = stor19[idx]
                                                mem[mem[64] + 36] = 0
                                                require ext_code.size(dogeAddress)
                                                call dogeAddress.0xa9059cbb with:
                                                     gas gas_remaining wei
                                                    args stor19[idx], 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _22008 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_22008] == bool(mem[_22008])
                                            else:
                                                if 4 * ext_call.return_data[0] / 5 and 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s > -1 / 4 * ext_call.return_data[0] / 5:
                                                    revert with 0, 17
                                                if not 4 * ext_call.return_data[0] / 5:
                                                    revert with 0, 18
                                                if 4 * ext_call.return_data[0] / 5 * 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 4 * ext_call.return_data[0] / 5 != 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _21194 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_21194] = 26
                                                mem[_21194 + 32] = 'SafeMath: division by zero'
                                                mem[mem[64] + 4] = stor19[idx]
                                                mem[mem[64] + 36] = 4 * ext_call.return_data[0] / 5 * 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 10000
                                                require ext_code.size(dogeAddress)
                                                call dogeAddress.0xa9059cbb with:
                                                     gas gas_remaining wei
                                                    args stor19[idx], 4 * ext_call.return_data[0] / 5 * 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 10000
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _22969 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_22969] == bool(mem[_22969])
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        t = 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s
                                        u = stor19[idx]
                                        continue 
                                    if balanceOf[stor19[idx]] and 10000 > -1 / balanceOf[stor19[idx]]:
                                        revert with 0, 17
                                    if not balanceOf[stor19[idx]]:
                                        revert with 0, 18
                                    if 10000 * balanceOf[stor19[idx]] / balanceOf[stor19[idx]] != 10000:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _18183 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18183] = 26
                                    mem[_18183 + 32] = 'SafeMath: division by zero'
                                    if not 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                        _18853 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _18853 + 68] = mem[idx + _18183 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18853 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _18853 + -mem[64] + 100
                                    if 10000 * balanceOf[stor19[idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                        if not 4 * ext_call.return_data[0] / 5:
                                            _21193 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_21193] = 26
                                            mem[_21193 + 32] = 'SafeMath: division by zero'
                                            mem[mem[64] + 4] = stor19[idx]
                                            mem[mem[64] + 36] = 0
                                            require ext_code.size(dogeAddress)
                                            call dogeAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args stor19[idx], 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _22968 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_22968] == bool(mem[_22968])
                                        else:
                                            if 4 * ext_call.return_data[0] / 5 and 10000 * balanceOf[stor19[idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s > -1 / 4 * ext_call.return_data[0] / 5:
                                                revert with 0, 17
                                            if not 4 * ext_call.return_data[0] / 5:
                                                revert with 0, 18
                                            if 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor19[idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 4 * ext_call.return_data[0] / 5 != 10000 * balanceOf[stor19[idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _22723 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_22723] = 26
                                            mem[_22723 + 32] = 'SafeMath: division by zero'
                                            mem[mem[64] + 4] = stor19[idx]
                                            mem[mem[64] + 36] = 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor19[idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 10000
                                            require ext_code.size(dogeAddress)
                                            call dogeAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args stor19[idx], 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor19[idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 10000
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _23331 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_23331] == bool(mem[_23331])
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    t = 10000 * balanceOf[stor19[idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s
                                    u = stor19[idx]
                                    continue 
                                mem[0] = msg.sender
                                mem[32] = 14
                                if stor14[address(msg.sender)]:
                                    if not msg.sender:
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if not arg1:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    _16898 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_16898] = 38
                                    mem[_16898 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                    if arg2 > balanceOf[address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 38
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_16898 + 70 len 26]
                                        var83001 = 64
                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                    if balanceOf[address(msg.sender)] < arg2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)] -= arg2
                                    if balanceOf[arg1] > !arg2:
                                        revert with 0, 17
                                    if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                    emit Transfer(arg2, msg.sender, arg1);
                                else:
                                    mem[0] = arg1
                                    mem[32] = 14
                                    if stor14[address(arg1)]:
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not arg1:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        _17237 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_17237] = 38
                                        mem[_17237 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                        if arg2 > balanceOf[address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 38
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17237 + 70 len 26]
                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                        if balanceOf[address(msg.sender)] < arg2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2
                                        if balanceOf[arg1] > !arg2:
                                            revert with 0, 17
                                        if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                        emit Transfer(arg2, msg.sender, arg1);
                                    else:
                                        if stor10:
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not arg1:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            _16901 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_16901] = 38
                                            mem[_16901 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                            if arg2 > balanceOf[address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 38
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_16901 + 70 len 26]
                                                var83001 = 64
                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                            if balanceOf[address(msg.sender)] < arg2:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2
                                            if balanceOf[arg1] > !arg2:
                                                revert with 0, 17
                                            if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                            emit Transfer(arg2, msg.sender, arg1);
                                        else:
                                            _16506 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_16506] = 26
                                            mem[_16506 + 32] = 'SafeMath: division by zero'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not stor13:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            _18849 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_18849] = 38
                                            mem[_18849 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 38
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_18849 + 70 len 26]
                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                            if balanceOf[stor13] > !(arg2 / 100):
                                                revert with 0, 17
                                            if balanceOf[stor13] + (arg2 / 100) < balanceOf[stor13]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = stor13
                                            mem[32] = 1
                                            balanceOf[stor13] += arg2 / 100
                                            emit Transfer((arg2 / 100), msg.sender, stor13);
                                            _22581 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_22581] = 26
                                            mem[_22581 + 32] = 'SafeMath: division by zero'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not sub_8230af5aAddress:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            _23419 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_23419] = 38
                                            mem[_23419 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 38
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_23419 + 70 len 26]
                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                            if balanceOf[stor9] > !(arg2 / 100):
                                                revert with 0, 17
                                            if balanceOf[stor9] + (arg2 / 100) < balanceOf[stor9]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = sub_8230af5aAddress
                                            mem[32] = 1
                                            balanceOf[stor9] += arg2 / 100
                                            emit Transfer((arg2 / 100), msg.sender, sub_8230af5aAddress);
                                            _24305 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_24305] = 26
                                            mem[_24305 + 32] = 'SafeMath: division by zero'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not uniswapV2PairAddress:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            _24489 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_24489] = 38
                                            mem[_24489 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 38
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_24489 + 70 len 26]
                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                            if balanceOf[stor7] > !(arg2 / 100):
                                                revert with 0, 17
                                            if balanceOf[stor7] + (arg2 / 100) < balanceOf[stor7]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = uniswapV2PairAddress
                                            mem[32] = 1
                                            balanceOf[stor7] += arg2 / 100
                                            emit Transfer((arg2 / 100), msg.sender, uniswapV2PairAddress);
                                            _25293 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_25293] = 26
                                            mem[_25293 + 32] = 'SafeMath: division by zero'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not this.address:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            _25477 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_25477] = 38
                                            mem[_25477 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                            if arg2 / 10 > balanceOf[address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 38
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_25477 + 70 len 26]
                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                            if balanceOf[address(msg.sender)] < arg2 / 10:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2 / 10
                                            if balanceOf[this.address] > !(arg2 / 10):
                                                revert with 0, 17
                                            if balanceOf[this.address] + (arg2 / 10) < balanceOf[this.address]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = this.address
                                            mem[32] = 1
                                            balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 10)
                                            emit Transfer((arg2 / 10), msg.sender, this.address);
                                            _26281 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_26281] = 26
                                            mem[_26281 + 32] = 'SafeMath: division by zero'
                                            if not arg2 / 100:
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not arg1:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _26476 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_26476] = 38
                                                mem[_26476 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if 0 > balanceOf[address(msg.sender)]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_26476 + 70 len 26]
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(msg.sender)] < 0:
                                                    revert with 0, 17
                                                if balanceOf[arg1] > -1:
                                                    revert with 0, 17
                                                if balanceOf[arg1] < balanceOf[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(arg1)] = balanceOf[arg1]
                                                emit Transfer(0, msg.sender, arg1);
                                            else:
                                                if arg2 / 100 and 87 > -1 / arg2 / 100:
                                                    revert with 0, 17
                                                if not arg2 / 100:
                                                    revert with 0, 18
                                                if 87 * arg2 / 100 / arg2 / 100 != 87:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not arg1:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _27045 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_27045] = 38
                                                mem[_27045 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if 87 * arg2 / 100 > balanceOf[address(msg.sender)]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_27045 + 70 len 26]
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(msg.sender)] < 87 * arg2 / 100:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] += -87 * arg2 / 100
                                                if balanceOf[arg1] > !(87 * arg2 / 100):
                                                    revert with 0, 17
                                                if balanceOf[arg1] + (87 * arg2 / 100) < balanceOf[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(arg1)] = balanceOf[arg1] + (87 * arg2 / 100)
                                                emit Transfer((87 * arg2 / 100), msg.sender, arg1);
                            else:
                                idx = 0
                                t = 0
                                u = 1440
                                while idx < 9:
                                    if block.timestamp % stor19.length - 9 > !idx:
                                        revert with 0, 17
                                    if (block.timestamp % stor19.length - 9) + idx >= stor19.length:
                                        revert with 0, 50
                                    mem[0] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                    mem[32] = 1
                                    if balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] < 10000000000 * 10^18:
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        t = t
                                        u = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                        continue 
                                    mem[0] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                    mem[32] = 1
                                    if not balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]]:
                                        _17658 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17658] = 26
                                        mem[_17658 + 32] = 'SafeMath: division by zero'
                                        if not 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                            _17960 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _17960 + 68] = mem[idx + _17658 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_17960 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _17960 + -mem[64] + 100
                                        if 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                            if not 4 * ext_call.return_data[0] / 5:
                                                _20826 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_20826] = 26
                                                mem[_20826 + 32] = 'SafeMath: division by zero'
                                                mem[mem[64] + 4] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                                mem[mem[64] + 36] = 0
                                                require ext_code.size(dogeAddress)
                                                call dogeAddress.0xa9059cbb with:
                                                     gas gas_remaining wei
                                                    args stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx], 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _22724 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_22724] == bool(mem[_22724])
                                            else:
                                                if 4 * ext_call.return_data[0] / 5 and 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s > -1 / 4 * ext_call.return_data[0] / 5:
                                                    revert with 0, 17
                                                if not 4 * ext_call.return_data[0] / 5:
                                                    revert with 0, 18
                                                if 4 * ext_call.return_data[0] / 5 * 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 4 * ext_call.return_data[0] / 5 != 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _22016 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_22016] = 26
                                                mem[_22016 + 32] = 'SafeMath: division by zero'
                                                mem[mem[64] + 4] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                                mem[mem[64] + 36] = 4 * ext_call.return_data[0] / 5 * 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 10000
                                                require ext_code.size(dogeAddress)
                                                call dogeAddress.0xa9059cbb with:
                                                     gas gas_remaining wei
                                                    args stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx], 4 * ext_call.return_data[0] / 5 * 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 10000
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _23156 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_23156] == bool(mem[_23156])
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        t = 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s
                                        u = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                        continue 
                                    if balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] and 10000 > -1 / balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]]:
                                        revert with 0, 17
                                    if not balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]]:
                                        revert with 0, 18
                                    if 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] != 10000:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _19194 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19194] = 26
                                    mem[_19194 + 32] = 'SafeMath: division by zero'
                                    if not 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                        _19479 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _19479 + 68] = mem[idx + _19194 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19479 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19479 + -mem[64] + 100
                                    if 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                        if not 4 * ext_call.return_data[0] / 5:
                                            _22015 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_22015] = 26
                                            mem[_22015 + 32] = 'SafeMath: division by zero'
                                            mem[mem[64] + 4] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                            mem[mem[64] + 36] = 0
                                            require ext_code.size(dogeAddress)
                                            call dogeAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx], 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _23155 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_23155] == bool(mem[_23155])
                                        else:
                                            if 4 * ext_call.return_data[0] / 5 and 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s > -1 / 4 * ext_call.return_data[0] / 5:
                                                revert with 0, 17
                                            if not 4 * ext_call.return_data[0] / 5:
                                                revert with 0, 18
                                            if 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 4 * ext_call.return_data[0] / 5 != 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _22970 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_22970] = 26
                                            mem[_22970 + 32] = 'SafeMath: division by zero'
                                            mem[mem[64] + 4] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                            mem[mem[64] + 36] = 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 10000
                                            require ext_code.size(dogeAddress)
                                            call dogeAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx], 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 10000
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _23636 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_23636] == bool(mem[_23636])
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    t = 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s
                                    u = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                    continue 
                                mem[0] = msg.sender
                                mem[32] = 14
                                if stor14[address(msg.sender)]:
                                    if not msg.sender:
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if not arg1:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    _16906 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_16906] = 38
                                    mem[_16906 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                    if arg2 > balanceOf[address(msg.sender)]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 38
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_16906 + 70 len 26]
                                        var83001 = 64
                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                    if balanceOf[address(msg.sender)] < arg2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)] -= arg2
                                    if balanceOf[arg1] > !arg2:
                                        revert with 0, 17
                                    if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                    emit Transfer(arg2, msg.sender, arg1);
                                else:
                                    mem[0] = arg1
                                    mem[32] = 14
                                    if stor14[address(arg1)]:
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not arg1:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        _17242 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_17242] = 38
                                        mem[_17242 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                        if arg2 > balanceOf[address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 38
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17242 + 70 len 26]
                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                        if balanceOf[address(msg.sender)] < arg2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2
                                        if balanceOf[arg1] > !arg2:
                                            revert with 0, 17
                                        if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                        emit Transfer(arg2, msg.sender, arg1);
                                    else:
                                        if stor10:
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not arg1:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            _16909 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_16909] = 38
                                            mem[_16909 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                            if arg2 > balanceOf[address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 38
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_16909 + 70 len 26]
                                                var83001 = 64
                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                            if balanceOf[address(msg.sender)] < arg2:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2
                                            if balanceOf[arg1] > !arg2:
                                                revert with 0, 17
                                            if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                            emit Transfer(arg2, msg.sender, arg1);
                                        else:
                                            _16507 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_16507] = 26
                                            mem[_16507 + 32] = 'SafeMath: division by zero'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not stor13:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            _18857 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_18857] = 38
                                            mem[_18857 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 38
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_18857 + 70 len 26]
                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                            if balanceOf[stor13] > !(arg2 / 100):
                                                revert with 0, 17
                                            if balanceOf[stor13] + (arg2 / 100) < balanceOf[stor13]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = stor13
                                            mem[32] = 1
                                            balanceOf[stor13] += arg2 / 100
                                            emit Transfer((arg2 / 100), msg.sender, stor13);
                                            _22585 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_22585] = 26
                                            mem[_22585 + 32] = 'SafeMath: division by zero'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not sub_8230af5aAddress:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            _23422 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_23422] = 38
                                            mem[_23422 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 38
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_23422 + 70 len 26]
                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                            if balanceOf[stor9] > !(arg2 / 100):
                                                revert with 0, 17
                                            if balanceOf[stor9] + (arg2 / 100) < balanceOf[stor9]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = sub_8230af5aAddress
                                            mem[32] = 1
                                            balanceOf[stor9] += arg2 / 100
                                            emit Transfer((arg2 / 100), msg.sender, sub_8230af5aAddress);
                                            _24306 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_24306] = 26
                                            mem[_24306 + 32] = 'SafeMath: division by zero'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not uniswapV2PairAddress:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            _24492 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_24492] = 38
                                            mem[_24492 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 38
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_24492 + 70 len 26]
                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                            if balanceOf[stor7] > !(arg2 / 100):
                                                revert with 0, 17
                                            if balanceOf[stor7] + (arg2 / 100) < balanceOf[stor7]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = uniswapV2PairAddress
                                            mem[32] = 1
                                            balanceOf[stor7] += arg2 / 100
                                            emit Transfer((arg2 / 100), msg.sender, uniswapV2PairAddress);
                                            _25294 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_25294] = 26
                                            mem[_25294 + 32] = 'SafeMath: division by zero'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not this.address:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            _25480 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_25480] = 38
                                            mem[_25480 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                            if arg2 / 10 > balanceOf[address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 38
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_25480 + 70 len 26]
                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                            if balanceOf[address(msg.sender)] < arg2 / 10:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2 / 10
                                            if balanceOf[this.address] > !(arg2 / 10):
                                                revert with 0, 17
                                            if balanceOf[this.address] + (arg2 / 10) < balanceOf[this.address]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = this.address
                                            mem[32] = 1
                                            balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 10)
                                            emit Transfer((arg2 / 10), msg.sender, this.address);
                                            _26282 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_26282] = 26
                                            mem[_26282 + 32] = 'SafeMath: division by zero'
                                            if not arg2 / 100:
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not arg1:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _26480 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_26480] = 38
                                                mem[_26480 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if 0 > balanceOf[address(msg.sender)]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_26480 + 70 len 26]
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(msg.sender)] < 0:
                                                    revert with 0, 17
                                                if balanceOf[arg1] > -1:
                                                    revert with 0, 17
                                                if balanceOf[arg1] < balanceOf[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(arg1)] = balanceOf[arg1]
                                                emit Transfer(0, msg.sender, arg1);
                                            else:
                                                if arg2 / 100 and 87 > -1 / arg2 / 100:
                                                    revert with 0, 17
                                                if not arg2 / 100:
                                                    revert with 0, 18
                                                if 87 * arg2 / 100 / arg2 / 100 != 87:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not arg1:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _27050 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_27050] = 38
                                                mem[_27050 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if 87 * arg2 / 100 > balanceOf[address(msg.sender)]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_27050 + 70 len 26]
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(msg.sender)] < 87 * arg2 / 100:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] += -87 * arg2 / 100
                                                if balanceOf[arg1] > !(87 * arg2 / 100):
                                                    revert with 0, 17
                                                if balanceOf[arg1] + (87 * arg2 / 100) < balanceOf[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(arg1)] = balanceOf[arg1] + (87 * arg2 / 100)
                                                emit Transfer((87 * arg2 / 100), msg.sender, arg1);
        else:
            if sub_dc4e5c71Address == msg.sender:
                mem[100] = this.address
                require ext_code.size(dogeAddress)
                staticcall dogeAddress.0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[96] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if ext_call.return_data[0] < 10^12:
                    if not msg.sender:
                        revert with 0, 'ERC20: transfer from the zero address'
                    if stor14[address(msg.sender)]:
                        if not arg1:
                            revert with 0, 'ERC20: transfer to the zero address'
                        if arg2 > balanceOf[address(msg.sender)]:
                            revert with 0, 
                                        32,
                                        38,
                                        0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 166 len 26] >> 48,
                                        0
                        if balanceOf[address(msg.sender)] < arg2:
                            revert with 0, 17
                        balanceOf[address(msg.sender)] -= arg2
                        if balanceOf[arg1] > !arg2:
                            revert with 0, 17
                        if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                            revert with 0, 'SafeMath: addition overflow'
                        balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                        emit Transfer(arg2, msg.sender, arg1);
                    else:
                        if stor14[address(arg1)]:
                            if not arg1:
                                revert with 0, 'ERC20: transfer to the zero address'
                            if arg2 > balanceOf[address(msg.sender)]:
                                revert with 0, 
                                            32,
                                            38,
                                            0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 166 len 26] >> 48,
                                            0
                            if balanceOf[address(msg.sender)] < arg2:
                                revert with 0, 17
                            balanceOf[address(msg.sender)] -= arg2
                            if balanceOf[arg1] > !arg2:
                                revert with 0, 17
                            if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                            emit Transfer(arg2, msg.sender, arg1);
                        else:
                            if stor10:
                                if not arg1:
                                    revert with 0, 'ERC20: transfer to the zero address'
                                if arg2 > balanceOf[address(msg.sender)]:
                                    revert with 0, 
                                                32,
                                                38,
                                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 166 len 26] >> 48,
                                                0
                                if balanceOf[address(msg.sender)] < arg2:
                                    revert with 0, 17
                                balanceOf[address(msg.sender)] -= arg2
                                if balanceOf[arg1] > !arg2:
                                    revert with 0, 17
                                if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                emit Transfer(arg2, msg.sender, arg1);
                            else:
                                if not stor13:
                                    revert with 0, 'ERC20: transfer to the zero address'
                                if arg2 / 100 > balanceOf[address(msg.sender)]:
                                    revert with 0, 
                                                32,
                                                38,
                                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 230 len 26] >> 48,
                                                0
                                if balanceOf[address(msg.sender)] < arg2 / 100:
                                    revert with 0, 17
                                balanceOf[address(msg.sender)] -= arg2 / 100
                                if balanceOf[stor13] > !(arg2 / 100):
                                    revert with 0, 17
                                if balanceOf[stor13] + (arg2 / 100) < balanceOf[stor13]:
                                    revert with 0, 'SafeMath: addition overflow'
                                balanceOf[stor13] += arg2 / 100
                                emit Transfer((arg2 / 100), msg.sender, stor13);
                                if not msg.sender:
                                    revert with 0, 'ERC20: transfer from the zero address'
                                if not sub_8230af5aAddress:
                                    revert with 0, 'ERC20: transfer to the zero address'
                                if arg2 / 100 > balanceOf[address(msg.sender)]:
                                    revert with 0, 
                                                32,
                                                38,
                                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 390 len 26] >> 48,
                                                0
                                if balanceOf[address(msg.sender)] < arg2 / 100:
                                    revert with 0, 17
                                balanceOf[address(msg.sender)] -= arg2 / 100
                                if balanceOf[stor9] > !(arg2 / 100):
                                    revert with 0, 17
                                if balanceOf[stor9] + (arg2 / 100) < balanceOf[stor9]:
                                    revert with 0, 'SafeMath: addition overflow'
                                balanceOf[stor9] += arg2 / 100
                                emit Transfer((arg2 / 100), msg.sender, sub_8230af5aAddress);
                                if not msg.sender:
                                    revert with 0, 'ERC20: transfer from the zero address'
                                if not uniswapV2PairAddress:
                                    revert with 0, 'ERC20: transfer to the zero address'
                                if arg2 / 100 > balanceOf[address(msg.sender)]:
                                    revert with 0, 
                                                32,
                                                38,
                                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 550 len 26] >> 48,
                                                0
                                if balanceOf[address(msg.sender)] < arg2 / 100:
                                    revert with 0, 17
                                balanceOf[address(msg.sender)] -= arg2 / 100
                                if balanceOf[stor7] > !(arg2 / 100):
                                    revert with 0, 17
                                if balanceOf[stor7] + (arg2 / 100) < balanceOf[stor7]:
                                    revert with 0, 'SafeMath: addition overflow'
                                balanceOf[stor7] += arg2 / 100
                                emit Transfer((arg2 / 100), msg.sender, uniswapV2PairAddress);
                                if not msg.sender:
                                    revert with 0, 'ERC20: transfer from the zero address'
                                if not this.address:
                                    revert with 0, 'ERC20: transfer to the zero address'
                                if arg2 / 10 > balanceOf[address(msg.sender)]:
                                    revert with 0, 
                                                32,
                                                38,
                                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 710 len 26] >> 48,
                                                0
                                if balanceOf[address(msg.sender)] < arg2 / 10:
                                    revert with 0, 17
                                balanceOf[address(msg.sender)] -= arg2 / 10
                                if balanceOf[this.address] > !(arg2 / 10):
                                    revert with 0, 17
                                if balanceOf[this.address] + (arg2 / 10) < balanceOf[this.address]:
                                    revert with 0, 'SafeMath: addition overflow'
                                balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 10)
                                emit Transfer((arg2 / 10), msg.sender, this.address);
                                if not arg2 / 100:
                                    if not msg.sender:
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if not arg1:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    if 0 > balanceOf[address(msg.sender)]:
                                        revert with 0, 
                                                    32,
                                                    38,
                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 870 len 26] >> 48,
                                                    0
                                    if balanceOf[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if balanceOf[arg1] > -1:
                                        revert with 0, 17
                                    if balanceOf[arg1] < balanceOf[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(arg1)] = balanceOf[arg1]
                                    emit Transfer(0, msg.sender, arg1);
                                else:
                                    if arg2 / 100 and 87 > -1 / arg2 / 100:
                                        revert with 0, 17
                                    if not arg2 / 100:
                                        revert with 0, 18
                                    if 87 * arg2 / 100 / arg2 / 100 != 87:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if not arg1:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    if 87 * arg2 / 100 > balanceOf[address(msg.sender)]:
                                        revert with 0, 
                                                    32,
                                                    38,
                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 870 len 26] >> 48,
                                                    0
                                    if balanceOf[address(msg.sender)] < 87 * arg2 / 100:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)] += -87 * arg2 / 100
                                    if balanceOf[arg1] > !(87 * arg2 / 100):
                                        revert with 0, 17
                                    if balanceOf[arg1] + (87 * arg2 / 100) < balanceOf[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(arg1)] = balanceOf[arg1] + (87 * arg2 / 100)
                                    emit Transfer((87 * arg2 / 100), msg.sender, arg1);
                else:
                    if not ext_call.return_data[0]:
                        mem[64] = ceil32(return_data.size) + 160
                        mem[ceil32(return_data.size) + 96] = 26
                        mem[ceil32(return_data.size) + 128] = 'SafeMath: division by zero'
                        if not stor19.length:
                            if not msg.sender:
                                revert with 0, 'ERC20: transfer from the zero address'
                            if stor14[address(msg.sender)]:
                                if not arg1:
                                    revert with 0, 'ERC20: transfer to the zero address'
                                if arg2 > balanceOf[address(msg.sender)]:
                                    revert with 0, 
                                                32,
                                                38,
                                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 230 len 26] >> 48,
                                                0
                                if balanceOf[address(msg.sender)] < arg2:
                                    revert with 0, 17
                                balanceOf[address(msg.sender)] -= arg2
                                if balanceOf[arg1] > !arg2:
                                    revert with 0, 17
                                if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                emit Transfer(arg2, msg.sender, arg1);
                            else:
                                if stor14[address(arg1)]:
                                    if not arg1:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    if arg2 > balanceOf[address(msg.sender)]:
                                        revert with 0, 
                                                    32,
                                                    38,
                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 230 len 26] >> 48,
                                                    0
                                    if balanceOf[address(msg.sender)] < arg2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)] -= arg2
                                    if balanceOf[arg1] > !arg2:
                                        revert with 0, 17
                                    if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                    emit Transfer(arg2, msg.sender, arg1);
                                else:
                                    if stor10:
                                        if not arg1:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        if arg2 > balanceOf[address(msg.sender)]:
                                            revert with 0, 
                                                        32,
                                                        38,
                                                        0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 230 len 26] >> 48,
                                                        0
                                        if balanceOf[address(msg.sender)] < arg2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2
                                        if balanceOf[arg1] > !arg2:
                                            revert with 0, 17
                                        if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                        emit Transfer(arg2, msg.sender, arg1);
                                    else:
                                        if not stor13:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        if arg2 / 100 > balanceOf[address(msg.sender)]:
                                            revert with 0, 
                                                        32,
                                                        38,
                                                        0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 294 len 26] >> 48,
                                                        0
                                        if balanceOf[address(msg.sender)] < arg2 / 100:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2 / 100
                                        if balanceOf[stor13] > !(arg2 / 100):
                                            revert with 0, 17
                                        if balanceOf[stor13] + (arg2 / 100) < balanceOf[stor13]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[stor13] += arg2 / 100
                                        emit Transfer((arg2 / 100), msg.sender, stor13);
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not sub_8230af5aAddress:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        if arg2 / 100 > balanceOf[address(msg.sender)]:
                                            revert with 0, 
                                                        32,
                                                        38,
                                                        0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 454 len 26] >> 48,
                                                        0
                                        if balanceOf[address(msg.sender)] < arg2 / 100:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2 / 100
                                        if balanceOf[stor9] > !(arg2 / 100):
                                            revert with 0, 17
                                        if balanceOf[stor9] + (arg2 / 100) < balanceOf[stor9]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[stor9] += arg2 / 100
                                        emit Transfer((arg2 / 100), msg.sender, sub_8230af5aAddress);
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not uniswapV2PairAddress:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        if arg2 / 100 > balanceOf[address(msg.sender)]:
                                            revert with 0, 
                                                        32,
                                                        38,
                                                        0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 614 len 26] >> 48,
                                                        0
                                        if balanceOf[address(msg.sender)] < arg2 / 100:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2 / 100
                                        if balanceOf[stor7] > !(arg2 / 100):
                                            revert with 0, 17
                                        if balanceOf[stor7] + (arg2 / 100) < balanceOf[stor7]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[stor7] += arg2 / 100
                                        emit Transfer((arg2 / 100), msg.sender, uniswapV2PairAddress);
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not this.address:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        if arg2 / 10 > balanceOf[address(msg.sender)]:
                                            revert with 0, 
                                                        32,
                                                        38,
                                                        0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 774 len 26] >> 48,
                                                        0
                                        if balanceOf[address(msg.sender)] < arg2 / 10:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2 / 10
                                        if balanceOf[this.address] > !(arg2 / 10):
                                            revert with 0, 17
                                        if balanceOf[this.address] + (arg2 / 10) < balanceOf[this.address]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 10)
                                        emit Transfer((arg2 / 10), msg.sender, this.address);
                                        if not arg2 / 100:
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not arg1:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            if 0 > balanceOf[address(msg.sender)]:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 934 len 26] >> 48,
                                                            0
                                            if balanceOf[address(msg.sender)] < 0:
                                                revert with 0, 17
                                            if balanceOf[arg1] > -1:
                                                revert with 0, 17
                                            if balanceOf[arg1] < balanceOf[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(arg1)] = balanceOf[arg1]
                                            emit Transfer(0, msg.sender, arg1);
                                        else:
                                            if arg2 / 100 and 87 > -1 / arg2 / 100:
                                                revert with 0, 17
                                            if not arg2 / 100:
                                                revert with 0, 18
                                            if 87 * arg2 / 100 / arg2 / 100 != 87:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not arg1:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            if 87 * arg2 / 100 > balanceOf[address(msg.sender)]:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 934 len 26] >> 48,
                                                            0
                                            if balanceOf[address(msg.sender)] < 87 * arg2 / 100:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] += -87 * arg2 / 100
                                            if balanceOf[arg1] > !(87 * arg2 / 100):
                                                revert with 0, 17
                                            if balanceOf[arg1] + (87 * arg2 / 100) < balanceOf[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(arg1)] = balanceOf[arg1] + (87 * arg2 / 100)
                                            emit Transfer((87 * arg2 / 100), msg.sender, arg1);
                        else:
                            if stor19.length <= 9:
                                idx = 0
                                s = 0
                                t = 0
                                while idx < stor19.length:
                                    mem[0] = stor19[idx]
                                    mem[32] = 1
                                    if s > !balanceOf[stor19[idx]]:
                                        revert with 0, 17
                                    if s + balanceOf[stor19[idx]] < s:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + balanceOf[stor19[idx]]
                                    t = stor19[idx]
                                    continue 
                                if stor19.length <= 9:
                                    idx = 0
                                    t = 0
                                    u = 160 * stor19.length
                                    while idx < stor19.length:
                                        mem[0] = stor19[idx]
                                        mem[32] = 1
                                        if balanceOf[stor19[idx]] < 10000000000 * 10^18:
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            t = t
                                            u = stor19[idx]
                                            continue 
                                        mem[0] = stor19[idx]
                                        mem[32] = 1
                                        if not balanceOf[stor19[idx]]:
                                            _16980 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_16980] = 26
                                            mem[_16980 + 32] = 'SafeMath: division by zero'
                                            if not s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                _17508 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _17508 + 68] = mem[idx + _16980 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_17508 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _17508 + -mem[64] + 100
                                            if 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                _20218 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_20218] = 26
                                                mem[_20218 + 32] = 'SafeMath: division by zero'
                                                mem[mem[64] + 4] = stor19[idx]
                                                mem[mem[64] + 36] = 0
                                                require ext_code.size(dogeAddress)
                                                call dogeAddress.0xa9059cbb with:
                                                     gas gas_remaining wei
                                                    args stor19[idx], 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _22081 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_22081] == bool(mem[_22081])
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            t = 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length
                                            u = stor19[idx]
                                            continue 
                                        if balanceOf[stor19[idx]] and 10000 > -1 / balanceOf[stor19[idx]]:
                                            revert with 0, 17
                                        if not balanceOf[stor19[idx]]:
                                            revert with 0, 18
                                        if 10000 * balanceOf[stor19[idx]] / balanceOf[stor19[idx]] != 10000:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _18253 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18253] = 26
                                        mem[_18253 + 32] = 'SafeMath: division by zero'
                                        if not s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                            _18933 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _18933 + 68] = mem[idx + _18253 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_18933 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _18933 + -mem[64] + 100
                                        if 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                            _21221 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_21221] = 26
                                            mem[_21221 + 32] = 'SafeMath: division by zero'
                                            mem[mem[64] + 4] = stor19[idx]
                                            mem[mem[64] + 36] = 0
                                            require ext_code.size(dogeAddress)
                                            call dogeAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args stor19[idx], 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _22979 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_22979] == bool(mem[_22979])
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        t = 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length
                                        u = stor19[idx]
                                        continue 
                                    mem[0] = msg.sender
                                    mem[32] = 14
                                    if stor14[address(msg.sender)]:
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not arg1:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        _16973 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_16973] = 38
                                        mem[_16973 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                        if arg2 > balanceOf[address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 38
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_16973 + 70 len 26]
                                            var67001 = 64
                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                        if balanceOf[address(msg.sender)] < arg2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2
                                        if balanceOf[arg1] > !arg2:
                                            revert with 0, 17
                                        if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                        emit Transfer(arg2, msg.sender, arg1);
                                    else:
                                        mem[0] = arg1
                                        mem[32] = 14
                                        if stor14[address(arg1)]:
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not arg1:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            _17287 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_17287] = 38
                                            mem[_17287 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                            if arg2 > balanceOf[address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 38
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17287 + 70 len 26]
                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                            if balanceOf[address(msg.sender)] < arg2:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2
                                            if balanceOf[arg1] > !arg2:
                                                revert with 0, 17
                                            if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                            emit Transfer(arg2, msg.sender, arg1);
                                        else:
                                            if stor10:
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not arg1:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _16976 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_16976] = 38
                                                mem[_16976 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if arg2 > balanceOf[address(msg.sender)]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_16976 + 70 len 26]
                                                    var67001 = 64
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(msg.sender)] < arg2:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= arg2
                                                if balanceOf[arg1] > !arg2:
                                                    revert with 0, 17
                                                if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                emit Transfer(arg2, msg.sender, arg1);
                                            else:
                                                _16521 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_16521] = 26
                                                mem[_16521 + 32] = 'SafeMath: division by zero'
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not stor13:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _18929 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_18929] = 38
                                                mem[_18929 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_18929 + 70 len 26]
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(msg.sender)] < arg2 / 100:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= arg2 / 100
                                                if balanceOf[stor13] > !(arg2 / 100):
                                                    revert with 0, 17
                                                if balanceOf[stor13] + (arg2 / 100) < balanceOf[stor13]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = stor13
                                                mem[32] = 1
                                                balanceOf[stor13] += arg2 / 100
                                                emit Transfer((arg2 / 100), msg.sender, stor13);
                                                _22609 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_22609] = 26
                                                mem[_22609 + 32] = 'SafeMath: division by zero'
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not sub_8230af5aAddress:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _23455 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_23455] = 38
                                                mem[_23455 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_23455 + 70 len 26]
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(msg.sender)] < arg2 / 100:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= arg2 / 100
                                                if balanceOf[stor9] > !(arg2 / 100):
                                                    revert with 0, 17
                                                if balanceOf[stor9] + (arg2 / 100) < balanceOf[stor9]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = sub_8230af5aAddress
                                                mem[32] = 1
                                                balanceOf[stor9] += arg2 / 100
                                                emit Transfer((arg2 / 100), msg.sender, sub_8230af5aAddress);
                                                _24315 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_24315] = 26
                                                mem[_24315 + 32] = 'SafeMath: division by zero'
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not uniswapV2PairAddress:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _24519 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_24519] = 38
                                                mem[_24519 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_24519 + 70 len 26]
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(msg.sender)] < arg2 / 100:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= arg2 / 100
                                                if balanceOf[stor7] > !(arg2 / 100):
                                                    revert with 0, 17
                                                if balanceOf[stor7] + (arg2 / 100) < balanceOf[stor7]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = uniswapV2PairAddress
                                                mem[32] = 1
                                                balanceOf[stor7] += arg2 / 100
                                                emit Transfer((arg2 / 100), msg.sender, uniswapV2PairAddress);
                                                _25303 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_25303] = 26
                                                mem[_25303 + 32] = 'SafeMath: division by zero'
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not this.address:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _25507 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_25507] = 38
                                                mem[_25507 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if arg2 / 10 > balanceOf[address(msg.sender)]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_25507 + 70 len 26]
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(msg.sender)] < arg2 / 10:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= arg2 / 10
                                                if balanceOf[this.address] > !(arg2 / 10):
                                                    revert with 0, 17
                                                if balanceOf[this.address] + (arg2 / 10) < balanceOf[this.address]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = this.address
                                                mem[32] = 1
                                                balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 10)
                                                emit Transfer((arg2 / 10), msg.sender, this.address);
                                                _26291 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_26291] = 26
                                                mem[_26291 + 32] = 'SafeMath: division by zero'
                                                if not arg2 / 100:
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not arg1:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _26516 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_26516] = 38
                                                    mem[_26516 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if 0 > balanceOf[address(msg.sender)]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_26516 + 70 len 26]
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(msg.sender)] < 0:
                                                        revert with 0, 17
                                                    if balanceOf[arg1] > -1:
                                                        revert with 0, 17
                                                    if balanceOf[arg1] < balanceOf[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(arg1)] = balanceOf[arg1]
                                                    emit Transfer(0, msg.sender, arg1);
                                                else:
                                                    if arg2 / 100 and 87 > -1 / arg2 / 100:
                                                        revert with 0, 17
                                                    if not arg2 / 100:
                                                        revert with 0, 18
                                                    if 87 * arg2 / 100 / arg2 / 100 != 87:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not arg1:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _27095 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_27095] = 38
                                                    mem[_27095 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if 87 * arg2 / 100 > balanceOf[address(msg.sender)]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_27095 + 70 len 26]
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(msg.sender)] < 87 * arg2 / 100:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] += -87 * arg2 / 100
                                                    if balanceOf[arg1] > !(87 * arg2 / 100):
                                                        revert with 0, 17
                                                    if balanceOf[arg1] + (87 * arg2 / 100) < balanceOf[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(arg1)] = balanceOf[arg1] + (87 * arg2 / 100)
                                                    emit Transfer((87 * arg2 / 100), msg.sender, arg1);
                                else:
                                    idx = 0
                                    t = 0
                                    u = 160 * stor19.length
                                    while idx < 9:
                                        if 0 > !idx:
                                            revert with 0, 17
                                        if idx >= stor19.length:
                                            revert with 0, 50
                                        mem[0] = stor19[idx]
                                        mem[32] = 1
                                        if balanceOf[stor19[idx]] < 10000000000 * 10^18:
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            t = t
                                            u = stor19[idx]
                                            continue 
                                        mem[0] = stor19[idx]
                                        mem[32] = 1
                                        if not balanceOf[stor19[idx]]:
                                            _17698 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_17698] = 26
                                            mem[_17698 + 32] = 'SafeMath: division by zero'
                                            if not s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                _17995 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _17995 + 68] = mem[idx + _17698 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_17995 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _17995 + -mem[64] + 100
                                            if 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                _20856 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_20856] = 26
                                                mem[_20856 + 32] = 'SafeMath: division by zero'
                                                mem[mem[64] + 4] = stor19[idx]
                                                mem[mem[64] + 36] = 0
                                                require ext_code.size(dogeAddress)
                                                call dogeAddress.0xa9059cbb with:
                                                     gas gas_remaining wei
                                                    args stor19[idx], 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _22731 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_22731] == bool(mem[_22731])
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            t = 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length
                                            u = stor19[idx]
                                            continue 
                                        if balanceOf[stor19[idx]] and 10000 > -1 / balanceOf[stor19[idx]]:
                                            revert with 0, 17
                                        if not balanceOf[stor19[idx]]:
                                            revert with 0, 18
                                        if 10000 * balanceOf[stor19[idx]] / balanceOf[stor19[idx]] != 10000:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _19224 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19224] = 26
                                        mem[_19224 + 32] = 'SafeMath: division by zero'
                                        if not s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                            _19524 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _19524 + 68] = mem[idx + _19224 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_19524 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _19524 + -mem[64] + 100
                                        if 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                            _22088 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_22088] = 26
                                            mem[_22088 + 32] = 'SafeMath: division by zero'
                                            mem[mem[64] + 4] = stor19[idx]
                                            mem[mem[64] + 36] = 0
                                            require ext_code.size(dogeAddress)
                                            call dogeAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args stor19[idx], 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _23163 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_23163] == bool(mem[_23163])
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        t = 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length
                                        u = stor19[idx]
                                        continue 
                                    mem[0] = msg.sender
                                    mem[32] = 14
                                    if stor14[address(msg.sender)]:
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not arg1:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        _16981 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_16981] = 38
                                        mem[_16981 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                        if arg2 > balanceOf[address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 38
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_16981 + 70 len 26]
                                            var67001 = 64
                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                        if balanceOf[address(msg.sender)] < arg2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2
                                        if balanceOf[arg1] > !arg2:
                                            revert with 0, 17
                                        if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                        emit Transfer(arg2, msg.sender, arg1);
                                    else:
                                        mem[0] = arg1
                                        mem[32] = 14
                                        if stor14[address(arg1)]:
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not arg1:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            _17292 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_17292] = 38
                                            mem[_17292 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                            if arg2 > balanceOf[address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 38
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17292 + 70 len 26]
                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                            if balanceOf[address(msg.sender)] < arg2:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2
                                            if balanceOf[arg1] > !arg2:
                                                revert with 0, 17
                                            if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                            emit Transfer(arg2, msg.sender, arg1);
                                        else:
                                            if stor10:
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not arg1:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _16984 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_16984] = 38
                                                mem[_16984 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if arg2 > balanceOf[address(msg.sender)]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_16984 + 70 len 26]
                                                    var67001 = 64
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(msg.sender)] < arg2:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= arg2
                                                if balanceOf[arg1] > !arg2:
                                                    revert with 0, 17
                                                if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                emit Transfer(arg2, msg.sender, arg1);
                                            else:
                                                _16522 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_16522] = 26
                                                mem[_16522 + 32] = 'SafeMath: division by zero'
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not stor13:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _18937 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_18937] = 38
                                                mem[_18937 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_18937 + 70 len 26]
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(msg.sender)] < arg2 / 100:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= arg2 / 100
                                                if balanceOf[stor13] > !(arg2 / 100):
                                                    revert with 0, 17
                                                if balanceOf[stor13] + (arg2 / 100) < balanceOf[stor13]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = stor13
                                                mem[32] = 1
                                                balanceOf[stor13] += arg2 / 100
                                                emit Transfer((arg2 / 100), msg.sender, stor13);
                                                _22612 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_22612] = 26
                                                mem[_22612 + 32] = 'SafeMath: division by zero'
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not sub_8230af5aAddress:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _23458 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_23458] = 38
                                                mem[_23458 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_23458 + 70 len 26]
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(msg.sender)] < arg2 / 100:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= arg2 / 100
                                                if balanceOf[stor9] > !(arg2 / 100):
                                                    revert with 0, 17
                                                if balanceOf[stor9] + (arg2 / 100) < balanceOf[stor9]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = sub_8230af5aAddress
                                                mem[32] = 1
                                                balanceOf[stor9] += arg2 / 100
                                                emit Transfer((arg2 / 100), msg.sender, sub_8230af5aAddress);
                                                _24316 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_24316] = 26
                                                mem[_24316 + 32] = 'SafeMath: division by zero'
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not uniswapV2PairAddress:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _24522 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_24522] = 38
                                                mem[_24522 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_24522 + 70 len 26]
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(msg.sender)] < arg2 / 100:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= arg2 / 100
                                                if balanceOf[stor7] > !(arg2 / 100):
                                                    revert with 0, 17
                                                if balanceOf[stor7] + (arg2 / 100) < balanceOf[stor7]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = uniswapV2PairAddress
                                                mem[32] = 1
                                                balanceOf[stor7] += arg2 / 100
                                                emit Transfer((arg2 / 100), msg.sender, uniswapV2PairAddress);
                                                _25304 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_25304] = 26
                                                mem[_25304 + 32] = 'SafeMath: division by zero'
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not this.address:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _25510 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_25510] = 38
                                                mem[_25510 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if arg2 / 10 > balanceOf[address(msg.sender)]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_25510 + 70 len 26]
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(msg.sender)] < arg2 / 10:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= arg2 / 10
                                                if balanceOf[this.address] > !(arg2 / 10):
                                                    revert with 0, 17
                                                if balanceOf[this.address] + (arg2 / 10) < balanceOf[this.address]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = this.address
                                                mem[32] = 1
                                                balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 10)
                                                emit Transfer((arg2 / 10), msg.sender, this.address);
                                                _26292 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_26292] = 26
                                                mem[_26292 + 32] = 'SafeMath: division by zero'
                                                if not arg2 / 100:
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not arg1:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _26520 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_26520] = 38
                                                    mem[_26520 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if 0 > balanceOf[address(msg.sender)]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_26520 + 70 len 26]
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(msg.sender)] < 0:
                                                        revert with 0, 17
                                                    if balanceOf[arg1] > -1:
                                                        revert with 0, 17
                                                    if balanceOf[arg1] < balanceOf[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(arg1)] = balanceOf[arg1]
                                                    emit Transfer(0, msg.sender, arg1);
                                                else:
                                                    if arg2 / 100 and 87 > -1 / arg2 / 100:
                                                        revert with 0, 17
                                                    if not arg2 / 100:
                                                        revert with 0, 18
                                                    if 87 * arg2 / 100 / arg2 / 100 != 87:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not arg1:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _27100 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_27100] = 38
                                                    mem[_27100 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if 87 * arg2 / 100 > balanceOf[address(msg.sender)]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_27100 + 70 len 26]
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(msg.sender)] < 87 * arg2 / 100:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] += -87 * arg2 / 100
                                                    if balanceOf[arg1] > !(87 * arg2 / 100):
                                                        revert with 0, 17
                                                    if balanceOf[arg1] + (87 * arg2 / 100) < balanceOf[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(arg1)] = balanceOf[arg1] + (87 * arg2 / 100)
                                                    emit Transfer((87 * arg2 / 100), msg.sender, arg1);
                            else:
                                if stor19.length < 9:
                                    revert with 0, 17
                                mem[64] = ceil32(return_data.size) + 224
                                mem[ceil32(return_data.size) + 160] = 24
                                mem[ceil32(return_data.size) + 192] = 'SafeMath: modulo by zero'
                                if not stor19.length - 9:
                                    revert with 0, 'SafeMath: modulo by zero', 0
                                idx = 0
                                s = 0
                                t = 0
                                while idx < 9:
                                    if block.timestamp % stor19.length - 9 > !idx:
                                        revert with 0, 17
                                    if (block.timestamp % stor19.length - 9) + idx >= stor19.length:
                                        revert with 0, 50
                                    mem[0] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                    mem[32] = 1
                                    if s > !balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]]:
                                        revert with 0, 17
                                    if s + balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] < s:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]]
                                    t = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                    continue 
                                if stor19.length <= 9:
                                    idx = 0
                                    t = 0
                                    u = 1440
                                    while idx < stor19.length:
                                        mem[0] = stor19[idx]
                                        mem[32] = 1
                                        if balanceOf[stor19[idx]] < 10000000000 * 10^18:
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            t = t
                                            u = stor19[idx]
                                            continue 
                                        mem[0] = stor19[idx]
                                        mem[32] = 1
                                        if not balanceOf[stor19[idx]]:
                                            _16995 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_16995] = 26
                                            mem[_16995 + 32] = 'SafeMath: division by zero'
                                            if not 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                _17515 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _17515 + 68] = mem[idx + _16995 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_17515 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _17515 + -mem[64] + 100
                                            if 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                _20232 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_20232] = 26
                                                mem[_20232 + 32] = 'SafeMath: division by zero'
                                                mem[mem[64] + 4] = stor19[idx]
                                                mem[mem[64] + 36] = 0
                                                require ext_code.size(dogeAddress)
                                                call dogeAddress.0xa9059cbb with:
                                                     gas gas_remaining wei
                                                    args stor19[idx], 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _22095 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_22095] == bool(mem[_22095])
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            t = 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s
                                            u = stor19[idx]
                                            continue 
                                        if balanceOf[stor19[idx]] and 10000 > -1 / balanceOf[stor19[idx]]:
                                            revert with 0, 17
                                        if not balanceOf[stor19[idx]]:
                                            revert with 0, 18
                                        if 10000 * balanceOf[stor19[idx]] / balanceOf[stor19[idx]] != 10000:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _18267 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18267] = 26
                                        mem[_18267 + 32] = 'SafeMath: division by zero'
                                        if not 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                            _18949 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _18949 + 68] = mem[idx + _18267 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_18949 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _18949 + -mem[64] + 100
                                        if 10000 * balanceOf[stor19[idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                            _21226 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_21226] = 26
                                            mem[_21226 + 32] = 'SafeMath: division by zero'
                                            mem[mem[64] + 4] = stor19[idx]
                                            mem[mem[64] + 36] = 0
                                            require ext_code.size(dogeAddress)
                                            call dogeAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args stor19[idx], 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _22980 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_22980] == bool(mem[_22980])
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        t = 10000 * balanceOf[stor19[idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s
                                        u = stor19[idx]
                                        continue 
                                    mem[0] = msg.sender
                                    mem[32] = 14
                                    if stor14[address(msg.sender)]:
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not arg1:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        _16988 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_16988] = 38
                                        mem[_16988 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                        if arg2 > balanceOf[address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 38
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_16988 + 70 len 26]
                                            var78001 = 64
                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                        if balanceOf[address(msg.sender)] < arg2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2
                                        if balanceOf[arg1] > !arg2:
                                            revert with 0, 17
                                        if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                        emit Transfer(arg2, msg.sender, arg1);
                                    else:
                                        mem[0] = arg1
                                        mem[32] = 14
                                        if stor14[address(arg1)]:
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not arg1:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            _17297 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_17297] = 38
                                            mem[_17297 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                            if arg2 > balanceOf[address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 38
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17297 + 70 len 26]
                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                            if balanceOf[address(msg.sender)] < arg2:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2
                                            if balanceOf[arg1] > !arg2:
                                                revert with 0, 17
                                            if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                            emit Transfer(arg2, msg.sender, arg1);
                                        else:
                                            if stor10:
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not arg1:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _16991 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_16991] = 38
                                                mem[_16991 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if arg2 > balanceOf[address(msg.sender)]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_16991 + 70 len 26]
                                                    var78001 = 64
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(msg.sender)] < arg2:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= arg2
                                                if balanceOf[arg1] > !arg2:
                                                    revert with 0, 17
                                                if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                emit Transfer(arg2, msg.sender, arg1);
                                            else:
                                                _16524 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_16524] = 26
                                                mem[_16524 + 32] = 'SafeMath: division by zero'
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not stor13:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _18945 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_18945] = 38
                                                mem[_18945 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_18945 + 70 len 26]
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(msg.sender)] < arg2 / 100:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= arg2 / 100
                                                if balanceOf[stor13] > !(arg2 / 100):
                                                    revert with 0, 17
                                                if balanceOf[stor13] + (arg2 / 100) < balanceOf[stor13]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = stor13
                                                mem[32] = 1
                                                balanceOf[stor13] += arg2 / 100
                                                emit Transfer((arg2 / 100), msg.sender, stor13);
                                                _22614 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_22614] = 26
                                                mem[_22614 + 32] = 'SafeMath: division by zero'
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not sub_8230af5aAddress:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _23461 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_23461] = 38
                                                mem[_23461 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_23461 + 70 len 26]
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(msg.sender)] < arg2 / 100:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= arg2 / 100
                                                if balanceOf[stor9] > !(arg2 / 100):
                                                    revert with 0, 17
                                                if balanceOf[stor9] + (arg2 / 100) < balanceOf[stor9]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = sub_8230af5aAddress
                                                mem[32] = 1
                                                balanceOf[stor9] += arg2 / 100
                                                emit Transfer((arg2 / 100), msg.sender, sub_8230af5aAddress);
                                                _24317 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_24317] = 26
                                                mem[_24317 + 32] = 'SafeMath: division by zero'
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not uniswapV2PairAddress:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _24525 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_24525] = 38
                                                mem[_24525 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_24525 + 70 len 26]
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(msg.sender)] < arg2 / 100:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= arg2 / 100
                                                if balanceOf[stor7] > !(arg2 / 100):
                                                    revert with 0, 17
                                                if balanceOf[stor7] + (arg2 / 100) < balanceOf[stor7]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = uniswapV2PairAddress
                                                mem[32] = 1
                                                balanceOf[stor7] += arg2 / 100
                                                emit Transfer((arg2 / 100), msg.sender, uniswapV2PairAddress);
                                                _25305 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_25305] = 26
                                                mem[_25305 + 32] = 'SafeMath: division by zero'
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not this.address:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _25513 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_25513] = 38
                                                mem[_25513 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if arg2 / 10 > balanceOf[address(msg.sender)]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_25513 + 70 len 26]
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(msg.sender)] < arg2 / 10:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= arg2 / 10
                                                if balanceOf[this.address] > !(arg2 / 10):
                                                    revert with 0, 17
                                                if balanceOf[this.address] + (arg2 / 10) < balanceOf[this.address]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = this.address
                                                mem[32] = 1
                                                balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 10)
                                                emit Transfer((arg2 / 10), msg.sender, this.address);
                                                _26293 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_26293] = 26
                                                mem[_26293 + 32] = 'SafeMath: division by zero'
                                                if not arg2 / 100:
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not arg1:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _26524 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_26524] = 38
                                                    mem[_26524 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if 0 > balanceOf[address(msg.sender)]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_26524 + 70 len 26]
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(msg.sender)] < 0:
                                                        revert with 0, 17
                                                    if balanceOf[arg1] > -1:
                                                        revert with 0, 17
                                                    if balanceOf[arg1] < balanceOf[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(arg1)] = balanceOf[arg1]
                                                    emit Transfer(0, msg.sender, arg1);
                                                else:
                                                    if arg2 / 100 and 87 > -1 / arg2 / 100:
                                                        revert with 0, 17
                                                    if not arg2 / 100:
                                                        revert with 0, 18
                                                    if 87 * arg2 / 100 / arg2 / 100 != 87:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not arg1:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _27105 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_27105] = 38
                                                    mem[_27105 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if 87 * arg2 / 100 > balanceOf[address(msg.sender)]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_27105 + 70 len 26]
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(msg.sender)] < 87 * arg2 / 100:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] += -87 * arg2 / 100
                                                    if balanceOf[arg1] > !(87 * arg2 / 100):
                                                        revert with 0, 17
                                                    if balanceOf[arg1] + (87 * arg2 / 100) < balanceOf[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(arg1)] = balanceOf[arg1] + (87 * arg2 / 100)
                                                    emit Transfer((87 * arg2 / 100), msg.sender, arg1);
                                else:
                                    idx = 0
                                    t = 0
                                    u = 1440
                                    while idx < 9:
                                        if block.timestamp % stor19.length - 9 > !idx:
                                            revert with 0, 17
                                        if (block.timestamp % stor19.length - 9) + idx >= stor19.length:
                                            revert with 0, 50
                                        mem[0] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                        mem[32] = 1
                                        if balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] < 10000000000 * 10^18:
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            t = t
                                            u = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                            continue 
                                        mem[0] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                        mem[32] = 1
                                        if not balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]]:
                                            _17706 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_17706] = 26
                                            mem[_17706 + 32] = 'SafeMath: division by zero'
                                            if not 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                _18002 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _18002 + 68] = mem[idx + _17706 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_18002 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _18002 + -mem[64] + 100
                                            if 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                _20862 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_20862] = 26
                                                mem[_20862 + 32] = 'SafeMath: division by zero'
                                                mem[mem[64] + 4] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                                mem[mem[64] + 36] = 0
                                                require ext_code.size(dogeAddress)
                                                call dogeAddress.0xa9059cbb with:
                                                     gas gas_remaining wei
                                                    args stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx], 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _22732 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_22732] == bool(mem[_22732])
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            t = 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s
                                            u = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                            continue 
                                        if balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] and 10000 > -1 / balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]]:
                                            revert with 0, 17
                                        if not balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]]:
                                            revert with 0, 18
                                        if 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] != 10000:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _19230 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19230] = 26
                                        mem[_19230 + 32] = 'SafeMath: division by zero'
                                        if not 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                            _19533 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _19533 + 68] = mem[idx + _19230 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_19533 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _19533 + -mem[64] + 100
                                        if 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                            _22102 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_22102] = 26
                                            mem[_22102 + 32] = 'SafeMath: division by zero'
                                            mem[mem[64] + 4] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                            mem[mem[64] + 36] = 0
                                            require ext_code.size(dogeAddress)
                                            call dogeAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx], 0
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _23164 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 32
                                            require mem[_23164] == bool(mem[_23164])
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        t = 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s
                                        u = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                        continue 
                                    mem[0] = msg.sender
                                    mem[32] = 14
                                    if stor14[address(msg.sender)]:
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not arg1:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        _16996 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_16996] = 38
                                        mem[_16996 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                        if arg2 > balanceOf[address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 38
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_16996 + 70 len 26]
                                            var78001 = 64
                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                        if balanceOf[address(msg.sender)] < arg2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2
                                        if balanceOf[arg1] > !arg2:
                                            revert with 0, 17
                                        if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                        emit Transfer(arg2, msg.sender, arg1);
                                    else:
                                        mem[0] = arg1
                                        mem[32] = 14
                                        if stor14[address(arg1)]:
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not arg1:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            _17302 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_17302] = 38
                                            mem[_17302 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                            if arg2 > balanceOf[address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 38
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17302 + 70 len 26]
                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                            if balanceOf[address(msg.sender)] < arg2:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2
                                            if balanceOf[arg1] > !arg2:
                                                revert with 0, 17
                                            if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                            emit Transfer(arg2, msg.sender, arg1);
                                        else:
                                            if stor10:
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not arg1:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _16999 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_16999] = 38
                                                mem[_16999 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if arg2 > balanceOf[address(msg.sender)]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_16999 + 70 len 26]
                                                    var78001 = 64
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(msg.sender)] < arg2:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= arg2
                                                if balanceOf[arg1] > !arg2:
                                                    revert with 0, 17
                                                if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                emit Transfer(arg2, msg.sender, arg1);
                                            else:
                                                _16525 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_16525] = 26
                                                mem[_16525 + 32] = 'SafeMath: division by zero'
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not stor13:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _18953 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_18953] = 38
                                                mem[_18953 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_18953 + 70 len 26]
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(msg.sender)] < arg2 / 100:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= arg2 / 100
                                                if balanceOf[stor13] > !(arg2 / 100):
                                                    revert with 0, 17
                                                if balanceOf[stor13] + (arg2 / 100) < balanceOf[stor13]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = stor13
                                                mem[32] = 1
                                                balanceOf[stor13] += arg2 / 100
                                                emit Transfer((arg2 / 100), msg.sender, stor13);
                                                _22617 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_22617] = 26
                                                mem[_22617 + 32] = 'SafeMath: division by zero'
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not sub_8230af5aAddress:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _23464 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_23464] = 38
                                                mem[_23464 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_23464 + 70 len 26]
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(msg.sender)] < arg2 / 100:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= arg2 / 100
                                                if balanceOf[stor9] > !(arg2 / 100):
                                                    revert with 0, 17
                                                if balanceOf[stor9] + (arg2 / 100) < balanceOf[stor9]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = sub_8230af5aAddress
                                                mem[32] = 1
                                                balanceOf[stor9] += arg2 / 100
                                                emit Transfer((arg2 / 100), msg.sender, sub_8230af5aAddress);
                                                _24318 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_24318] = 26
                                                mem[_24318 + 32] = 'SafeMath: division by zero'
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not uniswapV2PairAddress:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _24528 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_24528] = 38
                                                mem[_24528 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_24528 + 70 len 26]
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(msg.sender)] < arg2 / 100:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= arg2 / 100
                                                if balanceOf[stor7] > !(arg2 / 100):
                                                    revert with 0, 17
                                                if balanceOf[stor7] + (arg2 / 100) < balanceOf[stor7]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = uniswapV2PairAddress
                                                mem[32] = 1
                                                balanceOf[stor7] += arg2 / 100
                                                emit Transfer((arg2 / 100), msg.sender, uniswapV2PairAddress);
                                                _25306 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_25306] = 26
                                                mem[_25306 + 32] = 'SafeMath: division by zero'
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not this.address:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _25516 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_25516] = 38
                                                mem[_25516 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if arg2 / 10 > balanceOf[address(msg.sender)]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_25516 + 70 len 26]
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(msg.sender)] < arg2 / 10:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= arg2 / 10
                                                if balanceOf[this.address] > !(arg2 / 10):
                                                    revert with 0, 17
                                                if balanceOf[this.address] + (arg2 / 10) < balanceOf[this.address]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = this.address
                                                mem[32] = 1
                                                balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 10)
                                                emit Transfer((arg2 / 10), msg.sender, this.address);
                                                _26294 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_26294] = 26
                                                mem[_26294 + 32] = 'SafeMath: division by zero'
                                                if not arg2 / 100:
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not arg1:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _26528 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_26528] = 38
                                                    mem[_26528 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if 0 > balanceOf[address(msg.sender)]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_26528 + 70 len 26]
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(msg.sender)] < 0:
                                                        revert with 0, 17
                                                    if balanceOf[arg1] > -1:
                                                        revert with 0, 17
                                                    if balanceOf[arg1] < balanceOf[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(arg1)] = balanceOf[arg1]
                                                    emit Transfer(0, msg.sender, arg1);
                                                else:
                                                    if arg2 / 100 and 87 > -1 / arg2 / 100:
                                                        revert with 0, 17
                                                    if not arg2 / 100:
                                                        revert with 0, 18
                                                    if 87 * arg2 / 100 / arg2 / 100 != 87:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not arg1:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _27110 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_27110] = 38
                                                    mem[_27110 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if 87 * arg2 / 100 > balanceOf[address(msg.sender)]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_27110 + 70 len 26]
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(msg.sender)] < 87 * arg2 / 100:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] += -87 * arg2 / 100
                                                    if balanceOf[arg1] > !(87 * arg2 / 100):
                                                        revert with 0, 17
                                                    if balanceOf[arg1] + (87 * arg2 / 100) < balanceOf[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(arg1)] = balanceOf[arg1] + (87 * arg2 / 100)
                                                    emit Transfer((87 * arg2 / 100), msg.sender, arg1);
                    else:
                        if ext_call.return_data[0] and 4 > -1 / ext_call.return_data[0]:
                            revert with 0, 17
                        if not ext_call.return_data[0]:
                            revert with 0, 18
                        if 4 * ext_call.return_data[0] / ext_call.return_data[0] != 4:
                            revert with 0, 'SafeMath: multiplication overflow'
                        mem[64] = ceil32(return_data.size) + 160
                        mem[ceil32(return_data.size) + 96] = 26
                        mem[ceil32(return_data.size) + 128] = 'SafeMath: division by zero'
                        if not stor19.length:
                            if not msg.sender:
                                revert with 0, 'ERC20: transfer from the zero address'
                            if stor14[address(msg.sender)]:
                                if not arg1:
                                    revert with 0, 'ERC20: transfer to the zero address'
                                if arg2 > balanceOf[address(msg.sender)]:
                                    revert with 0, 
                                                32,
                                                38,
                                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 230 len 26] >> 48,
                                                0
                                if balanceOf[address(msg.sender)] < arg2:
                                    revert with 0, 17
                                balanceOf[address(msg.sender)] -= arg2
                                if balanceOf[arg1] > !arg2:
                                    revert with 0, 17
                                if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                emit Transfer(arg2, msg.sender, arg1);
                            else:
                                if stor14[address(arg1)]:
                                    if not arg1:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    if arg2 > balanceOf[address(msg.sender)]:
                                        revert with 0, 
                                                    32,
                                                    38,
                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 230 len 26] >> 48,
                                                    0
                                    if balanceOf[address(msg.sender)] < arg2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)] -= arg2
                                    if balanceOf[arg1] > !arg2:
                                        revert with 0, 17
                                    if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                    emit Transfer(arg2, msg.sender, arg1);
                                else:
                                    if stor10:
                                        if not arg1:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        if arg2 > balanceOf[address(msg.sender)]:
                                            revert with 0, 
                                                        32,
                                                        38,
                                                        0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 230 len 26] >> 48,
                                                        0
                                        if balanceOf[address(msg.sender)] < arg2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2
                                        if balanceOf[arg1] > !arg2:
                                            revert with 0, 17
                                        if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                        emit Transfer(arg2, msg.sender, arg1);
                                    else:
                                        if not stor13:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        if arg2 / 100 > balanceOf[address(msg.sender)]:
                                            revert with 0, 
                                                        32,
                                                        38,
                                                        0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 294 len 26] >> 48,
                                                        0
                                        if balanceOf[address(msg.sender)] < arg2 / 100:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2 / 100
                                        if balanceOf[stor13] > !(arg2 / 100):
                                            revert with 0, 17
                                        if balanceOf[stor13] + (arg2 / 100) < balanceOf[stor13]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[stor13] += arg2 / 100
                                        emit Transfer((arg2 / 100), msg.sender, stor13);
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not sub_8230af5aAddress:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        if arg2 / 100 > balanceOf[address(msg.sender)]:
                                            revert with 0, 
                                                        32,
                                                        38,
                                                        0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 454 len 26] >> 48,
                                                        0
                                        if balanceOf[address(msg.sender)] < arg2 / 100:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2 / 100
                                        if balanceOf[stor9] > !(arg2 / 100):
                                            revert with 0, 17
                                        if balanceOf[stor9] + (arg2 / 100) < balanceOf[stor9]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[stor9] += arg2 / 100
                                        emit Transfer((arg2 / 100), msg.sender, sub_8230af5aAddress);
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not uniswapV2PairAddress:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        if arg2 / 100 > balanceOf[address(msg.sender)]:
                                            revert with 0, 
                                                        32,
                                                        38,
                                                        0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 614 len 26] >> 48,
                                                        0
                                        if balanceOf[address(msg.sender)] < arg2 / 100:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2 / 100
                                        if balanceOf[stor7] > !(arg2 / 100):
                                            revert with 0, 17
                                        if balanceOf[stor7] + (arg2 / 100) < balanceOf[stor7]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[stor7] += arg2 / 100
                                        emit Transfer((arg2 / 100), msg.sender, uniswapV2PairAddress);
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not this.address:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        if arg2 / 10 > balanceOf[address(msg.sender)]:
                                            revert with 0, 
                                                        32,
                                                        38,
                                                        0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 774 len 26] >> 48,
                                                        0
                                        if balanceOf[address(msg.sender)] < arg2 / 10:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2 / 10
                                        if balanceOf[this.address] > !(arg2 / 10):
                                            revert with 0, 17
                                        if balanceOf[this.address] + (arg2 / 10) < balanceOf[this.address]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 10)
                                        emit Transfer((arg2 / 10), msg.sender, this.address);
                                        if not arg2 / 100:
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not arg1:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            if 0 > balanceOf[address(msg.sender)]:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 934 len 26] >> 48,
                                                            0
                                            if balanceOf[address(msg.sender)] < 0:
                                                revert with 0, 17
                                            if balanceOf[arg1] > -1:
                                                revert with 0, 17
                                            if balanceOf[arg1] < balanceOf[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(arg1)] = balanceOf[arg1]
                                            emit Transfer(0, msg.sender, arg1);
                                        else:
                                            if arg2 / 100 and 87 > -1 / arg2 / 100:
                                                revert with 0, 17
                                            if not arg2 / 100:
                                                revert with 0, 18
                                            if 87 * arg2 / 100 / arg2 / 100 != 87:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not arg1:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            if 87 * arg2 / 100 > balanceOf[address(msg.sender)]:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 934 len 26] >> 48,
                                                            0
                                            if balanceOf[address(msg.sender)] < 87 * arg2 / 100:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] += -87 * arg2 / 100
                                            if balanceOf[arg1] > !(87 * arg2 / 100):
                                                revert with 0, 17
                                            if balanceOf[arg1] + (87 * arg2 / 100) < balanceOf[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(arg1)] = balanceOf[arg1] + (87 * arg2 / 100)
                                            emit Transfer((87 * arg2 / 100), msg.sender, arg1);
                        else:
                            if stor19.length <= 9:
                                idx = 0
                                s = 0
                                t = 0
                                while idx < stor19.length:
                                    mem[0] = stor19[idx]
                                    mem[32] = 1
                                    if s > !balanceOf[stor19[idx]]:
                                        revert with 0, 17
                                    if s + balanceOf[stor19[idx]] < s:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + balanceOf[stor19[idx]]
                                    t = stor19[idx]
                                    continue 
                                if stor19.length <= 9:
                                    idx = 0
                                    t = 0
                                    u = 160 * stor19.length
                                    while idx < stor19.length:
                                        mem[0] = stor19[idx]
                                        mem[32] = 1
                                        if balanceOf[stor19[idx]] < 10000000000 * 10^18:
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            t = t
                                            u = stor19[idx]
                                            continue 
                                        mem[0] = stor19[idx]
                                        mem[32] = 1
                                        if not balanceOf[stor19[idx]]:
                                            _16950 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_16950] = 26
                                            mem[_16950 + 32] = 'SafeMath: division by zero'
                                            if not s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                _17494 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _17494 + 68] = mem[idx + _16950 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_17494 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _17494 + -mem[64] + 100
                                            if 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                if not 4 * ext_call.return_data[0] / 5:
                                                    _20190 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_20190] = 26
                                                    mem[_20190 + 32] = 'SafeMath: division by zero'
                                                    mem[mem[64] + 4] = stor19[idx]
                                                    mem[mem[64] + 36] = 0
                                                    require ext_code.size(dogeAddress)
                                                    call dogeAddress.0xa9059cbb with:
                                                         gas gas_remaining wei
                                                        args stor19[idx], 0
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _22051 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_22051] == bool(mem[_22051])
                                                else:
                                                    if 4 * ext_call.return_data[0] / 5 and 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length > -1 / 4 * ext_call.return_data[0] / 5:
                                                        revert with 0, 17
                                                    if not 4 * ext_call.return_data[0] / 5:
                                                        revert with 0, 18
                                                    if 4 * ext_call.return_data[0] / 5 * 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 4 * ext_call.return_data[0] / 5 != 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _21210 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_21210] = 26
                                                    mem[_21210 + 32] = 'SafeMath: division by zero'
                                                    mem[mem[64] + 4] = stor19[idx]
                                                    mem[mem[64] + 36] = 4 * ext_call.return_data[0] / 5 * 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 10000
                                                    require ext_code.size(dogeAddress)
                                                    call dogeAddress.0xa9059cbb with:
                                                         gas gas_remaining wei
                                                        args stor19[idx], 4 * ext_call.return_data[0] / 5 * 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 10000
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _22974 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_22974] == bool(mem[_22974])
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            t = 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length
                                            u = stor19[idx]
                                            continue 
                                        if balanceOf[stor19[idx]] and 10000 > -1 / balanceOf[stor19[idx]]:
                                            revert with 0, 17
                                        if not balanceOf[stor19[idx]]:
                                            revert with 0, 18
                                        if 10000 * balanceOf[stor19[idx]] / balanceOf[stor19[idx]] != 10000:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _18225 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18225] = 26
                                        mem[_18225 + 32] = 'SafeMath: division by zero'
                                        if not s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                            _18901 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _18901 + 68] = mem[idx + _18225 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_18901 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _18901 + -mem[64] + 100
                                        if 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                            if not 4 * ext_call.return_data[0] / 5:
                                                _21209 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_21209] = 26
                                                mem[_21209 + 32] = 'SafeMath: division by zero'
                                                mem[mem[64] + 4] = stor19[idx]
                                                mem[mem[64] + 36] = 0
                                                require ext_code.size(dogeAddress)
                                                call dogeAddress.0xa9059cbb with:
                                                     gas gas_remaining wei
                                                    args stor19[idx], 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _22973 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_22973] == bool(mem[_22973])
                                            else:
                                                if 4 * ext_call.return_data[0] / 5 and 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length > -1 / 4 * ext_call.return_data[0] / 5:
                                                    revert with 0, 17
                                                if not 4 * ext_call.return_data[0] / 5:
                                                    revert with 0, 18
                                                if 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 4 * ext_call.return_data[0] / 5 != 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _22727 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_22727] = 26
                                                mem[_22727 + 32] = 'SafeMath: division by zero'
                                                mem[mem[64] + 4] = stor19[idx]
                                                mem[mem[64] + 36] = 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 10000
                                                require ext_code.size(dogeAddress)
                                                call dogeAddress.0xa9059cbb with:
                                                     gas gas_remaining wei
                                                    args stor19[idx], 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 10000
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _23338 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_23338] == bool(mem[_23338])
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        t = 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length
                                        u = stor19[idx]
                                        continue 
                                    mem[0] = msg.sender
                                    mem[32] = 14
                                    if stor14[address(msg.sender)]:
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not arg1:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        _16943 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_16943] = 38
                                        mem[_16943 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                        if arg2 > balanceOf[address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 38
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_16943 + 70 len 26]
                                            var73001 = 64
                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                        if balanceOf[address(msg.sender)] < arg2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2
                                        if balanceOf[arg1] > !arg2:
                                            revert with 0, 17
                                        if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                        emit Transfer(arg2, msg.sender, arg1);
                                    else:
                                        mem[0] = arg1
                                        mem[32] = 14
                                        if stor14[address(arg1)]:
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not arg1:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            _17267 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_17267] = 38
                                            mem[_17267 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                            if arg2 > balanceOf[address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 38
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17267 + 70 len 26]
                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                            if balanceOf[address(msg.sender)] < arg2:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2
                                            if balanceOf[arg1] > !arg2:
                                                revert with 0, 17
                                            if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                            emit Transfer(arg2, msg.sender, arg1);
                                        else:
                                            if stor10:
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not arg1:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _16946 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_16946] = 38
                                                mem[_16946 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if arg2 > balanceOf[address(msg.sender)]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_16946 + 70 len 26]
                                                    var73001 = 64
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(msg.sender)] < arg2:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= arg2
                                                if balanceOf[arg1] > !arg2:
                                                    revert with 0, 17
                                                if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                emit Transfer(arg2, msg.sender, arg1);
                                            else:
                                                _16515 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_16515] = 26
                                                mem[_16515 + 32] = 'SafeMath: division by zero'
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not stor13:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _18897 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_18897] = 38
                                                mem[_18897 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_18897 + 70 len 26]
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(msg.sender)] < arg2 / 100:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= arg2 / 100
                                                if balanceOf[stor13] > !(arg2 / 100):
                                                    revert with 0, 17
                                                if balanceOf[stor13] + (arg2 / 100) < balanceOf[stor13]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = stor13
                                                mem[32] = 1
                                                balanceOf[stor13] += arg2 / 100
                                                emit Transfer((arg2 / 100), msg.sender, stor13);
                                                _22597 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_22597] = 26
                                                mem[_22597 + 32] = 'SafeMath: division by zero'
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not sub_8230af5aAddress:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _23439 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_23439] = 38
                                                mem[_23439 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_23439 + 70 len 26]
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(msg.sender)] < arg2 / 100:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= arg2 / 100
                                                if balanceOf[stor9] > !(arg2 / 100):
                                                    revert with 0, 17
                                                if balanceOf[stor9] + (arg2 / 100) < balanceOf[stor9]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = sub_8230af5aAddress
                                                mem[32] = 1
                                                balanceOf[stor9] += arg2 / 100
                                                emit Transfer((arg2 / 100), msg.sender, sub_8230af5aAddress);
                                                _24311 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_24311] = 26
                                                mem[_24311 + 32] = 'SafeMath: division by zero'
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not uniswapV2PairAddress:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _24507 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_24507] = 38
                                                mem[_24507 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_24507 + 70 len 26]
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(msg.sender)] < arg2 / 100:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= arg2 / 100
                                                if balanceOf[stor7] > !(arg2 / 100):
                                                    revert with 0, 17
                                                if balanceOf[stor7] + (arg2 / 100) < balanceOf[stor7]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = uniswapV2PairAddress
                                                mem[32] = 1
                                                balanceOf[stor7] += arg2 / 100
                                                emit Transfer((arg2 / 100), msg.sender, uniswapV2PairAddress);
                                                _25299 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_25299] = 26
                                                mem[_25299 + 32] = 'SafeMath: division by zero'
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not this.address:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _25495 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_25495] = 38
                                                mem[_25495 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if arg2 / 10 > balanceOf[address(msg.sender)]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_25495 + 70 len 26]
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(msg.sender)] < arg2 / 10:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= arg2 / 10
                                                if balanceOf[this.address] > !(arg2 / 10):
                                                    revert with 0, 17
                                                if balanceOf[this.address] + (arg2 / 10) < balanceOf[this.address]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = this.address
                                                mem[32] = 1
                                                balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 10)
                                                emit Transfer((arg2 / 10), msg.sender, this.address);
                                                _26287 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_26287] = 26
                                                mem[_26287 + 32] = 'SafeMath: division by zero'
                                                if not arg2 / 100:
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not arg1:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _26500 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_26500] = 38
                                                    mem[_26500 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if 0 > balanceOf[address(msg.sender)]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_26500 + 70 len 26]
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(msg.sender)] < 0:
                                                        revert with 0, 17
                                                    if balanceOf[arg1] > -1:
                                                        revert with 0, 17
                                                    if balanceOf[arg1] < balanceOf[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(arg1)] = balanceOf[arg1]
                                                    emit Transfer(0, msg.sender, arg1);
                                                else:
                                                    if arg2 / 100 and 87 > -1 / arg2 / 100:
                                                        revert with 0, 17
                                                    if not arg2 / 100:
                                                        revert with 0, 18
                                                    if 87 * arg2 / 100 / arg2 / 100 != 87:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not arg1:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _27075 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_27075] = 38
                                                    mem[_27075 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if 87 * arg2 / 100 > balanceOf[address(msg.sender)]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_27075 + 70 len 26]
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(msg.sender)] < 87 * arg2 / 100:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] += -87 * arg2 / 100
                                                    if balanceOf[arg1] > !(87 * arg2 / 100):
                                                        revert with 0, 17
                                                    if balanceOf[arg1] + (87 * arg2 / 100) < balanceOf[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(arg1)] = balanceOf[arg1] + (87 * arg2 / 100)
                                                    emit Transfer((87 * arg2 / 100), msg.sender, arg1);
                                else:
                                    idx = 0
                                    t = 0
                                    u = 160 * stor19.length
                                    while idx < 9:
                                        if 0 > !idx:
                                            revert with 0, 17
                                        if idx >= stor19.length:
                                            revert with 0, 50
                                        mem[0] = stor19[idx]
                                        mem[32] = 1
                                        if balanceOf[stor19[idx]] < 10000000000 * 10^18:
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            t = t
                                            u = stor19[idx]
                                            continue 
                                        mem[0] = stor19[idx]
                                        mem[32] = 1
                                        if not balanceOf[stor19[idx]]:
                                            _17682 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_17682] = 26
                                            mem[_17682 + 32] = 'SafeMath: division by zero'
                                            if not s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                _17981 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _17981 + 68] = mem[idx + _17682 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_17981 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _17981 + -mem[64] + 100
                                            if 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                if not 4 * ext_call.return_data[0] / 5:
                                                    _20844 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_20844] = 26
                                                    mem[_20844 + 32] = 'SafeMath: division by zero'
                                                    mem[mem[64] + 4] = stor19[idx]
                                                    mem[mem[64] + 36] = 0
                                                    require ext_code.size(dogeAddress)
                                                    call dogeAddress.0xa9059cbb with:
                                                         gas gas_remaining wei
                                                        args stor19[idx], 0
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _22728 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_22728] == bool(mem[_22728])
                                                else:
                                                    if 4 * ext_call.return_data[0] / 5 and 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length > -1 / 4 * ext_call.return_data[0] / 5:
                                                        revert with 0, 17
                                                    if not 4 * ext_call.return_data[0] / 5:
                                                        revert with 0, 18
                                                    if 4 * ext_call.return_data[0] / 5 * 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 4 * ext_call.return_data[0] / 5 != 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _22059 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_22059] = 26
                                                    mem[_22059 + 32] = 'SafeMath: division by zero'
                                                    mem[mem[64] + 4] = stor19[idx]
                                                    mem[mem[64] + 36] = 4 * ext_call.return_data[0] / 5 * 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 10000
                                                    require ext_code.size(dogeAddress)
                                                    call dogeAddress.0xa9059cbb with:
                                                         gas gas_remaining wei
                                                        args stor19[idx], 4 * ext_call.return_data[0] / 5 * 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 10000
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _23160 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_23160] == bool(mem[_23160])
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            t = 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length
                                            u = stor19[idx]
                                            continue 
                                        if balanceOf[stor19[idx]] and 10000 > -1 / balanceOf[stor19[idx]]:
                                            revert with 0, 17
                                        if not balanceOf[stor19[idx]]:
                                            revert with 0, 18
                                        if 10000 * balanceOf[stor19[idx]] / balanceOf[stor19[idx]] != 10000:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _19212 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19212] = 26
                                        mem[_19212 + 32] = 'SafeMath: division by zero'
                                        if not s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                            _19506 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _19506 + 68] = mem[idx + _19212 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_19506 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _19506 + -mem[64] + 100
                                        if 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                            if not 4 * ext_call.return_data[0] / 5:
                                                _22058 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_22058] = 26
                                                mem[_22058 + 32] = 'SafeMath: division by zero'
                                                mem[mem[64] + 4] = stor19[idx]
                                                mem[mem[64] + 36] = 0
                                                require ext_code.size(dogeAddress)
                                                call dogeAddress.0xa9059cbb with:
                                                     gas gas_remaining wei
                                                    args stor19[idx], 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _23159 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_23159] == bool(mem[_23159])
                                            else:
                                                if 4 * ext_call.return_data[0] / 5 and 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length > -1 / 4 * ext_call.return_data[0] / 5:
                                                    revert with 0, 17
                                                if not 4 * ext_call.return_data[0] / 5:
                                                    revert with 0, 18
                                                if 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 4 * ext_call.return_data[0] / 5 != 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _22975 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_22975] = 26
                                                mem[_22975 + 32] = 'SafeMath: division by zero'
                                                mem[mem[64] + 4] = stor19[idx]
                                                mem[mem[64] + 36] = 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 10000
                                                require ext_code.size(dogeAddress)
                                                call dogeAddress.0xa9059cbb with:
                                                     gas gas_remaining wei
                                                    args stor19[idx], 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 10000
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _23643 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_23643] == bool(mem[_23643])
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        t = 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length
                                        u = stor19[idx]
                                        continue 
                                    mem[0] = msg.sender
                                    mem[32] = 14
                                    if stor14[address(msg.sender)]:
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not arg1:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        _16951 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_16951] = 38
                                        mem[_16951 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                        if arg2 > balanceOf[address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 38
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_16951 + 70 len 26]
                                            var73001 = 64
                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                        if balanceOf[address(msg.sender)] < arg2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2
                                        if balanceOf[arg1] > !arg2:
                                            revert with 0, 17
                                        if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                        emit Transfer(arg2, msg.sender, arg1);
                                    else:
                                        mem[0] = arg1
                                        mem[32] = 14
                                        if stor14[address(arg1)]:
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not arg1:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            _17272 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_17272] = 38
                                            mem[_17272 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                            if arg2 > balanceOf[address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 38
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17272 + 70 len 26]
                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                            if balanceOf[address(msg.sender)] < arg2:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2
                                            if balanceOf[arg1] > !arg2:
                                                revert with 0, 17
                                            if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                            emit Transfer(arg2, msg.sender, arg1);
                                        else:
                                            if stor10:
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not arg1:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _16954 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_16954] = 38
                                                mem[_16954 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if arg2 > balanceOf[address(msg.sender)]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_16954 + 70 len 26]
                                                    var73001 = 64
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(msg.sender)] < arg2:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= arg2
                                                if balanceOf[arg1] > !arg2:
                                                    revert with 0, 17
                                                if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                emit Transfer(arg2, msg.sender, arg1);
                                            else:
                                                _16516 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_16516] = 26
                                                mem[_16516 + 32] = 'SafeMath: division by zero'
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not stor13:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _18905 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_18905] = 38
                                                mem[_18905 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_18905 + 70 len 26]
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(msg.sender)] < arg2 / 100:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= arg2 / 100
                                                if balanceOf[stor13] > !(arg2 / 100):
                                                    revert with 0, 17
                                                if balanceOf[stor13] + (arg2 / 100) < balanceOf[stor13]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = stor13
                                                mem[32] = 1
                                                balanceOf[stor13] += arg2 / 100
                                                emit Transfer((arg2 / 100), msg.sender, stor13);
                                                _22601 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_22601] = 26
                                                mem[_22601 + 32] = 'SafeMath: division by zero'
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not sub_8230af5aAddress:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _23442 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_23442] = 38
                                                mem[_23442 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_23442 + 70 len 26]
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(msg.sender)] < arg2 / 100:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= arg2 / 100
                                                if balanceOf[stor9] > !(arg2 / 100):
                                                    revert with 0, 17
                                                if balanceOf[stor9] + (arg2 / 100) < balanceOf[stor9]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = sub_8230af5aAddress
                                                mem[32] = 1
                                                balanceOf[stor9] += arg2 / 100
                                                emit Transfer((arg2 / 100), msg.sender, sub_8230af5aAddress);
                                                _24312 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_24312] = 26
                                                mem[_24312 + 32] = 'SafeMath: division by zero'
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not uniswapV2PairAddress:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _24510 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_24510] = 38
                                                mem[_24510 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_24510 + 70 len 26]
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(msg.sender)] < arg2 / 100:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= arg2 / 100
                                                if balanceOf[stor7] > !(arg2 / 100):
                                                    revert with 0, 17
                                                if balanceOf[stor7] + (arg2 / 100) < balanceOf[stor7]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = uniswapV2PairAddress
                                                mem[32] = 1
                                                balanceOf[stor7] += arg2 / 100
                                                emit Transfer((arg2 / 100), msg.sender, uniswapV2PairAddress);
                                                _25300 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_25300] = 26
                                                mem[_25300 + 32] = 'SafeMath: division by zero'
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not this.address:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _25498 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_25498] = 38
                                                mem[_25498 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if arg2 / 10 > balanceOf[address(msg.sender)]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_25498 + 70 len 26]
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(msg.sender)] < arg2 / 10:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= arg2 / 10
                                                if balanceOf[this.address] > !(arg2 / 10):
                                                    revert with 0, 17
                                                if balanceOf[this.address] + (arg2 / 10) < balanceOf[this.address]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = this.address
                                                mem[32] = 1
                                                balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 10)
                                                emit Transfer((arg2 / 10), msg.sender, this.address);
                                                _26288 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_26288] = 26
                                                mem[_26288 + 32] = 'SafeMath: division by zero'
                                                if not arg2 / 100:
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not arg1:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _26504 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_26504] = 38
                                                    mem[_26504 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if 0 > balanceOf[address(msg.sender)]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_26504 + 70 len 26]
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(msg.sender)] < 0:
                                                        revert with 0, 17
                                                    if balanceOf[arg1] > -1:
                                                        revert with 0, 17
                                                    if balanceOf[arg1] < balanceOf[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(arg1)] = balanceOf[arg1]
                                                    emit Transfer(0, msg.sender, arg1);
                                                else:
                                                    if arg2 / 100 and 87 > -1 / arg2 / 100:
                                                        revert with 0, 17
                                                    if not arg2 / 100:
                                                        revert with 0, 18
                                                    if 87 * arg2 / 100 / arg2 / 100 != 87:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not arg1:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _27080 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_27080] = 38
                                                    mem[_27080 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if 87 * arg2 / 100 > balanceOf[address(msg.sender)]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_27080 + 70 len 26]
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(msg.sender)] < 87 * arg2 / 100:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] += -87 * arg2 / 100
                                                    if balanceOf[arg1] > !(87 * arg2 / 100):
                                                        revert with 0, 17
                                                    if balanceOf[arg1] + (87 * arg2 / 100) < balanceOf[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(arg1)] = balanceOf[arg1] + (87 * arg2 / 100)
                                                    emit Transfer((87 * arg2 / 100), msg.sender, arg1);
                            else:
                                if stor19.length < 9:
                                    revert with 0, 17
                                mem[64] = ceil32(return_data.size) + 224
                                mem[ceil32(return_data.size) + 160] = 24
                                mem[ceil32(return_data.size) + 192] = 'SafeMath: modulo by zero'
                                if not stor19.length - 9:
                                    revert with 0, 'SafeMath: modulo by zero', 0
                                idx = 0
                                s = 0
                                t = 0
                                while idx < 9:
                                    if block.timestamp % stor19.length - 9 > !idx:
                                        revert with 0, 17
                                    if (block.timestamp % stor19.length - 9) + idx >= stor19.length:
                                        revert with 0, 50
                                    mem[0] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                    mem[32] = 1
                                    if s > !balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]]:
                                        revert with 0, 17
                                    if s + balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] < s:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]]
                                    t = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                    continue 
                                if stor19.length <= 9:
                                    idx = 0
                                    t = 0
                                    u = 1440
                                    while idx < stor19.length:
                                        mem[0] = stor19[idx]
                                        mem[32] = 1
                                        if balanceOf[stor19[idx]] < 10000000000 * 10^18:
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            t = t
                                            u = stor19[idx]
                                            continue 
                                        mem[0] = stor19[idx]
                                        mem[32] = 1
                                        if not balanceOf[stor19[idx]]:
                                            _16965 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_16965] = 26
                                            mem[_16965 + 32] = 'SafeMath: division by zero'
                                            if not 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                _17501 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _17501 + 68] = mem[idx + _16965 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_17501 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _17501 + -mem[64] + 100
                                            if 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                if not 4 * ext_call.return_data[0] / 5:
                                                    _20204 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_20204] = 26
                                                    mem[_20204 + 32] = 'SafeMath: division by zero'
                                                    mem[mem[64] + 4] = stor19[idx]
                                                    mem[mem[64] + 36] = 0
                                                    require ext_code.size(dogeAddress)
                                                    call dogeAddress.0xa9059cbb with:
                                                         gas gas_remaining wei
                                                        args stor19[idx], 0
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _22066 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_22066] == bool(mem[_22066])
                                                else:
                                                    if 4 * ext_call.return_data[0] / 5 and 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s > -1 / 4 * ext_call.return_data[0] / 5:
                                                        revert with 0, 17
                                                    if not 4 * ext_call.return_data[0] / 5:
                                                        revert with 0, 18
                                                    if 4 * ext_call.return_data[0] / 5 * 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 4 * ext_call.return_data[0] / 5 != 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _21216 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_21216] = 26
                                                    mem[_21216 + 32] = 'SafeMath: division by zero'
                                                    mem[mem[64] + 4] = stor19[idx]
                                                    mem[mem[64] + 36] = 4 * ext_call.return_data[0] / 5 * 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 10000
                                                    require ext_code.size(dogeAddress)
                                                    call dogeAddress.0xa9059cbb with:
                                                         gas gas_remaining wei
                                                        args stor19[idx], 4 * ext_call.return_data[0] / 5 * 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 10000
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _22977 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_22977] == bool(mem[_22977])
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            t = 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s
                                            u = stor19[idx]
                                            continue 
                                        if balanceOf[stor19[idx]] and 10000 > -1 / balanceOf[stor19[idx]]:
                                            revert with 0, 17
                                        if not balanceOf[stor19[idx]]:
                                            revert with 0, 18
                                        if 10000 * balanceOf[stor19[idx]] / balanceOf[stor19[idx]] != 10000:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _18239 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18239] = 26
                                        mem[_18239 + 32] = 'SafeMath: division by zero'
                                        if not 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                            _18917 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _18917 + 68] = mem[idx + _18239 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_18917 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _18917 + -mem[64] + 100
                                        if 10000 * balanceOf[stor19[idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                            if not 4 * ext_call.return_data[0] / 5:
                                                _21215 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_21215] = 26
                                                mem[_21215 + 32] = 'SafeMath: division by zero'
                                                mem[mem[64] + 4] = stor19[idx]
                                                mem[mem[64] + 36] = 0
                                                require ext_code.size(dogeAddress)
                                                call dogeAddress.0xa9059cbb with:
                                                     gas gas_remaining wei
                                                    args stor19[idx], 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _22976 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_22976] == bool(mem[_22976])
                                            else:
                                                if 4 * ext_call.return_data[0] / 5 and 10000 * balanceOf[stor19[idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s > -1 / 4 * ext_call.return_data[0] / 5:
                                                    revert with 0, 17
                                                if not 4 * ext_call.return_data[0] / 5:
                                                    revert with 0, 18
                                                if 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor19[idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 4 * ext_call.return_data[0] / 5 != 10000 * balanceOf[stor19[idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _22729 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_22729] = 26
                                                mem[_22729 + 32] = 'SafeMath: division by zero'
                                                mem[mem[64] + 4] = stor19[idx]
                                                mem[mem[64] + 36] = 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor19[idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 10000
                                                require ext_code.size(dogeAddress)
                                                call dogeAddress.0xa9059cbb with:
                                                     gas gas_remaining wei
                                                    args stor19[idx], 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor19[idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 10000
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _23341 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_23341] == bool(mem[_23341])
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        t = 10000 * balanceOf[stor19[idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s
                                        u = stor19[idx]
                                        continue 
                                    mem[0] = msg.sender
                                    mem[32] = 14
                                    if stor14[address(msg.sender)]:
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not arg1:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        _16958 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_16958] = 38
                                        mem[_16958 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                        if arg2 > balanceOf[address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 38
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_16958 + 70 len 26]
                                            var84001 = 64
                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                        if balanceOf[address(msg.sender)] < arg2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2
                                        if balanceOf[arg1] > !arg2:
                                            revert with 0, 17
                                        if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                        emit Transfer(arg2, msg.sender, arg1);
                                    else:
                                        mem[0] = arg1
                                        mem[32] = 14
                                        if stor14[address(arg1)]:
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not arg1:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            _17277 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_17277] = 38
                                            mem[_17277 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                            if arg2 > balanceOf[address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 38
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17277 + 70 len 26]
                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                            if balanceOf[address(msg.sender)] < arg2:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2
                                            if balanceOf[arg1] > !arg2:
                                                revert with 0, 17
                                            if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                            emit Transfer(arg2, msg.sender, arg1);
                                        else:
                                            if stor10:
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not arg1:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _16961 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_16961] = 38
                                                mem[_16961 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if arg2 > balanceOf[address(msg.sender)]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_16961 + 70 len 26]
                                                    var84001 = 64
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(msg.sender)] < arg2:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= arg2
                                                if balanceOf[arg1] > !arg2:
                                                    revert with 0, 17
                                                if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                emit Transfer(arg2, msg.sender, arg1);
                                            else:
                                                _16518 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_16518] = 26
                                                mem[_16518 + 32] = 'SafeMath: division by zero'
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not stor13:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _18913 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_18913] = 38
                                                mem[_18913 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_18913 + 70 len 26]
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(msg.sender)] < arg2 / 100:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= arg2 / 100
                                                if balanceOf[stor13] > !(arg2 / 100):
                                                    revert with 0, 17
                                                if balanceOf[stor13] + (arg2 / 100) < balanceOf[stor13]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = stor13
                                                mem[32] = 1
                                                balanceOf[stor13] += arg2 / 100
                                                emit Transfer((arg2 / 100), msg.sender, stor13);
                                                _22603 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_22603] = 26
                                                mem[_22603 + 32] = 'SafeMath: division by zero'
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not sub_8230af5aAddress:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _23447 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_23447] = 38
                                                mem[_23447 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_23447 + 70 len 26]
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(msg.sender)] < arg2 / 100:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= arg2 / 100
                                                if balanceOf[stor9] > !(arg2 / 100):
                                                    revert with 0, 17
                                                if balanceOf[stor9] + (arg2 / 100) < balanceOf[stor9]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = sub_8230af5aAddress
                                                mem[32] = 1
                                                balanceOf[stor9] += arg2 / 100
                                                emit Transfer((arg2 / 100), msg.sender, sub_8230af5aAddress);
                                                _24313 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_24313] = 26
                                                mem[_24313 + 32] = 'SafeMath: division by zero'
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not uniswapV2PairAddress:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _24513 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_24513] = 38
                                                mem[_24513 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_24513 + 70 len 26]
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(msg.sender)] < arg2 / 100:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= arg2 / 100
                                                if balanceOf[stor7] > !(arg2 / 100):
                                                    revert with 0, 17
                                                if balanceOf[stor7] + (arg2 / 100) < balanceOf[stor7]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = uniswapV2PairAddress
                                                mem[32] = 1
                                                balanceOf[stor7] += arg2 / 100
                                                emit Transfer((arg2 / 100), msg.sender, uniswapV2PairAddress);
                                                _25301 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_25301] = 26
                                                mem[_25301 + 32] = 'SafeMath: division by zero'
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not this.address:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _25501 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_25501] = 38
                                                mem[_25501 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if arg2 / 10 > balanceOf[address(msg.sender)]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_25501 + 70 len 26]
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(msg.sender)] < arg2 / 10:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= arg2 / 10
                                                if balanceOf[this.address] > !(arg2 / 10):
                                                    revert with 0, 17
                                                if balanceOf[this.address] + (arg2 / 10) < balanceOf[this.address]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = this.address
                                                mem[32] = 1
                                                balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 10)
                                                emit Transfer((arg2 / 10), msg.sender, this.address);
                                                _26289 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_26289] = 26
                                                mem[_26289 + 32] = 'SafeMath: division by zero'
                                                if not arg2 / 100:
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not arg1:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _26508 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_26508] = 38
                                                    mem[_26508 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if 0 > balanceOf[address(msg.sender)]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_26508 + 70 len 26]
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(msg.sender)] < 0:
                                                        revert with 0, 17
                                                    if balanceOf[arg1] > -1:
                                                        revert with 0, 17
                                                    if balanceOf[arg1] < balanceOf[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(arg1)] = balanceOf[arg1]
                                                    emit Transfer(0, msg.sender, arg1);
                                                else:
                                                    if arg2 / 100 and 87 > -1 / arg2 / 100:
                                                        revert with 0, 17
                                                    if not arg2 / 100:
                                                        revert with 0, 18
                                                    if 87 * arg2 / 100 / arg2 / 100 != 87:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not arg1:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _27085 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_27085] = 38
                                                    mem[_27085 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if 87 * arg2 / 100 > balanceOf[address(msg.sender)]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_27085 + 70 len 26]
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(msg.sender)] < 87 * arg2 / 100:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] += -87 * arg2 / 100
                                                    if balanceOf[arg1] > !(87 * arg2 / 100):
                                                        revert with 0, 17
                                                    if balanceOf[arg1] + (87 * arg2 / 100) < balanceOf[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(arg1)] = balanceOf[arg1] + (87 * arg2 / 100)
                                                    emit Transfer((87 * arg2 / 100), msg.sender, arg1);
                                else:
                                    idx = 0
                                    t = 0
                                    u = 1440
                                    while idx < 9:
                                        if block.timestamp % stor19.length - 9 > !idx:
                                            revert with 0, 17
                                        if (block.timestamp % stor19.length - 9) + idx >= stor19.length:
                                            revert with 0, 50
                                        mem[0] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                        mem[32] = 1
                                        if balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] < 10000000000 * 10^18:
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            t = t
                                            u = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                            continue 
                                        mem[0] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                        mem[32] = 1
                                        if not balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]]:
                                            _17690 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_17690] = 26
                                            mem[_17690 + 32] = 'SafeMath: division by zero'
                                            if not 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                _17988 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _17988 + 68] = mem[idx + _17690 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_17988 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _17988 + -mem[64] + 100
                                            if 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                if not 4 * ext_call.return_data[0] / 5:
                                                    _20850 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_20850] = 26
                                                    mem[_20850 + 32] = 'SafeMath: division by zero'
                                                    mem[mem[64] + 4] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                                    mem[mem[64] + 36] = 0
                                                    require ext_code.size(dogeAddress)
                                                    call dogeAddress.0xa9059cbb with:
                                                         gas gas_remaining wei
                                                        args stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx], 0
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _22730 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_22730] == bool(mem[_22730])
                                                else:
                                                    if 4 * ext_call.return_data[0] / 5 and 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s > -1 / 4 * ext_call.return_data[0] / 5:
                                                        revert with 0, 17
                                                    if not 4 * ext_call.return_data[0] / 5:
                                                        revert with 0, 18
                                                    if 4 * ext_call.return_data[0] / 5 * 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 4 * ext_call.return_data[0] / 5 != 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _22074 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_22074] = 26
                                                    mem[_22074 + 32] = 'SafeMath: division by zero'
                                                    mem[mem[64] + 4] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                                    mem[mem[64] + 36] = 4 * ext_call.return_data[0] / 5 * 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 10000
                                                    require ext_code.size(dogeAddress)
                                                    call dogeAddress.0xa9059cbb with:
                                                         gas gas_remaining wei
                                                        args stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx], 4 * ext_call.return_data[0] / 5 * 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 10000
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _23162 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_23162] == bool(mem[_23162])
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            t = 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s
                                            u = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                            continue 
                                        if balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] and 10000 > -1 / balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]]:
                                            revert with 0, 17
                                        if not balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]]:
                                            revert with 0, 18
                                        if 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] != 10000:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _19218 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19218] = 26
                                        mem[_19218 + 32] = 'SafeMath: division by zero'
                                        if not 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                            _19515 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _19515 + 68] = mem[idx + _19218 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_19515 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _19515 + -mem[64] + 100
                                        if 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                            if not 4 * ext_call.return_data[0] / 5:
                                                _22073 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_22073] = 26
                                                mem[_22073 + 32] = 'SafeMath: division by zero'
                                                mem[mem[64] + 4] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                                mem[mem[64] + 36] = 0
                                                require ext_code.size(dogeAddress)
                                                call dogeAddress.0xa9059cbb with:
                                                     gas gas_remaining wei
                                                    args stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx], 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _23161 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_23161] == bool(mem[_23161])
                                            else:
                                                if 4 * ext_call.return_data[0] / 5 and 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s > -1 / 4 * ext_call.return_data[0] / 5:
                                                    revert with 0, 17
                                                if not 4 * ext_call.return_data[0] / 5:
                                                    revert with 0, 18
                                                if 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 4 * ext_call.return_data[0] / 5 != 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _22978 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_22978] = 26
                                                mem[_22978 + 32] = 'SafeMath: division by zero'
                                                mem[mem[64] + 4] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                                mem[mem[64] + 36] = 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 10000
                                                require ext_code.size(dogeAddress)
                                                call dogeAddress.0xa9059cbb with:
                                                     gas gas_remaining wei
                                                    args stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx], 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 10000
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _23646 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_23646] == bool(mem[_23646])
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        t = 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s
                                        u = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                        continue 
                                    mem[0] = msg.sender
                                    mem[32] = 14
                                    if stor14[address(msg.sender)]:
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not arg1:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        _16966 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_16966] = 38
                                        mem[_16966 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                        if arg2 > balanceOf[address(msg.sender)]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 38
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_16966 + 70 len 26]
                                            var84001 = 64
                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                        if balanceOf[address(msg.sender)] < arg2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2
                                        if balanceOf[arg1] > !arg2:
                                            revert with 0, 17
                                        if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                        emit Transfer(arg2, msg.sender, arg1);
                                    else:
                                        mem[0] = arg1
                                        mem[32] = 14
                                        if stor14[address(arg1)]:
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not arg1:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            _17282 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_17282] = 38
                                            mem[_17282 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                            if arg2 > balanceOf[address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 38
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17282 + 70 len 26]
                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                            if balanceOf[address(msg.sender)] < arg2:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2
                                            if balanceOf[arg1] > !arg2:
                                                revert with 0, 17
                                            if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                            emit Transfer(arg2, msg.sender, arg1);
                                        else:
                                            if stor10:
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not arg1:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _16969 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_16969] = 38
                                                mem[_16969 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if arg2 > balanceOf[address(msg.sender)]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_16969 + 70 len 26]
                                                    var84001 = 64
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(msg.sender)] < arg2:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= arg2
                                                if balanceOf[arg1] > !arg2:
                                                    revert with 0, 17
                                                if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                emit Transfer(arg2, msg.sender, arg1);
                                            else:
                                                _16519 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_16519] = 26
                                                mem[_16519 + 32] = 'SafeMath: division by zero'
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not stor13:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _18921 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_18921] = 38
                                                mem[_18921 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_18921 + 70 len 26]
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(msg.sender)] < arg2 / 100:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= arg2 / 100
                                                if balanceOf[stor13] > !(arg2 / 100):
                                                    revert with 0, 17
                                                if balanceOf[stor13] + (arg2 / 100) < balanceOf[stor13]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = stor13
                                                mem[32] = 1
                                                balanceOf[stor13] += arg2 / 100
                                                emit Transfer((arg2 / 100), msg.sender, stor13);
                                                _22607 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_22607] = 26
                                                mem[_22607 + 32] = 'SafeMath: division by zero'
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not sub_8230af5aAddress:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _23450 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_23450] = 38
                                                mem[_23450 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_23450 + 70 len 26]
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(msg.sender)] < arg2 / 100:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= arg2 / 100
                                                if balanceOf[stor9] > !(arg2 / 100):
                                                    revert with 0, 17
                                                if balanceOf[stor9] + (arg2 / 100) < balanceOf[stor9]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = sub_8230af5aAddress
                                                mem[32] = 1
                                                balanceOf[stor9] += arg2 / 100
                                                emit Transfer((arg2 / 100), msg.sender, sub_8230af5aAddress);
                                                _24314 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_24314] = 26
                                                mem[_24314 + 32] = 'SafeMath: division by zero'
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not uniswapV2PairAddress:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _24516 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_24516] = 38
                                                mem[_24516 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_24516 + 70 len 26]
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(msg.sender)] < arg2 / 100:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= arg2 / 100
                                                if balanceOf[stor7] > !(arg2 / 100):
                                                    revert with 0, 17
                                                if balanceOf[stor7] + (arg2 / 100) < balanceOf[stor7]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = uniswapV2PairAddress
                                                mem[32] = 1
                                                balanceOf[stor7] += arg2 / 100
                                                emit Transfer((arg2 / 100), msg.sender, uniswapV2PairAddress);
                                                _25302 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_25302] = 26
                                                mem[_25302 + 32] = 'SafeMath: division by zero'
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not this.address:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _25504 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_25504] = 38
                                                mem[_25504 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if arg2 / 10 > balanceOf[address(msg.sender)]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_25504 + 70 len 26]
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(msg.sender)] < arg2 / 10:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= arg2 / 10
                                                if balanceOf[this.address] > !(arg2 / 10):
                                                    revert with 0, 17
                                                if balanceOf[this.address] + (arg2 / 10) < balanceOf[this.address]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = this.address
                                                mem[32] = 1
                                                balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 10)
                                                emit Transfer((arg2 / 10), msg.sender, this.address);
                                                _26290 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_26290] = 26
                                                mem[_26290 + 32] = 'SafeMath: division by zero'
                                                if not arg2 / 100:
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not arg1:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _26512 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_26512] = 38
                                                    mem[_26512 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if 0 > balanceOf[address(msg.sender)]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_26512 + 70 len 26]
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(msg.sender)] < 0:
                                                        revert with 0, 17
                                                    if balanceOf[arg1] > -1:
                                                        revert with 0, 17
                                                    if balanceOf[arg1] < balanceOf[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(arg1)] = balanceOf[arg1]
                                                    emit Transfer(0, msg.sender, arg1);
                                                else:
                                                    if arg2 / 100 and 87 > -1 / arg2 / 100:
                                                        revert with 0, 17
                                                    if not arg2 / 100:
                                                        revert with 0, 18
                                                    if 87 * arg2 / 100 / arg2 / 100 != 87:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not arg1:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _27090 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_27090] = 38
                                                    mem[_27090 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if 87 * arg2 / 100 > balanceOf[address(msg.sender)]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_27090 + 70 len 26]
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(msg.sender)] < 87 * arg2 / 100:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] += -87 * arg2 / 100
                                                    if balanceOf[arg1] > !(87 * arg2 / 100):
                                                        revert with 0, 17
                                                    if balanceOf[arg1] + (87 * arg2 / 100) < balanceOf[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(arg1)] = balanceOf[arg1] + (87 * arg2 / 100)
                                                    emit Transfer((87 * arg2 / 100), msg.sender, arg1);
            else:
                if sub_dc4e5c71Address == arg1:
                    mem[100] = this.address
                    require ext_code.size(dogeAddress)
                    staticcall dogeAddress.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    mem[96] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if ext_call.return_data[0] < 10^12:
                        if not msg.sender:
                            revert with 0, 'ERC20: transfer from the zero address'
                        if stor14[address(msg.sender)]:
                            if not arg1:
                                revert with 0, 'ERC20: transfer to the zero address'
                            if arg2 > balanceOf[address(msg.sender)]:
                                revert with 0, 
                                            32,
                                            38,
                                            0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 166 len 26] >> 48,
                                            0
                            if balanceOf[address(msg.sender)] < arg2:
                                revert with 0, 17
                            balanceOf[address(msg.sender)] -= arg2
                            if balanceOf[arg1] > !arg2:
                                revert with 0, 17
                            if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                            emit Transfer(arg2, msg.sender, arg1);
                        else:
                            if stor14[address(arg1)]:
                                if not arg1:
                                    revert with 0, 'ERC20: transfer to the zero address'
                                if arg2 > balanceOf[address(msg.sender)]:
                                    revert with 0, 
                                                32,
                                                38,
                                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 166 len 26] >> 48,
                                                0
                                if balanceOf[address(msg.sender)] < arg2:
                                    revert with 0, 17
                                balanceOf[address(msg.sender)] -= arg2
                                if balanceOf[arg1] > !arg2:
                                    revert with 0, 17
                                if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                emit Transfer(arg2, msg.sender, arg1);
                            else:
                                if stor10:
                                    if not arg1:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    if arg2 > balanceOf[address(msg.sender)]:
                                        revert with 0, 
                                                    32,
                                                    38,
                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 166 len 26] >> 48,
                                                    0
                                    if balanceOf[address(msg.sender)] < arg2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)] -= arg2
                                    if balanceOf[arg1] > !arg2:
                                        revert with 0, 17
                                    if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                    emit Transfer(arg2, msg.sender, arg1);
                                else:
                                    if not stor13:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    if arg2 / 100 > balanceOf[address(msg.sender)]:
                                        revert with 0, 
                                                    32,
                                                    38,
                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 230 len 26] >> 48,
                                                    0
                                    if balanceOf[address(msg.sender)] < arg2 / 100:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)] -= arg2 / 100
                                    if balanceOf[stor13] > !(arg2 / 100):
                                        revert with 0, 17
                                    if balanceOf[stor13] + (arg2 / 100) < balanceOf[stor13]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[stor13] += arg2 / 100
                                    emit Transfer((arg2 / 100), msg.sender, stor13);
                                    if not msg.sender:
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if not sub_8230af5aAddress:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    if arg2 / 100 > balanceOf[address(msg.sender)]:
                                        revert with 0, 
                                                    32,
                                                    38,
                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 390 len 26] >> 48,
                                                    0
                                    if balanceOf[address(msg.sender)] < arg2 / 100:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)] -= arg2 / 100
                                    if balanceOf[stor9] > !(arg2 / 100):
                                        revert with 0, 17
                                    if balanceOf[stor9] + (arg2 / 100) < balanceOf[stor9]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[stor9] += arg2 / 100
                                    emit Transfer((arg2 / 100), msg.sender, sub_8230af5aAddress);
                                    if not msg.sender:
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if not uniswapV2PairAddress:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    if arg2 / 100 > balanceOf[address(msg.sender)]:
                                        revert with 0, 
                                                    32,
                                                    38,
                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 550 len 26] >> 48,
                                                    0
                                    if balanceOf[address(msg.sender)] < arg2 / 100:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)] -= arg2 / 100
                                    if balanceOf[stor7] > !(arg2 / 100):
                                        revert with 0, 17
                                    if balanceOf[stor7] + (arg2 / 100) < balanceOf[stor7]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[stor7] += arg2 / 100
                                    emit Transfer((arg2 / 100), msg.sender, uniswapV2PairAddress);
                                    if not msg.sender:
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if not this.address:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    if arg2 / 10 > balanceOf[address(msg.sender)]:
                                        revert with 0, 
                                                    32,
                                                    38,
                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 710 len 26] >> 48,
                                                    0
                                    if balanceOf[address(msg.sender)] < arg2 / 10:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)] -= arg2 / 10
                                    if balanceOf[this.address] > !(arg2 / 10):
                                        revert with 0, 17
                                    if balanceOf[this.address] + (arg2 / 10) < balanceOf[this.address]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 10)
                                    emit Transfer((arg2 / 10), msg.sender, this.address);
                                    if not arg2 / 100:
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not arg1:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        if 0 > balanceOf[address(msg.sender)]:
                                            revert with 0, 
                                                        32,
                                                        38,
                                                        0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 870 len 26] >> 48,
                                                        0
                                        if balanceOf[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if balanceOf[arg1] > -1:
                                            revert with 0, 17
                                        if balanceOf[arg1] < balanceOf[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(arg1)] = balanceOf[arg1]
                                        emit Transfer(0, msg.sender, arg1);
                                    else:
                                        if arg2 / 100 and 87 > -1 / arg2 / 100:
                                            revert with 0, 17
                                        if not arg2 / 100:
                                            revert with 0, 18
                                        if 87 * arg2 / 100 / arg2 / 100 != 87:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not arg1:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        if 87 * arg2 / 100 > balanceOf[address(msg.sender)]:
                                            revert with 0, 
                                                        32,
                                                        38,
                                                        0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 870 len 26] >> 48,
                                                        0
                                        if balanceOf[address(msg.sender)] < 87 * arg2 / 100:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] += -87 * arg2 / 100
                                        if balanceOf[arg1] > !(87 * arg2 / 100):
                                            revert with 0, 17
                                        if balanceOf[arg1] + (87 * arg2 / 100) < balanceOf[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(arg1)] = balanceOf[arg1] + (87 * arg2 / 100)
                                        emit Transfer((87 * arg2 / 100), msg.sender, arg1);
                    else:
                        if not ext_call.return_data[0]:
                            mem[64] = ceil32(return_data.size) + 160
                            mem[ceil32(return_data.size) + 96] = 26
                            mem[ceil32(return_data.size) + 128] = 'SafeMath: division by zero'
                            if not stor19.length:
                                if not msg.sender:
                                    revert with 0, 'ERC20: transfer from the zero address'
                                if stor14[address(msg.sender)]:
                                    if not arg1:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    if arg2 > balanceOf[address(msg.sender)]:
                                        revert with 0, 
                                                    32,
                                                    38,
                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 230 len 26] >> 48,
                                                    0
                                    if balanceOf[address(msg.sender)] < arg2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)] -= arg2
                                    if balanceOf[arg1] > !arg2:
                                        revert with 0, 17
                                    if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                    emit Transfer(arg2, msg.sender, arg1);
                                else:
                                    if stor14[address(arg1)]:
                                        if not arg1:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        if arg2 > balanceOf[address(msg.sender)]:
                                            revert with 0, 
                                                        32,
                                                        38,
                                                        0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 230 len 26] >> 48,
                                                        0
                                        if balanceOf[address(msg.sender)] < arg2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2
                                        if balanceOf[arg1] > !arg2:
                                            revert with 0, 17
                                        if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                        emit Transfer(arg2, msg.sender, arg1);
                                    else:
                                        if stor10:
                                            if not arg1:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            if arg2 > balanceOf[address(msg.sender)]:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 230 len 26] >> 48,
                                                            0
                                            if balanceOf[address(msg.sender)] < arg2:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2
                                            if balanceOf[arg1] > !arg2:
                                                revert with 0, 17
                                            if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                            emit Transfer(arg2, msg.sender, arg1);
                                        else:
                                            if not stor13:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 294 len 26] >> 48,
                                                            0
                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                            if balanceOf[stor13] > !(arg2 / 100):
                                                revert with 0, 17
                                            if balanceOf[stor13] + (arg2 / 100) < balanceOf[stor13]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[stor13] += arg2 / 100
                                            emit Transfer((arg2 / 100), msg.sender, stor13);
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not sub_8230af5aAddress:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 454 len 26] >> 48,
                                                            0
                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                            if balanceOf[stor9] > !(arg2 / 100):
                                                revert with 0, 17
                                            if balanceOf[stor9] + (arg2 / 100) < balanceOf[stor9]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[stor9] += arg2 / 100
                                            emit Transfer((arg2 / 100), msg.sender, sub_8230af5aAddress);
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not uniswapV2PairAddress:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 614 len 26] >> 48,
                                                            0
                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                            if balanceOf[stor7] > !(arg2 / 100):
                                                revert with 0, 17
                                            if balanceOf[stor7] + (arg2 / 100) < balanceOf[stor7]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[stor7] += arg2 / 100
                                            emit Transfer((arg2 / 100), msg.sender, uniswapV2PairAddress);
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not this.address:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            if arg2 / 10 > balanceOf[address(msg.sender)]:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 774 len 26] >> 48,
                                                            0
                                            if balanceOf[address(msg.sender)] < arg2 / 10:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2 / 10
                                            if balanceOf[this.address] > !(arg2 / 10):
                                                revert with 0, 17
                                            if balanceOf[this.address] + (arg2 / 10) < balanceOf[this.address]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 10)
                                            emit Transfer((arg2 / 10), msg.sender, this.address);
                                            if not arg2 / 100:
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not arg1:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                if 0 > balanceOf[address(msg.sender)]:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 934 len 26] >> 48,
                                                                0
                                                if balanceOf[address(msg.sender)] < 0:
                                                    revert with 0, 17
                                                if balanceOf[arg1] > -1:
                                                    revert with 0, 17
                                                if balanceOf[arg1] < balanceOf[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(arg1)] = balanceOf[arg1]
                                                emit Transfer(0, msg.sender, arg1);
                                            else:
                                                if arg2 / 100 and 87 > -1 / arg2 / 100:
                                                    revert with 0, 17
                                                if not arg2 / 100:
                                                    revert with 0, 18
                                                if 87 * arg2 / 100 / arg2 / 100 != 87:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not arg1:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                if 87 * arg2 / 100 > balanceOf[address(msg.sender)]:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 934 len 26] >> 48,
                                                                0
                                                if balanceOf[address(msg.sender)] < 87 * arg2 / 100:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] += -87 * arg2 / 100
                                                if balanceOf[arg1] > !(87 * arg2 / 100):
                                                    revert with 0, 17
                                                if balanceOf[arg1] + (87 * arg2 / 100) < balanceOf[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(arg1)] = balanceOf[arg1] + (87 * arg2 / 100)
                                                emit Transfer((87 * arg2 / 100), msg.sender, arg1);
                            else:
                                if stor19.length <= 9:
                                    idx = 0
                                    s = 0
                                    t = 0
                                    while idx < stor19.length:
                                        mem[0] = stor19[idx]
                                        mem[32] = 1
                                        if s > !balanceOf[stor19[idx]]:
                                            revert with 0, 17
                                        if s + balanceOf[stor19[idx]] < s:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + balanceOf[stor19[idx]]
                                        t = stor19[idx]
                                        continue 
                                    if stor19.length <= 9:
                                        idx = 0
                                        t = 0
                                        u = 160 * stor19.length
                                        while idx < stor19.length:
                                            mem[0] = stor19[idx]
                                            mem[32] = 1
                                            if balanceOf[stor19[idx]] < 10000000000 * 10^18:
                                                if idx == -1:
                                                    revert with 0, 17
                                                idx = idx + 1
                                                t = t
                                                u = stor19[idx]
                                                continue 
                                            mem[0] = stor19[idx]
                                            mem[32] = 1
                                            if not balanceOf[stor19[idx]]:
                                                _17040 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_17040] = 26
                                                mem[_17040 + 32] = 'SafeMath: division by zero'
                                                if not s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                    _17536 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _17536 + 68] = mem[idx + _17040 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_17536 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _17536 + -mem[64] + 100
                                                if 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                    _20274 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_20274] = 26
                                                    mem[_20274 + 32] = 'SafeMath: division by zero'
                                                    mem[mem[64] + 4] = stor19[idx]
                                                    mem[mem[64] + 36] = 0
                                                    require ext_code.size(dogeAddress)
                                                    call dogeAddress.0xa9059cbb with:
                                                         gas gas_remaining wei
                                                        args stor19[idx], 0
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _22139 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_22139] == bool(mem[_22139])
                                                if idx == -1:
                                                    revert with 0, 17
                                                idx = idx + 1
                                                t = 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length
                                                u = stor19[idx]
                                                continue 
                                            if balanceOf[stor19[idx]] and 10000 > -1 / balanceOf[stor19[idx]]:
                                                revert with 0, 17
                                            if not balanceOf[stor19[idx]]:
                                                revert with 0, 18
                                            if 10000 * balanceOf[stor19[idx]] / balanceOf[stor19[idx]] != 10000:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _18309 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_18309] = 26
                                            mem[_18309 + 32] = 'SafeMath: division by zero'
                                            if not s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                _18997 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _18997 + 68] = mem[idx + _18309 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_18997 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _18997 + -mem[64] + 100
                                            if 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                _21243 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_21243] = 26
                                                mem[_21243 + 32] = 'SafeMath: division by zero'
                                                mem[mem[64] + 4] = stor19[idx]
                                                mem[mem[64] + 36] = 0
                                                require ext_code.size(dogeAddress)
                                                call dogeAddress.0xa9059cbb with:
                                                     gas gas_remaining wei
                                                    args stor19[idx], 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _22987 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_22987] == bool(mem[_22987])
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            t = 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length
                                            u = stor19[idx]
                                            continue 
                                        mem[0] = msg.sender
                                        mem[32] = 14
                                        if stor14[address(msg.sender)]:
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not arg1:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            _17033 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_17033] = 38
                                            mem[_17033 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                            if arg2 > balanceOf[address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 38
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17033 + 70 len 26]
                                                var68001 = 64
                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                            if balanceOf[address(msg.sender)] < arg2:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2
                                            if balanceOf[arg1] > !arg2:
                                                revert with 0, 17
                                            if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                            emit Transfer(arg2, msg.sender, arg1);
                                        else:
                                            mem[0] = arg1
                                            mem[32] = 14
                                            if stor14[address(arg1)]:
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not arg1:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _17327 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_17327] = 38
                                                mem[_17327 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if arg2 > balanceOf[address(msg.sender)]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17327 + 70 len 26]
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(msg.sender)] < arg2:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= arg2
                                                if balanceOf[arg1] > !arg2:
                                                    revert with 0, 17
                                                if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                emit Transfer(arg2, msg.sender, arg1);
                                            else:
                                                if stor10:
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not arg1:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _17036 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_17036] = 38
                                                    mem[_17036 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if arg2 > balanceOf[address(msg.sender)]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17036 + 70 len 26]
                                                        var68001 = 64
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(msg.sender)] < arg2:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2
                                                    if balanceOf[arg1] > !arg2:
                                                        revert with 0, 17
                                                    if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                    emit Transfer(arg2, msg.sender, arg1);
                                                else:
                                                    _16533 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_16533] = 26
                                                    mem[_16533 + 32] = 'SafeMath: division by zero'
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not stor13:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _18993 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_18993] = 38
                                                    mem[_18993 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_18993 + 70 len 26]
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(msg.sender)] < arg2 / 100:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2 / 100
                                                    if balanceOf[stor13] > !(arg2 / 100):
                                                        revert with 0, 17
                                                    if balanceOf[stor13] + (arg2 / 100) < balanceOf[stor13]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = stor13
                                                    mem[32] = 1
                                                    balanceOf[stor13] += arg2 / 100
                                                    emit Transfer((arg2 / 100), msg.sender, stor13);
                                                    _22631 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_22631] = 26
                                                    mem[_22631 + 32] = 'SafeMath: division by zero'
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not sub_8230af5aAddress:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _23483 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_23483] = 38
                                                    mem[_23483 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_23483 + 70 len 26]
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(msg.sender)] < arg2 / 100:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2 / 100
                                                    if balanceOf[stor9] > !(arg2 / 100):
                                                        revert with 0, 17
                                                    if balanceOf[stor9] + (arg2 / 100) < balanceOf[stor9]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = sub_8230af5aAddress
                                                    mem[32] = 1
                                                    balanceOf[stor9] += arg2 / 100
                                                    emit Transfer((arg2 / 100), msg.sender, sub_8230af5aAddress);
                                                    _24323 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_24323] = 26
                                                    mem[_24323 + 32] = 'SafeMath: division by zero'
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not uniswapV2PairAddress:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _24543 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_24543] = 38
                                                    mem[_24543 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_24543 + 70 len 26]
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(msg.sender)] < arg2 / 100:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2 / 100
                                                    if balanceOf[stor7] > !(arg2 / 100):
                                                        revert with 0, 17
                                                    if balanceOf[stor7] + (arg2 / 100) < balanceOf[stor7]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = uniswapV2PairAddress
                                                    mem[32] = 1
                                                    balanceOf[stor7] += arg2 / 100
                                                    emit Transfer((arg2 / 100), msg.sender, uniswapV2PairAddress);
                                                    _25311 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_25311] = 26
                                                    mem[_25311 + 32] = 'SafeMath: division by zero'
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not this.address:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _25531 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_25531] = 38
                                                    mem[_25531 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if arg2 / 10 > balanceOf[address(msg.sender)]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_25531 + 70 len 26]
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(msg.sender)] < arg2 / 10:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2 / 10
                                                    if balanceOf[this.address] > !(arg2 / 10):
                                                        revert with 0, 17
                                                    if balanceOf[this.address] + (arg2 / 10) < balanceOf[this.address]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = this.address
                                                    mem[32] = 1
                                                    balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 10)
                                                    emit Transfer((arg2 / 10), msg.sender, this.address);
                                                    _26299 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_26299] = 26
                                                    mem[_26299 + 32] = 'SafeMath: division by zero'
                                                    if not arg2 / 100:
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not arg1:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        _26548 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_26548] = 38
                                                        mem[_26548 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if 0 > balanceOf[address(msg.sender)]:
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 38
                                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_26548 + 70 len 26]
                                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                        if balanceOf[address(msg.sender)] < 0:
                                                            revert with 0, 17
                                                        if balanceOf[arg1] > -1:
                                                            revert with 0, 17
                                                        if balanceOf[arg1] < balanceOf[arg1]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(arg1)] = balanceOf[arg1]
                                                        emit Transfer(0, msg.sender, arg1);
                                                    else:
                                                        if arg2 / 100 and 87 > -1 / arg2 / 100:
                                                            revert with 0, 17
                                                        if not arg2 / 100:
                                                            revert with 0, 18
                                                        if 87 * arg2 / 100 / arg2 / 100 != 87:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not arg1:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        _27135 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_27135] = 38
                                                        mem[_27135 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if 87 * arg2 / 100 > balanceOf[address(msg.sender)]:
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 38
                                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_27135 + 70 len 26]
                                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                        if balanceOf[address(msg.sender)] < 87 * arg2 / 100:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] += -87 * arg2 / 100
                                                        if balanceOf[arg1] > !(87 * arg2 / 100):
                                                            revert with 0, 17
                                                        if balanceOf[arg1] + (87 * arg2 / 100) < balanceOf[arg1]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(arg1)] = balanceOf[arg1] + (87 * arg2 / 100)
                                                        emit Transfer((87 * arg2 / 100), msg.sender, arg1);
                                    else:
                                        idx = 0
                                        t = 0
                                        u = 160 * stor19.length
                                        while idx < 9:
                                            if 0 > !idx:
                                                revert with 0, 17
                                            if idx >= stor19.length:
                                                revert with 0, 50
                                            mem[0] = stor19[idx]
                                            mem[32] = 1
                                            if balanceOf[stor19[idx]] < 10000000000 * 10^18:
                                                if idx == -1:
                                                    revert with 0, 17
                                                idx = idx + 1
                                                t = t
                                                u = stor19[idx]
                                                continue 
                                            mem[0] = stor19[idx]
                                            mem[32] = 1
                                            if not balanceOf[stor19[idx]]:
                                                _17730 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_17730] = 26
                                                mem[_17730 + 32] = 'SafeMath: division by zero'
                                                if not s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                    _18023 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _18023 + 68] = mem[idx + _17730 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_18023 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _18023 + -mem[64] + 100
                                                if 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                    _20880 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_20880] = 26
                                                    mem[_20880 + 32] = 'SafeMath: division by zero'
                                                    mem[mem[64] + 4] = stor19[idx]
                                                    mem[mem[64] + 36] = 0
                                                    require ext_code.size(dogeAddress)
                                                    call dogeAddress.0xa9059cbb with:
                                                         gas gas_remaining wei
                                                        args stor19[idx], 0
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _22737 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_22737] == bool(mem[_22737])
                                                if idx == -1:
                                                    revert with 0, 17
                                                idx = idx + 1
                                                t = 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length
                                                u = stor19[idx]
                                                continue 
                                            if balanceOf[stor19[idx]] and 10000 > -1 / balanceOf[stor19[idx]]:
                                                revert with 0, 17
                                            if not balanceOf[stor19[idx]]:
                                                revert with 0, 18
                                            if 10000 * balanceOf[stor19[idx]] / balanceOf[stor19[idx]] != 10000:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _19248 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_19248] = 26
                                            mem[_19248 + 32] = 'SafeMath: division by zero'
                                            if not s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                _19560 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _19560 + 68] = mem[idx + _19248 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_19560 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _19560 + -mem[64] + 100
                                            if 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                _22146 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_22146] = 26
                                                mem[_22146 + 32] = 'SafeMath: division by zero'
                                                mem[mem[64] + 4] = stor19[idx]
                                                mem[mem[64] + 36] = 0
                                                require ext_code.size(dogeAddress)
                                                call dogeAddress.0xa9059cbb with:
                                                     gas gas_remaining wei
                                                    args stor19[idx], 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _23169 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_23169] == bool(mem[_23169])
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            t = 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length
                                            u = stor19[idx]
                                            continue 
                                        mem[0] = msg.sender
                                        mem[32] = 14
                                        if stor14[address(msg.sender)]:
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not arg1:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            _17041 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_17041] = 38
                                            mem[_17041 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                            if arg2 > balanceOf[address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 38
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17041 + 70 len 26]
                                                var68001 = 64
                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                            if balanceOf[address(msg.sender)] < arg2:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2
                                            if balanceOf[arg1] > !arg2:
                                                revert with 0, 17
                                            if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                            emit Transfer(arg2, msg.sender, arg1);
                                        else:
                                            mem[0] = arg1
                                            mem[32] = 14
                                            if stor14[address(arg1)]:
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not arg1:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _17332 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_17332] = 38
                                                mem[_17332 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if arg2 > balanceOf[address(msg.sender)]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17332 + 70 len 26]
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(msg.sender)] < arg2:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= arg2
                                                if balanceOf[arg1] > !arg2:
                                                    revert with 0, 17
                                                if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                emit Transfer(arg2, msg.sender, arg1);
                                            else:
                                                if stor10:
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not arg1:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _17044 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_17044] = 38
                                                    mem[_17044 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if arg2 > balanceOf[address(msg.sender)]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17044 + 70 len 26]
                                                        var68001 = 64
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(msg.sender)] < arg2:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2
                                                    if balanceOf[arg1] > !arg2:
                                                        revert with 0, 17
                                                    if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                    emit Transfer(arg2, msg.sender, arg1);
                                                else:
                                                    _16534 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_16534] = 26
                                                    mem[_16534 + 32] = 'SafeMath: division by zero'
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not stor13:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _19001 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_19001] = 38
                                                    mem[_19001 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_19001 + 70 len 26]
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(msg.sender)] < arg2 / 100:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2 / 100
                                                    if balanceOf[stor13] > !(arg2 / 100):
                                                        revert with 0, 17
                                                    if balanceOf[stor13] + (arg2 / 100) < balanceOf[stor13]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = stor13
                                                    mem[32] = 1
                                                    balanceOf[stor13] += arg2 / 100
                                                    emit Transfer((arg2 / 100), msg.sender, stor13);
                                                    _22634 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_22634] = 26
                                                    mem[_22634 + 32] = 'SafeMath: division by zero'
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not sub_8230af5aAddress:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _23486 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_23486] = 38
                                                    mem[_23486 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_23486 + 70 len 26]
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(msg.sender)] < arg2 / 100:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2 / 100
                                                    if balanceOf[stor9] > !(arg2 / 100):
                                                        revert with 0, 17
                                                    if balanceOf[stor9] + (arg2 / 100) < balanceOf[stor9]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = sub_8230af5aAddress
                                                    mem[32] = 1
                                                    balanceOf[stor9] += arg2 / 100
                                                    emit Transfer((arg2 / 100), msg.sender, sub_8230af5aAddress);
                                                    _24324 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_24324] = 26
                                                    mem[_24324 + 32] = 'SafeMath: division by zero'
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not uniswapV2PairAddress:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _24546 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_24546] = 38
                                                    mem[_24546 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_24546 + 70 len 26]
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(msg.sender)] < arg2 / 100:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2 / 100
                                                    if balanceOf[stor7] > !(arg2 / 100):
                                                        revert with 0, 17
                                                    if balanceOf[stor7] + (arg2 / 100) < balanceOf[stor7]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = uniswapV2PairAddress
                                                    mem[32] = 1
                                                    balanceOf[stor7] += arg2 / 100
                                                    emit Transfer((arg2 / 100), msg.sender, uniswapV2PairAddress);
                                                    _25312 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_25312] = 26
                                                    mem[_25312 + 32] = 'SafeMath: division by zero'
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not this.address:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _25534 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_25534] = 38
                                                    mem[_25534 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if arg2 / 10 > balanceOf[address(msg.sender)]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_25534 + 70 len 26]
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(msg.sender)] < arg2 / 10:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2 / 10
                                                    if balanceOf[this.address] > !(arg2 / 10):
                                                        revert with 0, 17
                                                    if balanceOf[this.address] + (arg2 / 10) < balanceOf[this.address]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = this.address
                                                    mem[32] = 1
                                                    balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 10)
                                                    emit Transfer((arg2 / 10), msg.sender, this.address);
                                                    _26300 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_26300] = 26
                                                    mem[_26300 + 32] = 'SafeMath: division by zero'
                                                    if not arg2 / 100:
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not arg1:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        _26552 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_26552] = 38
                                                        mem[_26552 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if 0 > balanceOf[address(msg.sender)]:
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 38
                                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_26552 + 70 len 26]
                                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                        if balanceOf[address(msg.sender)] < 0:
                                                            revert with 0, 17
                                                        if balanceOf[arg1] > -1:
                                                            revert with 0, 17
                                                        if balanceOf[arg1] < balanceOf[arg1]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(arg1)] = balanceOf[arg1]
                                                        emit Transfer(0, msg.sender, arg1);
                                                    else:
                                                        if arg2 / 100 and 87 > -1 / arg2 / 100:
                                                            revert with 0, 17
                                                        if not arg2 / 100:
                                                            revert with 0, 18
                                                        if 87 * arg2 / 100 / arg2 / 100 != 87:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not arg1:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        _27140 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_27140] = 38
                                                        mem[_27140 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if 87 * arg2 / 100 > balanceOf[address(msg.sender)]:
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 38
                                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_27140 + 70 len 26]
                                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                        if balanceOf[address(msg.sender)] < 87 * arg2 / 100:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] += -87 * arg2 / 100
                                                        if balanceOf[arg1] > !(87 * arg2 / 100):
                                                            revert with 0, 17
                                                        if balanceOf[arg1] + (87 * arg2 / 100) < balanceOf[arg1]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(arg1)] = balanceOf[arg1] + (87 * arg2 / 100)
                                                        emit Transfer((87 * arg2 / 100), msg.sender, arg1);
                                else:
                                    if stor19.length < 9:
                                        revert with 0, 17
                                    mem[64] = ceil32(return_data.size) + 224
                                    mem[ceil32(return_data.size) + 160] = 24
                                    mem[ceil32(return_data.size) + 192] = 'SafeMath: modulo by zero'
                                    if not stor19.length - 9:
                                        revert with 0, 'SafeMath: modulo by zero', 0
                                    idx = 0
                                    s = 0
                                    t = 0
                                    while idx < 9:
                                        if block.timestamp % stor19.length - 9 > !idx:
                                            revert with 0, 17
                                        if (block.timestamp % stor19.length - 9) + idx >= stor19.length:
                                            revert with 0, 50
                                        mem[0] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                        mem[32] = 1
                                        if s > !balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]]:
                                            revert with 0, 17
                                        if s + balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] < s:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]]
                                        t = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                        continue 
                                    if stor19.length <= 9:
                                        idx = 0
                                        t = 0
                                        u = 1440
                                        while idx < stor19.length:
                                            mem[0] = stor19[idx]
                                            mem[32] = 1
                                            if balanceOf[stor19[idx]] < 10000000000 * 10^18:
                                                if idx == -1:
                                                    revert with 0, 17
                                                idx = idx + 1
                                                t = t
                                                u = stor19[idx]
                                                continue 
                                            mem[0] = stor19[idx]
                                            mem[32] = 1
                                            if not balanceOf[stor19[idx]]:
                                                _17055 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_17055] = 26
                                                mem[_17055 + 32] = 'SafeMath: division by zero'
                                                if not 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                    _17543 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _17543 + 68] = mem[idx + _17055 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_17543 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _17543 + -mem[64] + 100
                                                if 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                    _20288 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_20288] = 26
                                                    mem[_20288 + 32] = 'SafeMath: division by zero'
                                                    mem[mem[64] + 4] = stor19[idx]
                                                    mem[mem[64] + 36] = 0
                                                    require ext_code.size(dogeAddress)
                                                    call dogeAddress.0xa9059cbb with:
                                                         gas gas_remaining wei
                                                        args stor19[idx], 0
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _22153 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_22153] == bool(mem[_22153])
                                                if idx == -1:
                                                    revert with 0, 17
                                                idx = idx + 1
                                                t = 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s
                                                u = stor19[idx]
                                                continue 
                                            if balanceOf[stor19[idx]] and 10000 > -1 / balanceOf[stor19[idx]]:
                                                revert with 0, 17
                                            if not balanceOf[stor19[idx]]:
                                                revert with 0, 18
                                            if 10000 * balanceOf[stor19[idx]] / balanceOf[stor19[idx]] != 10000:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _18323 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_18323] = 26
                                            mem[_18323 + 32] = 'SafeMath: division by zero'
                                            if not 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                _19013 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _19013 + 68] = mem[idx + _18323 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_19013 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _19013 + -mem[64] + 100
                                            if 10000 * balanceOf[stor19[idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                _21248 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_21248] = 26
                                                mem[_21248 + 32] = 'SafeMath: division by zero'
                                                mem[mem[64] + 4] = stor19[idx]
                                                mem[mem[64] + 36] = 0
                                                require ext_code.size(dogeAddress)
                                                call dogeAddress.0xa9059cbb with:
                                                     gas gas_remaining wei
                                                    args stor19[idx], 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _22988 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_22988] == bool(mem[_22988])
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            t = 10000 * balanceOf[stor19[idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s
                                            u = stor19[idx]
                                            continue 
                                        mem[0] = msg.sender
                                        mem[32] = 14
                                        if stor14[address(msg.sender)]:
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not arg1:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            _17048 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_17048] = 38
                                            mem[_17048 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                            if arg2 > balanceOf[address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 38
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17048 + 70 len 26]
                                                var79001 = 64
                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                            if balanceOf[address(msg.sender)] < arg2:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2
                                            if balanceOf[arg1] > !arg2:
                                                revert with 0, 17
                                            if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                            emit Transfer(arg2, msg.sender, arg1);
                                        else:
                                            mem[0] = arg1
                                            mem[32] = 14
                                            if stor14[address(arg1)]:
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not arg1:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _17337 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_17337] = 38
                                                mem[_17337 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if arg2 > balanceOf[address(msg.sender)]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17337 + 70 len 26]
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(msg.sender)] < arg2:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= arg2
                                                if balanceOf[arg1] > !arg2:
                                                    revert with 0, 17
                                                if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                emit Transfer(arg2, msg.sender, arg1);
                                            else:
                                                if stor10:
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not arg1:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _17051 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_17051] = 38
                                                    mem[_17051 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if arg2 > balanceOf[address(msg.sender)]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17051 + 70 len 26]
                                                        var79001 = 64
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(msg.sender)] < arg2:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2
                                                    if balanceOf[arg1] > !arg2:
                                                        revert with 0, 17
                                                    if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                    emit Transfer(arg2, msg.sender, arg1);
                                                else:
                                                    _16536 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_16536] = 26
                                                    mem[_16536 + 32] = 'SafeMath: division by zero'
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not stor13:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _19009 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_19009] = 38
                                                    mem[_19009 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_19009 + 70 len 26]
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(msg.sender)] < arg2 / 100:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2 / 100
                                                    if balanceOf[stor13] > !(arg2 / 100):
                                                        revert with 0, 17
                                                    if balanceOf[stor13] + (arg2 / 100) < balanceOf[stor13]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = stor13
                                                    mem[32] = 1
                                                    balanceOf[stor13] += arg2 / 100
                                                    emit Transfer((arg2 / 100), msg.sender, stor13);
                                                    _22636 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_22636] = 26
                                                    mem[_22636 + 32] = 'SafeMath: division by zero'
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not sub_8230af5aAddress:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _23489 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_23489] = 38
                                                    mem[_23489 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_23489 + 70 len 26]
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(msg.sender)] < arg2 / 100:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2 / 100
                                                    if balanceOf[stor9] > !(arg2 / 100):
                                                        revert with 0, 17
                                                    if balanceOf[stor9] + (arg2 / 100) < balanceOf[stor9]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = sub_8230af5aAddress
                                                    mem[32] = 1
                                                    balanceOf[stor9] += arg2 / 100
                                                    emit Transfer((arg2 / 100), msg.sender, sub_8230af5aAddress);
                                                    _24325 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_24325] = 26
                                                    mem[_24325 + 32] = 'SafeMath: division by zero'
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not uniswapV2PairAddress:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _24549 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_24549] = 38
                                                    mem[_24549 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_24549 + 70 len 26]
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(msg.sender)] < arg2 / 100:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2 / 100
                                                    if balanceOf[stor7] > !(arg2 / 100):
                                                        revert with 0, 17
                                                    if balanceOf[stor7] + (arg2 / 100) < balanceOf[stor7]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = uniswapV2PairAddress
                                                    mem[32] = 1
                                                    balanceOf[stor7] += arg2 / 100
                                                    emit Transfer((arg2 / 100), msg.sender, uniswapV2PairAddress);
                                                    _25313 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_25313] = 26
                                                    mem[_25313 + 32] = 'SafeMath: division by zero'
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not this.address:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _25537 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_25537] = 38
                                                    mem[_25537 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if arg2 / 10 > balanceOf[address(msg.sender)]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_25537 + 70 len 26]
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(msg.sender)] < arg2 / 10:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2 / 10
                                                    if balanceOf[this.address] > !(arg2 / 10):
                                                        revert with 0, 17
                                                    if balanceOf[this.address] + (arg2 / 10) < balanceOf[this.address]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = this.address
                                                    mem[32] = 1
                                                    balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 10)
                                                    emit Transfer((arg2 / 10), msg.sender, this.address);
                                                    _26301 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_26301] = 26
                                                    mem[_26301 + 32] = 'SafeMath: division by zero'
                                                    if not arg2 / 100:
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not arg1:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        _26556 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_26556] = 38
                                                        mem[_26556 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if 0 > balanceOf[address(msg.sender)]:
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 38
                                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_26556 + 70 len 26]
                                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                        if balanceOf[address(msg.sender)] < 0:
                                                            revert with 0, 17
                                                        if balanceOf[arg1] > -1:
                                                            revert with 0, 17
                                                        if balanceOf[arg1] < balanceOf[arg1]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(arg1)] = balanceOf[arg1]
                                                        emit Transfer(0, msg.sender, arg1);
                                                    else:
                                                        if arg2 / 100 and 87 > -1 / arg2 / 100:
                                                            revert with 0, 17
                                                        if not arg2 / 100:
                                                            revert with 0, 18
                                                        if 87 * arg2 / 100 / arg2 / 100 != 87:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not arg1:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        _27145 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_27145] = 38
                                                        mem[_27145 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if 87 * arg2 / 100 > balanceOf[address(msg.sender)]:
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 38
                                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_27145 + 70 len 26]
                                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                        if balanceOf[address(msg.sender)] < 87 * arg2 / 100:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] += -87 * arg2 / 100
                                                        if balanceOf[arg1] > !(87 * arg2 / 100):
                                                            revert with 0, 17
                                                        if balanceOf[arg1] + (87 * arg2 / 100) < balanceOf[arg1]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(arg1)] = balanceOf[arg1] + (87 * arg2 / 100)
                                                        emit Transfer((87 * arg2 / 100), msg.sender, arg1);
                                    else:
                                        idx = 0
                                        t = 0
                                        u = 1440
                                        while idx < 9:
                                            if block.timestamp % stor19.length - 9 > !idx:
                                                revert with 0, 17
                                            if (block.timestamp % stor19.length - 9) + idx >= stor19.length:
                                                revert with 0, 50
                                            mem[0] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                            mem[32] = 1
                                            if balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] < 10000000000 * 10^18:
                                                if idx == -1:
                                                    revert with 0, 17
                                                idx = idx + 1
                                                t = t
                                                u = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                                continue 
                                            mem[0] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                            mem[32] = 1
                                            if not balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]]:
                                                _17738 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_17738] = 26
                                                mem[_17738 + 32] = 'SafeMath: division by zero'
                                                if not 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                    _18030 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _18030 + 68] = mem[idx + _17738 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_18030 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _18030 + -mem[64] + 100
                                                if 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                    _20886 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_20886] = 26
                                                    mem[_20886 + 32] = 'SafeMath: division by zero'
                                                    mem[mem[64] + 4] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                                    mem[mem[64] + 36] = 0
                                                    require ext_code.size(dogeAddress)
                                                    call dogeAddress.0xa9059cbb with:
                                                         gas gas_remaining wei
                                                        args stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx], 0
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _22738 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_22738] == bool(mem[_22738])
                                                if idx == -1:
                                                    revert with 0, 17
                                                idx = idx + 1
                                                t = 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s
                                                u = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                                continue 
                                            if balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] and 10000 > -1 / balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]]:
                                                revert with 0, 17
                                            if not balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]]:
                                                revert with 0, 18
                                            if 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] != 10000:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _19254 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_19254] = 26
                                            mem[_19254 + 32] = 'SafeMath: division by zero'
                                            if not 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                _19569 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _19569 + 68] = mem[idx + _19254 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_19569 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _19569 + -mem[64] + 100
                                            if 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                _22160 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_22160] = 26
                                                mem[_22160 + 32] = 'SafeMath: division by zero'
                                                mem[mem[64] + 4] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                                mem[mem[64] + 36] = 0
                                                require ext_code.size(dogeAddress)
                                                call dogeAddress.0xa9059cbb with:
                                                     gas gas_remaining wei
                                                    args stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx], 0
                                                mem[mem[64]] = ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _23170 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 32
                                                require mem[_23170] == bool(mem[_23170])
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            t = 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s
                                            u = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                            continue 
                                        mem[0] = msg.sender
                                        mem[32] = 14
                                        if stor14[address(msg.sender)]:
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not arg1:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            _17056 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_17056] = 38
                                            mem[_17056 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                            if arg2 > balanceOf[address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 38
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17056 + 70 len 26]
                                                var79001 = 64
                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                            if balanceOf[address(msg.sender)] < arg2:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2
                                            if balanceOf[arg1] > !arg2:
                                                revert with 0, 17
                                            if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                            emit Transfer(arg2, msg.sender, arg1);
                                        else:
                                            mem[0] = arg1
                                            mem[32] = 14
                                            if stor14[address(arg1)]:
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not arg1:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _17342 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_17342] = 38
                                                mem[_17342 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if arg2 > balanceOf[address(msg.sender)]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17342 + 70 len 26]
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(msg.sender)] < arg2:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= arg2
                                                if balanceOf[arg1] > !arg2:
                                                    revert with 0, 17
                                                if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                emit Transfer(arg2, msg.sender, arg1);
                                            else:
                                                if stor10:
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not arg1:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _17059 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_17059] = 38
                                                    mem[_17059 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if arg2 > balanceOf[address(msg.sender)]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17059 + 70 len 26]
                                                        var79001 = 64
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(msg.sender)] < arg2:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2
                                                    if balanceOf[arg1] > !arg2:
                                                        revert with 0, 17
                                                    if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                    emit Transfer(arg2, msg.sender, arg1);
                                                else:
                                                    _16537 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_16537] = 26
                                                    mem[_16537 + 32] = 'SafeMath: division by zero'
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not stor13:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _19017 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_19017] = 38
                                                    mem[_19017 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_19017 + 70 len 26]
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(msg.sender)] < arg2 / 100:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2 / 100
                                                    if balanceOf[stor13] > !(arg2 / 100):
                                                        revert with 0, 17
                                                    if balanceOf[stor13] + (arg2 / 100) < balanceOf[stor13]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = stor13
                                                    mem[32] = 1
                                                    balanceOf[stor13] += arg2 / 100
                                                    emit Transfer((arg2 / 100), msg.sender, stor13);
                                                    _22639 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_22639] = 26
                                                    mem[_22639 + 32] = 'SafeMath: division by zero'
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not sub_8230af5aAddress:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _23492 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_23492] = 38
                                                    mem[_23492 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_23492 + 70 len 26]
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(msg.sender)] < arg2 / 100:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2 / 100
                                                    if balanceOf[stor9] > !(arg2 / 100):
                                                        revert with 0, 17
                                                    if balanceOf[stor9] + (arg2 / 100) < balanceOf[stor9]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = sub_8230af5aAddress
                                                    mem[32] = 1
                                                    balanceOf[stor9] += arg2 / 100
                                                    emit Transfer((arg2 / 100), msg.sender, sub_8230af5aAddress);
                                                    _24326 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_24326] = 26
                                                    mem[_24326 + 32] = 'SafeMath: division by zero'
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not uniswapV2PairAddress:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _24552 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_24552] = 38
                                                    mem[_24552 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_24552 + 70 len 26]
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(msg.sender)] < arg2 / 100:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2 / 100
                                                    if balanceOf[stor7] > !(arg2 / 100):
                                                        revert with 0, 17
                                                    if balanceOf[stor7] + (arg2 / 100) < balanceOf[stor7]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = uniswapV2PairAddress
                                                    mem[32] = 1
                                                    balanceOf[stor7] += arg2 / 100
                                                    emit Transfer((arg2 / 100), msg.sender, uniswapV2PairAddress);
                                                    _25314 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_25314] = 26
                                                    mem[_25314 + 32] = 'SafeMath: division by zero'
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not this.address:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _25540 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_25540] = 38
                                                    mem[_25540 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if arg2 / 10 > balanceOf[address(msg.sender)]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_25540 + 70 len 26]
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(msg.sender)] < arg2 / 10:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2 / 10
                                                    if balanceOf[this.address] > !(arg2 / 10):
                                                        revert with 0, 17
                                                    if balanceOf[this.address] + (arg2 / 10) < balanceOf[this.address]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = this.address
                                                    mem[32] = 1
                                                    balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 10)
                                                    emit Transfer((arg2 / 10), msg.sender, this.address);
                                                    _26302 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_26302] = 26
                                                    mem[_26302 + 32] = 'SafeMath: division by zero'
                                                    if not arg2 / 100:
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not arg1:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        _26560 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_26560] = 38
                                                        mem[_26560 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if 0 > balanceOf[address(msg.sender)]:
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 38
                                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_26560 + 70 len 26]
                                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                        if balanceOf[address(msg.sender)] < 0:
                                                            revert with 0, 17
                                                        if balanceOf[arg1] > -1:
                                                            revert with 0, 17
                                                        if balanceOf[arg1] < balanceOf[arg1]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(arg1)] = balanceOf[arg1]
                                                        emit Transfer(0, msg.sender, arg1);
                                                    else:
                                                        if arg2 / 100 and 87 > -1 / arg2 / 100:
                                                            revert with 0, 17
                                                        if not arg2 / 100:
                                                            revert with 0, 18
                                                        if 87 * arg2 / 100 / arg2 / 100 != 87:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not arg1:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        _27150 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_27150] = 38
                                                        mem[_27150 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if 87 * arg2 / 100 > balanceOf[address(msg.sender)]:
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 38
                                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_27150 + 70 len 26]
                                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                        if balanceOf[address(msg.sender)] < 87 * arg2 / 100:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] += -87 * arg2 / 100
                                                        if balanceOf[arg1] > !(87 * arg2 / 100):
                                                            revert with 0, 17
                                                        if balanceOf[arg1] + (87 * arg2 / 100) < balanceOf[arg1]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(arg1)] = balanceOf[arg1] + (87 * arg2 / 100)
                                                        emit Transfer((87 * arg2 / 100), msg.sender, arg1);
                        else:
                            if ext_call.return_data[0] and 4 > -1 / ext_call.return_data[0]:
                                revert with 0, 17
                            if not ext_call.return_data[0]:
                                revert with 0, 18
                            if 4 * ext_call.return_data[0] / ext_call.return_data[0] != 4:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[64] = ceil32(return_data.size) + 160
                            mem[ceil32(return_data.size) + 96] = 26
                            mem[ceil32(return_data.size) + 128] = 'SafeMath: division by zero'
                            if not stor19.length:
                                if not msg.sender:
                                    revert with 0, 'ERC20: transfer from the zero address'
                                if stor14[address(msg.sender)]:
                                    if not arg1:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    if arg2 > balanceOf[address(msg.sender)]:
                                        revert with 0, 
                                                    32,
                                                    38,
                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 230 len 26] >> 48,
                                                    0
                                    if balanceOf[address(msg.sender)] < arg2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)] -= arg2
                                    if balanceOf[arg1] > !arg2:
                                        revert with 0, 17
                                    if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                    emit Transfer(arg2, msg.sender, arg1);
                                else:
                                    if stor14[address(arg1)]:
                                        if not arg1:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        if arg2 > balanceOf[address(msg.sender)]:
                                            revert with 0, 
                                                        32,
                                                        38,
                                                        0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 230 len 26] >> 48,
                                                        0
                                        if balanceOf[address(msg.sender)] < arg2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2
                                        if balanceOf[arg1] > !arg2:
                                            revert with 0, 17
                                        if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                        emit Transfer(arg2, msg.sender, arg1);
                                    else:
                                        if stor10:
                                            if not arg1:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            if arg2 > balanceOf[address(msg.sender)]:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 230 len 26] >> 48,
                                                            0
                                            if balanceOf[address(msg.sender)] < arg2:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2
                                            if balanceOf[arg1] > !arg2:
                                                revert with 0, 17
                                            if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                            emit Transfer(arg2, msg.sender, arg1);
                                        else:
                                            if not stor13:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 294 len 26] >> 48,
                                                            0
                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                            if balanceOf[stor13] > !(arg2 / 100):
                                                revert with 0, 17
                                            if balanceOf[stor13] + (arg2 / 100) < balanceOf[stor13]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[stor13] += arg2 / 100
                                            emit Transfer((arg2 / 100), msg.sender, stor13);
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not sub_8230af5aAddress:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 454 len 26] >> 48,
                                                            0
                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                            if balanceOf[stor9] > !(arg2 / 100):
                                                revert with 0, 17
                                            if balanceOf[stor9] + (arg2 / 100) < balanceOf[stor9]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[stor9] += arg2 / 100
                                            emit Transfer((arg2 / 100), msg.sender, sub_8230af5aAddress);
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not uniswapV2PairAddress:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 614 len 26] >> 48,
                                                            0
                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                            if balanceOf[stor7] > !(arg2 / 100):
                                                revert with 0, 17
                                            if balanceOf[stor7] + (arg2 / 100) < balanceOf[stor7]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[stor7] += arg2 / 100
                                            emit Transfer((arg2 / 100), msg.sender, uniswapV2PairAddress);
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not this.address:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            if arg2 / 10 > balanceOf[address(msg.sender)]:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 774 len 26] >> 48,
                                                            0
                                            if balanceOf[address(msg.sender)] < arg2 / 10:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2 / 10
                                            if balanceOf[this.address] > !(arg2 / 10):
                                                revert with 0, 17
                                            if balanceOf[this.address] + (arg2 / 10) < balanceOf[this.address]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 10)
                                            emit Transfer((arg2 / 10), msg.sender, this.address);
                                            if not arg2 / 100:
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not arg1:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                if 0 > balanceOf[address(msg.sender)]:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 934 len 26] >> 48,
                                                                0
                                                if balanceOf[address(msg.sender)] < 0:
                                                    revert with 0, 17
                                                if balanceOf[arg1] > -1:
                                                    revert with 0, 17
                                                if balanceOf[arg1] < balanceOf[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(arg1)] = balanceOf[arg1]
                                                emit Transfer(0, msg.sender, arg1);
                                            else:
                                                if arg2 / 100 and 87 > -1 / arg2 / 100:
                                                    revert with 0, 17
                                                if not arg2 / 100:
                                                    revert with 0, 18
                                                if 87 * arg2 / 100 / arg2 / 100 != 87:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not arg1:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                if 87 * arg2 / 100 > balanceOf[address(msg.sender)]:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 934 len 26] >> 48,
                                                                0
                                                if balanceOf[address(msg.sender)] < 87 * arg2 / 100:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] += -87 * arg2 / 100
                                                if balanceOf[arg1] > !(87 * arg2 / 100):
                                                    revert with 0, 17
                                                if balanceOf[arg1] + (87 * arg2 / 100) < balanceOf[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(arg1)] = balanceOf[arg1] + (87 * arg2 / 100)
                                                emit Transfer((87 * arg2 / 100), msg.sender, arg1);
                            else:
                                if stor19.length <= 9:
                                    idx = 0
                                    s = 0
                                    t = 0
                                    while idx < stor19.length:
                                        mem[0] = stor19[idx]
                                        mem[32] = 1
                                        if s > !balanceOf[stor19[idx]]:
                                            revert with 0, 17
                                        if s + balanceOf[stor19[idx]] < s:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + balanceOf[stor19[idx]]
                                        t = stor19[idx]
                                        continue 
                                    if stor19.length <= 9:
                                        idx = 0
                                        t = 0
                                        u = 160 * stor19.length
                                        while idx < stor19.length:
                                            mem[0] = stor19[idx]
                                            mem[32] = 1
                                            if balanceOf[stor19[idx]] < 10000000000 * 10^18:
                                                if idx == -1:
                                                    revert with 0, 17
                                                idx = idx + 1
                                                t = t
                                                u = stor19[idx]
                                                continue 
                                            mem[0] = stor19[idx]
                                            mem[32] = 1
                                            if not balanceOf[stor19[idx]]:
                                                _17010 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_17010] = 26
                                                mem[_17010 + 32] = 'SafeMath: division by zero'
                                                if not s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                    _17522 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _17522 + 68] = mem[idx + _17010 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_17522 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _17522 + -mem[64] + 100
                                                if 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                    if not 4 * ext_call.return_data[0] / 5:
                                                        _20246 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_20246] = 26
                                                        mem[_20246 + 32] = 'SafeMath: division by zero'
                                                        mem[mem[64] + 4] = stor19[idx]
                                                        mem[mem[64] + 36] = 0
                                                        require ext_code.size(dogeAddress)
                                                        call dogeAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args stor19[idx], 0
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _22109 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_22109] == bool(mem[_22109])
                                                    else:
                                                        if 4 * ext_call.return_data[0] / 5 and 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length > -1 / 4 * ext_call.return_data[0] / 5:
                                                            revert with 0, 17
                                                        if not 4 * ext_call.return_data[0] / 5:
                                                            revert with 0, 18
                                                        if 4 * ext_call.return_data[0] / 5 * 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 4 * ext_call.return_data[0] / 5 != 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _21232 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_21232] = 26
                                                        mem[_21232 + 32] = 'SafeMath: division by zero'
                                                        mem[mem[64] + 4] = stor19[idx]
                                                        mem[mem[64] + 36] = 4 * ext_call.return_data[0] / 5 * 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 10000
                                                        require ext_code.size(dogeAddress)
                                                        call dogeAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args stor19[idx], 4 * ext_call.return_data[0] / 5 * 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 10000
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _22982 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_22982] == bool(mem[_22982])
                                                if idx == -1:
                                                    revert with 0, 17
                                                idx = idx + 1
                                                t = 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length
                                                u = stor19[idx]
                                                continue 
                                            if balanceOf[stor19[idx]] and 10000 > -1 / balanceOf[stor19[idx]]:
                                                revert with 0, 17
                                            if not balanceOf[stor19[idx]]:
                                                revert with 0, 18
                                            if 10000 * balanceOf[stor19[idx]] / balanceOf[stor19[idx]] != 10000:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _18281 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_18281] = 26
                                            mem[_18281 + 32] = 'SafeMath: division by zero'
                                            if not s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                _18965 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _18965 + 68] = mem[idx + _18281 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_18965 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _18965 + -mem[64] + 100
                                            if 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                if not 4 * ext_call.return_data[0] / 5:
                                                    _21231 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_21231] = 26
                                                    mem[_21231 + 32] = 'SafeMath: division by zero'
                                                    mem[mem[64] + 4] = stor19[idx]
                                                    mem[mem[64] + 36] = 0
                                                    require ext_code.size(dogeAddress)
                                                    call dogeAddress.0xa9059cbb with:
                                                         gas gas_remaining wei
                                                        args stor19[idx], 0
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _22981 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_22981] == bool(mem[_22981])
                                                else:
                                                    if 4 * ext_call.return_data[0] / 5 and 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length > -1 / 4 * ext_call.return_data[0] / 5:
                                                        revert with 0, 17
                                                    if not 4 * ext_call.return_data[0] / 5:
                                                        revert with 0, 18
                                                    if 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 4 * ext_call.return_data[0] / 5 != 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _22733 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_22733] = 26
                                                    mem[_22733 + 32] = 'SafeMath: division by zero'
                                                    mem[mem[64] + 4] = stor19[idx]
                                                    mem[mem[64] + 36] = 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 10000
                                                    require ext_code.size(dogeAddress)
                                                    call dogeAddress.0xa9059cbb with:
                                                         gas gas_remaining wei
                                                        args stor19[idx], 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 10000
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _23348 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_23348] == bool(mem[_23348])
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            t = 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length
                                            u = stor19[idx]
                                            continue 
                                        mem[0] = msg.sender
                                        mem[32] = 14
                                        if stor14[address(msg.sender)]:
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not arg1:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            _17003 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_17003] = 38
                                            mem[_17003 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                            if arg2 > balanceOf[address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 38
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17003 + 70 len 26]
                                                var74001 = 64
                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                            if balanceOf[address(msg.sender)] < arg2:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2
                                            if balanceOf[arg1] > !arg2:
                                                revert with 0, 17
                                            if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                            emit Transfer(arg2, msg.sender, arg1);
                                        else:
                                            mem[0] = arg1
                                            mem[32] = 14
                                            if stor14[address(arg1)]:
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not arg1:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _17307 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_17307] = 38
                                                mem[_17307 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if arg2 > balanceOf[address(msg.sender)]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17307 + 70 len 26]
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(msg.sender)] < arg2:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= arg2
                                                if balanceOf[arg1] > !arg2:
                                                    revert with 0, 17
                                                if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                emit Transfer(arg2, msg.sender, arg1);
                                            else:
                                                if stor10:
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not arg1:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _17006 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_17006] = 38
                                                    mem[_17006 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if arg2 > balanceOf[address(msg.sender)]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17006 + 70 len 26]
                                                        var74001 = 64
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(msg.sender)] < arg2:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2
                                                    if balanceOf[arg1] > !arg2:
                                                        revert with 0, 17
                                                    if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                    emit Transfer(arg2, msg.sender, arg1);
                                                else:
                                                    _16527 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_16527] = 26
                                                    mem[_16527 + 32] = 'SafeMath: division by zero'
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not stor13:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _18961 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_18961] = 38
                                                    mem[_18961 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_18961 + 70 len 26]
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(msg.sender)] < arg2 / 100:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2 / 100
                                                    if balanceOf[stor13] > !(arg2 / 100):
                                                        revert with 0, 17
                                                    if balanceOf[stor13] + (arg2 / 100) < balanceOf[stor13]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = stor13
                                                    mem[32] = 1
                                                    balanceOf[stor13] += arg2 / 100
                                                    emit Transfer((arg2 / 100), msg.sender, stor13);
                                                    _22619 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_22619] = 26
                                                    mem[_22619 + 32] = 'SafeMath: division by zero'
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not sub_8230af5aAddress:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _23467 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_23467] = 38
                                                    mem[_23467 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_23467 + 70 len 26]
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(msg.sender)] < arg2 / 100:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2 / 100
                                                    if balanceOf[stor9] > !(arg2 / 100):
                                                        revert with 0, 17
                                                    if balanceOf[stor9] + (arg2 / 100) < balanceOf[stor9]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = sub_8230af5aAddress
                                                    mem[32] = 1
                                                    balanceOf[stor9] += arg2 / 100
                                                    emit Transfer((arg2 / 100), msg.sender, sub_8230af5aAddress);
                                                    _24319 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_24319] = 26
                                                    mem[_24319 + 32] = 'SafeMath: division by zero'
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not uniswapV2PairAddress:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _24531 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_24531] = 38
                                                    mem[_24531 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_24531 + 70 len 26]
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(msg.sender)] < arg2 / 100:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2 / 100
                                                    if balanceOf[stor7] > !(arg2 / 100):
                                                        revert with 0, 17
                                                    if balanceOf[stor7] + (arg2 / 100) < balanceOf[stor7]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = uniswapV2PairAddress
                                                    mem[32] = 1
                                                    balanceOf[stor7] += arg2 / 100
                                                    emit Transfer((arg2 / 100), msg.sender, uniswapV2PairAddress);
                                                    _25307 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_25307] = 26
                                                    mem[_25307 + 32] = 'SafeMath: division by zero'
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not this.address:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _25519 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_25519] = 38
                                                    mem[_25519 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if arg2 / 10 > balanceOf[address(msg.sender)]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_25519 + 70 len 26]
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(msg.sender)] < arg2 / 10:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2 / 10
                                                    if balanceOf[this.address] > !(arg2 / 10):
                                                        revert with 0, 17
                                                    if balanceOf[this.address] + (arg2 / 10) < balanceOf[this.address]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = this.address
                                                    mem[32] = 1
                                                    balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 10)
                                                    emit Transfer((arg2 / 10), msg.sender, this.address);
                                                    _26295 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_26295] = 26
                                                    mem[_26295 + 32] = 'SafeMath: division by zero'
                                                    if not arg2 / 100:
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not arg1:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        _26532 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_26532] = 38
                                                        mem[_26532 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if 0 > balanceOf[address(msg.sender)]:
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 38
                                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_26532 + 70 len 26]
                                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                        if balanceOf[address(msg.sender)] < 0:
                                                            revert with 0, 17
                                                        if balanceOf[arg1] > -1:
                                                            revert with 0, 17
                                                        if balanceOf[arg1] < balanceOf[arg1]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(arg1)] = balanceOf[arg1]
                                                        emit Transfer(0, msg.sender, arg1);
                                                    else:
                                                        if arg2 / 100 and 87 > -1 / arg2 / 100:
                                                            revert with 0, 17
                                                        if not arg2 / 100:
                                                            revert with 0, 18
                                                        if 87 * arg2 / 100 / arg2 / 100 != 87:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not arg1:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        _27115 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_27115] = 38
                                                        mem[_27115 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if 87 * arg2 / 100 > balanceOf[address(msg.sender)]:
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 38
                                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_27115 + 70 len 26]
                                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                        if balanceOf[address(msg.sender)] < 87 * arg2 / 100:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] += -87 * arg2 / 100
                                                        if balanceOf[arg1] > !(87 * arg2 / 100):
                                                            revert with 0, 17
                                                        if balanceOf[arg1] + (87 * arg2 / 100) < balanceOf[arg1]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(arg1)] = balanceOf[arg1] + (87 * arg2 / 100)
                                                        emit Transfer((87 * arg2 / 100), msg.sender, arg1);
                                    else:
                                        idx = 0
                                        t = 0
                                        u = 160 * stor19.length
                                        while idx < 9:
                                            if 0 > !idx:
                                                revert with 0, 17
                                            if idx >= stor19.length:
                                                revert with 0, 50
                                            mem[0] = stor19[idx]
                                            mem[32] = 1
                                            if balanceOf[stor19[idx]] < 10000000000 * 10^18:
                                                if idx == -1:
                                                    revert with 0, 17
                                                idx = idx + 1
                                                t = t
                                                u = stor19[idx]
                                                continue 
                                            mem[0] = stor19[idx]
                                            mem[32] = 1
                                            if not balanceOf[stor19[idx]]:
                                                _17714 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_17714] = 26
                                                mem[_17714 + 32] = 'SafeMath: division by zero'
                                                if not s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                    _18009 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _18009 + 68] = mem[idx + _17714 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_18009 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _18009 + -mem[64] + 100
                                                if 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                    if not 4 * ext_call.return_data[0] / 5:
                                                        _20868 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_20868] = 26
                                                        mem[_20868 + 32] = 'SafeMath: division by zero'
                                                        mem[mem[64] + 4] = stor19[idx]
                                                        mem[mem[64] + 36] = 0
                                                        require ext_code.size(dogeAddress)
                                                        call dogeAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args stor19[idx], 0
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _22734 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_22734] == bool(mem[_22734])
                                                    else:
                                                        if 4 * ext_call.return_data[0] / 5 and 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length > -1 / 4 * ext_call.return_data[0] / 5:
                                                            revert with 0, 17
                                                        if not 4 * ext_call.return_data[0] / 5:
                                                            revert with 0, 18
                                                        if 4 * ext_call.return_data[0] / 5 * 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 4 * ext_call.return_data[0] / 5 != 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _22117 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_22117] = 26
                                                        mem[_22117 + 32] = 'SafeMath: division by zero'
                                                        mem[mem[64] + 4] = stor19[idx]
                                                        mem[mem[64] + 36] = 4 * ext_call.return_data[0] / 5 * 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 10000
                                                        require ext_code.size(dogeAddress)
                                                        call dogeAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args stor19[idx], 4 * ext_call.return_data[0] / 5 * 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 10000
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _23166 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_23166] == bool(mem[_23166])
                                                if idx == -1:
                                                    revert with 0, 17
                                                idx = idx + 1
                                                t = 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length
                                                u = stor19[idx]
                                                continue 
                                            if balanceOf[stor19[idx]] and 10000 > -1 / balanceOf[stor19[idx]]:
                                                revert with 0, 17
                                            if not balanceOf[stor19[idx]]:
                                                revert with 0, 18
                                            if 10000 * balanceOf[stor19[idx]] / balanceOf[stor19[idx]] != 10000:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _19236 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_19236] = 26
                                            mem[_19236 + 32] = 'SafeMath: division by zero'
                                            if not s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                _19542 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _19542 + 68] = mem[idx + _19236 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_19542 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _19542 + -mem[64] + 100
                                            if 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                if not 4 * ext_call.return_data[0] / 5:
                                                    _22116 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_22116] = 26
                                                    mem[_22116 + 32] = 'SafeMath: division by zero'
                                                    mem[mem[64] + 4] = stor19[idx]
                                                    mem[mem[64] + 36] = 0
                                                    require ext_code.size(dogeAddress)
                                                    call dogeAddress.0xa9059cbb with:
                                                         gas gas_remaining wei
                                                        args stor19[idx], 0
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _23165 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_23165] == bool(mem[_23165])
                                                else:
                                                    if 4 * ext_call.return_data[0] / 5 and 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length > -1 / 4 * ext_call.return_data[0] / 5:
                                                        revert with 0, 17
                                                    if not 4 * ext_call.return_data[0] / 5:
                                                        revert with 0, 18
                                                    if 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 4 * ext_call.return_data[0] / 5 != 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _22983 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_22983] = 26
                                                    mem[_22983 + 32] = 'SafeMath: division by zero'
                                                    mem[mem[64] + 4] = stor19[idx]
                                                    mem[mem[64] + 36] = 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 10000
                                                    require ext_code.size(dogeAddress)
                                                    call dogeAddress.0xa9059cbb with:
                                                         gas gas_remaining wei
                                                        args stor19[idx], 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 10000
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _23653 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_23653] == bool(mem[_23653])
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            t = 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length
                                            u = stor19[idx]
                                            continue 
                                        mem[0] = msg.sender
                                        mem[32] = 14
                                        if stor14[address(msg.sender)]:
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not arg1:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            _17011 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_17011] = 38
                                            mem[_17011 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                            if arg2 > balanceOf[address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 38
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17011 + 70 len 26]
                                                var74001 = 64
                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                            if balanceOf[address(msg.sender)] < arg2:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2
                                            if balanceOf[arg1] > !arg2:
                                                revert with 0, 17
                                            if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                            emit Transfer(arg2, msg.sender, arg1);
                                        else:
                                            mem[0] = arg1
                                            mem[32] = 14
                                            if stor14[address(arg1)]:
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not arg1:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _17312 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_17312] = 38
                                                mem[_17312 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if arg2 > balanceOf[address(msg.sender)]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17312 + 70 len 26]
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(msg.sender)] < arg2:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= arg2
                                                if balanceOf[arg1] > !arg2:
                                                    revert with 0, 17
                                                if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                emit Transfer(arg2, msg.sender, arg1);
                                            else:
                                                if stor10:
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not arg1:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _17014 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_17014] = 38
                                                    mem[_17014 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if arg2 > balanceOf[address(msg.sender)]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17014 + 70 len 26]
                                                        var74001 = 64
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(msg.sender)] < arg2:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2
                                                    if balanceOf[arg1] > !arg2:
                                                        revert with 0, 17
                                                    if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                    emit Transfer(arg2, msg.sender, arg1);
                                                else:
                                                    _16528 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_16528] = 26
                                                    mem[_16528 + 32] = 'SafeMath: division by zero'
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not stor13:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _18969 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_18969] = 38
                                                    mem[_18969 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_18969 + 70 len 26]
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(msg.sender)] < arg2 / 100:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2 / 100
                                                    if balanceOf[stor13] > !(arg2 / 100):
                                                        revert with 0, 17
                                                    if balanceOf[stor13] + (arg2 / 100) < balanceOf[stor13]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = stor13
                                                    mem[32] = 1
                                                    balanceOf[stor13] += arg2 / 100
                                                    emit Transfer((arg2 / 100), msg.sender, stor13);
                                                    _22623 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_22623] = 26
                                                    mem[_22623 + 32] = 'SafeMath: division by zero'
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not sub_8230af5aAddress:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _23470 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_23470] = 38
                                                    mem[_23470 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_23470 + 70 len 26]
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(msg.sender)] < arg2 / 100:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2 / 100
                                                    if balanceOf[stor9] > !(arg2 / 100):
                                                        revert with 0, 17
                                                    if balanceOf[stor9] + (arg2 / 100) < balanceOf[stor9]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = sub_8230af5aAddress
                                                    mem[32] = 1
                                                    balanceOf[stor9] += arg2 / 100
                                                    emit Transfer((arg2 / 100), msg.sender, sub_8230af5aAddress);
                                                    _24320 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_24320] = 26
                                                    mem[_24320 + 32] = 'SafeMath: division by zero'
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not uniswapV2PairAddress:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _24534 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_24534] = 38
                                                    mem[_24534 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_24534 + 70 len 26]
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(msg.sender)] < arg2 / 100:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2 / 100
                                                    if balanceOf[stor7] > !(arg2 / 100):
                                                        revert with 0, 17
                                                    if balanceOf[stor7] + (arg2 / 100) < balanceOf[stor7]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = uniswapV2PairAddress
                                                    mem[32] = 1
                                                    balanceOf[stor7] += arg2 / 100
                                                    emit Transfer((arg2 / 100), msg.sender, uniswapV2PairAddress);
                                                    _25308 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_25308] = 26
                                                    mem[_25308 + 32] = 'SafeMath: division by zero'
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not this.address:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _25522 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_25522] = 38
                                                    mem[_25522 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if arg2 / 10 > balanceOf[address(msg.sender)]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_25522 + 70 len 26]
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(msg.sender)] < arg2 / 10:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2 / 10
                                                    if balanceOf[this.address] > !(arg2 / 10):
                                                        revert with 0, 17
                                                    if balanceOf[this.address] + (arg2 / 10) < balanceOf[this.address]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = this.address
                                                    mem[32] = 1
                                                    balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 10)
                                                    emit Transfer((arg2 / 10), msg.sender, this.address);
                                                    _26296 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_26296] = 26
                                                    mem[_26296 + 32] = 'SafeMath: division by zero'
                                                    if not arg2 / 100:
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not arg1:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        _26536 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_26536] = 38
                                                        mem[_26536 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if 0 > balanceOf[address(msg.sender)]:
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 38
                                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_26536 + 70 len 26]
                                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                        if balanceOf[address(msg.sender)] < 0:
                                                            revert with 0, 17
                                                        if balanceOf[arg1] > -1:
                                                            revert with 0, 17
                                                        if balanceOf[arg1] < balanceOf[arg1]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(arg1)] = balanceOf[arg1]
                                                        emit Transfer(0, msg.sender, arg1);
                                                    else:
                                                        if arg2 / 100 and 87 > -1 / arg2 / 100:
                                                            revert with 0, 17
                                                        if not arg2 / 100:
                                                            revert with 0, 18
                                                        if 87 * arg2 / 100 / arg2 / 100 != 87:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not arg1:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        _27120 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_27120] = 38
                                                        mem[_27120 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if 87 * arg2 / 100 > balanceOf[address(msg.sender)]:
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 38
                                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_27120 + 70 len 26]
                                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                        if balanceOf[address(msg.sender)] < 87 * arg2 / 100:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] += -87 * arg2 / 100
                                                        if balanceOf[arg1] > !(87 * arg2 / 100):
                                                            revert with 0, 17
                                                        if balanceOf[arg1] + (87 * arg2 / 100) < balanceOf[arg1]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(arg1)] = balanceOf[arg1] + (87 * arg2 / 100)
                                                        emit Transfer((87 * arg2 / 100), msg.sender, arg1);
                                else:
                                    if stor19.length < 9:
                                        revert with 0, 17
                                    mem[64] = ceil32(return_data.size) + 224
                                    mem[ceil32(return_data.size) + 160] = 24
                                    mem[ceil32(return_data.size) + 192] = 'SafeMath: modulo by zero'
                                    if not stor19.length - 9:
                                        revert with 0, 'SafeMath: modulo by zero', 0
                                    idx = 0
                                    s = 0
                                    t = 0
                                    while idx < 9:
                                        if block.timestamp % stor19.length - 9 > !idx:
                                            revert with 0, 17
                                        if (block.timestamp % stor19.length - 9) + idx >= stor19.length:
                                            revert with 0, 50
                                        mem[0] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                        mem[32] = 1
                                        if s > !balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]]:
                                            revert with 0, 17
                                        if s + balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] < s:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]]
                                        t = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                        continue 
                                    if stor19.length <= 9:
                                        idx = 0
                                        t = 0
                                        u = 1440
                                        while idx < stor19.length:
                                            mem[0] = stor19[idx]
                                            mem[32] = 1
                                            if balanceOf[stor19[idx]] < 10000000000 * 10^18:
                                                if idx == -1:
                                                    revert with 0, 17
                                                idx = idx + 1
                                                t = t
                                                u = stor19[idx]
                                                continue 
                                            mem[0] = stor19[idx]
                                            mem[32] = 1
                                            if not balanceOf[stor19[idx]]:
                                                _17025 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_17025] = 26
                                                mem[_17025 + 32] = 'SafeMath: division by zero'
                                                if not 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                    _17529 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _17529 + 68] = mem[idx + _17025 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_17529 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _17529 + -mem[64] + 100
                                                if 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                    if not 4 * ext_call.return_data[0] / 5:
                                                        _20260 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_20260] = 26
                                                        mem[_20260 + 32] = 'SafeMath: division by zero'
                                                        mem[mem[64] + 4] = stor19[idx]
                                                        mem[mem[64] + 36] = 0
                                                        require ext_code.size(dogeAddress)
                                                        call dogeAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args stor19[idx], 0
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _22124 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_22124] == bool(mem[_22124])
                                                    else:
                                                        if 4 * ext_call.return_data[0] / 5 and 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s > -1 / 4 * ext_call.return_data[0] / 5:
                                                            revert with 0, 17
                                                        if not 4 * ext_call.return_data[0] / 5:
                                                            revert with 0, 18
                                                        if 4 * ext_call.return_data[0] / 5 * 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 4 * ext_call.return_data[0] / 5 != 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _21238 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_21238] = 26
                                                        mem[_21238 + 32] = 'SafeMath: division by zero'
                                                        mem[mem[64] + 4] = stor19[idx]
                                                        mem[mem[64] + 36] = 4 * ext_call.return_data[0] / 5 * 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 10000
                                                        require ext_code.size(dogeAddress)
                                                        call dogeAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args stor19[idx], 4 * ext_call.return_data[0] / 5 * 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 10000
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _22985 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_22985] == bool(mem[_22985])
                                                if idx == -1:
                                                    revert with 0, 17
                                                idx = idx + 1
                                                t = 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s
                                                u = stor19[idx]
                                                continue 
                                            if balanceOf[stor19[idx]] and 10000 > -1 / balanceOf[stor19[idx]]:
                                                revert with 0, 17
                                            if not balanceOf[stor19[idx]]:
                                                revert with 0, 18
                                            if 10000 * balanceOf[stor19[idx]] / balanceOf[stor19[idx]] != 10000:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _18295 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_18295] = 26
                                            mem[_18295 + 32] = 'SafeMath: division by zero'
                                            if not 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                _18981 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _18981 + 68] = mem[idx + _18295 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_18981 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _18981 + -mem[64] + 100
                                            if 10000 * balanceOf[stor19[idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                if not 4 * ext_call.return_data[0] / 5:
                                                    _21237 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_21237] = 26
                                                    mem[_21237 + 32] = 'SafeMath: division by zero'
                                                    mem[mem[64] + 4] = stor19[idx]
                                                    mem[mem[64] + 36] = 0
                                                    require ext_code.size(dogeAddress)
                                                    call dogeAddress.0xa9059cbb with:
                                                         gas gas_remaining wei
                                                        args stor19[idx], 0
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _22984 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_22984] == bool(mem[_22984])
                                                else:
                                                    if 4 * ext_call.return_data[0] / 5 and 10000 * balanceOf[stor19[idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s > -1 / 4 * ext_call.return_data[0] / 5:
                                                        revert with 0, 17
                                                    if not 4 * ext_call.return_data[0] / 5:
                                                        revert with 0, 18
                                                    if 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor19[idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 4 * ext_call.return_data[0] / 5 != 10000 * balanceOf[stor19[idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _22735 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_22735] = 26
                                                    mem[_22735 + 32] = 'SafeMath: division by zero'
                                                    mem[mem[64] + 4] = stor19[idx]
                                                    mem[mem[64] + 36] = 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor19[idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 10000
                                                    require ext_code.size(dogeAddress)
                                                    call dogeAddress.0xa9059cbb with:
                                                         gas gas_remaining wei
                                                        args stor19[idx], 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor19[idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 10000
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _23351 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_23351] == bool(mem[_23351])
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            t = 10000 * balanceOf[stor19[idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s
                                            u = stor19[idx]
                                            continue 
                                        mem[0] = msg.sender
                                        mem[32] = 14
                                        if stor14[address(msg.sender)]:
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not arg1:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            _17018 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_17018] = 38
                                            mem[_17018 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                            if arg2 > balanceOf[address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 38
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17018 + 70 len 26]
                                                var85001 = 64
                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                            if balanceOf[address(msg.sender)] < arg2:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2
                                            if balanceOf[arg1] > !arg2:
                                                revert with 0, 17
                                            if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                            emit Transfer(arg2, msg.sender, arg1);
                                        else:
                                            mem[0] = arg1
                                            mem[32] = 14
                                            if stor14[address(arg1)]:
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not arg1:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _17317 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_17317] = 38
                                                mem[_17317 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if arg2 > balanceOf[address(msg.sender)]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17317 + 70 len 26]
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(msg.sender)] < arg2:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= arg2
                                                if balanceOf[arg1] > !arg2:
                                                    revert with 0, 17
                                                if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                emit Transfer(arg2, msg.sender, arg1);
                                            else:
                                                if stor10:
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not arg1:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _17021 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_17021] = 38
                                                    mem[_17021 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if arg2 > balanceOf[address(msg.sender)]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17021 + 70 len 26]
                                                        var85001 = 64
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(msg.sender)] < arg2:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2
                                                    if balanceOf[arg1] > !arg2:
                                                        revert with 0, 17
                                                    if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                    emit Transfer(arg2, msg.sender, arg1);
                                                else:
                                                    _16530 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_16530] = 26
                                                    mem[_16530 + 32] = 'SafeMath: division by zero'
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not stor13:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _18977 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_18977] = 38
                                                    mem[_18977 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_18977 + 70 len 26]
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(msg.sender)] < arg2 / 100:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2 / 100
                                                    if balanceOf[stor13] > !(arg2 / 100):
                                                        revert with 0, 17
                                                    if balanceOf[stor13] + (arg2 / 100) < balanceOf[stor13]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = stor13
                                                    mem[32] = 1
                                                    balanceOf[stor13] += arg2 / 100
                                                    emit Transfer((arg2 / 100), msg.sender, stor13);
                                                    _22625 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_22625] = 26
                                                    mem[_22625 + 32] = 'SafeMath: division by zero'
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not sub_8230af5aAddress:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _23475 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_23475] = 38
                                                    mem[_23475 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_23475 + 70 len 26]
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(msg.sender)] < arg2 / 100:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2 / 100
                                                    if balanceOf[stor9] > !(arg2 / 100):
                                                        revert with 0, 17
                                                    if balanceOf[stor9] + (arg2 / 100) < balanceOf[stor9]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = sub_8230af5aAddress
                                                    mem[32] = 1
                                                    balanceOf[stor9] += arg2 / 100
                                                    emit Transfer((arg2 / 100), msg.sender, sub_8230af5aAddress);
                                                    _24321 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_24321] = 26
                                                    mem[_24321 + 32] = 'SafeMath: division by zero'
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not uniswapV2PairAddress:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _24537 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_24537] = 38
                                                    mem[_24537 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_24537 + 70 len 26]
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(msg.sender)] < arg2 / 100:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2 / 100
                                                    if balanceOf[stor7] > !(arg2 / 100):
                                                        revert with 0, 17
                                                    if balanceOf[stor7] + (arg2 / 100) < balanceOf[stor7]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = uniswapV2PairAddress
                                                    mem[32] = 1
                                                    balanceOf[stor7] += arg2 / 100
                                                    emit Transfer((arg2 / 100), msg.sender, uniswapV2PairAddress);
                                                    _25309 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_25309] = 26
                                                    mem[_25309 + 32] = 'SafeMath: division by zero'
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not this.address:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _25525 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_25525] = 38
                                                    mem[_25525 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if arg2 / 10 > balanceOf[address(msg.sender)]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_25525 + 70 len 26]
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(msg.sender)] < arg2 / 10:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2 / 10
                                                    if balanceOf[this.address] > !(arg2 / 10):
                                                        revert with 0, 17
                                                    if balanceOf[this.address] + (arg2 / 10) < balanceOf[this.address]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = this.address
                                                    mem[32] = 1
                                                    balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 10)
                                                    emit Transfer((arg2 / 10), msg.sender, this.address);
                                                    _26297 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_26297] = 26
                                                    mem[_26297 + 32] = 'SafeMath: division by zero'
                                                    if not arg2 / 100:
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not arg1:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        _26540 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_26540] = 38
                                                        mem[_26540 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if 0 > balanceOf[address(msg.sender)]:
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 38
                                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_26540 + 70 len 26]
                                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                        if balanceOf[address(msg.sender)] < 0:
                                                            revert with 0, 17
                                                        if balanceOf[arg1] > -1:
                                                            revert with 0, 17
                                                        if balanceOf[arg1] < balanceOf[arg1]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(arg1)] = balanceOf[arg1]
                                                        emit Transfer(0, msg.sender, arg1);
                                                    else:
                                                        if arg2 / 100 and 87 > -1 / arg2 / 100:
                                                            revert with 0, 17
                                                        if not arg2 / 100:
                                                            revert with 0, 18
                                                        if 87 * arg2 / 100 / arg2 / 100 != 87:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not arg1:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        _27125 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_27125] = 38
                                                        mem[_27125 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if 87 * arg2 / 100 > balanceOf[address(msg.sender)]:
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 38
                                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_27125 + 70 len 26]
                                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                        if balanceOf[address(msg.sender)] < 87 * arg2 / 100:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] += -87 * arg2 / 100
                                                        if balanceOf[arg1] > !(87 * arg2 / 100):
                                                            revert with 0, 17
                                                        if balanceOf[arg1] + (87 * arg2 / 100) < balanceOf[arg1]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(arg1)] = balanceOf[arg1] + (87 * arg2 / 100)
                                                        emit Transfer((87 * arg2 / 100), msg.sender, arg1);
                                    else:
                                        idx = 0
                                        t = 0
                                        u = 1440
                                        while idx < 9:
                                            if block.timestamp % stor19.length - 9 > !idx:
                                                revert with 0, 17
                                            if (block.timestamp % stor19.length - 9) + idx >= stor19.length:
                                                revert with 0, 50
                                            mem[0] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                            mem[32] = 1
                                            if balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] < 10000000000 * 10^18:
                                                if idx == -1:
                                                    revert with 0, 17
                                                idx = idx + 1
                                                t = t
                                                u = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                                continue 
                                            mem[0] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                            mem[32] = 1
                                            if not balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]]:
                                                _17722 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_17722] = 26
                                                mem[_17722 + 32] = 'SafeMath: division by zero'
                                                if not 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                    _18016 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _18016 + 68] = mem[idx + _17722 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_18016 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _18016 + -mem[64] + 100
                                                if 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                    if not 4 * ext_call.return_data[0] / 5:
                                                        _20874 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_20874] = 26
                                                        mem[_20874 + 32] = 'SafeMath: division by zero'
                                                        mem[mem[64] + 4] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                                        mem[mem[64] + 36] = 0
                                                        require ext_code.size(dogeAddress)
                                                        call dogeAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx], 0
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _22736 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_22736] == bool(mem[_22736])
                                                    else:
                                                        if 4 * ext_call.return_data[0] / 5 and 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s > -1 / 4 * ext_call.return_data[0] / 5:
                                                            revert with 0, 17
                                                        if not 4 * ext_call.return_data[0] / 5:
                                                            revert with 0, 18
                                                        if 4 * ext_call.return_data[0] / 5 * 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 4 * ext_call.return_data[0] / 5 != 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _22132 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_22132] = 26
                                                        mem[_22132 + 32] = 'SafeMath: division by zero'
                                                        mem[mem[64] + 4] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                                        mem[mem[64] + 36] = 4 * ext_call.return_data[0] / 5 * 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 10000
                                                        require ext_code.size(dogeAddress)
                                                        call dogeAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx], 4 * ext_call.return_data[0] / 5 * 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 10000
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _23168 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_23168] == bool(mem[_23168])
                                                if idx == -1:
                                                    revert with 0, 17
                                                idx = idx + 1
                                                t = 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s
                                                u = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                                continue 
                                            if balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] and 10000 > -1 / balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]]:
                                                revert with 0, 17
                                            if not balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]]:
                                                revert with 0, 18
                                            if 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] != 10000:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _19242 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_19242] = 26
                                            mem[_19242 + 32] = 'SafeMath: division by zero'
                                            if not 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                _19551 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _19551 + 68] = mem[idx + _19242 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_19551 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _19551 + -mem[64] + 100
                                            if 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                if not 4 * ext_call.return_data[0] / 5:
                                                    _22131 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_22131] = 26
                                                    mem[_22131 + 32] = 'SafeMath: division by zero'
                                                    mem[mem[64] + 4] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                                    mem[mem[64] + 36] = 0
                                                    require ext_code.size(dogeAddress)
                                                    call dogeAddress.0xa9059cbb with:
                                                         gas gas_remaining wei
                                                        args stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx], 0
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _23167 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_23167] == bool(mem[_23167])
                                                else:
                                                    if 4 * ext_call.return_data[0] / 5 and 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s > -1 / 4 * ext_call.return_data[0] / 5:
                                                        revert with 0, 17
                                                    if not 4 * ext_call.return_data[0] / 5:
                                                        revert with 0, 18
                                                    if 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 4 * ext_call.return_data[0] / 5 != 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _22986 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_22986] = 26
                                                    mem[_22986 + 32] = 'SafeMath: division by zero'
                                                    mem[mem[64] + 4] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                                    mem[mem[64] + 36] = 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 10000
                                                    require ext_code.size(dogeAddress)
                                                    call dogeAddress.0xa9059cbb with:
                                                         gas gas_remaining wei
                                                        args stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx], 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 10000
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _23656 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_23656] == bool(mem[_23656])
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            t = 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s
                                            u = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                            continue 
                                        mem[0] = msg.sender
                                        mem[32] = 14
                                        if stor14[address(msg.sender)]:
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not arg1:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            _17026 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_17026] = 38
                                            mem[_17026 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                            if arg2 > balanceOf[address(msg.sender)]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 38
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17026 + 70 len 26]
                                                var85001 = 64
                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                            if balanceOf[address(msg.sender)] < arg2:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2
                                            if balanceOf[arg1] > !arg2:
                                                revert with 0, 17
                                            if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                            emit Transfer(arg2, msg.sender, arg1);
                                        else:
                                            mem[0] = arg1
                                            mem[32] = 14
                                            if stor14[address(arg1)]:
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not arg1:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _17322 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_17322] = 38
                                                mem[_17322 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if arg2 > balanceOf[address(msg.sender)]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17322 + 70 len 26]
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(msg.sender)] < arg2:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= arg2
                                                if balanceOf[arg1] > !arg2:
                                                    revert with 0, 17
                                                if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                emit Transfer(arg2, msg.sender, arg1);
                                            else:
                                                if stor10:
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not arg1:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _17029 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_17029] = 38
                                                    mem[_17029 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if arg2 > balanceOf[address(msg.sender)]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17029 + 70 len 26]
                                                        var85001 = 64
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(msg.sender)] < arg2:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2
                                                    if balanceOf[arg1] > !arg2:
                                                        revert with 0, 17
                                                    if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                    emit Transfer(arg2, msg.sender, arg1);
                                                else:
                                                    _16531 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_16531] = 26
                                                    mem[_16531 + 32] = 'SafeMath: division by zero'
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not stor13:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _18985 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_18985] = 38
                                                    mem[_18985 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_18985 + 70 len 26]
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(msg.sender)] < arg2 / 100:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2 / 100
                                                    if balanceOf[stor13] > !(arg2 / 100):
                                                        revert with 0, 17
                                                    if balanceOf[stor13] + (arg2 / 100) < balanceOf[stor13]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = stor13
                                                    mem[32] = 1
                                                    balanceOf[stor13] += arg2 / 100
                                                    emit Transfer((arg2 / 100), msg.sender, stor13);
                                                    _22629 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_22629] = 26
                                                    mem[_22629 + 32] = 'SafeMath: division by zero'
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not sub_8230af5aAddress:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _23478 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_23478] = 38
                                                    mem[_23478 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_23478 + 70 len 26]
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(msg.sender)] < arg2 / 100:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2 / 100
                                                    if balanceOf[stor9] > !(arg2 / 100):
                                                        revert with 0, 17
                                                    if balanceOf[stor9] + (arg2 / 100) < balanceOf[stor9]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = sub_8230af5aAddress
                                                    mem[32] = 1
                                                    balanceOf[stor9] += arg2 / 100
                                                    emit Transfer((arg2 / 100), msg.sender, sub_8230af5aAddress);
                                                    _24322 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_24322] = 26
                                                    mem[_24322 + 32] = 'SafeMath: division by zero'
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not uniswapV2PairAddress:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _24540 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_24540] = 38
                                                    mem[_24540 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_24540 + 70 len 26]
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(msg.sender)] < arg2 / 100:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2 / 100
                                                    if balanceOf[stor7] > !(arg2 / 100):
                                                        revert with 0, 17
                                                    if balanceOf[stor7] + (arg2 / 100) < balanceOf[stor7]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = uniswapV2PairAddress
                                                    mem[32] = 1
                                                    balanceOf[stor7] += arg2 / 100
                                                    emit Transfer((arg2 / 100), msg.sender, uniswapV2PairAddress);
                                                    _25310 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_25310] = 26
                                                    mem[_25310 + 32] = 'SafeMath: division by zero'
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not this.address:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _25528 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_25528] = 38
                                                    mem[_25528 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if arg2 / 10 > balanceOf[address(msg.sender)]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_25528 + 70 len 26]
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(msg.sender)] < arg2 / 10:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2 / 10
                                                    if balanceOf[this.address] > !(arg2 / 10):
                                                        revert with 0, 17
                                                    if balanceOf[this.address] + (arg2 / 10) < balanceOf[this.address]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    mem[0] = this.address
                                                    mem[32] = 1
                                                    balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 10)
                                                    emit Transfer((arg2 / 10), msg.sender, this.address);
                                                    _26298 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_26298] = 26
                                                    mem[_26298 + 32] = 'SafeMath: division by zero'
                                                    if not arg2 / 100:
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not arg1:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        _26544 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_26544] = 38
                                                        mem[_26544 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if 0 > balanceOf[address(msg.sender)]:
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 38
                                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_26544 + 70 len 26]
                                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                        if balanceOf[address(msg.sender)] < 0:
                                                            revert with 0, 17
                                                        if balanceOf[arg1] > -1:
                                                            revert with 0, 17
                                                        if balanceOf[arg1] < balanceOf[arg1]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(arg1)] = balanceOf[arg1]
                                                        emit Transfer(0, msg.sender, arg1);
                                                    else:
                                                        if arg2 / 100 and 87 > -1 / arg2 / 100:
                                                            revert with 0, 17
                                                        if not arg2 / 100:
                                                            revert with 0, 18
                                                        if 87 * arg2 / 100 / arg2 / 100 != 87:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not arg1:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        _27130 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_27130] = 38
                                                        mem[_27130 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if 87 * arg2 / 100 > balanceOf[address(msg.sender)]:
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 38
                                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_27130 + 70 len 26]
                                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                        if balanceOf[address(msg.sender)] < 87 * arg2 / 100:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] += -87 * arg2 / 100
                                                        if balanceOf[arg1] > !(87 * arg2 / 100):
                                                            revert with 0, 17
                                                        if balanceOf[arg1] + (87 * arg2 / 100) < balanceOf[arg1]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(arg1)] = balanceOf[arg1] + (87 * arg2 / 100)
                                                        emit Transfer((87 * arg2 / 100), msg.sender, arg1);
                else:
                    if uniswapV2PairAddress == msg.sender:
                        mem[100] = this.address
                        require ext_code.size(dogeAddress)
                        staticcall dogeAddress.0x70a08231 with:
                                gas gas_remaining wei
                               args this.address
                        mem[96] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if ext_call.return_data[0] < 10^12:
                            if not msg.sender:
                                revert with 0, 'ERC20: transfer from the zero address'
                            if stor14[address(msg.sender)]:
                                if not arg1:
                                    revert with 0, 'ERC20: transfer to the zero address'
                                if arg2 > balanceOf[address(msg.sender)]:
                                    revert with 0, 
                                                32,
                                                38,
                                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 166 len 26] >> 48,
                                                0
                                if balanceOf[address(msg.sender)] < arg2:
                                    revert with 0, 17
                                balanceOf[address(msg.sender)] -= arg2
                                if balanceOf[arg1] > !arg2:
                                    revert with 0, 17
                                if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                emit Transfer(arg2, msg.sender, arg1);
                            else:
                                if stor14[address(arg1)]:
                                    if not arg1:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    if arg2 > balanceOf[address(msg.sender)]:
                                        revert with 0, 
                                                    32,
                                                    38,
                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 166 len 26] >> 48,
                                                    0
                                    if balanceOf[address(msg.sender)] < arg2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)] -= arg2
                                    if balanceOf[arg1] > !arg2:
                                        revert with 0, 17
                                    if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                    emit Transfer(arg2, msg.sender, arg1);
                                else:
                                    if stor10:
                                        if not arg1:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        if arg2 > balanceOf[address(msg.sender)]:
                                            revert with 0, 
                                                        32,
                                                        38,
                                                        0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 166 len 26] >> 48,
                                                        0
                                        if balanceOf[address(msg.sender)] < arg2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2
                                        if balanceOf[arg1] > !arg2:
                                            revert with 0, 17
                                        if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                        emit Transfer(arg2, msg.sender, arg1);
                                    else:
                                        if not stor13:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        if arg2 / 100 > balanceOf[address(msg.sender)]:
                                            revert with 0, 
                                                        32,
                                                        38,
                                                        0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 230 len 26] >> 48,
                                                        0
                                        if balanceOf[address(msg.sender)] < arg2 / 100:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2 / 100
                                        if balanceOf[stor13] > !(arg2 / 100):
                                            revert with 0, 17
                                        if balanceOf[stor13] + (arg2 / 100) < balanceOf[stor13]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[stor13] += arg2 / 100
                                        emit Transfer((arg2 / 100), msg.sender, stor13);
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not sub_8230af5aAddress:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        if arg2 / 100 > balanceOf[address(msg.sender)]:
                                            revert with 0, 
                                                        32,
                                                        38,
                                                        0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 390 len 26] >> 48,
                                                        0
                                        if balanceOf[address(msg.sender)] < arg2 / 100:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2 / 100
                                        if balanceOf[stor9] > !(arg2 / 100):
                                            revert with 0, 17
                                        if balanceOf[stor9] + (arg2 / 100) < balanceOf[stor9]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[stor9] += arg2 / 100
                                        emit Transfer((arg2 / 100), msg.sender, sub_8230af5aAddress);
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not uniswapV2PairAddress:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        if arg2 / 100 > balanceOf[address(msg.sender)]:
                                            revert with 0, 
                                                        32,
                                                        38,
                                                        0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 550 len 26] >> 48,
                                                        0
                                        if balanceOf[address(msg.sender)] < arg2 / 100:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2 / 100
                                        if balanceOf[stor7] > !(arg2 / 100):
                                            revert with 0, 17
                                        if balanceOf[stor7] + (arg2 / 100) < balanceOf[stor7]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[stor7] += arg2 / 100
                                        emit Transfer((arg2 / 100), msg.sender, uniswapV2PairAddress);
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not this.address:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        if arg2 / 10 > balanceOf[address(msg.sender)]:
                                            revert with 0, 
                                                        32,
                                                        38,
                                                        0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 710 len 26] >> 48,
                                                        0
                                        if balanceOf[address(msg.sender)] < arg2 / 10:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2 / 10
                                        if balanceOf[this.address] > !(arg2 / 10):
                                            revert with 0, 17
                                        if balanceOf[this.address] + (arg2 / 10) < balanceOf[this.address]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 10)
                                        emit Transfer((arg2 / 10), msg.sender, this.address);
                                        if not arg2 / 100:
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not arg1:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            if 0 > balanceOf[address(msg.sender)]:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 870 len 26] >> 48,
                                                            0
                                            if balanceOf[address(msg.sender)] < 0:
                                                revert with 0, 17
                                            if balanceOf[arg1] > -1:
                                                revert with 0, 17
                                            if balanceOf[arg1] < balanceOf[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(arg1)] = balanceOf[arg1]
                                            emit Transfer(0, msg.sender, arg1);
                                        else:
                                            if arg2 / 100 and 87 > -1 / arg2 / 100:
                                                revert with 0, 17
                                            if not arg2 / 100:
                                                revert with 0, 18
                                            if 87 * arg2 / 100 / arg2 / 100 != 87:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not arg1:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            if 87 * arg2 / 100 > balanceOf[address(msg.sender)]:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 870 len 26] >> 48,
                                                            0
                                            if balanceOf[address(msg.sender)] < 87 * arg2 / 100:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] += -87 * arg2 / 100
                                            if balanceOf[arg1] > !(87 * arg2 / 100):
                                                revert with 0, 17
                                            if balanceOf[arg1] + (87 * arg2 / 100) < balanceOf[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(arg1)] = balanceOf[arg1] + (87 * arg2 / 100)
                                            emit Transfer((87 * arg2 / 100), msg.sender, arg1);
                        else:
                            if not ext_call.return_data[0]:
                                mem[64] = ceil32(return_data.size) + 160
                                mem[ceil32(return_data.size) + 96] = 26
                                mem[ceil32(return_data.size) + 128] = 'SafeMath: division by zero'
                                if not stor19.length:
                                    if not msg.sender:
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if stor14[address(msg.sender)]:
                                        if not arg1:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        if arg2 > balanceOf[address(msg.sender)]:
                                            revert with 0, 
                                                        32,
                                                        38,
                                                        0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 230 len 26] >> 48,
                                                        0
                                        if balanceOf[address(msg.sender)] < arg2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2
                                        if balanceOf[arg1] > !arg2:
                                            revert with 0, 17
                                        if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                        emit Transfer(arg2, msg.sender, arg1);
                                    else:
                                        if stor14[address(arg1)]:
                                            if not arg1:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            if arg2 > balanceOf[address(msg.sender)]:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 230 len 26] >> 48,
                                                            0
                                            if balanceOf[address(msg.sender)] < arg2:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2
                                            if balanceOf[arg1] > !arg2:
                                                revert with 0, 17
                                            if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                            emit Transfer(arg2, msg.sender, arg1);
                                        else:
                                            if stor10:
                                                if not arg1:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                if arg2 > balanceOf[address(msg.sender)]:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 230 len 26] >> 48,
                                                                0
                                                if balanceOf[address(msg.sender)] < arg2:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= arg2
                                                if balanceOf[arg1] > !arg2:
                                                    revert with 0, 17
                                                if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                emit Transfer(arg2, msg.sender, arg1);
                                            else:
                                                if not stor13:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 294 len 26] >> 48,
                                                                0
                                                if balanceOf[address(msg.sender)] < arg2 / 100:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= arg2 / 100
                                                if balanceOf[stor13] > !(arg2 / 100):
                                                    revert with 0, 17
                                                if balanceOf[stor13] + (arg2 / 100) < balanceOf[stor13]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[stor13] += arg2 / 100
                                                emit Transfer((arg2 / 100), msg.sender, stor13);
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not sub_8230af5aAddress:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 454 len 26] >> 48,
                                                                0
                                                if balanceOf[address(msg.sender)] < arg2 / 100:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= arg2 / 100
                                                if balanceOf[stor9] > !(arg2 / 100):
                                                    revert with 0, 17
                                                if balanceOf[stor9] + (arg2 / 100) < balanceOf[stor9]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[stor9] += arg2 / 100
                                                emit Transfer((arg2 / 100), msg.sender, sub_8230af5aAddress);
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not uniswapV2PairAddress:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 614 len 26] >> 48,
                                                                0
                                                if balanceOf[address(msg.sender)] < arg2 / 100:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= arg2 / 100
                                                if balanceOf[stor7] > !(arg2 / 100):
                                                    revert with 0, 17
                                                if balanceOf[stor7] + (arg2 / 100) < balanceOf[stor7]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[stor7] += arg2 / 100
                                                emit Transfer((arg2 / 100), msg.sender, uniswapV2PairAddress);
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not this.address:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                if arg2 / 10 > balanceOf[address(msg.sender)]:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 774 len 26] >> 48,
                                                                0
                                                if balanceOf[address(msg.sender)] < arg2 / 10:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= arg2 / 10
                                                if balanceOf[this.address] > !(arg2 / 10):
                                                    revert with 0, 17
                                                if balanceOf[this.address] + (arg2 / 10) < balanceOf[this.address]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 10)
                                                emit Transfer((arg2 / 10), msg.sender, this.address);
                                                if not arg2 / 100:
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not arg1:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    if 0 > balanceOf[address(msg.sender)]:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 934 len 26] >> 48,
                                                                    0
                                                    if balanceOf[address(msg.sender)] < 0:
                                                        revert with 0, 17
                                                    if balanceOf[arg1] > -1:
                                                        revert with 0, 17
                                                    if balanceOf[arg1] < balanceOf[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(arg1)] = balanceOf[arg1]
                                                    emit Transfer(0, msg.sender, arg1);
                                                else:
                                                    if arg2 / 100 and 87 > -1 / arg2 / 100:
                                                        revert with 0, 17
                                                    if not arg2 / 100:
                                                        revert with 0, 18
                                                    if 87 * arg2 / 100 / arg2 / 100 != 87:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not arg1:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    if 87 * arg2 / 100 > balanceOf[address(msg.sender)]:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 934 len 26] >> 48,
                                                                    0
                                                    if balanceOf[address(msg.sender)] < 87 * arg2 / 100:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] += -87 * arg2 / 100
                                                    if balanceOf[arg1] > !(87 * arg2 / 100):
                                                        revert with 0, 17
                                                    if balanceOf[arg1] + (87 * arg2 / 100) < balanceOf[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(arg1)] = balanceOf[arg1] + (87 * arg2 / 100)
                                                    emit Transfer((87 * arg2 / 100), msg.sender, arg1);
                                else:
                                    if stor19.length <= 9:
                                        idx = 0
                                        s = 0
                                        t = 0
                                        while idx < stor19.length:
                                            mem[0] = stor19[idx]
                                            mem[32] = 1
                                            if s > !balanceOf[stor19[idx]]:
                                                revert with 0, 17
                                            if s + balanceOf[stor19[idx]] < s:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            s = s + balanceOf[stor19[idx]]
                                            t = stor19[idx]
                                            continue 
                                        if stor19.length <= 9:
                                            idx = 0
                                            t = 0
                                            u = 160 * stor19.length
                                            while idx < stor19.length:
                                                mem[0] = stor19[idx]
                                                mem[32] = 1
                                                if balanceOf[stor19[idx]] < 10000000000 * 10^18:
                                                    if idx == -1:
                                                        revert with 0, 17
                                                    idx = idx + 1
                                                    t = t
                                                    u = stor19[idx]
                                                    continue 
                                                mem[0] = stor19[idx]
                                                mem[32] = 1
                                                if not balanceOf[stor19[idx]]:
                                                    _17100 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_17100] = 26
                                                    mem[_17100 + 32] = 'SafeMath: division by zero'
                                                    if not s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                        _17564 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _17564 + 68] = mem[idx + _17100 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_17564 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _17564 + -mem[64] + 100
                                                    if 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                        _20330 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_20330] = 26
                                                        mem[_20330 + 32] = 'SafeMath: division by zero'
                                                        mem[mem[64] + 4] = stor19[idx]
                                                        mem[mem[64] + 36] = 0
                                                        require ext_code.size(dogeAddress)
                                                        call dogeAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args stor19[idx], 0
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _22197 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_22197] == bool(mem[_22197])
                                                    if idx == -1:
                                                        revert with 0, 17
                                                    idx = idx + 1
                                                    t = 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length
                                                    u = stor19[idx]
                                                    continue 
                                                if balanceOf[stor19[idx]] and 10000 > -1 / balanceOf[stor19[idx]]:
                                                    revert with 0, 17
                                                if not balanceOf[stor19[idx]]:
                                                    revert with 0, 18
                                                if 10000 * balanceOf[stor19[idx]] / balanceOf[stor19[idx]] != 10000:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _18365 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_18365] = 26
                                                mem[_18365 + 32] = 'SafeMath: division by zero'
                                                if not s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                    _19061 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _19061 + 68] = mem[idx + _18365 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_19061 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _19061 + -mem[64] + 100
                                                if 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                    _21265 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_21265] = 26
                                                    mem[_21265 + 32] = 'SafeMath: division by zero'
                                                    mem[mem[64] + 4] = stor19[idx]
                                                    mem[mem[64] + 36] = 0
                                                    require ext_code.size(dogeAddress)
                                                    call dogeAddress.0xa9059cbb with:
                                                         gas gas_remaining wei
                                                        args stor19[idx], 0
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _22995 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_22995] == bool(mem[_22995])
                                                if idx == -1:
                                                    revert with 0, 17
                                                idx = idx + 1
                                                t = 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length
                                                u = stor19[idx]
                                                continue 
                                            mem[0] = msg.sender
                                            mem[32] = 14
                                            if stor14[address(msg.sender)]:
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not arg1:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _17093 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_17093] = 38
                                                mem[_17093 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if arg2 > balanceOf[address(msg.sender)]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17093 + 70 len 26]
                                                    var69001 = 64
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(msg.sender)] < arg2:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= arg2
                                                if balanceOf[arg1] > !arg2:
                                                    revert with 0, 17
                                                if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                emit Transfer(arg2, msg.sender, arg1);
                                            else:
                                                mem[0] = arg1
                                                mem[32] = 14
                                                if stor14[address(arg1)]:
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not arg1:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _17367 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_17367] = 38
                                                    mem[_17367 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if arg2 > balanceOf[address(msg.sender)]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17367 + 70 len 26]
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(msg.sender)] < arg2:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2
                                                    if balanceOf[arg1] > !arg2:
                                                        revert with 0, 17
                                                    if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                    emit Transfer(arg2, msg.sender, arg1);
                                                else:
                                                    if stor10:
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not arg1:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        _17096 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_17096] = 38
                                                        mem[_17096 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if arg2 > balanceOf[address(msg.sender)]:
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 38
                                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17096 + 70 len 26]
                                                            var69001 = 64
                                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                        if balanceOf[address(msg.sender)] < arg2:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] -= arg2
                                                        if balanceOf[arg1] > !arg2:
                                                            revert with 0, 17
                                                        if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                        emit Transfer(arg2, msg.sender, arg1);
                                                    else:
                                                        _16545 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_16545] = 26
                                                        mem[_16545 + 32] = 'SafeMath: division by zero'
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not stor13:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        _19057 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_19057] = 38
                                                        mem[_19057 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 38
                                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_19057 + 70 len 26]
                                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                        if balanceOf[address(msg.sender)] < arg2 / 100:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] -= arg2 / 100
                                                        if balanceOf[stor13] > !(arg2 / 100):
                                                            revert with 0, 17
                                                        if balanceOf[stor13] + (arg2 / 100) < balanceOf[stor13]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        mem[0] = stor13
                                                        mem[32] = 1
                                                        balanceOf[stor13] += arg2 / 100
                                                        emit Transfer((arg2 / 100), msg.sender, stor13);
                                                        _22653 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_22653] = 26
                                                        mem[_22653 + 32] = 'SafeMath: division by zero'
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not sub_8230af5aAddress:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        _23511 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_23511] = 38
                                                        mem[_23511 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 38
                                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_23511 + 70 len 26]
                                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                        if balanceOf[address(msg.sender)] < arg2 / 100:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] -= arg2 / 100
                                                        if balanceOf[stor9] > !(arg2 / 100):
                                                            revert with 0, 17
                                                        if balanceOf[stor9] + (arg2 / 100) < balanceOf[stor9]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        mem[0] = sub_8230af5aAddress
                                                        mem[32] = 1
                                                        balanceOf[stor9] += arg2 / 100
                                                        emit Transfer((arg2 / 100), msg.sender, sub_8230af5aAddress);
                                                        _24331 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_24331] = 26
                                                        mem[_24331 + 32] = 'SafeMath: division by zero'
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not uniswapV2PairAddress:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        _24567 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_24567] = 38
                                                        mem[_24567 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 38
                                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_24567 + 70 len 26]
                                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                        if balanceOf[address(msg.sender)] < arg2 / 100:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] -= arg2 / 100
                                                        if balanceOf[stor7] > !(arg2 / 100):
                                                            revert with 0, 17
                                                        if balanceOf[stor7] + (arg2 / 100) < balanceOf[stor7]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        mem[0] = uniswapV2PairAddress
                                                        mem[32] = 1
                                                        balanceOf[stor7] += arg2 / 100
                                                        emit Transfer((arg2 / 100), msg.sender, uniswapV2PairAddress);
                                                        _25319 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_25319] = 26
                                                        mem[_25319 + 32] = 'SafeMath: division by zero'
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not this.address:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        _25555 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_25555] = 38
                                                        mem[_25555 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if arg2 / 10 > balanceOf[address(msg.sender)]:
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 38
                                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_25555 + 70 len 26]
                                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                        if balanceOf[address(msg.sender)] < arg2 / 10:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] -= arg2 / 10
                                                        if balanceOf[this.address] > !(arg2 / 10):
                                                            revert with 0, 17
                                                        if balanceOf[this.address] + (arg2 / 10) < balanceOf[this.address]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        mem[0] = this.address
                                                        mem[32] = 1
                                                        balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 10)
                                                        emit Transfer((arg2 / 10), msg.sender, this.address);
                                                        _26307 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_26307] = 26
                                                        mem[_26307 + 32] = 'SafeMath: division by zero'
                                                        if not arg2 / 100:
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not arg1:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _26580 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_26580] = 38
                                                            mem[_26580 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if 0 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_26580 + 70 len 26]
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < 0:
                                                                revert with 0, 17
                                                            if balanceOf[arg1] > -1:
                                                                revert with 0, 17
                                                            if balanceOf[arg1] < balanceOf[arg1]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            balanceOf[address(arg1)] = balanceOf[arg1]
                                                            emit Transfer(0, msg.sender, arg1);
                                                        else:
                                                            if arg2 / 100 and 87 > -1 / arg2 / 100:
                                                                revert with 0, 17
                                                            if not arg2 / 100:
                                                                revert with 0, 18
                                                            if 87 * arg2 / 100 / arg2 / 100 != 87:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not arg1:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _27175 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_27175] = 38
                                                            mem[_27175 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if 87 * arg2 / 100 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_27175 + 70 len 26]
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < 87 * arg2 / 100:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] += -87 * arg2 / 100
                                                            if balanceOf[arg1] > !(87 * arg2 / 100):
                                                                revert with 0, 17
                                                            if balanceOf[arg1] + (87 * arg2 / 100) < balanceOf[arg1]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            balanceOf[address(arg1)] = balanceOf[arg1] + (87 * arg2 / 100)
                                                            emit Transfer((87 * arg2 / 100), msg.sender, arg1);
                                        else:
                                            idx = 0
                                            t = 0
                                            u = 160 * stor19.length
                                            while idx < 9:
                                                if 0 > !idx:
                                                    revert with 0, 17
                                                if idx >= stor19.length:
                                                    revert with 0, 50
                                                mem[0] = stor19[idx]
                                                mem[32] = 1
                                                if balanceOf[stor19[idx]] < 10000000000 * 10^18:
                                                    if idx == -1:
                                                        revert with 0, 17
                                                    idx = idx + 1
                                                    t = t
                                                    u = stor19[idx]
                                                    continue 
                                                mem[0] = stor19[idx]
                                                mem[32] = 1
                                                if not balanceOf[stor19[idx]]:
                                                    _17762 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_17762] = 26
                                                    mem[_17762 + 32] = 'SafeMath: division by zero'
                                                    if not s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                        _18051 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _18051 + 68] = mem[idx + _17762 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_18051 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _18051 + -mem[64] + 100
                                                    if 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                        _20904 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_20904] = 26
                                                        mem[_20904 + 32] = 'SafeMath: division by zero'
                                                        mem[mem[64] + 4] = stor19[idx]
                                                        mem[mem[64] + 36] = 0
                                                        require ext_code.size(dogeAddress)
                                                        call dogeAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args stor19[idx], 0
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _22743 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_22743] == bool(mem[_22743])
                                                    if idx == -1:
                                                        revert with 0, 17
                                                    idx = idx + 1
                                                    t = 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length
                                                    u = stor19[idx]
                                                    continue 
                                                if balanceOf[stor19[idx]] and 10000 > -1 / balanceOf[stor19[idx]]:
                                                    revert with 0, 17
                                                if not balanceOf[stor19[idx]]:
                                                    revert with 0, 18
                                                if 10000 * balanceOf[stor19[idx]] / balanceOf[stor19[idx]] != 10000:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _19272 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_19272] = 26
                                                mem[_19272 + 32] = 'SafeMath: division by zero'
                                                if not s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                    _19596 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _19596 + 68] = mem[idx + _19272 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_19596 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _19596 + -mem[64] + 100
                                                if 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                    _22204 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_22204] = 26
                                                    mem[_22204 + 32] = 'SafeMath: division by zero'
                                                    mem[mem[64] + 4] = stor19[idx]
                                                    mem[mem[64] + 36] = 0
                                                    require ext_code.size(dogeAddress)
                                                    call dogeAddress.0xa9059cbb with:
                                                         gas gas_remaining wei
                                                        args stor19[idx], 0
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _23175 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_23175] == bool(mem[_23175])
                                                if idx == -1:
                                                    revert with 0, 17
                                                idx = idx + 1
                                                t = 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length
                                                u = stor19[idx]
                                                continue 
                                            mem[0] = msg.sender
                                            mem[32] = 14
                                            if stor14[address(msg.sender)]:
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not arg1:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _17101 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_17101] = 38
                                                mem[_17101 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if arg2 > balanceOf[address(msg.sender)]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17101 + 70 len 26]
                                                    var69001 = 64
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(msg.sender)] < arg2:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= arg2
                                                if balanceOf[arg1] > !arg2:
                                                    revert with 0, 17
                                                if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                emit Transfer(arg2, msg.sender, arg1);
                                            else:
                                                mem[0] = arg1
                                                mem[32] = 14
                                                if stor14[address(arg1)]:
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not arg1:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _17372 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_17372] = 38
                                                    mem[_17372 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if arg2 > balanceOf[address(msg.sender)]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17372 + 70 len 26]
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(msg.sender)] < arg2:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2
                                                    if balanceOf[arg1] > !arg2:
                                                        revert with 0, 17
                                                    if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                    emit Transfer(arg2, msg.sender, arg1);
                                                else:
                                                    if stor10:
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not arg1:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        _17104 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_17104] = 38
                                                        mem[_17104 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if arg2 > balanceOf[address(msg.sender)]:
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 38
                                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17104 + 70 len 26]
                                                            var69001 = 64
                                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                        if balanceOf[address(msg.sender)] < arg2:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] -= arg2
                                                        if balanceOf[arg1] > !arg2:
                                                            revert with 0, 17
                                                        if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                        emit Transfer(arg2, msg.sender, arg1);
                                                    else:
                                                        _16546 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_16546] = 26
                                                        mem[_16546 + 32] = 'SafeMath: division by zero'
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not stor13:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        _19065 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_19065] = 38
                                                        mem[_19065 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 38
                                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_19065 + 70 len 26]
                                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                        if balanceOf[address(msg.sender)] < arg2 / 100:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] -= arg2 / 100
                                                        if balanceOf[stor13] > !(arg2 / 100):
                                                            revert with 0, 17
                                                        if balanceOf[stor13] + (arg2 / 100) < balanceOf[stor13]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        mem[0] = stor13
                                                        mem[32] = 1
                                                        balanceOf[stor13] += arg2 / 100
                                                        emit Transfer((arg2 / 100), msg.sender, stor13);
                                                        _22656 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_22656] = 26
                                                        mem[_22656 + 32] = 'SafeMath: division by zero'
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not sub_8230af5aAddress:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        _23514 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_23514] = 38
                                                        mem[_23514 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 38
                                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_23514 + 70 len 26]
                                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                        if balanceOf[address(msg.sender)] < arg2 / 100:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] -= arg2 / 100
                                                        if balanceOf[stor9] > !(arg2 / 100):
                                                            revert with 0, 17
                                                        if balanceOf[stor9] + (arg2 / 100) < balanceOf[stor9]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        mem[0] = sub_8230af5aAddress
                                                        mem[32] = 1
                                                        balanceOf[stor9] += arg2 / 100
                                                        emit Transfer((arg2 / 100), msg.sender, sub_8230af5aAddress);
                                                        _24332 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_24332] = 26
                                                        mem[_24332 + 32] = 'SafeMath: division by zero'
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not uniswapV2PairAddress:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        _24570 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_24570] = 38
                                                        mem[_24570 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 38
                                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_24570 + 70 len 26]
                                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                        if balanceOf[address(msg.sender)] < arg2 / 100:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] -= arg2 / 100
                                                        if balanceOf[stor7] > !(arg2 / 100):
                                                            revert with 0, 17
                                                        if balanceOf[stor7] + (arg2 / 100) < balanceOf[stor7]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        mem[0] = uniswapV2PairAddress
                                                        mem[32] = 1
                                                        balanceOf[stor7] += arg2 / 100
                                                        emit Transfer((arg2 / 100), msg.sender, uniswapV2PairAddress);
                                                        _25320 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_25320] = 26
                                                        mem[_25320 + 32] = 'SafeMath: division by zero'
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not this.address:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        _25558 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_25558] = 38
                                                        mem[_25558 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if arg2 / 10 > balanceOf[address(msg.sender)]:
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 38
                                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_25558 + 70 len 26]
                                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                        if balanceOf[address(msg.sender)] < arg2 / 10:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] -= arg2 / 10
                                                        if balanceOf[this.address] > !(arg2 / 10):
                                                            revert with 0, 17
                                                        if balanceOf[this.address] + (arg2 / 10) < balanceOf[this.address]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        mem[0] = this.address
                                                        mem[32] = 1
                                                        balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 10)
                                                        emit Transfer((arg2 / 10), msg.sender, this.address);
                                                        _26308 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_26308] = 26
                                                        mem[_26308 + 32] = 'SafeMath: division by zero'
                                                        if not arg2 / 100:
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not arg1:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _26584 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_26584] = 38
                                                            mem[_26584 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if 0 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_26584 + 70 len 26]
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < 0:
                                                                revert with 0, 17
                                                            if balanceOf[arg1] > -1:
                                                                revert with 0, 17
                                                            if balanceOf[arg1] < balanceOf[arg1]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            balanceOf[address(arg1)] = balanceOf[arg1]
                                                            emit Transfer(0, msg.sender, arg1);
                                                        else:
                                                            if arg2 / 100 and 87 > -1 / arg2 / 100:
                                                                revert with 0, 17
                                                            if not arg2 / 100:
                                                                revert with 0, 18
                                                            if 87 * arg2 / 100 / arg2 / 100 != 87:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not arg1:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _27180 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_27180] = 38
                                                            mem[_27180 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if 87 * arg2 / 100 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_27180 + 70 len 26]
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < 87 * arg2 / 100:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] += -87 * arg2 / 100
                                                            if balanceOf[arg1] > !(87 * arg2 / 100):
                                                                revert with 0, 17
                                                            if balanceOf[arg1] + (87 * arg2 / 100) < balanceOf[arg1]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            balanceOf[address(arg1)] = balanceOf[arg1] + (87 * arg2 / 100)
                                                            emit Transfer((87 * arg2 / 100), msg.sender, arg1);
                                    else:
                                        if stor19.length < 9:
                                            revert with 0, 17
                                        mem[64] = ceil32(return_data.size) + 224
                                        mem[ceil32(return_data.size) + 160] = 24
                                        mem[ceil32(return_data.size) + 192] = 'SafeMath: modulo by zero'
                                        if not stor19.length - 9:
                                            revert with 0, 'SafeMath: modulo by zero', 0
                                        idx = 0
                                        s = 0
                                        t = 0
                                        while idx < 9:
                                            if block.timestamp % stor19.length - 9 > !idx:
                                                revert with 0, 17
                                            if (block.timestamp % stor19.length - 9) + idx >= stor19.length:
                                                revert with 0, 50
                                            mem[0] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                            mem[32] = 1
                                            if s > !balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]]:
                                                revert with 0, 17
                                            if s + balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] < s:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            s = s + balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]]
                                            t = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                            continue 
                                        if stor19.length <= 9:
                                            idx = 0
                                            t = 0
                                            u = 1440
                                            while idx < stor19.length:
                                                mem[0] = stor19[idx]
                                                mem[32] = 1
                                                if balanceOf[stor19[idx]] < 10000000000 * 10^18:
                                                    if idx == -1:
                                                        revert with 0, 17
                                                    idx = idx + 1
                                                    t = t
                                                    u = stor19[idx]
                                                    continue 
                                                mem[0] = stor19[idx]
                                                mem[32] = 1
                                                if not balanceOf[stor19[idx]]:
                                                    _17115 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_17115] = 26
                                                    mem[_17115 + 32] = 'SafeMath: division by zero'
                                                    if not 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                        _17571 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _17571 + 68] = mem[idx + _17115 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_17571 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _17571 + -mem[64] + 100
                                                    if 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                        _20344 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_20344] = 26
                                                        mem[_20344 + 32] = 'SafeMath: division by zero'
                                                        mem[mem[64] + 4] = stor19[idx]
                                                        mem[mem[64] + 36] = 0
                                                        require ext_code.size(dogeAddress)
                                                        call dogeAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args stor19[idx], 0
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _22211 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_22211] == bool(mem[_22211])
                                                    if idx == -1:
                                                        revert with 0, 17
                                                    idx = idx + 1
                                                    t = 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s
                                                    u = stor19[idx]
                                                    continue 
                                                if balanceOf[stor19[idx]] and 10000 > -1 / balanceOf[stor19[idx]]:
                                                    revert with 0, 17
                                                if not balanceOf[stor19[idx]]:
                                                    revert with 0, 18
                                                if 10000 * balanceOf[stor19[idx]] / balanceOf[stor19[idx]] != 10000:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _18379 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_18379] = 26
                                                mem[_18379 + 32] = 'SafeMath: division by zero'
                                                if not 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                    _19077 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _19077 + 68] = mem[idx + _18379 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_19077 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _19077 + -mem[64] + 100
                                                if 10000 * balanceOf[stor19[idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                    _21270 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_21270] = 26
                                                    mem[_21270 + 32] = 'SafeMath: division by zero'
                                                    mem[mem[64] + 4] = stor19[idx]
                                                    mem[mem[64] + 36] = 0
                                                    require ext_code.size(dogeAddress)
                                                    call dogeAddress.0xa9059cbb with:
                                                         gas gas_remaining wei
                                                        args stor19[idx], 0
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _22996 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_22996] == bool(mem[_22996])
                                                if idx == -1:
                                                    revert with 0, 17
                                                idx = idx + 1
                                                t = 10000 * balanceOf[stor19[idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s
                                                u = stor19[idx]
                                                continue 
                                            mem[0] = msg.sender
                                            mem[32] = 14
                                            if stor14[address(msg.sender)]:
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not arg1:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _17108 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_17108] = 38
                                                mem[_17108 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if arg2 > balanceOf[address(msg.sender)]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17108 + 70 len 26]
                                                    var80001 = 64
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(msg.sender)] < arg2:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= arg2
                                                if balanceOf[arg1] > !arg2:
                                                    revert with 0, 17
                                                if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                emit Transfer(arg2, msg.sender, arg1);
                                            else:
                                                mem[0] = arg1
                                                mem[32] = 14
                                                if stor14[address(arg1)]:
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not arg1:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _17377 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_17377] = 38
                                                    mem[_17377 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if arg2 > balanceOf[address(msg.sender)]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17377 + 70 len 26]
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(msg.sender)] < arg2:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2
                                                    if balanceOf[arg1] > !arg2:
                                                        revert with 0, 17
                                                    if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                    emit Transfer(arg2, msg.sender, arg1);
                                                else:
                                                    if stor10:
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not arg1:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        _17111 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_17111] = 38
                                                        mem[_17111 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if arg2 > balanceOf[address(msg.sender)]:
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 38
                                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17111 + 70 len 26]
                                                            var80001 = 64
                                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                        if balanceOf[address(msg.sender)] < arg2:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] -= arg2
                                                        if balanceOf[arg1] > !arg2:
                                                            revert with 0, 17
                                                        if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                        emit Transfer(arg2, msg.sender, arg1);
                                                    else:
                                                        _16548 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_16548] = 26
                                                        mem[_16548 + 32] = 'SafeMath: division by zero'
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not stor13:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        _19073 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_19073] = 38
                                                        mem[_19073 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 38
                                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_19073 + 70 len 26]
                                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                        if balanceOf[address(msg.sender)] < arg2 / 100:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] -= arg2 / 100
                                                        if balanceOf[stor13] > !(arg2 / 100):
                                                            revert with 0, 17
                                                        if balanceOf[stor13] + (arg2 / 100) < balanceOf[stor13]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        mem[0] = stor13
                                                        mem[32] = 1
                                                        balanceOf[stor13] += arg2 / 100
                                                        emit Transfer((arg2 / 100), msg.sender, stor13);
                                                        _22658 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_22658] = 26
                                                        mem[_22658 + 32] = 'SafeMath: division by zero'
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not sub_8230af5aAddress:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        _23517 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_23517] = 38
                                                        mem[_23517 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 38
                                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_23517 + 70 len 26]
                                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                        if balanceOf[address(msg.sender)] < arg2 / 100:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] -= arg2 / 100
                                                        if balanceOf[stor9] > !(arg2 / 100):
                                                            revert with 0, 17
                                                        if balanceOf[stor9] + (arg2 / 100) < balanceOf[stor9]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        mem[0] = sub_8230af5aAddress
                                                        mem[32] = 1
                                                        balanceOf[stor9] += arg2 / 100
                                                        emit Transfer((arg2 / 100), msg.sender, sub_8230af5aAddress);
                                                        _24333 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_24333] = 26
                                                        mem[_24333 + 32] = 'SafeMath: division by zero'
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not uniswapV2PairAddress:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        _24573 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_24573] = 38
                                                        mem[_24573 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 38
                                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_24573 + 70 len 26]
                                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                        if balanceOf[address(msg.sender)] < arg2 / 100:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] -= arg2 / 100
                                                        if balanceOf[stor7] > !(arg2 / 100):
                                                            revert with 0, 17
                                                        if balanceOf[stor7] + (arg2 / 100) < balanceOf[stor7]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        mem[0] = uniswapV2PairAddress
                                                        mem[32] = 1
                                                        balanceOf[stor7] += arg2 / 100
                                                        emit Transfer((arg2 / 100), msg.sender, uniswapV2PairAddress);
                                                        _25321 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_25321] = 26
                                                        mem[_25321 + 32] = 'SafeMath: division by zero'
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not this.address:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        _25561 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_25561] = 38
                                                        mem[_25561 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if arg2 / 10 > balanceOf[address(msg.sender)]:
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 38
                                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_25561 + 70 len 26]
                                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                        if balanceOf[address(msg.sender)] < arg2 / 10:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] -= arg2 / 10
                                                        if balanceOf[this.address] > !(arg2 / 10):
                                                            revert with 0, 17
                                                        if balanceOf[this.address] + (arg2 / 10) < balanceOf[this.address]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        mem[0] = this.address
                                                        mem[32] = 1
                                                        balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 10)
                                                        emit Transfer((arg2 / 10), msg.sender, this.address);
                                                        _26309 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_26309] = 26
                                                        mem[_26309 + 32] = 'SafeMath: division by zero'
                                                        if not arg2 / 100:
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not arg1:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _26588 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_26588] = 38
                                                            mem[_26588 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if 0 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_26588 + 70 len 26]
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < 0:
                                                                revert with 0, 17
                                                            if balanceOf[arg1] > -1:
                                                                revert with 0, 17
                                                            if balanceOf[arg1] < balanceOf[arg1]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            balanceOf[address(arg1)] = balanceOf[arg1]
                                                            emit Transfer(0, msg.sender, arg1);
                                                        else:
                                                            if arg2 / 100 and 87 > -1 / arg2 / 100:
                                                                revert with 0, 17
                                                            if not arg2 / 100:
                                                                revert with 0, 18
                                                            if 87 * arg2 / 100 / arg2 / 100 != 87:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not arg1:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _27185 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_27185] = 38
                                                            mem[_27185 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if 87 * arg2 / 100 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_27185 + 70 len 26]
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < 87 * arg2 / 100:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] += -87 * arg2 / 100
                                                            if balanceOf[arg1] > !(87 * arg2 / 100):
                                                                revert with 0, 17
                                                            if balanceOf[arg1] + (87 * arg2 / 100) < balanceOf[arg1]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            balanceOf[address(arg1)] = balanceOf[arg1] + (87 * arg2 / 100)
                                                            emit Transfer((87 * arg2 / 100), msg.sender, arg1);
                                        else:
                                            idx = 0
                                            t = 0
                                            u = 1440
                                            while idx < 9:
                                                if block.timestamp % stor19.length - 9 > !idx:
                                                    revert with 0, 17
                                                if (block.timestamp % stor19.length - 9) + idx >= stor19.length:
                                                    revert with 0, 50
                                                mem[0] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                                mem[32] = 1
                                                if balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] < 10000000000 * 10^18:
                                                    if idx == -1:
                                                        revert with 0, 17
                                                    idx = idx + 1
                                                    t = t
                                                    u = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                                    continue 
                                                mem[0] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                                mem[32] = 1
                                                if not balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]]:
                                                    _17770 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_17770] = 26
                                                    mem[_17770 + 32] = 'SafeMath: division by zero'
                                                    if not 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                        _18058 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _18058 + 68] = mem[idx + _17770 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_18058 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _18058 + -mem[64] + 100
                                                    if 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                        _20910 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_20910] = 26
                                                        mem[_20910 + 32] = 'SafeMath: division by zero'
                                                        mem[mem[64] + 4] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                                        mem[mem[64] + 36] = 0
                                                        require ext_code.size(dogeAddress)
                                                        call dogeAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx], 0
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _22744 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_22744] == bool(mem[_22744])
                                                    if idx == -1:
                                                        revert with 0, 17
                                                    idx = idx + 1
                                                    t = 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s
                                                    u = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                                    continue 
                                                if balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] and 10000 > -1 / balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]]:
                                                    revert with 0, 17
                                                if not balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]]:
                                                    revert with 0, 18
                                                if 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] != 10000:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _19278 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_19278] = 26
                                                mem[_19278 + 32] = 'SafeMath: division by zero'
                                                if not 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                    _19605 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _19605 + 68] = mem[idx + _19278 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_19605 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _19605 + -mem[64] + 100
                                                if 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                    _22218 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_22218] = 26
                                                    mem[_22218 + 32] = 'SafeMath: division by zero'
                                                    mem[mem[64] + 4] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                                    mem[mem[64] + 36] = 0
                                                    require ext_code.size(dogeAddress)
                                                    call dogeAddress.0xa9059cbb with:
                                                         gas gas_remaining wei
                                                        args stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx], 0
                                                    mem[mem[64]] = ext_call.return_data[0]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _23176 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 32
                                                    require mem[_23176] == bool(mem[_23176])
                                                if idx == -1:
                                                    revert with 0, 17
                                                idx = idx + 1
                                                t = 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s
                                                u = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                                continue 
                                            mem[0] = msg.sender
                                            mem[32] = 14
                                            if stor14[address(msg.sender)]:
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not arg1:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _17116 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_17116] = 38
                                                mem[_17116 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if arg2 > balanceOf[address(msg.sender)]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17116 + 70 len 26]
                                                    var80001 = 64
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(msg.sender)] < arg2:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= arg2
                                                if balanceOf[arg1] > !arg2:
                                                    revert with 0, 17
                                                if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                emit Transfer(arg2, msg.sender, arg1);
                                            else:
                                                mem[0] = arg1
                                                mem[32] = 14
                                                if stor14[address(arg1)]:
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not arg1:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _17382 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_17382] = 38
                                                    mem[_17382 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if arg2 > balanceOf[address(msg.sender)]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17382 + 70 len 26]
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(msg.sender)] < arg2:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2
                                                    if balanceOf[arg1] > !arg2:
                                                        revert with 0, 17
                                                    if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                    emit Transfer(arg2, msg.sender, arg1);
                                                else:
                                                    if stor10:
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not arg1:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        _17119 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_17119] = 38
                                                        mem[_17119 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if arg2 > balanceOf[address(msg.sender)]:
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 38
                                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17119 + 70 len 26]
                                                            var80001 = 64
                                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                        if balanceOf[address(msg.sender)] < arg2:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] -= arg2
                                                        if balanceOf[arg1] > !arg2:
                                                            revert with 0, 17
                                                        if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                        emit Transfer(arg2, msg.sender, arg1);
                                                    else:
                                                        _16549 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_16549] = 26
                                                        mem[_16549 + 32] = 'SafeMath: division by zero'
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not stor13:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        _19081 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_19081] = 38
                                                        mem[_19081 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 38
                                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_19081 + 70 len 26]
                                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                        if balanceOf[address(msg.sender)] < arg2 / 100:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] -= arg2 / 100
                                                        if balanceOf[stor13] > !(arg2 / 100):
                                                            revert with 0, 17
                                                        if balanceOf[stor13] + (arg2 / 100) < balanceOf[stor13]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        mem[0] = stor13
                                                        mem[32] = 1
                                                        balanceOf[stor13] += arg2 / 100
                                                        emit Transfer((arg2 / 100), msg.sender, stor13);
                                                        _22661 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_22661] = 26
                                                        mem[_22661 + 32] = 'SafeMath: division by zero'
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not sub_8230af5aAddress:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        _23520 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_23520] = 38
                                                        mem[_23520 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 38
                                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_23520 + 70 len 26]
                                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                        if balanceOf[address(msg.sender)] < arg2 / 100:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] -= arg2 / 100
                                                        if balanceOf[stor9] > !(arg2 / 100):
                                                            revert with 0, 17
                                                        if balanceOf[stor9] + (arg2 / 100) < balanceOf[stor9]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        mem[0] = sub_8230af5aAddress
                                                        mem[32] = 1
                                                        balanceOf[stor9] += arg2 / 100
                                                        emit Transfer((arg2 / 100), msg.sender, sub_8230af5aAddress);
                                                        _24334 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_24334] = 26
                                                        mem[_24334 + 32] = 'SafeMath: division by zero'
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not uniswapV2PairAddress:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        _24576 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_24576] = 38
                                                        mem[_24576 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 38
                                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_24576 + 70 len 26]
                                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                        if balanceOf[address(msg.sender)] < arg2 / 100:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] -= arg2 / 100
                                                        if balanceOf[stor7] > !(arg2 / 100):
                                                            revert with 0, 17
                                                        if balanceOf[stor7] + (arg2 / 100) < balanceOf[stor7]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        mem[0] = uniswapV2PairAddress
                                                        mem[32] = 1
                                                        balanceOf[stor7] += arg2 / 100
                                                        emit Transfer((arg2 / 100), msg.sender, uniswapV2PairAddress);
                                                        _25322 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_25322] = 26
                                                        mem[_25322 + 32] = 'SafeMath: division by zero'
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not this.address:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        _25564 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_25564] = 38
                                                        mem[_25564 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if arg2 / 10 > balanceOf[address(msg.sender)]:
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 38
                                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_25564 + 70 len 26]
                                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                        if balanceOf[address(msg.sender)] < arg2 / 10:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] -= arg2 / 10
                                                        if balanceOf[this.address] > !(arg2 / 10):
                                                            revert with 0, 17
                                                        if balanceOf[this.address] + (arg2 / 10) < balanceOf[this.address]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        mem[0] = this.address
                                                        mem[32] = 1
                                                        balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 10)
                                                        emit Transfer((arg2 / 10), msg.sender, this.address);
                                                        _26310 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_26310] = 26
                                                        mem[_26310 + 32] = 'SafeMath: division by zero'
                                                        if not arg2 / 100:
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not arg1:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _26592 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_26592] = 38
                                                            mem[_26592 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if 0 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_26592 + 70 len 26]
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < 0:
                                                                revert with 0, 17
                                                            if balanceOf[arg1] > -1:
                                                                revert with 0, 17
                                                            if balanceOf[arg1] < balanceOf[arg1]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            balanceOf[address(arg1)] = balanceOf[arg1]
                                                            emit Transfer(0, msg.sender, arg1);
                                                        else:
                                                            if arg2 / 100 and 87 > -1 / arg2 / 100:
                                                                revert with 0, 17
                                                            if not arg2 / 100:
                                                                revert with 0, 18
                                                            if 87 * arg2 / 100 / arg2 / 100 != 87:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not arg1:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _27190 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_27190] = 38
                                                            mem[_27190 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if 87 * arg2 / 100 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_27190 + 70 len 26]
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < 87 * arg2 / 100:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] += -87 * arg2 / 100
                                                            if balanceOf[arg1] > !(87 * arg2 / 100):
                                                                revert with 0, 17
                                                            if balanceOf[arg1] + (87 * arg2 / 100) < balanceOf[arg1]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            balanceOf[address(arg1)] = balanceOf[arg1] + (87 * arg2 / 100)
                                                            emit Transfer((87 * arg2 / 100), msg.sender, arg1);
                            else:
                                if ext_call.return_data[0] and 4 > -1 / ext_call.return_data[0]:
                                    revert with 0, 17
                                if not ext_call.return_data[0]:
                                    revert with 0, 18
                                if 4 * ext_call.return_data[0] / ext_call.return_data[0] != 4:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[64] = ceil32(return_data.size) + 160
                                mem[ceil32(return_data.size) + 96] = 26
                                mem[ceil32(return_data.size) + 128] = 'SafeMath: division by zero'
                                if not stor19.length:
                                    if not msg.sender:
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if stor14[address(msg.sender)]:
                                        if not arg1:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        if arg2 > balanceOf[address(msg.sender)]:
                                            revert with 0, 
                                                        32,
                                                        38,
                                                        0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 230 len 26] >> 48,
                                                        0
                                        if balanceOf[address(msg.sender)] < arg2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2
                                        if balanceOf[arg1] > !arg2:
                                            revert with 0, 17
                                        if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                        emit Transfer(arg2, msg.sender, arg1);
                                    else:
                                        if stor14[address(arg1)]:
                                            if not arg1:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            if arg2 > balanceOf[address(msg.sender)]:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 230 len 26] >> 48,
                                                            0
                                            if balanceOf[address(msg.sender)] < arg2:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2
                                            if balanceOf[arg1] > !arg2:
                                                revert with 0, 17
                                            if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                            emit Transfer(arg2, msg.sender, arg1);
                                        else:
                                            if stor10:
                                                if not arg1:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                if arg2 > balanceOf[address(msg.sender)]:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 230 len 26] >> 48,
                                                                0
                                                if balanceOf[address(msg.sender)] < arg2:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= arg2
                                                if balanceOf[arg1] > !arg2:
                                                    revert with 0, 17
                                                if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                emit Transfer(arg2, msg.sender, arg1);
                                            else:
                                                if not stor13:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 294 len 26] >> 48,
                                                                0
                                                if balanceOf[address(msg.sender)] < arg2 / 100:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= arg2 / 100
                                                if balanceOf[stor13] > !(arg2 / 100):
                                                    revert with 0, 17
                                                if balanceOf[stor13] + (arg2 / 100) < balanceOf[stor13]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[stor13] += arg2 / 100
                                                emit Transfer((arg2 / 100), msg.sender, stor13);
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not sub_8230af5aAddress:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 454 len 26] >> 48,
                                                                0
                                                if balanceOf[address(msg.sender)] < arg2 / 100:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= arg2 / 100
                                                if balanceOf[stor9] > !(arg2 / 100):
                                                    revert with 0, 17
                                                if balanceOf[stor9] + (arg2 / 100) < balanceOf[stor9]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[stor9] += arg2 / 100
                                                emit Transfer((arg2 / 100), msg.sender, sub_8230af5aAddress);
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not uniswapV2PairAddress:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 614 len 26] >> 48,
                                                                0
                                                if balanceOf[address(msg.sender)] < arg2 / 100:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= arg2 / 100
                                                if balanceOf[stor7] > !(arg2 / 100):
                                                    revert with 0, 17
                                                if balanceOf[stor7] + (arg2 / 100) < balanceOf[stor7]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[stor7] += arg2 / 100
                                                emit Transfer((arg2 / 100), msg.sender, uniswapV2PairAddress);
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not this.address:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                if arg2 / 10 > balanceOf[address(msg.sender)]:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 774 len 26] >> 48,
                                                                0
                                                if balanceOf[address(msg.sender)] < arg2 / 10:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= arg2 / 10
                                                if balanceOf[this.address] > !(arg2 / 10):
                                                    revert with 0, 17
                                                if balanceOf[this.address] + (arg2 / 10) < balanceOf[this.address]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 10)
                                                emit Transfer((arg2 / 10), msg.sender, this.address);
                                                if not arg2 / 100:
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not arg1:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    if 0 > balanceOf[address(msg.sender)]:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 934 len 26] >> 48,
                                                                    0
                                                    if balanceOf[address(msg.sender)] < 0:
                                                        revert with 0, 17
                                                    if balanceOf[arg1] > -1:
                                                        revert with 0, 17
                                                    if balanceOf[arg1] < balanceOf[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(arg1)] = balanceOf[arg1]
                                                    emit Transfer(0, msg.sender, arg1);
                                                else:
                                                    if arg2 / 100 and 87 > -1 / arg2 / 100:
                                                        revert with 0, 17
                                                    if not arg2 / 100:
                                                        revert with 0, 18
                                                    if 87 * arg2 / 100 / arg2 / 100 != 87:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not arg1:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    if 87 * arg2 / 100 > balanceOf[address(msg.sender)]:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 934 len 26] >> 48,
                                                                    0
                                                    if balanceOf[address(msg.sender)] < 87 * arg2 / 100:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] += -87 * arg2 / 100
                                                    if balanceOf[arg1] > !(87 * arg2 / 100):
                                                        revert with 0, 17
                                                    if balanceOf[arg1] + (87 * arg2 / 100) < balanceOf[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(arg1)] = balanceOf[arg1] + (87 * arg2 / 100)
                                                    emit Transfer((87 * arg2 / 100), msg.sender, arg1);
                                else:
                                    if stor19.length <= 9:
                                        idx = 0
                                        s = 0
                                        t = 0
                                        while idx < stor19.length:
                                            mem[0] = stor19[idx]
                                            mem[32] = 1
                                            if s > !balanceOf[stor19[idx]]:
                                                revert with 0, 17
                                            if s + balanceOf[stor19[idx]] < s:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            s = s + balanceOf[stor19[idx]]
                                            t = stor19[idx]
                                            continue 
                                        if stor19.length <= 9:
                                            idx = 0
                                            t = 0
                                            u = 160 * stor19.length
                                            while idx < stor19.length:
                                                mem[0] = stor19[idx]
                                                mem[32] = 1
                                                if balanceOf[stor19[idx]] < 10000000000 * 10^18:
                                                    if idx == -1:
                                                        revert with 0, 17
                                                    idx = idx + 1
                                                    t = t
                                                    u = stor19[idx]
                                                    continue 
                                                mem[0] = stor19[idx]
                                                mem[32] = 1
                                                if not balanceOf[stor19[idx]]:
                                                    _17070 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_17070] = 26
                                                    mem[_17070 + 32] = 'SafeMath: division by zero'
                                                    if not s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                        _17550 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _17550 + 68] = mem[idx + _17070 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_17550 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _17550 + -mem[64] + 100
                                                    if 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                        if not 4 * ext_call.return_data[0] / 5:
                                                            _20302 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_20302] = 26
                                                            mem[_20302 + 32] = 'SafeMath: division by zero'
                                                            mem[mem[64] + 4] = stor19[idx]
                                                            mem[mem[64] + 36] = 0
                                                            require ext_code.size(dogeAddress)
                                                            call dogeAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args stor19[idx], 0
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _22167 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_22167] == bool(mem[_22167])
                                                        else:
                                                            if 4 * ext_call.return_data[0] / 5 and 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length > -1 / 4 * ext_call.return_data[0] / 5:
                                                                revert with 0, 17
                                                            if not 4 * ext_call.return_data[0] / 5:
                                                                revert with 0, 18
                                                            if 4 * ext_call.return_data[0] / 5 * 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 4 * ext_call.return_data[0] / 5 != 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _21254 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_21254] = 26
                                                            mem[_21254 + 32] = 'SafeMath: division by zero'
                                                            mem[mem[64] + 4] = stor19[idx]
                                                            mem[mem[64] + 36] = 4 * ext_call.return_data[0] / 5 * 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 10000
                                                            require ext_code.size(dogeAddress)
                                                            call dogeAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args stor19[idx], 4 * ext_call.return_data[0] / 5 * 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 10000
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _22990 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_22990] == bool(mem[_22990])
                                                    if idx == -1:
                                                        revert with 0, 17
                                                    idx = idx + 1
                                                    t = 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length
                                                    u = stor19[idx]
                                                    continue 
                                                if balanceOf[stor19[idx]] and 10000 > -1 / balanceOf[stor19[idx]]:
                                                    revert with 0, 17
                                                if not balanceOf[stor19[idx]]:
                                                    revert with 0, 18
                                                if 10000 * balanceOf[stor19[idx]] / balanceOf[stor19[idx]] != 10000:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _18337 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_18337] = 26
                                                mem[_18337 + 32] = 'SafeMath: division by zero'
                                                if not s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                    _19029 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _19029 + 68] = mem[idx + _18337 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_19029 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _19029 + -mem[64] + 100
                                                if 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                    if not 4 * ext_call.return_data[0] / 5:
                                                        _21253 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_21253] = 26
                                                        mem[_21253 + 32] = 'SafeMath: division by zero'
                                                        mem[mem[64] + 4] = stor19[idx]
                                                        mem[mem[64] + 36] = 0
                                                        require ext_code.size(dogeAddress)
                                                        call dogeAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args stor19[idx], 0
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _22989 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_22989] == bool(mem[_22989])
                                                    else:
                                                        if 4 * ext_call.return_data[0] / 5 and 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length > -1 / 4 * ext_call.return_data[0] / 5:
                                                            revert with 0, 17
                                                        if not 4 * ext_call.return_data[0] / 5:
                                                            revert with 0, 18
                                                        if 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 4 * ext_call.return_data[0] / 5 != 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _22739 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_22739] = 26
                                                        mem[_22739 + 32] = 'SafeMath: division by zero'
                                                        mem[mem[64] + 4] = stor19[idx]
                                                        mem[mem[64] + 36] = 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 10000
                                                        require ext_code.size(dogeAddress)
                                                        call dogeAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args stor19[idx], 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 10000
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _23358 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_23358] == bool(mem[_23358])
                                                if idx == -1:
                                                    revert with 0, 17
                                                idx = idx + 1
                                                t = 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length
                                                u = stor19[idx]
                                                continue 
                                            mem[0] = msg.sender
                                            mem[32] = 14
                                            if stor14[address(msg.sender)]:
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not arg1:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _17063 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_17063] = 38
                                                mem[_17063 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if arg2 > balanceOf[address(msg.sender)]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17063 + 70 len 26]
                                                    var75001 = 64
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(msg.sender)] < arg2:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= arg2
                                                if balanceOf[arg1] > !arg2:
                                                    revert with 0, 17
                                                if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                emit Transfer(arg2, msg.sender, arg1);
                                            else:
                                                mem[0] = arg1
                                                mem[32] = 14
                                                if stor14[address(arg1)]:
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not arg1:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _17347 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_17347] = 38
                                                    mem[_17347 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if arg2 > balanceOf[address(msg.sender)]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17347 + 70 len 26]
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(msg.sender)] < arg2:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2
                                                    if balanceOf[arg1] > !arg2:
                                                        revert with 0, 17
                                                    if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                    emit Transfer(arg2, msg.sender, arg1);
                                                else:
                                                    if stor10:
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not arg1:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        _17066 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_17066] = 38
                                                        mem[_17066 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if arg2 > balanceOf[address(msg.sender)]:
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 38
                                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17066 + 70 len 26]
                                                            var75001 = 64
                                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                        if balanceOf[address(msg.sender)] < arg2:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] -= arg2
                                                        if balanceOf[arg1] > !arg2:
                                                            revert with 0, 17
                                                        if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                        emit Transfer(arg2, msg.sender, arg1);
                                                    else:
                                                        _16539 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_16539] = 26
                                                        mem[_16539 + 32] = 'SafeMath: division by zero'
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not stor13:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        _19025 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_19025] = 38
                                                        mem[_19025 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 38
                                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_19025 + 70 len 26]
                                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                        if balanceOf[address(msg.sender)] < arg2 / 100:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] -= arg2 / 100
                                                        if balanceOf[stor13] > !(arg2 / 100):
                                                            revert with 0, 17
                                                        if balanceOf[stor13] + (arg2 / 100) < balanceOf[stor13]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        mem[0] = stor13
                                                        mem[32] = 1
                                                        balanceOf[stor13] += arg2 / 100
                                                        emit Transfer((arg2 / 100), msg.sender, stor13);
                                                        _22641 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_22641] = 26
                                                        mem[_22641 + 32] = 'SafeMath: division by zero'
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not sub_8230af5aAddress:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        _23495 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_23495] = 38
                                                        mem[_23495 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 38
                                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_23495 + 70 len 26]
                                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                        if balanceOf[address(msg.sender)] < arg2 / 100:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] -= arg2 / 100
                                                        if balanceOf[stor9] > !(arg2 / 100):
                                                            revert with 0, 17
                                                        if balanceOf[stor9] + (arg2 / 100) < balanceOf[stor9]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        mem[0] = sub_8230af5aAddress
                                                        mem[32] = 1
                                                        balanceOf[stor9] += arg2 / 100
                                                        emit Transfer((arg2 / 100), msg.sender, sub_8230af5aAddress);
                                                        _24327 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_24327] = 26
                                                        mem[_24327 + 32] = 'SafeMath: division by zero'
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not uniswapV2PairAddress:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        _24555 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_24555] = 38
                                                        mem[_24555 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 38
                                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_24555 + 70 len 26]
                                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                        if balanceOf[address(msg.sender)] < arg2 / 100:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] -= arg2 / 100
                                                        if balanceOf[stor7] > !(arg2 / 100):
                                                            revert with 0, 17
                                                        if balanceOf[stor7] + (arg2 / 100) < balanceOf[stor7]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        mem[0] = uniswapV2PairAddress
                                                        mem[32] = 1
                                                        balanceOf[stor7] += arg2 / 100
                                                        emit Transfer((arg2 / 100), msg.sender, uniswapV2PairAddress);
                                                        _25315 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_25315] = 26
                                                        mem[_25315 + 32] = 'SafeMath: division by zero'
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not this.address:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        _25543 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_25543] = 38
                                                        mem[_25543 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if arg2 / 10 > balanceOf[address(msg.sender)]:
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 38
                                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_25543 + 70 len 26]
                                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                        if balanceOf[address(msg.sender)] < arg2 / 10:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] -= arg2 / 10
                                                        if balanceOf[this.address] > !(arg2 / 10):
                                                            revert with 0, 17
                                                        if balanceOf[this.address] + (arg2 / 10) < balanceOf[this.address]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        mem[0] = this.address
                                                        mem[32] = 1
                                                        balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 10)
                                                        emit Transfer((arg2 / 10), msg.sender, this.address);
                                                        _26303 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_26303] = 26
                                                        mem[_26303 + 32] = 'SafeMath: division by zero'
                                                        if not arg2 / 100:
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not arg1:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _26564 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_26564] = 38
                                                            mem[_26564 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if 0 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_26564 + 70 len 26]
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < 0:
                                                                revert with 0, 17
                                                            if balanceOf[arg1] > -1:
                                                                revert with 0, 17
                                                            if balanceOf[arg1] < balanceOf[arg1]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            balanceOf[address(arg1)] = balanceOf[arg1]
                                                            emit Transfer(0, msg.sender, arg1);
                                                        else:
                                                            if arg2 / 100 and 87 > -1 / arg2 / 100:
                                                                revert with 0, 17
                                                            if not arg2 / 100:
                                                                revert with 0, 18
                                                            if 87 * arg2 / 100 / arg2 / 100 != 87:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not arg1:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _27155 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_27155] = 38
                                                            mem[_27155 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if 87 * arg2 / 100 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_27155 + 70 len 26]
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < 87 * arg2 / 100:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] += -87 * arg2 / 100
                                                            if balanceOf[arg1] > !(87 * arg2 / 100):
                                                                revert with 0, 17
                                                            if balanceOf[arg1] + (87 * arg2 / 100) < balanceOf[arg1]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            balanceOf[address(arg1)] = balanceOf[arg1] + (87 * arg2 / 100)
                                                            emit Transfer((87 * arg2 / 100), msg.sender, arg1);
                                        else:
                                            idx = 0
                                            t = 0
                                            u = 160 * stor19.length
                                            while idx < 9:
                                                if 0 > !idx:
                                                    revert with 0, 17
                                                if idx >= stor19.length:
                                                    revert with 0, 50
                                                mem[0] = stor19[idx]
                                                mem[32] = 1
                                                if balanceOf[stor19[idx]] < 10000000000 * 10^18:
                                                    if idx == -1:
                                                        revert with 0, 17
                                                    idx = idx + 1
                                                    t = t
                                                    u = stor19[idx]
                                                    continue 
                                                mem[0] = stor19[idx]
                                                mem[32] = 1
                                                if not balanceOf[stor19[idx]]:
                                                    _17746 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_17746] = 26
                                                    mem[_17746 + 32] = 'SafeMath: division by zero'
                                                    if not s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                        _18037 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _18037 + 68] = mem[idx + _17746 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_18037 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _18037 + -mem[64] + 100
                                                    if 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                        if not 4 * ext_call.return_data[0] / 5:
                                                            _20892 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_20892] = 26
                                                            mem[_20892 + 32] = 'SafeMath: division by zero'
                                                            mem[mem[64] + 4] = stor19[idx]
                                                            mem[mem[64] + 36] = 0
                                                            require ext_code.size(dogeAddress)
                                                            call dogeAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args stor19[idx], 0
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _22740 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_22740] == bool(mem[_22740])
                                                        else:
                                                            if 4 * ext_call.return_data[0] / 5 and 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length > -1 / 4 * ext_call.return_data[0] / 5:
                                                                revert with 0, 17
                                                            if not 4 * ext_call.return_data[0] / 5:
                                                                revert with 0, 18
                                                            if 4 * ext_call.return_data[0] / 5 * 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 4 * ext_call.return_data[0] / 5 != 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _22175 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_22175] = 26
                                                            mem[_22175 + 32] = 'SafeMath: division by zero'
                                                            mem[mem[64] + 4] = stor19[idx]
                                                            mem[mem[64] + 36] = 4 * ext_call.return_data[0] / 5 * 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 10000
                                                            require ext_code.size(dogeAddress)
                                                            call dogeAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args stor19[idx], 4 * ext_call.return_data[0] / 5 * 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 10000
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _23172 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_23172] == bool(mem[_23172])
                                                    if idx == -1:
                                                        revert with 0, 17
                                                    idx = idx + 1
                                                    t = 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length
                                                    u = stor19[idx]
                                                    continue 
                                                if balanceOf[stor19[idx]] and 10000 > -1 / balanceOf[stor19[idx]]:
                                                    revert with 0, 17
                                                if not balanceOf[stor19[idx]]:
                                                    revert with 0, 18
                                                if 10000 * balanceOf[stor19[idx]] / balanceOf[stor19[idx]] != 10000:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _19260 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_19260] = 26
                                                mem[_19260 + 32] = 'SafeMath: division by zero'
                                                if not s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                    _19578 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _19578 + 68] = mem[idx + _19260 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_19578 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _19578 + -mem[64] + 100
                                                if 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                    if not 4 * ext_call.return_data[0] / 5:
                                                        _22174 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_22174] = 26
                                                        mem[_22174 + 32] = 'SafeMath: division by zero'
                                                        mem[mem[64] + 4] = stor19[idx]
                                                        mem[mem[64] + 36] = 0
                                                        require ext_code.size(dogeAddress)
                                                        call dogeAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args stor19[idx], 0
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _23171 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_23171] == bool(mem[_23171])
                                                    else:
                                                        if 4 * ext_call.return_data[0] / 5 and 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length > -1 / 4 * ext_call.return_data[0] / 5:
                                                            revert with 0, 17
                                                        if not 4 * ext_call.return_data[0] / 5:
                                                            revert with 0, 18
                                                        if 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 4 * ext_call.return_data[0] / 5 != 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _22991 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_22991] = 26
                                                        mem[_22991 + 32] = 'SafeMath: division by zero'
                                                        mem[mem[64] + 4] = stor19[idx]
                                                        mem[mem[64] + 36] = 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 10000
                                                        require ext_code.size(dogeAddress)
                                                        call dogeAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args stor19[idx], 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 10000
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _23663 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_23663] == bool(mem[_23663])
                                                if idx == -1:
                                                    revert with 0, 17
                                                idx = idx + 1
                                                t = 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length
                                                u = stor19[idx]
                                                continue 
                                            mem[0] = msg.sender
                                            mem[32] = 14
                                            if stor14[address(msg.sender)]:
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not arg1:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _17071 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_17071] = 38
                                                mem[_17071 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if arg2 > balanceOf[address(msg.sender)]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17071 + 70 len 26]
                                                    var75001 = 64
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(msg.sender)] < arg2:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= arg2
                                                if balanceOf[arg1] > !arg2:
                                                    revert with 0, 17
                                                if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                emit Transfer(arg2, msg.sender, arg1);
                                            else:
                                                mem[0] = arg1
                                                mem[32] = 14
                                                if stor14[address(arg1)]:
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not arg1:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _17352 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_17352] = 38
                                                    mem[_17352 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if arg2 > balanceOf[address(msg.sender)]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17352 + 70 len 26]
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(msg.sender)] < arg2:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2
                                                    if balanceOf[arg1] > !arg2:
                                                        revert with 0, 17
                                                    if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                    emit Transfer(arg2, msg.sender, arg1);
                                                else:
                                                    if stor10:
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not arg1:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        _17074 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_17074] = 38
                                                        mem[_17074 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if arg2 > balanceOf[address(msg.sender)]:
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 38
                                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17074 + 70 len 26]
                                                            var75001 = 64
                                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                        if balanceOf[address(msg.sender)] < arg2:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] -= arg2
                                                        if balanceOf[arg1] > !arg2:
                                                            revert with 0, 17
                                                        if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                        emit Transfer(arg2, msg.sender, arg1);
                                                    else:
                                                        _16540 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_16540] = 26
                                                        mem[_16540 + 32] = 'SafeMath: division by zero'
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not stor13:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        _19033 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_19033] = 38
                                                        mem[_19033 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 38
                                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_19033 + 70 len 26]
                                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                        if balanceOf[address(msg.sender)] < arg2 / 100:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] -= arg2 / 100
                                                        if balanceOf[stor13] > !(arg2 / 100):
                                                            revert with 0, 17
                                                        if balanceOf[stor13] + (arg2 / 100) < balanceOf[stor13]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        mem[0] = stor13
                                                        mem[32] = 1
                                                        balanceOf[stor13] += arg2 / 100
                                                        emit Transfer((arg2 / 100), msg.sender, stor13);
                                                        _22645 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_22645] = 26
                                                        mem[_22645 + 32] = 'SafeMath: division by zero'
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not sub_8230af5aAddress:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        _23498 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_23498] = 38
                                                        mem[_23498 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 38
                                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_23498 + 70 len 26]
                                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                        if balanceOf[address(msg.sender)] < arg2 / 100:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] -= arg2 / 100
                                                        if balanceOf[stor9] > !(arg2 / 100):
                                                            revert with 0, 17
                                                        if balanceOf[stor9] + (arg2 / 100) < balanceOf[stor9]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        mem[0] = sub_8230af5aAddress
                                                        mem[32] = 1
                                                        balanceOf[stor9] += arg2 / 100
                                                        emit Transfer((arg2 / 100), msg.sender, sub_8230af5aAddress);
                                                        _24328 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_24328] = 26
                                                        mem[_24328 + 32] = 'SafeMath: division by zero'
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not uniswapV2PairAddress:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        _24558 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_24558] = 38
                                                        mem[_24558 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 38
                                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_24558 + 70 len 26]
                                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                        if balanceOf[address(msg.sender)] < arg2 / 100:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] -= arg2 / 100
                                                        if balanceOf[stor7] > !(arg2 / 100):
                                                            revert with 0, 17
                                                        if balanceOf[stor7] + (arg2 / 100) < balanceOf[stor7]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        mem[0] = uniswapV2PairAddress
                                                        mem[32] = 1
                                                        balanceOf[stor7] += arg2 / 100
                                                        emit Transfer((arg2 / 100), msg.sender, uniswapV2PairAddress);
                                                        _25316 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_25316] = 26
                                                        mem[_25316 + 32] = 'SafeMath: division by zero'
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not this.address:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        _25546 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_25546] = 38
                                                        mem[_25546 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if arg2 / 10 > balanceOf[address(msg.sender)]:
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 38
                                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_25546 + 70 len 26]
                                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                        if balanceOf[address(msg.sender)] < arg2 / 10:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] -= arg2 / 10
                                                        if balanceOf[this.address] > !(arg2 / 10):
                                                            revert with 0, 17
                                                        if balanceOf[this.address] + (arg2 / 10) < balanceOf[this.address]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        mem[0] = this.address
                                                        mem[32] = 1
                                                        balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 10)
                                                        emit Transfer((arg2 / 10), msg.sender, this.address);
                                                        _26304 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_26304] = 26
                                                        mem[_26304 + 32] = 'SafeMath: division by zero'
                                                        if not arg2 / 100:
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not arg1:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _26568 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_26568] = 38
                                                            mem[_26568 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if 0 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_26568 + 70 len 26]
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < 0:
                                                                revert with 0, 17
                                                            if balanceOf[arg1] > -1:
                                                                revert with 0, 17
                                                            if balanceOf[arg1] < balanceOf[arg1]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            balanceOf[address(arg1)] = balanceOf[arg1]
                                                            emit Transfer(0, msg.sender, arg1);
                                                        else:
                                                            if arg2 / 100 and 87 > -1 / arg2 / 100:
                                                                revert with 0, 17
                                                            if not arg2 / 100:
                                                                revert with 0, 18
                                                            if 87 * arg2 / 100 / arg2 / 100 != 87:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not arg1:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _27160 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_27160] = 38
                                                            mem[_27160 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if 87 * arg2 / 100 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_27160 + 70 len 26]
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < 87 * arg2 / 100:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] += -87 * arg2 / 100
                                                            if balanceOf[arg1] > !(87 * arg2 / 100):
                                                                revert with 0, 17
                                                            if balanceOf[arg1] + (87 * arg2 / 100) < balanceOf[arg1]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            balanceOf[address(arg1)] = balanceOf[arg1] + (87 * arg2 / 100)
                                                            emit Transfer((87 * arg2 / 100), msg.sender, arg1);
                                    else:
                                        if stor19.length < 9:
                                            revert with 0, 17
                                        mem[64] = ceil32(return_data.size) + 224
                                        mem[ceil32(return_data.size) + 160] = 24
                                        mem[ceil32(return_data.size) + 192] = 'SafeMath: modulo by zero'
                                        if not stor19.length - 9:
                                            revert with 0, 'SafeMath: modulo by zero', 0
                                        idx = 0
                                        s = 0
                                        t = 0
                                        while idx < 9:
                                            if block.timestamp % stor19.length - 9 > !idx:
                                                revert with 0, 17
                                            if (block.timestamp % stor19.length - 9) + idx >= stor19.length:
                                                revert with 0, 50
                                            mem[0] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                            mem[32] = 1
                                            if s > !balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]]:
                                                revert with 0, 17
                                            if s + balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] < s:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            s = s + balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]]
                                            t = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                            continue 
                                        if stor19.length <= 9:
                                            idx = 0
                                            t = 0
                                            u = 1440
                                            while idx < stor19.length:
                                                mem[0] = stor19[idx]
                                                mem[32] = 1
                                                if balanceOf[stor19[idx]] < 10000000000 * 10^18:
                                                    if idx == -1:
                                                        revert with 0, 17
                                                    idx = idx + 1
                                                    t = t
                                                    u = stor19[idx]
                                                    continue 
                                                mem[0] = stor19[idx]
                                                mem[32] = 1
                                                if not balanceOf[stor19[idx]]:
                                                    _17085 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_17085] = 26
                                                    mem[_17085 + 32] = 'SafeMath: division by zero'
                                                    if not 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                        _17557 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _17557 + 68] = mem[idx + _17085 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_17557 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _17557 + -mem[64] + 100
                                                    if 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                        if not 4 * ext_call.return_data[0] / 5:
                                                            _20316 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_20316] = 26
                                                            mem[_20316 + 32] = 'SafeMath: division by zero'
                                                            mem[mem[64] + 4] = stor19[idx]
                                                            mem[mem[64] + 36] = 0
                                                            require ext_code.size(dogeAddress)
                                                            call dogeAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args stor19[idx], 0
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _22182 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_22182] == bool(mem[_22182])
                                                        else:
                                                            if 4 * ext_call.return_data[0] / 5 and 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s > -1 / 4 * ext_call.return_data[0] / 5:
                                                                revert with 0, 17
                                                            if not 4 * ext_call.return_data[0] / 5:
                                                                revert with 0, 18
                                                            if 4 * ext_call.return_data[0] / 5 * 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 4 * ext_call.return_data[0] / 5 != 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _21260 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_21260] = 26
                                                            mem[_21260 + 32] = 'SafeMath: division by zero'
                                                            mem[mem[64] + 4] = stor19[idx]
                                                            mem[mem[64] + 36] = 4 * ext_call.return_data[0] / 5 * 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 10000
                                                            require ext_code.size(dogeAddress)
                                                            call dogeAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args stor19[idx], 4 * ext_call.return_data[0] / 5 * 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 10000
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _22993 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_22993] == bool(mem[_22993])
                                                    if idx == -1:
                                                        revert with 0, 17
                                                    idx = idx + 1
                                                    t = 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s
                                                    u = stor19[idx]
                                                    continue 
                                                if balanceOf[stor19[idx]] and 10000 > -1 / balanceOf[stor19[idx]]:
                                                    revert with 0, 17
                                                if not balanceOf[stor19[idx]]:
                                                    revert with 0, 18
                                                if 10000 * balanceOf[stor19[idx]] / balanceOf[stor19[idx]] != 10000:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _18351 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_18351] = 26
                                                mem[_18351 + 32] = 'SafeMath: division by zero'
                                                if not 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                    _19045 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _19045 + 68] = mem[idx + _18351 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_19045 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _19045 + -mem[64] + 100
                                                if 10000 * balanceOf[stor19[idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                    if not 4 * ext_call.return_data[0] / 5:
                                                        _21259 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_21259] = 26
                                                        mem[_21259 + 32] = 'SafeMath: division by zero'
                                                        mem[mem[64] + 4] = stor19[idx]
                                                        mem[mem[64] + 36] = 0
                                                        require ext_code.size(dogeAddress)
                                                        call dogeAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args stor19[idx], 0
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _22992 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_22992] == bool(mem[_22992])
                                                    else:
                                                        if 4 * ext_call.return_data[0] / 5 and 10000 * balanceOf[stor19[idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s > -1 / 4 * ext_call.return_data[0] / 5:
                                                            revert with 0, 17
                                                        if not 4 * ext_call.return_data[0] / 5:
                                                            revert with 0, 18
                                                        if 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor19[idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 4 * ext_call.return_data[0] / 5 != 10000 * balanceOf[stor19[idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _22741 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_22741] = 26
                                                        mem[_22741 + 32] = 'SafeMath: division by zero'
                                                        mem[mem[64] + 4] = stor19[idx]
                                                        mem[mem[64] + 36] = 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor19[idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 10000
                                                        require ext_code.size(dogeAddress)
                                                        call dogeAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args stor19[idx], 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor19[idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 10000
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _23361 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_23361] == bool(mem[_23361])
                                                if idx == -1:
                                                    revert with 0, 17
                                                idx = idx + 1
                                                t = 10000 * balanceOf[stor19[idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s
                                                u = stor19[idx]
                                                continue 
                                            mem[0] = msg.sender
                                            mem[32] = 14
                                            if stor14[address(msg.sender)]:
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not arg1:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _17078 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_17078] = 38
                                                mem[_17078 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if arg2 > balanceOf[address(msg.sender)]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17078 + 70 len 26]
                                                    var86001 = 64
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(msg.sender)] < arg2:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= arg2
                                                if balanceOf[arg1] > !arg2:
                                                    revert with 0, 17
                                                if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                emit Transfer(arg2, msg.sender, arg1);
                                            else:
                                                mem[0] = arg1
                                                mem[32] = 14
                                                if stor14[address(arg1)]:
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not arg1:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _17357 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_17357] = 38
                                                    mem[_17357 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if arg2 > balanceOf[address(msg.sender)]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17357 + 70 len 26]
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(msg.sender)] < arg2:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2
                                                    if balanceOf[arg1] > !arg2:
                                                        revert with 0, 17
                                                    if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                    emit Transfer(arg2, msg.sender, arg1);
                                                else:
                                                    if stor10:
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not arg1:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        _17081 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_17081] = 38
                                                        mem[_17081 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if arg2 > balanceOf[address(msg.sender)]:
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 38
                                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17081 + 70 len 26]
                                                            var86001 = 64
                                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                        if balanceOf[address(msg.sender)] < arg2:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] -= arg2
                                                        if balanceOf[arg1] > !arg2:
                                                            revert with 0, 17
                                                        if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                        emit Transfer(arg2, msg.sender, arg1);
                                                    else:
                                                        _16542 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_16542] = 26
                                                        mem[_16542 + 32] = 'SafeMath: division by zero'
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not stor13:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        _19041 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_19041] = 38
                                                        mem[_19041 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 38
                                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_19041 + 70 len 26]
                                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                        if balanceOf[address(msg.sender)] < arg2 / 100:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] -= arg2 / 100
                                                        if balanceOf[stor13] > !(arg2 / 100):
                                                            revert with 0, 17
                                                        if balanceOf[stor13] + (arg2 / 100) < balanceOf[stor13]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        mem[0] = stor13
                                                        mem[32] = 1
                                                        balanceOf[stor13] += arg2 / 100
                                                        emit Transfer((arg2 / 100), msg.sender, stor13);
                                                        _22647 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_22647] = 26
                                                        mem[_22647 + 32] = 'SafeMath: division by zero'
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not sub_8230af5aAddress:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        _23503 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_23503] = 38
                                                        mem[_23503 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 38
                                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_23503 + 70 len 26]
                                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                        if balanceOf[address(msg.sender)] < arg2 / 100:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] -= arg2 / 100
                                                        if balanceOf[stor9] > !(arg2 / 100):
                                                            revert with 0, 17
                                                        if balanceOf[stor9] + (arg2 / 100) < balanceOf[stor9]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        mem[0] = sub_8230af5aAddress
                                                        mem[32] = 1
                                                        balanceOf[stor9] += arg2 / 100
                                                        emit Transfer((arg2 / 100), msg.sender, sub_8230af5aAddress);
                                                        _24329 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_24329] = 26
                                                        mem[_24329 + 32] = 'SafeMath: division by zero'
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not uniswapV2PairAddress:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        _24561 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_24561] = 38
                                                        mem[_24561 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 38
                                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_24561 + 70 len 26]
                                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                        if balanceOf[address(msg.sender)] < arg2 / 100:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] -= arg2 / 100
                                                        if balanceOf[stor7] > !(arg2 / 100):
                                                            revert with 0, 17
                                                        if balanceOf[stor7] + (arg2 / 100) < balanceOf[stor7]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        mem[0] = uniswapV2PairAddress
                                                        mem[32] = 1
                                                        balanceOf[stor7] += arg2 / 100
                                                        emit Transfer((arg2 / 100), msg.sender, uniswapV2PairAddress);
                                                        _25317 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_25317] = 26
                                                        mem[_25317 + 32] = 'SafeMath: division by zero'
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not this.address:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        _25549 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_25549] = 38
                                                        mem[_25549 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if arg2 / 10 > balanceOf[address(msg.sender)]:
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 38
                                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_25549 + 70 len 26]
                                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                        if balanceOf[address(msg.sender)] < arg2 / 10:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] -= arg2 / 10
                                                        if balanceOf[this.address] > !(arg2 / 10):
                                                            revert with 0, 17
                                                        if balanceOf[this.address] + (arg2 / 10) < balanceOf[this.address]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        mem[0] = this.address
                                                        mem[32] = 1
                                                        balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 10)
                                                        emit Transfer((arg2 / 10), msg.sender, this.address);
                                                        _26305 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_26305] = 26
                                                        mem[_26305 + 32] = 'SafeMath: division by zero'
                                                        if not arg2 / 100:
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not arg1:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _26572 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_26572] = 38
                                                            mem[_26572 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if 0 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_26572 + 70 len 26]
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < 0:
                                                                revert with 0, 17
                                                            if balanceOf[arg1] > -1:
                                                                revert with 0, 17
                                                            if balanceOf[arg1] < balanceOf[arg1]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            balanceOf[address(arg1)] = balanceOf[arg1]
                                                            emit Transfer(0, msg.sender, arg1);
                                                        else:
                                                            if arg2 / 100 and 87 > -1 / arg2 / 100:
                                                                revert with 0, 17
                                                            if not arg2 / 100:
                                                                revert with 0, 18
                                                            if 87 * arg2 / 100 / arg2 / 100 != 87:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not arg1:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _27165 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_27165] = 38
                                                            mem[_27165 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if 87 * arg2 / 100 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_27165 + 70 len 26]
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < 87 * arg2 / 100:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] += -87 * arg2 / 100
                                                            if balanceOf[arg1] > !(87 * arg2 / 100):
                                                                revert with 0, 17
                                                            if balanceOf[arg1] + (87 * arg2 / 100) < balanceOf[arg1]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            balanceOf[address(arg1)] = balanceOf[arg1] + (87 * arg2 / 100)
                                                            emit Transfer((87 * arg2 / 100), msg.sender, arg1);
                                        else:
                                            idx = 0
                                            t = 0
                                            u = 1440
                                            while idx < 9:
                                                if block.timestamp % stor19.length - 9 > !idx:
                                                    revert with 0, 17
                                                if (block.timestamp % stor19.length - 9) + idx >= stor19.length:
                                                    revert with 0, 50
                                                mem[0] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                                mem[32] = 1
                                                if balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] < 10000000000 * 10^18:
                                                    if idx == -1:
                                                        revert with 0, 17
                                                    idx = idx + 1
                                                    t = t
                                                    u = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                                    continue 
                                                mem[0] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                                mem[32] = 1
                                                if not balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]]:
                                                    _17754 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_17754] = 26
                                                    mem[_17754 + 32] = 'SafeMath: division by zero'
                                                    if not 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                        _18044 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _18044 + 68] = mem[idx + _17754 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_18044 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _18044 + -mem[64] + 100
                                                    if 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                        if not 4 * ext_call.return_data[0] / 5:
                                                            _20898 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_20898] = 26
                                                            mem[_20898 + 32] = 'SafeMath: division by zero'
                                                            mem[mem[64] + 4] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                                            mem[mem[64] + 36] = 0
                                                            require ext_code.size(dogeAddress)
                                                            call dogeAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx], 0
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _22742 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_22742] == bool(mem[_22742])
                                                        else:
                                                            if 4 * ext_call.return_data[0] / 5 and 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s > -1 / 4 * ext_call.return_data[0] / 5:
                                                                revert with 0, 17
                                                            if not 4 * ext_call.return_data[0] / 5:
                                                                revert with 0, 18
                                                            if 4 * ext_call.return_data[0] / 5 * 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 4 * ext_call.return_data[0] / 5 != 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _22190 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_22190] = 26
                                                            mem[_22190 + 32] = 'SafeMath: division by zero'
                                                            mem[mem[64] + 4] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                                            mem[mem[64] + 36] = 4 * ext_call.return_data[0] / 5 * 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 10000
                                                            require ext_code.size(dogeAddress)
                                                            call dogeAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx], 4 * ext_call.return_data[0] / 5 * 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 10000
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _23174 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_23174] == bool(mem[_23174])
                                                    if idx == -1:
                                                        revert with 0, 17
                                                    idx = idx + 1
                                                    t = 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s
                                                    u = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                                    continue 
                                                if balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] and 10000 > -1 / balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]]:
                                                    revert with 0, 17
                                                if not balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]]:
                                                    revert with 0, 18
                                                if 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] != 10000:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _19266 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_19266] = 26
                                                mem[_19266 + 32] = 'SafeMath: division by zero'
                                                if not 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                    _19587 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _19587 + 68] = mem[idx + _19266 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_19587 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _19587 + -mem[64] + 100
                                                if 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                    if not 4 * ext_call.return_data[0] / 5:
                                                        _22189 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_22189] = 26
                                                        mem[_22189 + 32] = 'SafeMath: division by zero'
                                                        mem[mem[64] + 4] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                                        mem[mem[64] + 36] = 0
                                                        require ext_code.size(dogeAddress)
                                                        call dogeAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx], 0
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _23173 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_23173] == bool(mem[_23173])
                                                    else:
                                                        if 4 * ext_call.return_data[0] / 5 and 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s > -1 / 4 * ext_call.return_data[0] / 5:
                                                            revert with 0, 17
                                                        if not 4 * ext_call.return_data[0] / 5:
                                                            revert with 0, 18
                                                        if 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 4 * ext_call.return_data[0] / 5 != 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _22994 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_22994] = 26
                                                        mem[_22994 + 32] = 'SafeMath: division by zero'
                                                        mem[mem[64] + 4] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                                        mem[mem[64] + 36] = 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 10000
                                                        require ext_code.size(dogeAddress)
                                                        call dogeAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx], 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 10000
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _23666 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_23666] == bool(mem[_23666])
                                                if idx == -1:
                                                    revert with 0, 17
                                                idx = idx + 1
                                                t = 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s
                                                u = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                                continue 
                                            mem[0] = msg.sender
                                            mem[32] = 14
                                            if stor14[address(msg.sender)]:
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not arg1:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _17086 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_17086] = 38
                                                mem[_17086 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if arg2 > balanceOf[address(msg.sender)]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17086 + 70 len 26]
                                                    var86001 = 64
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(msg.sender)] < arg2:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= arg2
                                                if balanceOf[arg1] > !arg2:
                                                    revert with 0, 17
                                                if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                emit Transfer(arg2, msg.sender, arg1);
                                            else:
                                                mem[0] = arg1
                                                mem[32] = 14
                                                if stor14[address(arg1)]:
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not arg1:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _17362 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_17362] = 38
                                                    mem[_17362 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if arg2 > balanceOf[address(msg.sender)]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17362 + 70 len 26]
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(msg.sender)] < arg2:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2
                                                    if balanceOf[arg1] > !arg2:
                                                        revert with 0, 17
                                                    if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                    emit Transfer(arg2, msg.sender, arg1);
                                                else:
                                                    if stor10:
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not arg1:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        _17089 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_17089] = 38
                                                        mem[_17089 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if arg2 > balanceOf[address(msg.sender)]:
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 38
                                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17089 + 70 len 26]
                                                            var86001 = 64
                                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                        if balanceOf[address(msg.sender)] < arg2:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] -= arg2
                                                        if balanceOf[arg1] > !arg2:
                                                            revert with 0, 17
                                                        if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                        emit Transfer(arg2, msg.sender, arg1);
                                                    else:
                                                        _16543 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_16543] = 26
                                                        mem[_16543 + 32] = 'SafeMath: division by zero'
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not stor13:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        _19049 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_19049] = 38
                                                        mem[_19049 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 38
                                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_19049 + 70 len 26]
                                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                        if balanceOf[address(msg.sender)] < arg2 / 100:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] -= arg2 / 100
                                                        if balanceOf[stor13] > !(arg2 / 100):
                                                            revert with 0, 17
                                                        if balanceOf[stor13] + (arg2 / 100) < balanceOf[stor13]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        mem[0] = stor13
                                                        mem[32] = 1
                                                        balanceOf[stor13] += arg2 / 100
                                                        emit Transfer((arg2 / 100), msg.sender, stor13);
                                                        _22651 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_22651] = 26
                                                        mem[_22651 + 32] = 'SafeMath: division by zero'
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not sub_8230af5aAddress:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        _23506 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_23506] = 38
                                                        mem[_23506 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 38
                                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_23506 + 70 len 26]
                                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                        if balanceOf[address(msg.sender)] < arg2 / 100:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] -= arg2 / 100
                                                        if balanceOf[stor9] > !(arg2 / 100):
                                                            revert with 0, 17
                                                        if balanceOf[stor9] + (arg2 / 100) < balanceOf[stor9]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        mem[0] = sub_8230af5aAddress
                                                        mem[32] = 1
                                                        balanceOf[stor9] += arg2 / 100
                                                        emit Transfer((arg2 / 100), msg.sender, sub_8230af5aAddress);
                                                        _24330 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_24330] = 26
                                                        mem[_24330 + 32] = 'SafeMath: division by zero'
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not uniswapV2PairAddress:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        _24564 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_24564] = 38
                                                        mem[_24564 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 38
                                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_24564 + 70 len 26]
                                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                        if balanceOf[address(msg.sender)] < arg2 / 100:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] -= arg2 / 100
                                                        if balanceOf[stor7] > !(arg2 / 100):
                                                            revert with 0, 17
                                                        if balanceOf[stor7] + (arg2 / 100) < balanceOf[stor7]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        mem[0] = uniswapV2PairAddress
                                                        mem[32] = 1
                                                        balanceOf[stor7] += arg2 / 100
                                                        emit Transfer((arg2 / 100), msg.sender, uniswapV2PairAddress);
                                                        _25318 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_25318] = 26
                                                        mem[_25318 + 32] = 'SafeMath: division by zero'
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not this.address:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        _25552 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_25552] = 38
                                                        mem[_25552 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if arg2 / 10 > balanceOf[address(msg.sender)]:
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 38
                                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_25552 + 70 len 26]
                                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                        if balanceOf[address(msg.sender)] < arg2 / 10:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] -= arg2 / 10
                                                        if balanceOf[this.address] > !(arg2 / 10):
                                                            revert with 0, 17
                                                        if balanceOf[this.address] + (arg2 / 10) < balanceOf[this.address]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        mem[0] = this.address
                                                        mem[32] = 1
                                                        balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 10)
                                                        emit Transfer((arg2 / 10), msg.sender, this.address);
                                                        _26306 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_26306] = 26
                                                        mem[_26306 + 32] = 'SafeMath: division by zero'
                                                        if not arg2 / 100:
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not arg1:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _26576 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_26576] = 38
                                                            mem[_26576 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if 0 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_26576 + 70 len 26]
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < 0:
                                                                revert with 0, 17
                                                            if balanceOf[arg1] > -1:
                                                                revert with 0, 17
                                                            if balanceOf[arg1] < balanceOf[arg1]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            balanceOf[address(arg1)] = balanceOf[arg1]
                                                            emit Transfer(0, msg.sender, arg1);
                                                        else:
                                                            if arg2 / 100 and 87 > -1 / arg2 / 100:
                                                                revert with 0, 17
                                                            if not arg2 / 100:
                                                                revert with 0, 18
                                                            if 87 * arg2 / 100 / arg2 / 100 != 87:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not arg1:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _27170 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_27170] = 38
                                                            mem[_27170 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if 87 * arg2 / 100 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_27170 + 70 len 26]
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < 87 * arg2 / 100:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] += -87 * arg2 / 100
                                                            if balanceOf[arg1] > !(87 * arg2 / 100):
                                                                revert with 0, 17
                                                            if balanceOf[arg1] + (87 * arg2 / 100) < balanceOf[arg1]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            balanceOf[address(arg1)] = balanceOf[arg1] + (87 * arg2 / 100)
                                                            emit Transfer((87 * arg2 / 100), msg.sender, arg1);
                    else:
                        if not swapAndLiquifyEnabled:
                            mem[100] = this.address
                            require ext_code.size(dogeAddress)
                            staticcall dogeAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[96] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if ext_call.return_data[0] < 10^12:
                                if not msg.sender:
                                    revert with 0, 'ERC20: transfer from the zero address'
                                if stor14[address(msg.sender)]:
                                    if not arg1:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    if arg2 > balanceOf[address(msg.sender)]:
                                        revert with 0, 
                                                    32,
                                                    38,
                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 166 len 26] >> 48,
                                                    0
                                    if balanceOf[address(msg.sender)] < arg2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)] -= arg2
                                    if balanceOf[arg1] > !arg2:
                                        revert with 0, 17
                                    if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                    emit Transfer(arg2, msg.sender, arg1);
                                else:
                                    if stor14[address(arg1)]:
                                        if not arg1:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        if arg2 > balanceOf[address(msg.sender)]:
                                            revert with 0, 
                                                        32,
                                                        38,
                                                        0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 166 len 26] >> 48,
                                                        0
                                        if balanceOf[address(msg.sender)] < arg2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2
                                        if balanceOf[arg1] > !arg2:
                                            revert with 0, 17
                                        if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                        emit Transfer(arg2, msg.sender, arg1);
                                    else:
                                        if stor10:
                                            if not arg1:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            if arg2 > balanceOf[address(msg.sender)]:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 166 len 26] >> 48,
                                                            0
                                            if balanceOf[address(msg.sender)] < arg2:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2
                                            if balanceOf[arg1] > !arg2:
                                                revert with 0, 17
                                            if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                            emit Transfer(arg2, msg.sender, arg1);
                                        else:
                                            if not stor13:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 230 len 26] >> 48,
                                                            0
                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                            if balanceOf[stor13] > !(arg2 / 100):
                                                revert with 0, 17
                                            if balanceOf[stor13] + (arg2 / 100) < balanceOf[stor13]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[stor13] += arg2 / 100
                                            emit Transfer((arg2 / 100), msg.sender, stor13);
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not sub_8230af5aAddress:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 390 len 26] >> 48,
                                                            0
                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                            if balanceOf[stor9] > !(arg2 / 100):
                                                revert with 0, 17
                                            if balanceOf[stor9] + (arg2 / 100) < balanceOf[stor9]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[stor9] += arg2 / 100
                                            emit Transfer((arg2 / 100), msg.sender, sub_8230af5aAddress);
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not uniswapV2PairAddress:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 550 len 26] >> 48,
                                                            0
                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                            if balanceOf[stor7] > !(arg2 / 100):
                                                revert with 0, 17
                                            if balanceOf[stor7] + (arg2 / 100) < balanceOf[stor7]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[stor7] += arg2 / 100
                                            emit Transfer((arg2 / 100), msg.sender, uniswapV2PairAddress);
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not this.address:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            if arg2 / 10 > balanceOf[address(msg.sender)]:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 710 len 26] >> 48,
                                                            0
                                            if balanceOf[address(msg.sender)] < arg2 / 10:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2 / 10
                                            if balanceOf[this.address] > !(arg2 / 10):
                                                revert with 0, 17
                                            if balanceOf[this.address] + (arg2 / 10) < balanceOf[this.address]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 10)
                                            emit Transfer((arg2 / 10), msg.sender, this.address);
                                            if not arg2 / 100:
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not arg1:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                if 0 > balanceOf[address(msg.sender)]:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 870 len 26] >> 48,
                                                                0
                                                if balanceOf[address(msg.sender)] < 0:
                                                    revert with 0, 17
                                                if balanceOf[arg1] > -1:
                                                    revert with 0, 17
                                                if balanceOf[arg1] < balanceOf[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(arg1)] = balanceOf[arg1]
                                                emit Transfer(0, msg.sender, arg1);
                                            else:
                                                if arg2 / 100 and 87 > -1 / arg2 / 100:
                                                    revert with 0, 17
                                                if not arg2 / 100:
                                                    revert with 0, 18
                                                if 87 * arg2 / 100 / arg2 / 100 != 87:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not arg1:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                if 87 * arg2 / 100 > balanceOf[address(msg.sender)]:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 870 len 26] >> 48,
                                                                0
                                                if balanceOf[address(msg.sender)] < 87 * arg2 / 100:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] += -87 * arg2 / 100
                                                if balanceOf[arg1] > !(87 * arg2 / 100):
                                                    revert with 0, 17
                                                if balanceOf[arg1] + (87 * arg2 / 100) < balanceOf[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(arg1)] = balanceOf[arg1] + (87 * arg2 / 100)
                                                emit Transfer((87 * arg2 / 100), msg.sender, arg1);
                            else:
                                if not ext_call.return_data[0]:
                                    mem[64] = ceil32(return_data.size) + 160
                                    mem[ceil32(return_data.size) + 96] = 26
                                    mem[ceil32(return_data.size) + 128] = 'SafeMath: division by zero'
                                    if not stor19.length:
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if stor14[address(msg.sender)]:
                                            if not arg1:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            if arg2 > balanceOf[address(msg.sender)]:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 230 len 26] >> 48,
                                                            0
                                            if balanceOf[address(msg.sender)] < arg2:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2
                                            if balanceOf[arg1] > !arg2:
                                                revert with 0, 17
                                            if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                            emit Transfer(arg2, msg.sender, arg1);
                                        else:
                                            if stor14[address(arg1)]:
                                                if not arg1:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                if arg2 > balanceOf[address(msg.sender)]:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 230 len 26] >> 48,
                                                                0
                                                if balanceOf[address(msg.sender)] < arg2:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= arg2
                                                if balanceOf[arg1] > !arg2:
                                                    revert with 0, 17
                                                if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                emit Transfer(arg2, msg.sender, arg1);
                                            else:
                                                if stor10:
                                                    if not arg1:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    if arg2 > balanceOf[address(msg.sender)]:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 230 len 26] >> 48,
                                                                    0
                                                    if balanceOf[address(msg.sender)] < arg2:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2
                                                    if balanceOf[arg1] > !arg2:
                                                        revert with 0, 17
                                                    if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                    emit Transfer(arg2, msg.sender, arg1);
                                                else:
                                                    if not stor13:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 294 len 26] >> 48,
                                                                    0
                                                    if balanceOf[address(msg.sender)] < arg2 / 100:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2 / 100
                                                    if balanceOf[stor13] > !(arg2 / 100):
                                                        revert with 0, 17
                                                    if balanceOf[stor13] + (arg2 / 100) < balanceOf[stor13]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[stor13] += arg2 / 100
                                                    emit Transfer((arg2 / 100), msg.sender, stor13);
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not sub_8230af5aAddress:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 454 len 26] >> 48,
                                                                    0
                                                    if balanceOf[address(msg.sender)] < arg2 / 100:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2 / 100
                                                    if balanceOf[stor9] > !(arg2 / 100):
                                                        revert with 0, 17
                                                    if balanceOf[stor9] + (arg2 / 100) < balanceOf[stor9]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[stor9] += arg2 / 100
                                                    emit Transfer((arg2 / 100), msg.sender, sub_8230af5aAddress);
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not uniswapV2PairAddress:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 614 len 26] >> 48,
                                                                    0
                                                    if balanceOf[address(msg.sender)] < arg2 / 100:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2 / 100
                                                    if balanceOf[stor7] > !(arg2 / 100):
                                                        revert with 0, 17
                                                    if balanceOf[stor7] + (arg2 / 100) < balanceOf[stor7]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[stor7] += arg2 / 100
                                                    emit Transfer((arg2 / 100), msg.sender, uniswapV2PairAddress);
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not this.address:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    if arg2 / 10 > balanceOf[address(msg.sender)]:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 774 len 26] >> 48,
                                                                    0
                                                    if balanceOf[address(msg.sender)] < arg2 / 10:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2 / 10
                                                    if balanceOf[this.address] > !(arg2 / 10):
                                                        revert with 0, 17
                                                    if balanceOf[this.address] + (arg2 / 10) < balanceOf[this.address]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 10)
                                                    emit Transfer((arg2 / 10), msg.sender, this.address);
                                                    if not arg2 / 100:
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not arg1:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        if 0 > balanceOf[address(msg.sender)]:
                                                            revert with 0, 
                                                                        32,
                                                                        38,
                                                                        0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 934 len 26] >> 48,
                                                                        0
                                                        if balanceOf[address(msg.sender)] < 0:
                                                            revert with 0, 17
                                                        if balanceOf[arg1] > -1:
                                                            revert with 0, 17
                                                        if balanceOf[arg1] < balanceOf[arg1]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(arg1)] = balanceOf[arg1]
                                                        emit Transfer(0, msg.sender, arg1);
                                                    else:
                                                        if arg2 / 100 and 87 > -1 / arg2 / 100:
                                                            revert with 0, 17
                                                        if not arg2 / 100:
                                                            revert with 0, 18
                                                        if 87 * arg2 / 100 / arg2 / 100 != 87:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not arg1:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        if 87 * arg2 / 100 > balanceOf[address(msg.sender)]:
                                                            revert with 0, 
                                                                        32,
                                                                        38,
                                                                        0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 934 len 26] >> 48,
                                                                        0
                                                        if balanceOf[address(msg.sender)] < 87 * arg2 / 100:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] += -87 * arg2 / 100
                                                        if balanceOf[arg1] > !(87 * arg2 / 100):
                                                            revert with 0, 17
                                                        if balanceOf[arg1] + (87 * arg2 / 100) < balanceOf[arg1]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(arg1)] = balanceOf[arg1] + (87 * arg2 / 100)
                                                        emit Transfer((87 * arg2 / 100), msg.sender, arg1);
                                    else:
                                        if stor19.length <= 9:
                                            idx = 0
                                            s = 0
                                            t = 0
                                            while idx < stor19.length:
                                                mem[0] = stor19[idx]
                                                mem[32] = 1
                                                if s > !balanceOf[stor19[idx]]:
                                                    revert with 0, 17
                                                if s + balanceOf[stor19[idx]] < s:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if idx == -1:
                                                    revert with 0, 17
                                                idx = idx + 1
                                                s = s + balanceOf[stor19[idx]]
                                                t = stor19[idx]
                                                continue 
                                            if stor19.length <= 9:
                                                idx = 0
                                                t = 0
                                                u = 160 * stor19.length
                                                while idx < stor19.length:
                                                    mem[0] = stor19[idx]
                                                    mem[32] = 1
                                                    if balanceOf[stor19[idx]] < 10000000000 * 10^18:
                                                        if idx == -1:
                                                            revert with 0, 17
                                                        idx = idx + 1
                                                        t = t
                                                        u = stor19[idx]
                                                        continue 
                                                    mem[0] = stor19[idx]
                                                    mem[32] = 1
                                                    if not balanceOf[stor19[idx]]:
                                                        _17160 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_17160] = 26
                                                        mem[_17160 + 32] = 'SafeMath: division by zero'
                                                        if not s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                            _17592 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _17592 + 68] = mem[idx + _17160 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_17592 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _17592 + -mem[64] + 100
                                                        if 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                            _20386 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_20386] = 26
                                                            mem[_20386 + 32] = 'SafeMath: division by zero'
                                                            mem[mem[64] + 4] = stor19[idx]
                                                            mem[mem[64] + 36] = 0
                                                            require ext_code.size(dogeAddress)
                                                            call dogeAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args stor19[idx], 0
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _22255 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_22255] == bool(mem[_22255])
                                                        if idx == -1:
                                                            revert with 0, 17
                                                        idx = idx + 1
                                                        t = 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length
                                                        u = stor19[idx]
                                                        continue 
                                                    if balanceOf[stor19[idx]] and 10000 > -1 / balanceOf[stor19[idx]]:
                                                        revert with 0, 17
                                                    if not balanceOf[stor19[idx]]:
                                                        revert with 0, 18
                                                    if 10000 * balanceOf[stor19[idx]] / balanceOf[stor19[idx]] != 10000:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _18421 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_18421] = 26
                                                    mem[_18421 + 32] = 'SafeMath: division by zero'
                                                    if not s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                        _19125 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _19125 + 68] = mem[idx + _18421 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_19125 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _19125 + -mem[64] + 100
                                                    if 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                        _21287 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_21287] = 26
                                                        mem[_21287 + 32] = 'SafeMath: division by zero'
                                                        mem[mem[64] + 4] = stor19[idx]
                                                        mem[mem[64] + 36] = 0
                                                        require ext_code.size(dogeAddress)
                                                        call dogeAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args stor19[idx], 0
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _23003 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_23003] == bool(mem[_23003])
                                                    if idx == -1:
                                                        revert with 0, 17
                                                    idx = idx + 1
                                                    t = 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length
                                                    u = stor19[idx]
                                                    continue 
                                                mem[0] = msg.sender
                                                mem[32] = 14
                                                if stor14[address(msg.sender)]:
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not arg1:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _17153 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_17153] = 38
                                                    mem[_17153 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if arg2 > balanceOf[address(msg.sender)]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17153 + 70 len 26]
                                                        var70001 = 64
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(msg.sender)] < arg2:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2
                                                    if balanceOf[arg1] > !arg2:
                                                        revert with 0, 17
                                                    if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                    emit Transfer(arg2, msg.sender, arg1);
                                                else:
                                                    mem[0] = arg1
                                                    mem[32] = 14
                                                    if stor14[address(arg1)]:
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not arg1:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        _17407 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_17407] = 38
                                                        mem[_17407 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if arg2 > balanceOf[address(msg.sender)]:
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 38
                                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17407 + 70 len 26]
                                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                        if balanceOf[address(msg.sender)] < arg2:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] -= arg2
                                                        if balanceOf[arg1] > !arg2:
                                                            revert with 0, 17
                                                        if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                        emit Transfer(arg2, msg.sender, arg1);
                                                    else:
                                                        if stor10:
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not arg1:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _17156 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_17156] = 38
                                                            mem[_17156 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if arg2 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17156 + 70 len 26]
                                                                var70001 = 64
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < arg2:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2
                                                            if balanceOf[arg1] > !arg2:
                                                                revert with 0, 17
                                                            if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                            emit Transfer(arg2, msg.sender, arg1);
                                                        else:
                                                            _16557 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_16557] = 26
                                                            mem[_16557 + 32] = 'SafeMath: division by zero'
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not stor13:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _19121 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_19121] = 38
                                                            mem[_19121 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_19121 + 70 len 26]
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                                            if balanceOf[stor13] > !(arg2 / 100):
                                                                revert with 0, 17
                                                            if balanceOf[stor13] + (arg2 / 100) < balanceOf[stor13]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = stor13
                                                            mem[32] = 1
                                                            balanceOf[stor13] += arg2 / 100
                                                            emit Transfer((arg2 / 100), msg.sender, stor13);
                                                            _22675 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_22675] = 26
                                                            mem[_22675 + 32] = 'SafeMath: division by zero'
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not sub_8230af5aAddress:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _23539 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_23539] = 38
                                                            mem[_23539 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_23539 + 70 len 26]
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                                            if balanceOf[stor9] > !(arg2 / 100):
                                                                revert with 0, 17
                                                            if balanceOf[stor9] + (arg2 / 100) < balanceOf[stor9]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = sub_8230af5aAddress
                                                            mem[32] = 1
                                                            balanceOf[stor9] += arg2 / 100
                                                            emit Transfer((arg2 / 100), msg.sender, sub_8230af5aAddress);
                                                            _24339 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_24339] = 26
                                                            mem[_24339 + 32] = 'SafeMath: division by zero'
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not uniswapV2PairAddress:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _24591 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_24591] = 38
                                                            mem[_24591 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_24591 + 70 len 26]
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                                            if balanceOf[stor7] > !(arg2 / 100):
                                                                revert with 0, 17
                                                            if balanceOf[stor7] + (arg2 / 100) < balanceOf[stor7]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = uniswapV2PairAddress
                                                            mem[32] = 1
                                                            balanceOf[stor7] += arg2 / 100
                                                            emit Transfer((arg2 / 100), msg.sender, uniswapV2PairAddress);
                                                            _25327 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_25327] = 26
                                                            mem[_25327 + 32] = 'SafeMath: division by zero'
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not this.address:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _25579 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_25579] = 38
                                                            mem[_25579 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if arg2 / 10 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_25579 + 70 len 26]
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < arg2 / 10:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2 / 10
                                                            if balanceOf[this.address] > !(arg2 / 10):
                                                                revert with 0, 17
                                                            if balanceOf[this.address] + (arg2 / 10) < balanceOf[this.address]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = this.address
                                                            mem[32] = 1
                                                            balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 10)
                                                            emit Transfer((arg2 / 10), msg.sender, this.address);
                                                            _26315 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_26315] = 26
                                                            mem[_26315 + 32] = 'SafeMath: division by zero'
                                                            if not arg2 / 100:
                                                                if not msg.sender:
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not arg1:
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                _26612 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_26612] = 38
                                                                mem[_26612 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                if 0 > balanceOf[address(msg.sender)]:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 38
                                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_26612 + 70 len 26]
                                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                if balanceOf[address(msg.sender)] < 0:
                                                                    revert with 0, 17
                                                                if balanceOf[arg1] > -1:
                                                                    revert with 0, 17
                                                                if balanceOf[arg1] < balanceOf[arg1]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                balanceOf[address(arg1)] = balanceOf[arg1]
                                                                emit Transfer(0, msg.sender, arg1);
                                                            else:
                                                                if arg2 / 100 and 87 > -1 / arg2 / 100:
                                                                    revert with 0, 17
                                                                if not arg2 / 100:
                                                                    revert with 0, 18
                                                                if 87 * arg2 / 100 / arg2 / 100 != 87:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if not msg.sender:
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not arg1:
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                _27215 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_27215] = 38
                                                                mem[_27215 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                if 87 * arg2 / 100 > balanceOf[address(msg.sender)]:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 38
                                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_27215 + 70 len 26]
                                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                if balanceOf[address(msg.sender)] < 87 * arg2 / 100:
                                                                    revert with 0, 17
                                                                balanceOf[address(msg.sender)] += -87 * arg2 / 100
                                                                if balanceOf[arg1] > !(87 * arg2 / 100):
                                                                    revert with 0, 17
                                                                if balanceOf[arg1] + (87 * arg2 / 100) < balanceOf[arg1]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                balanceOf[address(arg1)] = balanceOf[arg1] + (87 * arg2 / 100)
                                                                emit Transfer((87 * arg2 / 100), msg.sender, arg1);
                                            else:
                                                idx = 0
                                                t = 0
                                                u = 160 * stor19.length
                                                while idx < 9:
                                                    if 0 > !idx:
                                                        revert with 0, 17
                                                    if idx >= stor19.length:
                                                        revert with 0, 50
                                                    mem[0] = stor19[idx]
                                                    mem[32] = 1
                                                    if balanceOf[stor19[idx]] < 10000000000 * 10^18:
                                                        if idx == -1:
                                                            revert with 0, 17
                                                        idx = idx + 1
                                                        t = t
                                                        u = stor19[idx]
                                                        continue 
                                                    mem[0] = stor19[idx]
                                                    mem[32] = 1
                                                    if not balanceOf[stor19[idx]]:
                                                        _17794 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_17794] = 26
                                                        mem[_17794 + 32] = 'SafeMath: division by zero'
                                                        if not s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                            _18079 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _18079 + 68] = mem[idx + _17794 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_18079 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _18079 + -mem[64] + 100
                                                        if 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                            _20928 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_20928] = 26
                                                            mem[_20928 + 32] = 'SafeMath: division by zero'
                                                            mem[mem[64] + 4] = stor19[idx]
                                                            mem[mem[64] + 36] = 0
                                                            require ext_code.size(dogeAddress)
                                                            call dogeAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args stor19[idx], 0
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _22749 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_22749] == bool(mem[_22749])
                                                        if idx == -1:
                                                            revert with 0, 17
                                                        idx = idx + 1
                                                        t = 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length
                                                        u = stor19[idx]
                                                        continue 
                                                    if balanceOf[stor19[idx]] and 10000 > -1 / balanceOf[stor19[idx]]:
                                                        revert with 0, 17
                                                    if not balanceOf[stor19[idx]]:
                                                        revert with 0, 18
                                                    if 10000 * balanceOf[stor19[idx]] / balanceOf[stor19[idx]] != 10000:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _19296 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_19296] = 26
                                                    mem[_19296 + 32] = 'SafeMath: division by zero'
                                                    if not s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                        _19632 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _19632 + 68] = mem[idx + _19296 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_19632 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _19632 + -mem[64] + 100
                                                    if 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                        _22262 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_22262] = 26
                                                        mem[_22262 + 32] = 'SafeMath: division by zero'
                                                        mem[mem[64] + 4] = stor19[idx]
                                                        mem[mem[64] + 36] = 0
                                                        require ext_code.size(dogeAddress)
                                                        call dogeAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args stor19[idx], 0
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _23181 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_23181] == bool(mem[_23181])
                                                    if idx == -1:
                                                        revert with 0, 17
                                                    idx = idx + 1
                                                    t = 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length
                                                    u = stor19[idx]
                                                    continue 
                                                mem[0] = msg.sender
                                                mem[32] = 14
                                                if stor14[address(msg.sender)]:
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not arg1:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _17161 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_17161] = 38
                                                    mem[_17161 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if arg2 > balanceOf[address(msg.sender)]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17161 + 70 len 26]
                                                        var70001 = 64
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(msg.sender)] < arg2:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2
                                                    if balanceOf[arg1] > !arg2:
                                                        revert with 0, 17
                                                    if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                    emit Transfer(arg2, msg.sender, arg1);
                                                else:
                                                    mem[0] = arg1
                                                    mem[32] = 14
                                                    if stor14[address(arg1)]:
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not arg1:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        _17412 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_17412] = 38
                                                        mem[_17412 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if arg2 > balanceOf[address(msg.sender)]:
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 38
                                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17412 + 70 len 26]
                                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                        if balanceOf[address(msg.sender)] < arg2:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] -= arg2
                                                        if balanceOf[arg1] > !arg2:
                                                            revert with 0, 17
                                                        if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                        emit Transfer(arg2, msg.sender, arg1);
                                                    else:
                                                        if stor10:
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not arg1:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _17164 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_17164] = 38
                                                            mem[_17164 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if arg2 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17164 + 70 len 26]
                                                                var70001 = 64
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < arg2:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2
                                                            if balanceOf[arg1] > !arg2:
                                                                revert with 0, 17
                                                            if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                            emit Transfer(arg2, msg.sender, arg1);
                                                        else:
                                                            _16558 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_16558] = 26
                                                            mem[_16558 + 32] = 'SafeMath: division by zero'
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not stor13:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _19129 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_19129] = 38
                                                            mem[_19129 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_19129 + 70 len 26]
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                                            if balanceOf[stor13] > !(arg2 / 100):
                                                                revert with 0, 17
                                                            if balanceOf[stor13] + (arg2 / 100) < balanceOf[stor13]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = stor13
                                                            mem[32] = 1
                                                            balanceOf[stor13] += arg2 / 100
                                                            emit Transfer((arg2 / 100), msg.sender, stor13);
                                                            _22678 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_22678] = 26
                                                            mem[_22678 + 32] = 'SafeMath: division by zero'
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not sub_8230af5aAddress:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _23542 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_23542] = 38
                                                            mem[_23542 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_23542 + 70 len 26]
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                                            if balanceOf[stor9] > !(arg2 / 100):
                                                                revert with 0, 17
                                                            if balanceOf[stor9] + (arg2 / 100) < balanceOf[stor9]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = sub_8230af5aAddress
                                                            mem[32] = 1
                                                            balanceOf[stor9] += arg2 / 100
                                                            emit Transfer((arg2 / 100), msg.sender, sub_8230af5aAddress);
                                                            _24340 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_24340] = 26
                                                            mem[_24340 + 32] = 'SafeMath: division by zero'
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not uniswapV2PairAddress:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _24594 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_24594] = 38
                                                            mem[_24594 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_24594 + 70 len 26]
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                                            if balanceOf[stor7] > !(arg2 / 100):
                                                                revert with 0, 17
                                                            if balanceOf[stor7] + (arg2 / 100) < balanceOf[stor7]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = uniswapV2PairAddress
                                                            mem[32] = 1
                                                            balanceOf[stor7] += arg2 / 100
                                                            emit Transfer((arg2 / 100), msg.sender, uniswapV2PairAddress);
                                                            _25328 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_25328] = 26
                                                            mem[_25328 + 32] = 'SafeMath: division by zero'
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not this.address:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _25582 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_25582] = 38
                                                            mem[_25582 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if arg2 / 10 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_25582 + 70 len 26]
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < arg2 / 10:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2 / 10
                                                            if balanceOf[this.address] > !(arg2 / 10):
                                                                revert with 0, 17
                                                            if balanceOf[this.address] + (arg2 / 10) < balanceOf[this.address]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = this.address
                                                            mem[32] = 1
                                                            balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 10)
                                                            emit Transfer((arg2 / 10), msg.sender, this.address);
                                                            _26316 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_26316] = 26
                                                            mem[_26316 + 32] = 'SafeMath: division by zero'
                                                            if not arg2 / 100:
                                                                if not msg.sender:
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not arg1:
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                _26616 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_26616] = 38
                                                                mem[_26616 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                if 0 > balanceOf[address(msg.sender)]:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 38
                                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_26616 + 70 len 26]
                                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                if balanceOf[address(msg.sender)] < 0:
                                                                    revert with 0, 17
                                                                if balanceOf[arg1] > -1:
                                                                    revert with 0, 17
                                                                if balanceOf[arg1] < balanceOf[arg1]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                balanceOf[address(arg1)] = balanceOf[arg1]
                                                                emit Transfer(0, msg.sender, arg1);
                                                            else:
                                                                if arg2 / 100 and 87 > -1 / arg2 / 100:
                                                                    revert with 0, 17
                                                                if not arg2 / 100:
                                                                    revert with 0, 18
                                                                if 87 * arg2 / 100 / arg2 / 100 != 87:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if not msg.sender:
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not arg1:
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                _27220 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_27220] = 38
                                                                mem[_27220 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                if 87 * arg2 / 100 > balanceOf[address(msg.sender)]:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 38
                                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_27220 + 70 len 26]
                                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                if balanceOf[address(msg.sender)] < 87 * arg2 / 100:
                                                                    revert with 0, 17
                                                                balanceOf[address(msg.sender)] += -87 * arg2 / 100
                                                                if balanceOf[arg1] > !(87 * arg2 / 100):
                                                                    revert with 0, 17
                                                                if balanceOf[arg1] + (87 * arg2 / 100) < balanceOf[arg1]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                balanceOf[address(arg1)] = balanceOf[arg1] + (87 * arg2 / 100)
                                                                emit Transfer((87 * arg2 / 100), msg.sender, arg1);
                                        else:
                                            if stor19.length < 9:
                                                revert with 0, 17
                                            mem[64] = ceil32(return_data.size) + 224
                                            mem[ceil32(return_data.size) + 160] = 24
                                            mem[ceil32(return_data.size) + 192] = 'SafeMath: modulo by zero'
                                            if not stor19.length - 9:
                                                revert with 0, 'SafeMath: modulo by zero', 0
                                            idx = 0
                                            s = 0
                                            t = 0
                                            while idx < 9:
                                                if block.timestamp % stor19.length - 9 > !idx:
                                                    revert with 0, 17
                                                if (block.timestamp % stor19.length - 9) + idx >= stor19.length:
                                                    revert with 0, 50
                                                mem[0] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                                mem[32] = 1
                                                if s > !balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]]:
                                                    revert with 0, 17
                                                if s + balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] < s:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if idx == -1:
                                                    revert with 0, 17
                                                idx = idx + 1
                                                s = s + balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]]
                                                t = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                                continue 
                                            if stor19.length <= 9:
                                                idx = 0
                                                t = 0
                                                u = 1440
                                                while idx < stor19.length:
                                                    mem[0] = stor19[idx]
                                                    mem[32] = 1
                                                    if balanceOf[stor19[idx]] < 10000000000 * 10^18:
                                                        if idx == -1:
                                                            revert with 0, 17
                                                        idx = idx + 1
                                                        t = t
                                                        u = stor19[idx]
                                                        continue 
                                                    mem[0] = stor19[idx]
                                                    mem[32] = 1
                                                    if not balanceOf[stor19[idx]]:
                                                        _17175 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_17175] = 26
                                                        mem[_17175 + 32] = 'SafeMath: division by zero'
                                                        if not 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                            _17599 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _17599 + 68] = mem[idx + _17175 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_17599 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _17599 + -mem[64] + 100
                                                        if 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                            _20400 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_20400] = 26
                                                            mem[_20400 + 32] = 'SafeMath: division by zero'
                                                            mem[mem[64] + 4] = stor19[idx]
                                                            mem[mem[64] + 36] = 0
                                                            require ext_code.size(dogeAddress)
                                                            call dogeAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args stor19[idx], 0
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _22269 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_22269] == bool(mem[_22269])
                                                        if idx == -1:
                                                            revert with 0, 17
                                                        idx = idx + 1
                                                        t = 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s
                                                        u = stor19[idx]
                                                        continue 
                                                    if balanceOf[stor19[idx]] and 10000 > -1 / balanceOf[stor19[idx]]:
                                                        revert with 0, 17
                                                    if not balanceOf[stor19[idx]]:
                                                        revert with 0, 18
                                                    if 10000 * balanceOf[stor19[idx]] / balanceOf[stor19[idx]] != 10000:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _18435 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_18435] = 26
                                                    mem[_18435 + 32] = 'SafeMath: division by zero'
                                                    if not 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                        _19141 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _19141 + 68] = mem[idx + _18435 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_19141 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _19141 + -mem[64] + 100
                                                    if 10000 * balanceOf[stor19[idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                        _21292 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_21292] = 26
                                                        mem[_21292 + 32] = 'SafeMath: division by zero'
                                                        mem[mem[64] + 4] = stor19[idx]
                                                        mem[mem[64] + 36] = 0
                                                        require ext_code.size(dogeAddress)
                                                        call dogeAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args stor19[idx], 0
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _23004 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_23004] == bool(mem[_23004])
                                                    if idx == -1:
                                                        revert with 0, 17
                                                    idx = idx + 1
                                                    t = 10000 * balanceOf[stor19[idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s
                                                    u = stor19[idx]
                                                    continue 
                                                mem[0] = msg.sender
                                                mem[32] = 14
                                                if stor14[address(msg.sender)]:
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not arg1:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _17168 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_17168] = 38
                                                    mem[_17168 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if arg2 > balanceOf[address(msg.sender)]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17168 + 70 len 26]
                                                        var81001 = 64
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(msg.sender)] < arg2:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2
                                                    if balanceOf[arg1] > !arg2:
                                                        revert with 0, 17
                                                    if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                    emit Transfer(arg2, msg.sender, arg1);
                                                else:
                                                    mem[0] = arg1
                                                    mem[32] = 14
                                                    if stor14[address(arg1)]:
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not arg1:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        _17417 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_17417] = 38
                                                        mem[_17417 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if arg2 > balanceOf[address(msg.sender)]:
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 38
                                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17417 + 70 len 26]
                                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                        if balanceOf[address(msg.sender)] < arg2:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] -= arg2
                                                        if balanceOf[arg1] > !arg2:
                                                            revert with 0, 17
                                                        if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                        emit Transfer(arg2, msg.sender, arg1);
                                                    else:
                                                        if stor10:
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not arg1:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _17171 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_17171] = 38
                                                            mem[_17171 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if arg2 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17171 + 70 len 26]
                                                                var81001 = 64
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < arg2:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2
                                                            if balanceOf[arg1] > !arg2:
                                                                revert with 0, 17
                                                            if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                            emit Transfer(arg2, msg.sender, arg1);
                                                        else:
                                                            _16560 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_16560] = 26
                                                            mem[_16560 + 32] = 'SafeMath: division by zero'
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not stor13:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _19137 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_19137] = 38
                                                            mem[_19137 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_19137 + 70 len 26]
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                                            if balanceOf[stor13] > !(arg2 / 100):
                                                                revert with 0, 17
                                                            if balanceOf[stor13] + (arg2 / 100) < balanceOf[stor13]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = stor13
                                                            mem[32] = 1
                                                            balanceOf[stor13] += arg2 / 100
                                                            emit Transfer((arg2 / 100), msg.sender, stor13);
                                                            _22680 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_22680] = 26
                                                            mem[_22680 + 32] = 'SafeMath: division by zero'
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not sub_8230af5aAddress:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _23545 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_23545] = 38
                                                            mem[_23545 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_23545 + 70 len 26]
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                                            if balanceOf[stor9] > !(arg2 / 100):
                                                                revert with 0, 17
                                                            if balanceOf[stor9] + (arg2 / 100) < balanceOf[stor9]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = sub_8230af5aAddress
                                                            mem[32] = 1
                                                            balanceOf[stor9] += arg2 / 100
                                                            emit Transfer((arg2 / 100), msg.sender, sub_8230af5aAddress);
                                                            _24341 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_24341] = 26
                                                            mem[_24341 + 32] = 'SafeMath: division by zero'
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not uniswapV2PairAddress:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _24597 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_24597] = 38
                                                            mem[_24597 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_24597 + 70 len 26]
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                                            if balanceOf[stor7] > !(arg2 / 100):
                                                                revert with 0, 17
                                                            if balanceOf[stor7] + (arg2 / 100) < balanceOf[stor7]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = uniswapV2PairAddress
                                                            mem[32] = 1
                                                            balanceOf[stor7] += arg2 / 100
                                                            emit Transfer((arg2 / 100), msg.sender, uniswapV2PairAddress);
                                                            _25329 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_25329] = 26
                                                            mem[_25329 + 32] = 'SafeMath: division by zero'
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not this.address:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _25585 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_25585] = 38
                                                            mem[_25585 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if arg2 / 10 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_25585 + 70 len 26]
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < arg2 / 10:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2 / 10
                                                            if balanceOf[this.address] > !(arg2 / 10):
                                                                revert with 0, 17
                                                            if balanceOf[this.address] + (arg2 / 10) < balanceOf[this.address]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = this.address
                                                            mem[32] = 1
                                                            balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 10)
                                                            emit Transfer((arg2 / 10), msg.sender, this.address);
                                                            _26317 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_26317] = 26
                                                            mem[_26317 + 32] = 'SafeMath: division by zero'
                                                            if not arg2 / 100:
                                                                if not msg.sender:
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not arg1:
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                _26620 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_26620] = 38
                                                                mem[_26620 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                if 0 > balanceOf[address(msg.sender)]:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 38
                                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_26620 + 70 len 26]
                                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                if balanceOf[address(msg.sender)] < 0:
                                                                    revert with 0, 17
                                                                if balanceOf[arg1] > -1:
                                                                    revert with 0, 17
                                                                if balanceOf[arg1] < balanceOf[arg1]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                balanceOf[address(arg1)] = balanceOf[arg1]
                                                                emit Transfer(0, msg.sender, arg1);
                                                            else:
                                                                if arg2 / 100 and 87 > -1 / arg2 / 100:
                                                                    revert with 0, 17
                                                                if not arg2 / 100:
                                                                    revert with 0, 18
                                                                if 87 * arg2 / 100 / arg2 / 100 != 87:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if not msg.sender:
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not arg1:
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                _27225 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_27225] = 38
                                                                mem[_27225 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                if 87 * arg2 / 100 > balanceOf[address(msg.sender)]:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 38
                                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_27225 + 70 len 26]
                                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                if balanceOf[address(msg.sender)] < 87 * arg2 / 100:
                                                                    revert with 0, 17
                                                                balanceOf[address(msg.sender)] += -87 * arg2 / 100
                                                                if balanceOf[arg1] > !(87 * arg2 / 100):
                                                                    revert with 0, 17
                                                                if balanceOf[arg1] + (87 * arg2 / 100) < balanceOf[arg1]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                balanceOf[address(arg1)] = balanceOf[arg1] + (87 * arg2 / 100)
                                                                emit Transfer((87 * arg2 / 100), msg.sender, arg1);
                                            else:
                                                idx = 0
                                                t = 0
                                                u = 1440
                                                while idx < 9:
                                                    if block.timestamp % stor19.length - 9 > !idx:
                                                        revert with 0, 17
                                                    if (block.timestamp % stor19.length - 9) + idx >= stor19.length:
                                                        revert with 0, 50
                                                    mem[0] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                                    mem[32] = 1
                                                    if balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] < 10000000000 * 10^18:
                                                        if idx == -1:
                                                            revert with 0, 17
                                                        idx = idx + 1
                                                        t = t
                                                        u = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                                        continue 
                                                    mem[0] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                                    mem[32] = 1
                                                    if not balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]]:
                                                        _17802 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_17802] = 26
                                                        mem[_17802 + 32] = 'SafeMath: division by zero'
                                                        if not 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                            _18086 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _18086 + 68] = mem[idx + _17802 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_18086 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _18086 + -mem[64] + 100
                                                        if 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                            _20934 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_20934] = 26
                                                            mem[_20934 + 32] = 'SafeMath: division by zero'
                                                            mem[mem[64] + 4] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                                            mem[mem[64] + 36] = 0
                                                            require ext_code.size(dogeAddress)
                                                            call dogeAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx], 0
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _22750 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_22750] == bool(mem[_22750])
                                                        if idx == -1:
                                                            revert with 0, 17
                                                        idx = idx + 1
                                                        t = 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s
                                                        u = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                                        continue 
                                                    if balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] and 10000 > -1 / balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]]:
                                                        revert with 0, 17
                                                    if not balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]]:
                                                        revert with 0, 18
                                                    if 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] != 10000:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _19302 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_19302] = 26
                                                    mem[_19302 + 32] = 'SafeMath: division by zero'
                                                    if not 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                        _19641 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _19641 + 68] = mem[idx + _19302 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_19641 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _19641 + -mem[64] + 100
                                                    if 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                        _22276 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_22276] = 26
                                                        mem[_22276 + 32] = 'SafeMath: division by zero'
                                                        mem[mem[64] + 4] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                                        mem[mem[64] + 36] = 0
                                                        require ext_code.size(dogeAddress)
                                                        call dogeAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx], 0
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _23182 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_23182] == bool(mem[_23182])
                                                    if idx == -1:
                                                        revert with 0, 17
                                                    idx = idx + 1
                                                    t = 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s
                                                    u = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                                    continue 
                                                mem[0] = msg.sender
                                                mem[32] = 14
                                                if stor14[address(msg.sender)]:
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not arg1:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _17176 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_17176] = 38
                                                    mem[_17176 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if arg2 > balanceOf[address(msg.sender)]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17176 + 70 len 26]
                                                        var81001 = 64
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(msg.sender)] < arg2:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2
                                                    if balanceOf[arg1] > !arg2:
                                                        revert with 0, 17
                                                    if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                    emit Transfer(arg2, msg.sender, arg1);
                                                else:
                                                    mem[0] = arg1
                                                    mem[32] = 14
                                                    if stor14[address(arg1)]:
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not arg1:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        _17422 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_17422] = 38
                                                        mem[_17422 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if arg2 > balanceOf[address(msg.sender)]:
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 38
                                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17422 + 70 len 26]
                                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                        if balanceOf[address(msg.sender)] < arg2:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] -= arg2
                                                        if balanceOf[arg1] > !arg2:
                                                            revert with 0, 17
                                                        if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                        emit Transfer(arg2, msg.sender, arg1);
                                                    else:
                                                        if stor10:
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not arg1:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _17179 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_17179] = 38
                                                            mem[_17179 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if arg2 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17179 + 70 len 26]
                                                                var81001 = 64
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < arg2:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2
                                                            if balanceOf[arg1] > !arg2:
                                                                revert with 0, 17
                                                            if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                            emit Transfer(arg2, msg.sender, arg1);
                                                        else:
                                                            _16561 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_16561] = 26
                                                            mem[_16561 + 32] = 'SafeMath: division by zero'
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not stor13:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _19145 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_19145] = 38
                                                            mem[_19145 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_19145 + 70 len 26]
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                                            if balanceOf[stor13] > !(arg2 / 100):
                                                                revert with 0, 17
                                                            if balanceOf[stor13] + (arg2 / 100) < balanceOf[stor13]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = stor13
                                                            mem[32] = 1
                                                            balanceOf[stor13] += arg2 / 100
                                                            emit Transfer((arg2 / 100), msg.sender, stor13);
                                                            _22683 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_22683] = 26
                                                            mem[_22683 + 32] = 'SafeMath: division by zero'
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not sub_8230af5aAddress:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _23548 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_23548] = 38
                                                            mem[_23548 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_23548 + 70 len 26]
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                                            if balanceOf[stor9] > !(arg2 / 100):
                                                                revert with 0, 17
                                                            if balanceOf[stor9] + (arg2 / 100) < balanceOf[stor9]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = sub_8230af5aAddress
                                                            mem[32] = 1
                                                            balanceOf[stor9] += arg2 / 100
                                                            emit Transfer((arg2 / 100), msg.sender, sub_8230af5aAddress);
                                                            _24342 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_24342] = 26
                                                            mem[_24342 + 32] = 'SafeMath: division by zero'
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not uniswapV2PairAddress:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _24600 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_24600] = 38
                                                            mem[_24600 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_24600 + 70 len 26]
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                                            if balanceOf[stor7] > !(arg2 / 100):
                                                                revert with 0, 17
                                                            if balanceOf[stor7] + (arg2 / 100) < balanceOf[stor7]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = uniswapV2PairAddress
                                                            mem[32] = 1
                                                            balanceOf[stor7] += arg2 / 100
                                                            emit Transfer((arg2 / 100), msg.sender, uniswapV2PairAddress);
                                                            _25330 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_25330] = 26
                                                            mem[_25330 + 32] = 'SafeMath: division by zero'
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not this.address:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _25588 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_25588] = 38
                                                            mem[_25588 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if arg2 / 10 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_25588 + 70 len 26]
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < arg2 / 10:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2 / 10
                                                            if balanceOf[this.address] > !(arg2 / 10):
                                                                revert with 0, 17
                                                            if balanceOf[this.address] + (arg2 / 10) < balanceOf[this.address]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = this.address
                                                            mem[32] = 1
                                                            balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 10)
                                                            emit Transfer((arg2 / 10), msg.sender, this.address);
                                                            _26318 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_26318] = 26
                                                            mem[_26318 + 32] = 'SafeMath: division by zero'
                                                            if not arg2 / 100:
                                                                if not msg.sender:
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not arg1:
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                _26624 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_26624] = 38
                                                                mem[_26624 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                if 0 > balanceOf[address(msg.sender)]:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 38
                                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_26624 + 70 len 26]
                                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                if balanceOf[address(msg.sender)] < 0:
                                                                    revert with 0, 17
                                                                if balanceOf[arg1] > -1:
                                                                    revert with 0, 17
                                                                if balanceOf[arg1] < balanceOf[arg1]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                balanceOf[address(arg1)] = balanceOf[arg1]
                                                                emit Transfer(0, msg.sender, arg1);
                                                            else:
                                                                if arg2 / 100 and 87 > -1 / arg2 / 100:
                                                                    revert with 0, 17
                                                                if not arg2 / 100:
                                                                    revert with 0, 18
                                                                if 87 * arg2 / 100 / arg2 / 100 != 87:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if not msg.sender:
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not arg1:
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                _27230 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_27230] = 38
                                                                mem[_27230 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                if 87 * arg2 / 100 > balanceOf[address(msg.sender)]:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 38
                                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_27230 + 70 len 26]
                                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                if balanceOf[address(msg.sender)] < 87 * arg2 / 100:
                                                                    revert with 0, 17
                                                                balanceOf[address(msg.sender)] += -87 * arg2 / 100
                                                                if balanceOf[arg1] > !(87 * arg2 / 100):
                                                                    revert with 0, 17
                                                                if balanceOf[arg1] + (87 * arg2 / 100) < balanceOf[arg1]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                balanceOf[address(arg1)] = balanceOf[arg1] + (87 * arg2 / 100)
                                                                emit Transfer((87 * arg2 / 100), msg.sender, arg1);
                                else:
                                    if ext_call.return_data[0] and 4 > -1 / ext_call.return_data[0]:
                                        revert with 0, 17
                                    if not ext_call.return_data[0]:
                                        revert with 0, 18
                                    if 4 * ext_call.return_data[0] / ext_call.return_data[0] != 4:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[64] = ceil32(return_data.size) + 160
                                    mem[ceil32(return_data.size) + 96] = 26
                                    mem[ceil32(return_data.size) + 128] = 'SafeMath: division by zero'
                                    if not stor19.length:
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if stor14[address(msg.sender)]:
                                            if not arg1:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            if arg2 > balanceOf[address(msg.sender)]:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 230 len 26] >> 48,
                                                            0
                                            if balanceOf[address(msg.sender)] < arg2:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2
                                            if balanceOf[arg1] > !arg2:
                                                revert with 0, 17
                                            if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                            emit Transfer(arg2, msg.sender, arg1);
                                        else:
                                            if stor14[address(arg1)]:
                                                if not arg1:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                if arg2 > balanceOf[address(msg.sender)]:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 230 len 26] >> 48,
                                                                0
                                                if balanceOf[address(msg.sender)] < arg2:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= arg2
                                                if balanceOf[arg1] > !arg2:
                                                    revert with 0, 17
                                                if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                emit Transfer(arg2, msg.sender, arg1);
                                            else:
                                                if stor10:
                                                    if not arg1:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    if arg2 > balanceOf[address(msg.sender)]:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 230 len 26] >> 48,
                                                                    0
                                                    if balanceOf[address(msg.sender)] < arg2:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2
                                                    if balanceOf[arg1] > !arg2:
                                                        revert with 0, 17
                                                    if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                    emit Transfer(arg2, msg.sender, arg1);
                                                else:
                                                    if not stor13:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 294 len 26] >> 48,
                                                                    0
                                                    if balanceOf[address(msg.sender)] < arg2 / 100:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2 / 100
                                                    if balanceOf[stor13] > !(arg2 / 100):
                                                        revert with 0, 17
                                                    if balanceOf[stor13] + (arg2 / 100) < balanceOf[stor13]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[stor13] += arg2 / 100
                                                    emit Transfer((arg2 / 100), msg.sender, stor13);
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not sub_8230af5aAddress:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 454 len 26] >> 48,
                                                                    0
                                                    if balanceOf[address(msg.sender)] < arg2 / 100:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2 / 100
                                                    if balanceOf[stor9] > !(arg2 / 100):
                                                        revert with 0, 17
                                                    if balanceOf[stor9] + (arg2 / 100) < balanceOf[stor9]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[stor9] += arg2 / 100
                                                    emit Transfer((arg2 / 100), msg.sender, sub_8230af5aAddress);
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not uniswapV2PairAddress:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 614 len 26] >> 48,
                                                                    0
                                                    if balanceOf[address(msg.sender)] < arg2 / 100:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2 / 100
                                                    if balanceOf[stor7] > !(arg2 / 100):
                                                        revert with 0, 17
                                                    if balanceOf[stor7] + (arg2 / 100) < balanceOf[stor7]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[stor7] += arg2 / 100
                                                    emit Transfer((arg2 / 100), msg.sender, uniswapV2PairAddress);
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not this.address:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    if arg2 / 10 > balanceOf[address(msg.sender)]:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 774 len 26] >> 48,
                                                                    0
                                                    if balanceOf[address(msg.sender)] < arg2 / 10:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2 / 10
                                                    if balanceOf[this.address] > !(arg2 / 10):
                                                        revert with 0, 17
                                                    if balanceOf[this.address] + (arg2 / 10) < balanceOf[this.address]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 10)
                                                    emit Transfer((arg2 / 10), msg.sender, this.address);
                                                    if not arg2 / 100:
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not arg1:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        if 0 > balanceOf[address(msg.sender)]:
                                                            revert with 0, 
                                                                        32,
                                                                        38,
                                                                        0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 934 len 26] >> 48,
                                                                        0
                                                        if balanceOf[address(msg.sender)] < 0:
                                                            revert with 0, 17
                                                        if balanceOf[arg1] > -1:
                                                            revert with 0, 17
                                                        if balanceOf[arg1] < balanceOf[arg1]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(arg1)] = balanceOf[arg1]
                                                        emit Transfer(0, msg.sender, arg1);
                                                    else:
                                                        if arg2 / 100 and 87 > -1 / arg2 / 100:
                                                            revert with 0, 17
                                                        if not arg2 / 100:
                                                            revert with 0, 18
                                                        if 87 * arg2 / 100 / arg2 / 100 != 87:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not arg1:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        if 87 * arg2 / 100 > balanceOf[address(msg.sender)]:
                                                            revert with 0, 
                                                                        32,
                                                                        38,
                                                                        0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[ceil32(return_data.size) + 934 len 26] >> 48,
                                                                        0
                                                        if balanceOf[address(msg.sender)] < 87 * arg2 / 100:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] += -87 * arg2 / 100
                                                        if balanceOf[arg1] > !(87 * arg2 / 100):
                                                            revert with 0, 17
                                                        if balanceOf[arg1] + (87 * arg2 / 100) < balanceOf[arg1]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(arg1)] = balanceOf[arg1] + (87 * arg2 / 100)
                                                        emit Transfer((87 * arg2 / 100), msg.sender, arg1);
                                    else:
                                        if stor19.length <= 9:
                                            idx = 0
                                            s = 0
                                            t = 0
                                            while idx < stor19.length:
                                                mem[0] = stor19[idx]
                                                mem[32] = 1
                                                if s > !balanceOf[stor19[idx]]:
                                                    revert with 0, 17
                                                if s + balanceOf[stor19[idx]] < s:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if idx == -1:
                                                    revert with 0, 17
                                                idx = idx + 1
                                                s = s + balanceOf[stor19[idx]]
                                                t = stor19[idx]
                                                continue 
                                            if stor19.length <= 9:
                                                idx = 0
                                                t = 0
                                                u = 160 * stor19.length
                                                while idx < stor19.length:
                                                    mem[0] = stor19[idx]
                                                    mem[32] = 1
                                                    if balanceOf[stor19[idx]] < 10000000000 * 10^18:
                                                        if idx == -1:
                                                            revert with 0, 17
                                                        idx = idx + 1
                                                        t = t
                                                        u = stor19[idx]
                                                        continue 
                                                    mem[0] = stor19[idx]
                                                    mem[32] = 1
                                                    if not balanceOf[stor19[idx]]:
                                                        _17130 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_17130] = 26
                                                        mem[_17130 + 32] = 'SafeMath: division by zero'
                                                        if not s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                            _17578 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _17578 + 68] = mem[idx + _17130 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_17578 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _17578 + -mem[64] + 100
                                                        if 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                            if not 4 * ext_call.return_data[0] / 5:
                                                                _20358 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_20358] = 26
                                                                mem[_20358 + 32] = 'SafeMath: division by zero'
                                                                mem[mem[64] + 4] = stor19[idx]
                                                                mem[mem[64] + 36] = 0
                                                                require ext_code.size(dogeAddress)
                                                                call dogeAddress.0xa9059cbb with:
                                                                     gas gas_remaining wei
                                                                    args stor19[idx], 0
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _22225 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_22225] == bool(mem[_22225])
                                                            else:
                                                                if 4 * ext_call.return_data[0] / 5 and 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length > -1 / 4 * ext_call.return_data[0] / 5:
                                                                    revert with 0, 17
                                                                if not 4 * ext_call.return_data[0] / 5:
                                                                    revert with 0, 18
                                                                if 4 * ext_call.return_data[0] / 5 * 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 4 * ext_call.return_data[0] / 5 != 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                _21276 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_21276] = 26
                                                                mem[_21276 + 32] = 'SafeMath: division by zero'
                                                                mem[mem[64] + 4] = stor19[idx]
                                                                mem[mem[64] + 36] = 4 * ext_call.return_data[0] / 5 * 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 10000
                                                                require ext_code.size(dogeAddress)
                                                                call dogeAddress.0xa9059cbb with:
                                                                     gas gas_remaining wei
                                                                    args stor19[idx], 4 * ext_call.return_data[0] / 5 * 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 10000
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _22998 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_22998] == bool(mem[_22998])
                                                        if idx == -1:
                                                            revert with 0, 17
                                                        idx = idx + 1
                                                        t = 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length
                                                        u = stor19[idx]
                                                        continue 
                                                    if balanceOf[stor19[idx]] and 10000 > -1 / balanceOf[stor19[idx]]:
                                                        revert with 0, 17
                                                    if not balanceOf[stor19[idx]]:
                                                        revert with 0, 18
                                                    if 10000 * balanceOf[stor19[idx]] / balanceOf[stor19[idx]] != 10000:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _18393 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_18393] = 26
                                                    mem[_18393 + 32] = 'SafeMath: division by zero'
                                                    if not s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                        _19093 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _19093 + 68] = mem[idx + _18393 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_19093 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _19093 + -mem[64] + 100
                                                    if 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                        if not 4 * ext_call.return_data[0] / 5:
                                                            _21275 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_21275] = 26
                                                            mem[_21275 + 32] = 'SafeMath: division by zero'
                                                            mem[mem[64] + 4] = stor19[idx]
                                                            mem[mem[64] + 36] = 0
                                                            require ext_code.size(dogeAddress)
                                                            call dogeAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args stor19[idx], 0
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _22997 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_22997] == bool(mem[_22997])
                                                        else:
                                                            if 4 * ext_call.return_data[0] / 5 and 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length > -1 / 4 * ext_call.return_data[0] / 5:
                                                                revert with 0, 17
                                                            if not 4 * ext_call.return_data[0] / 5:
                                                                revert with 0, 18
                                                            if 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 4 * ext_call.return_data[0] / 5 != 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _22745 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_22745] = 26
                                                            mem[_22745 + 32] = 'SafeMath: division by zero'
                                                            mem[mem[64] + 4] = stor19[idx]
                                                            mem[mem[64] + 36] = 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 10000
                                                            require ext_code.size(dogeAddress)
                                                            call dogeAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args stor19[idx], 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 10000
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _23368 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_23368] == bool(mem[_23368])
                                                    if idx == -1:
                                                        revert with 0, 17
                                                    idx = idx + 1
                                                    t = 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length
                                                    u = stor19[idx]
                                                    continue 
                                                mem[0] = msg.sender
                                                mem[32] = 14
                                                if stor14[address(msg.sender)]:
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not arg1:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _17123 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_17123] = 38
                                                    mem[_17123 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if arg2 > balanceOf[address(msg.sender)]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17123 + 70 len 26]
                                                        var76001 = 64
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(msg.sender)] < arg2:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2
                                                    if balanceOf[arg1] > !arg2:
                                                        revert with 0, 17
                                                    if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                    emit Transfer(arg2, msg.sender, arg1);
                                                else:
                                                    mem[0] = arg1
                                                    mem[32] = 14
                                                    if stor14[address(arg1)]:
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not arg1:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        _17387 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_17387] = 38
                                                        mem[_17387 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if arg2 > balanceOf[address(msg.sender)]:
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 38
                                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17387 + 70 len 26]
                                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                        if balanceOf[address(msg.sender)] < arg2:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] -= arg2
                                                        if balanceOf[arg1] > !arg2:
                                                            revert with 0, 17
                                                        if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                        emit Transfer(arg2, msg.sender, arg1);
                                                    else:
                                                        if stor10:
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not arg1:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _17126 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_17126] = 38
                                                            mem[_17126 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if arg2 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17126 + 70 len 26]
                                                                var76001 = 64
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < arg2:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2
                                                            if balanceOf[arg1] > !arg2:
                                                                revert with 0, 17
                                                            if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                            emit Transfer(arg2, msg.sender, arg1);
                                                        else:
                                                            _16551 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_16551] = 26
                                                            mem[_16551 + 32] = 'SafeMath: division by zero'
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not stor13:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _19089 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_19089] = 38
                                                            mem[_19089 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_19089 + 70 len 26]
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                                            if balanceOf[stor13] > !(arg2 / 100):
                                                                revert with 0, 17
                                                            if balanceOf[stor13] + (arg2 / 100) < balanceOf[stor13]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = stor13
                                                            mem[32] = 1
                                                            balanceOf[stor13] += arg2 / 100
                                                            emit Transfer((arg2 / 100), msg.sender, stor13);
                                                            _22663 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_22663] = 26
                                                            mem[_22663 + 32] = 'SafeMath: division by zero'
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not sub_8230af5aAddress:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _23523 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_23523] = 38
                                                            mem[_23523 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_23523 + 70 len 26]
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                                            if balanceOf[stor9] > !(arg2 / 100):
                                                                revert with 0, 17
                                                            if balanceOf[stor9] + (arg2 / 100) < balanceOf[stor9]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = sub_8230af5aAddress
                                                            mem[32] = 1
                                                            balanceOf[stor9] += arg2 / 100
                                                            emit Transfer((arg2 / 100), msg.sender, sub_8230af5aAddress);
                                                            _24335 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_24335] = 26
                                                            mem[_24335 + 32] = 'SafeMath: division by zero'
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not uniswapV2PairAddress:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _24579 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_24579] = 38
                                                            mem[_24579 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_24579 + 70 len 26]
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                                            if balanceOf[stor7] > !(arg2 / 100):
                                                                revert with 0, 17
                                                            if balanceOf[stor7] + (arg2 / 100) < balanceOf[stor7]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = uniswapV2PairAddress
                                                            mem[32] = 1
                                                            balanceOf[stor7] += arg2 / 100
                                                            emit Transfer((arg2 / 100), msg.sender, uniswapV2PairAddress);
                                                            _25323 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_25323] = 26
                                                            mem[_25323 + 32] = 'SafeMath: division by zero'
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not this.address:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _25567 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_25567] = 38
                                                            mem[_25567 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if arg2 / 10 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_25567 + 70 len 26]
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < arg2 / 10:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2 / 10
                                                            if balanceOf[this.address] > !(arg2 / 10):
                                                                revert with 0, 17
                                                            if balanceOf[this.address] + (arg2 / 10) < balanceOf[this.address]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = this.address
                                                            mem[32] = 1
                                                            balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 10)
                                                            emit Transfer((arg2 / 10), msg.sender, this.address);
                                                            _26311 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_26311] = 26
                                                            mem[_26311 + 32] = 'SafeMath: division by zero'
                                                            if not arg2 / 100:
                                                                if not msg.sender:
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not arg1:
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                _26596 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_26596] = 38
                                                                mem[_26596 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                if 0 > balanceOf[address(msg.sender)]:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 38
                                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_26596 + 70 len 26]
                                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                if balanceOf[address(msg.sender)] < 0:
                                                                    revert with 0, 17
                                                                if balanceOf[arg1] > -1:
                                                                    revert with 0, 17
                                                                if balanceOf[arg1] < balanceOf[arg1]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                balanceOf[address(arg1)] = balanceOf[arg1]
                                                                emit Transfer(0, msg.sender, arg1);
                                                            else:
                                                                if arg2 / 100 and 87 > -1 / arg2 / 100:
                                                                    revert with 0, 17
                                                                if not arg2 / 100:
                                                                    revert with 0, 18
                                                                if 87 * arg2 / 100 / arg2 / 100 != 87:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if not msg.sender:
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not arg1:
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                _27195 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_27195] = 38
                                                                mem[_27195 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                if 87 * arg2 / 100 > balanceOf[address(msg.sender)]:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 38
                                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_27195 + 70 len 26]
                                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                if balanceOf[address(msg.sender)] < 87 * arg2 / 100:
                                                                    revert with 0, 17
                                                                balanceOf[address(msg.sender)] += -87 * arg2 / 100
                                                                if balanceOf[arg1] > !(87 * arg2 / 100):
                                                                    revert with 0, 17
                                                                if balanceOf[arg1] + (87 * arg2 / 100) < balanceOf[arg1]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                balanceOf[address(arg1)] = balanceOf[arg1] + (87 * arg2 / 100)
                                                                emit Transfer((87 * arg2 / 100), msg.sender, arg1);
                                            else:
                                                idx = 0
                                                t = 0
                                                u = 160 * stor19.length
                                                while idx < 9:
                                                    if 0 > !idx:
                                                        revert with 0, 17
                                                    if idx >= stor19.length:
                                                        revert with 0, 50
                                                    mem[0] = stor19[idx]
                                                    mem[32] = 1
                                                    if balanceOf[stor19[idx]] < 10000000000 * 10^18:
                                                        if idx == -1:
                                                            revert with 0, 17
                                                        idx = idx + 1
                                                        t = t
                                                        u = stor19[idx]
                                                        continue 
                                                    mem[0] = stor19[idx]
                                                    mem[32] = 1
                                                    if not balanceOf[stor19[idx]]:
                                                        _17778 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_17778] = 26
                                                        mem[_17778 + 32] = 'SafeMath: division by zero'
                                                        if not s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                            _18065 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _18065 + 68] = mem[idx + _17778 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_18065 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _18065 + -mem[64] + 100
                                                        if 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                            if not 4 * ext_call.return_data[0] / 5:
                                                                _20916 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_20916] = 26
                                                                mem[_20916 + 32] = 'SafeMath: division by zero'
                                                                mem[mem[64] + 4] = stor19[idx]
                                                                mem[mem[64] + 36] = 0
                                                                require ext_code.size(dogeAddress)
                                                                call dogeAddress.0xa9059cbb with:
                                                                     gas gas_remaining wei
                                                                    args stor19[idx], 0
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _22746 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_22746] == bool(mem[_22746])
                                                            else:
                                                                if 4 * ext_call.return_data[0] / 5 and 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length > -1 / 4 * ext_call.return_data[0] / 5:
                                                                    revert with 0, 17
                                                                if not 4 * ext_call.return_data[0] / 5:
                                                                    revert with 0, 18
                                                                if 4 * ext_call.return_data[0] / 5 * 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 4 * ext_call.return_data[0] / 5 != 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                _22233 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_22233] = 26
                                                                mem[_22233 + 32] = 'SafeMath: division by zero'
                                                                mem[mem[64] + 4] = stor19[idx]
                                                                mem[mem[64] + 36] = 4 * ext_call.return_data[0] / 5 * 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 10000
                                                                require ext_code.size(dogeAddress)
                                                                call dogeAddress.0xa9059cbb with:
                                                                     gas gas_remaining wei
                                                                    args stor19[idx], 4 * ext_call.return_data[0] / 5 * 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 10000
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _23178 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_23178] == bool(mem[_23178])
                                                        if idx == -1:
                                                            revert with 0, 17
                                                        idx = idx + 1
                                                        t = 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length
                                                        u = stor19[idx]
                                                        continue 
                                                    if balanceOf[stor19[idx]] and 10000 > -1 / balanceOf[stor19[idx]]:
                                                        revert with 0, 17
                                                    if not balanceOf[stor19[idx]]:
                                                        revert with 0, 18
                                                    if 10000 * balanceOf[stor19[idx]] / balanceOf[stor19[idx]] != 10000:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _19284 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_19284] = 26
                                                    mem[_19284 + 32] = 'SafeMath: division by zero'
                                                    if not s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                        _19614 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _19614 + 68] = mem[idx + _19284 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_19614 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _19614 + -mem[64] + 100
                                                    if 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                        if not 4 * ext_call.return_data[0] / 5:
                                                            _22232 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_22232] = 26
                                                            mem[_22232 + 32] = 'SafeMath: division by zero'
                                                            mem[mem[64] + 4] = stor19[idx]
                                                            mem[mem[64] + 36] = 0
                                                            require ext_code.size(dogeAddress)
                                                            call dogeAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args stor19[idx], 0
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _23177 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_23177] == bool(mem[_23177])
                                                        else:
                                                            if 4 * ext_call.return_data[0] / 5 and 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length > -1 / 4 * ext_call.return_data[0] / 5:
                                                                revert with 0, 17
                                                            if not 4 * ext_call.return_data[0] / 5:
                                                                revert with 0, 18
                                                            if 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 4 * ext_call.return_data[0] / 5 != 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _22999 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_22999] = 26
                                                            mem[_22999 + 32] = 'SafeMath: division by zero'
                                                            mem[mem[64] + 4] = stor19[idx]
                                                            mem[mem[64] + 36] = 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 10000
                                                            require ext_code.size(dogeAddress)
                                                            call dogeAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args stor19[idx], 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 10000
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _23673 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_23673] == bool(mem[_23673])
                                                    if idx == -1:
                                                        revert with 0, 17
                                                    idx = idx + 1
                                                    t = 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length
                                                    u = stor19[idx]
                                                    continue 
                                                mem[0] = msg.sender
                                                mem[32] = 14
                                                if stor14[address(msg.sender)]:
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not arg1:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _17131 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_17131] = 38
                                                    mem[_17131 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if arg2 > balanceOf[address(msg.sender)]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17131 + 70 len 26]
                                                        var76001 = 64
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(msg.sender)] < arg2:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2
                                                    if balanceOf[arg1] > !arg2:
                                                        revert with 0, 17
                                                    if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                    emit Transfer(arg2, msg.sender, arg1);
                                                else:
                                                    mem[0] = arg1
                                                    mem[32] = 14
                                                    if stor14[address(arg1)]:
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not arg1:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        _17392 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_17392] = 38
                                                        mem[_17392 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if arg2 > balanceOf[address(msg.sender)]:
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 38
                                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17392 + 70 len 26]
                                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                        if balanceOf[address(msg.sender)] < arg2:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] -= arg2
                                                        if balanceOf[arg1] > !arg2:
                                                            revert with 0, 17
                                                        if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                        emit Transfer(arg2, msg.sender, arg1);
                                                    else:
                                                        if stor10:
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not arg1:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _17134 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_17134] = 38
                                                            mem[_17134 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if arg2 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17134 + 70 len 26]
                                                                var76001 = 64
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < arg2:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2
                                                            if balanceOf[arg1] > !arg2:
                                                                revert with 0, 17
                                                            if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                            emit Transfer(arg2, msg.sender, arg1);
                                                        else:
                                                            _16552 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_16552] = 26
                                                            mem[_16552 + 32] = 'SafeMath: division by zero'
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not stor13:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _19097 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_19097] = 38
                                                            mem[_19097 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_19097 + 70 len 26]
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                                            if balanceOf[stor13] > !(arg2 / 100):
                                                                revert with 0, 17
                                                            if balanceOf[stor13] + (arg2 / 100) < balanceOf[stor13]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = stor13
                                                            mem[32] = 1
                                                            balanceOf[stor13] += arg2 / 100
                                                            emit Transfer((arg2 / 100), msg.sender, stor13);
                                                            _22667 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_22667] = 26
                                                            mem[_22667 + 32] = 'SafeMath: division by zero'
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not sub_8230af5aAddress:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _23526 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_23526] = 38
                                                            mem[_23526 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_23526 + 70 len 26]
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                                            if balanceOf[stor9] > !(arg2 / 100):
                                                                revert with 0, 17
                                                            if balanceOf[stor9] + (arg2 / 100) < balanceOf[stor9]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = sub_8230af5aAddress
                                                            mem[32] = 1
                                                            balanceOf[stor9] += arg2 / 100
                                                            emit Transfer((arg2 / 100), msg.sender, sub_8230af5aAddress);
                                                            _24336 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_24336] = 26
                                                            mem[_24336 + 32] = 'SafeMath: division by zero'
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not uniswapV2PairAddress:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _24582 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_24582] = 38
                                                            mem[_24582 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_24582 + 70 len 26]
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                                            if balanceOf[stor7] > !(arg2 / 100):
                                                                revert with 0, 17
                                                            if balanceOf[stor7] + (arg2 / 100) < balanceOf[stor7]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = uniswapV2PairAddress
                                                            mem[32] = 1
                                                            balanceOf[stor7] += arg2 / 100
                                                            emit Transfer((arg2 / 100), msg.sender, uniswapV2PairAddress);
                                                            _25324 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_25324] = 26
                                                            mem[_25324 + 32] = 'SafeMath: division by zero'
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not this.address:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _25570 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_25570] = 38
                                                            mem[_25570 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if arg2 / 10 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_25570 + 70 len 26]
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < arg2 / 10:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2 / 10
                                                            if balanceOf[this.address] > !(arg2 / 10):
                                                                revert with 0, 17
                                                            if balanceOf[this.address] + (arg2 / 10) < balanceOf[this.address]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = this.address
                                                            mem[32] = 1
                                                            balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 10)
                                                            emit Transfer((arg2 / 10), msg.sender, this.address);
                                                            _26312 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_26312] = 26
                                                            mem[_26312 + 32] = 'SafeMath: division by zero'
                                                            if not arg2 / 100:
                                                                if not msg.sender:
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not arg1:
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                _26600 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_26600] = 38
                                                                mem[_26600 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                if 0 > balanceOf[address(msg.sender)]:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 38
                                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_26600 + 70 len 26]
                                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                if balanceOf[address(msg.sender)] < 0:
                                                                    revert with 0, 17
                                                                if balanceOf[arg1] > -1:
                                                                    revert with 0, 17
                                                                if balanceOf[arg1] < balanceOf[arg1]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                balanceOf[address(arg1)] = balanceOf[arg1]
                                                                emit Transfer(0, msg.sender, arg1);
                                                            else:
                                                                if arg2 / 100 and 87 > -1 / arg2 / 100:
                                                                    revert with 0, 17
                                                                if not arg2 / 100:
                                                                    revert with 0, 18
                                                                if 87 * arg2 / 100 / arg2 / 100 != 87:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if not msg.sender:
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not arg1:
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                _27200 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_27200] = 38
                                                                mem[_27200 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                if 87 * arg2 / 100 > balanceOf[address(msg.sender)]:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 38
                                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_27200 + 70 len 26]
                                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                if balanceOf[address(msg.sender)] < 87 * arg2 / 100:
                                                                    revert with 0, 17
                                                                balanceOf[address(msg.sender)] += -87 * arg2 / 100
                                                                if balanceOf[arg1] > !(87 * arg2 / 100):
                                                                    revert with 0, 17
                                                                if balanceOf[arg1] + (87 * arg2 / 100) < balanceOf[arg1]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                balanceOf[address(arg1)] = balanceOf[arg1] + (87 * arg2 / 100)
                                                                emit Transfer((87 * arg2 / 100), msg.sender, arg1);
                                        else:
                                            if stor19.length < 9:
                                                revert with 0, 17
                                            mem[64] = ceil32(return_data.size) + 224
                                            mem[ceil32(return_data.size) + 160] = 24
                                            mem[ceil32(return_data.size) + 192] = 'SafeMath: modulo by zero'
                                            if not stor19.length - 9:
                                                revert with 0, 'SafeMath: modulo by zero', 0
                                            idx = 0
                                            s = 0
                                            t = 0
                                            while idx < 9:
                                                if block.timestamp % stor19.length - 9 > !idx:
                                                    revert with 0, 17
                                                if (block.timestamp % stor19.length - 9) + idx >= stor19.length:
                                                    revert with 0, 50
                                                mem[0] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                                mem[32] = 1
                                                if s > !balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]]:
                                                    revert with 0, 17
                                                if s + balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] < s:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if idx == -1:
                                                    revert with 0, 17
                                                idx = idx + 1
                                                s = s + balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]]
                                                t = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                                continue 
                                            if stor19.length <= 9:
                                                idx = 0
                                                t = 0
                                                u = 1440
                                                while idx < stor19.length:
                                                    mem[0] = stor19[idx]
                                                    mem[32] = 1
                                                    if balanceOf[stor19[idx]] < 10000000000 * 10^18:
                                                        if idx == -1:
                                                            revert with 0, 17
                                                        idx = idx + 1
                                                        t = t
                                                        u = stor19[idx]
                                                        continue 
                                                    mem[0] = stor19[idx]
                                                    mem[32] = 1
                                                    if not balanceOf[stor19[idx]]:
                                                        _17145 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_17145] = 26
                                                        mem[_17145 + 32] = 'SafeMath: division by zero'
                                                        if not 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                            _17585 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _17585 + 68] = mem[idx + _17145 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_17585 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _17585 + -mem[64] + 100
                                                        if 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                            if not 4 * ext_call.return_data[0] / 5:
                                                                _20372 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_20372] = 26
                                                                mem[_20372 + 32] = 'SafeMath: division by zero'
                                                                mem[mem[64] + 4] = stor19[idx]
                                                                mem[mem[64] + 36] = 0
                                                                require ext_code.size(dogeAddress)
                                                                call dogeAddress.0xa9059cbb with:
                                                                     gas gas_remaining wei
                                                                    args stor19[idx], 0
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _22240 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_22240] == bool(mem[_22240])
                                                            else:
                                                                if 4 * ext_call.return_data[0] / 5 and 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s > -1 / 4 * ext_call.return_data[0] / 5:
                                                                    revert with 0, 17
                                                                if not 4 * ext_call.return_data[0] / 5:
                                                                    revert with 0, 18
                                                                if 4 * ext_call.return_data[0] / 5 * 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 4 * ext_call.return_data[0] / 5 != 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                _21282 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_21282] = 26
                                                                mem[_21282 + 32] = 'SafeMath: division by zero'
                                                                mem[mem[64] + 4] = stor19[idx]
                                                                mem[mem[64] + 36] = 4 * ext_call.return_data[0] / 5 * 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 10000
                                                                require ext_code.size(dogeAddress)
                                                                call dogeAddress.0xa9059cbb with:
                                                                     gas gas_remaining wei
                                                                    args stor19[idx], 4 * ext_call.return_data[0] / 5 * 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 10000
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _23001 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_23001] == bool(mem[_23001])
                                                        if idx == -1:
                                                            revert with 0, 17
                                                        idx = idx + 1
                                                        t = 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s
                                                        u = stor19[idx]
                                                        continue 
                                                    if balanceOf[stor19[idx]] and 10000 > -1 / balanceOf[stor19[idx]]:
                                                        revert with 0, 17
                                                    if not balanceOf[stor19[idx]]:
                                                        revert with 0, 18
                                                    if 10000 * balanceOf[stor19[idx]] / balanceOf[stor19[idx]] != 10000:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _18407 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_18407] = 26
                                                    mem[_18407 + 32] = 'SafeMath: division by zero'
                                                    if not 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                        _19109 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _19109 + 68] = mem[idx + _18407 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_19109 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _19109 + -mem[64] + 100
                                                    if 10000 * balanceOf[stor19[idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                        if not 4 * ext_call.return_data[0] / 5:
                                                            _21281 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_21281] = 26
                                                            mem[_21281 + 32] = 'SafeMath: division by zero'
                                                            mem[mem[64] + 4] = stor19[idx]
                                                            mem[mem[64] + 36] = 0
                                                            require ext_code.size(dogeAddress)
                                                            call dogeAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args stor19[idx], 0
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _23000 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_23000] == bool(mem[_23000])
                                                        else:
                                                            if 4 * ext_call.return_data[0] / 5 and 10000 * balanceOf[stor19[idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s > -1 / 4 * ext_call.return_data[0] / 5:
                                                                revert with 0, 17
                                                            if not 4 * ext_call.return_data[0] / 5:
                                                                revert with 0, 18
                                                            if 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor19[idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 4 * ext_call.return_data[0] / 5 != 10000 * balanceOf[stor19[idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _22747 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_22747] = 26
                                                            mem[_22747 + 32] = 'SafeMath: division by zero'
                                                            mem[mem[64] + 4] = stor19[idx]
                                                            mem[mem[64] + 36] = 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor19[idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 10000
                                                            require ext_code.size(dogeAddress)
                                                            call dogeAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args stor19[idx], 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor19[idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 10000
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _23371 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_23371] == bool(mem[_23371])
                                                    if idx == -1:
                                                        revert with 0, 17
                                                    idx = idx + 1
                                                    t = 10000 * balanceOf[stor19[idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s
                                                    u = stor19[idx]
                                                    continue 
                                                mem[0] = msg.sender
                                                mem[32] = 14
                                                if stor14[address(msg.sender)]:
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not arg1:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _17138 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_17138] = 38
                                                    mem[_17138 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if arg2 > balanceOf[address(msg.sender)]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17138 + 70 len 26]
                                                        var87001 = 64
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(msg.sender)] < arg2:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2
                                                    if balanceOf[arg1] > !arg2:
                                                        revert with 0, 17
                                                    if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                    emit Transfer(arg2, msg.sender, arg1);
                                                else:
                                                    mem[0] = arg1
                                                    mem[32] = 14
                                                    if stor14[address(arg1)]:
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not arg1:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        _17397 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_17397] = 38
                                                        mem[_17397 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if arg2 > balanceOf[address(msg.sender)]:
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 38
                                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17397 + 70 len 26]
                                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                        if balanceOf[address(msg.sender)] < arg2:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] -= arg2
                                                        if balanceOf[arg1] > !arg2:
                                                            revert with 0, 17
                                                        if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                        emit Transfer(arg2, msg.sender, arg1);
                                                    else:
                                                        if stor10:
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not arg1:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _17141 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_17141] = 38
                                                            mem[_17141 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if arg2 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17141 + 70 len 26]
                                                                var87001 = 64
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < arg2:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2
                                                            if balanceOf[arg1] > !arg2:
                                                                revert with 0, 17
                                                            if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                            emit Transfer(arg2, msg.sender, arg1);
                                                        else:
                                                            _16554 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_16554] = 26
                                                            mem[_16554 + 32] = 'SafeMath: division by zero'
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not stor13:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _19105 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_19105] = 38
                                                            mem[_19105 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_19105 + 70 len 26]
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                                            if balanceOf[stor13] > !(arg2 / 100):
                                                                revert with 0, 17
                                                            if balanceOf[stor13] + (arg2 / 100) < balanceOf[stor13]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = stor13
                                                            mem[32] = 1
                                                            balanceOf[stor13] += arg2 / 100
                                                            emit Transfer((arg2 / 100), msg.sender, stor13);
                                                            _22669 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_22669] = 26
                                                            mem[_22669 + 32] = 'SafeMath: division by zero'
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not sub_8230af5aAddress:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _23531 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_23531] = 38
                                                            mem[_23531 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_23531 + 70 len 26]
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                                            if balanceOf[stor9] > !(arg2 / 100):
                                                                revert with 0, 17
                                                            if balanceOf[stor9] + (arg2 / 100) < balanceOf[stor9]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = sub_8230af5aAddress
                                                            mem[32] = 1
                                                            balanceOf[stor9] += arg2 / 100
                                                            emit Transfer((arg2 / 100), msg.sender, sub_8230af5aAddress);
                                                            _24337 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_24337] = 26
                                                            mem[_24337 + 32] = 'SafeMath: division by zero'
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not uniswapV2PairAddress:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _24585 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_24585] = 38
                                                            mem[_24585 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_24585 + 70 len 26]
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                                            if balanceOf[stor7] > !(arg2 / 100):
                                                                revert with 0, 17
                                                            if balanceOf[stor7] + (arg2 / 100) < balanceOf[stor7]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = uniswapV2PairAddress
                                                            mem[32] = 1
                                                            balanceOf[stor7] += arg2 / 100
                                                            emit Transfer((arg2 / 100), msg.sender, uniswapV2PairAddress);
                                                            _25325 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_25325] = 26
                                                            mem[_25325 + 32] = 'SafeMath: division by zero'
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not this.address:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _25573 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_25573] = 38
                                                            mem[_25573 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if arg2 / 10 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_25573 + 70 len 26]
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < arg2 / 10:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2 / 10
                                                            if balanceOf[this.address] > !(arg2 / 10):
                                                                revert with 0, 17
                                                            if balanceOf[this.address] + (arg2 / 10) < balanceOf[this.address]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = this.address
                                                            mem[32] = 1
                                                            balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 10)
                                                            emit Transfer((arg2 / 10), msg.sender, this.address);
                                                            _26313 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_26313] = 26
                                                            mem[_26313 + 32] = 'SafeMath: division by zero'
                                                            if not arg2 / 100:
                                                                if not msg.sender:
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not arg1:
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                _26604 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_26604] = 38
                                                                mem[_26604 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                if 0 > balanceOf[address(msg.sender)]:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 38
                                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_26604 + 70 len 26]
                                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                if balanceOf[address(msg.sender)] < 0:
                                                                    revert with 0, 17
                                                                if balanceOf[arg1] > -1:
                                                                    revert with 0, 17
                                                                if balanceOf[arg1] < balanceOf[arg1]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                balanceOf[address(arg1)] = balanceOf[arg1]
                                                                emit Transfer(0, msg.sender, arg1);
                                                            else:
                                                                if arg2 / 100 and 87 > -1 / arg2 / 100:
                                                                    revert with 0, 17
                                                                if not arg2 / 100:
                                                                    revert with 0, 18
                                                                if 87 * arg2 / 100 / arg2 / 100 != 87:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if not msg.sender:
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not arg1:
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                _27205 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_27205] = 38
                                                                mem[_27205 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                if 87 * arg2 / 100 > balanceOf[address(msg.sender)]:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 38
                                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_27205 + 70 len 26]
                                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                if balanceOf[address(msg.sender)] < 87 * arg2 / 100:
                                                                    revert with 0, 17
                                                                balanceOf[address(msg.sender)] += -87 * arg2 / 100
                                                                if balanceOf[arg1] > !(87 * arg2 / 100):
                                                                    revert with 0, 17
                                                                if balanceOf[arg1] + (87 * arg2 / 100) < balanceOf[arg1]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                balanceOf[address(arg1)] = balanceOf[arg1] + (87 * arg2 / 100)
                                                                emit Transfer((87 * arg2 / 100), msg.sender, arg1);
                                            else:
                                                idx = 0
                                                t = 0
                                                u = 1440
                                                while idx < 9:
                                                    if block.timestamp % stor19.length - 9 > !idx:
                                                        revert with 0, 17
                                                    if (block.timestamp % stor19.length - 9) + idx >= stor19.length:
                                                        revert with 0, 50
                                                    mem[0] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                                    mem[32] = 1
                                                    if balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] < 10000000000 * 10^18:
                                                        if idx == -1:
                                                            revert with 0, 17
                                                        idx = idx + 1
                                                        t = t
                                                        u = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                                        continue 
                                                    mem[0] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                                    mem[32] = 1
                                                    if not balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]]:
                                                        _17786 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_17786] = 26
                                                        mem[_17786 + 32] = 'SafeMath: division by zero'
                                                        if not 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                            _18072 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _18072 + 68] = mem[idx + _17786 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_18072 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _18072 + -mem[64] + 100
                                                        if 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                            if not 4 * ext_call.return_data[0] / 5:
                                                                _20922 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_20922] = 26
                                                                mem[_20922 + 32] = 'SafeMath: division by zero'
                                                                mem[mem[64] + 4] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                                                mem[mem[64] + 36] = 0
                                                                require ext_code.size(dogeAddress)
                                                                call dogeAddress.0xa9059cbb with:
                                                                     gas gas_remaining wei
                                                                    args stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx], 0
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _22748 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_22748] == bool(mem[_22748])
                                                            else:
                                                                if 4 * ext_call.return_data[0] / 5 and 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s > -1 / 4 * ext_call.return_data[0] / 5:
                                                                    revert with 0, 17
                                                                if not 4 * ext_call.return_data[0] / 5:
                                                                    revert with 0, 18
                                                                if 4 * ext_call.return_data[0] / 5 * 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 4 * ext_call.return_data[0] / 5 != 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                _22248 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_22248] = 26
                                                                mem[_22248 + 32] = 'SafeMath: division by zero'
                                                                mem[mem[64] + 4] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                                                mem[mem[64] + 36] = 4 * ext_call.return_data[0] / 5 * 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 10000
                                                                require ext_code.size(dogeAddress)
                                                                call dogeAddress.0xa9059cbb with:
                                                                     gas gas_remaining wei
                                                                    args stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx], 4 * ext_call.return_data[0] / 5 * 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 10000
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _23180 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_23180] == bool(mem[_23180])
                                                        if idx == -1:
                                                            revert with 0, 17
                                                        idx = idx + 1
                                                        t = 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s
                                                        u = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                                        continue 
                                                    if balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] and 10000 > -1 / balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]]:
                                                        revert with 0, 17
                                                    if not balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]]:
                                                        revert with 0, 18
                                                    if 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] != 10000:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _19290 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_19290] = 26
                                                    mem[_19290 + 32] = 'SafeMath: division by zero'
                                                    if not 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                        _19623 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _19623 + 68] = mem[idx + _19290 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_19623 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _19623 + -mem[64] + 100
                                                    if 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                        if not 4 * ext_call.return_data[0] / 5:
                                                            _22247 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_22247] = 26
                                                            mem[_22247 + 32] = 'SafeMath: division by zero'
                                                            mem[mem[64] + 4] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                                            mem[mem[64] + 36] = 0
                                                            require ext_code.size(dogeAddress)
                                                            call dogeAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx], 0
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _23179 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_23179] == bool(mem[_23179])
                                                        else:
                                                            if 4 * ext_call.return_data[0] / 5 and 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s > -1 / 4 * ext_call.return_data[0] / 5:
                                                                revert with 0, 17
                                                            if not 4 * ext_call.return_data[0] / 5:
                                                                revert with 0, 18
                                                            if 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 4 * ext_call.return_data[0] / 5 != 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _23002 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_23002] = 26
                                                            mem[_23002 + 32] = 'SafeMath: division by zero'
                                                            mem[mem[64] + 4] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                                            mem[mem[64] + 36] = 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 10000
                                                            require ext_code.size(dogeAddress)
                                                            call dogeAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx], 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 10000
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _23676 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_23676] == bool(mem[_23676])
                                                    if idx == -1:
                                                        revert with 0, 17
                                                    idx = idx + 1
                                                    t = 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s
                                                    u = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                                    continue 
                                                mem[0] = msg.sender
                                                mem[32] = 14
                                                if stor14[address(msg.sender)]:
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not arg1:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _17146 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_17146] = 38
                                                    mem[_17146 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if arg2 > balanceOf[address(msg.sender)]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17146 + 70 len 26]
                                                        var87001 = 64
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(msg.sender)] < arg2:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2
                                                    if balanceOf[arg1] > !arg2:
                                                        revert with 0, 17
                                                    if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                    emit Transfer(arg2, msg.sender, arg1);
                                                else:
                                                    mem[0] = arg1
                                                    mem[32] = 14
                                                    if stor14[address(arg1)]:
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not arg1:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        _17402 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_17402] = 38
                                                        mem[_17402 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if arg2 > balanceOf[address(msg.sender)]:
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 38
                                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17402 + 70 len 26]
                                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                        if balanceOf[address(msg.sender)] < arg2:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] -= arg2
                                                        if balanceOf[arg1] > !arg2:
                                                            revert with 0, 17
                                                        if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                        emit Transfer(arg2, msg.sender, arg1);
                                                    else:
                                                        if stor10:
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not arg1:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _17149 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_17149] = 38
                                                            mem[_17149 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if arg2 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_17149 + 70 len 26]
                                                                var87001 = 64
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < arg2:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2
                                                            if balanceOf[arg1] > !arg2:
                                                                revert with 0, 17
                                                            if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                            emit Transfer(arg2, msg.sender, arg1);
                                                        else:
                                                            _16555 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_16555] = 26
                                                            mem[_16555 + 32] = 'SafeMath: division by zero'
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not stor13:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _19113 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_19113] = 38
                                                            mem[_19113 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_19113 + 70 len 26]
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                                            if balanceOf[stor13] > !(arg2 / 100):
                                                                revert with 0, 17
                                                            if balanceOf[stor13] + (arg2 / 100) < balanceOf[stor13]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = stor13
                                                            mem[32] = 1
                                                            balanceOf[stor13] += arg2 / 100
                                                            emit Transfer((arg2 / 100), msg.sender, stor13);
                                                            _22673 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_22673] = 26
                                                            mem[_22673 + 32] = 'SafeMath: division by zero'
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not sub_8230af5aAddress:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _23534 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_23534] = 38
                                                            mem[_23534 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_23534 + 70 len 26]
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                                            if balanceOf[stor9] > !(arg2 / 100):
                                                                revert with 0, 17
                                                            if balanceOf[stor9] + (arg2 / 100) < balanceOf[stor9]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = sub_8230af5aAddress
                                                            mem[32] = 1
                                                            balanceOf[stor9] += arg2 / 100
                                                            emit Transfer((arg2 / 100), msg.sender, sub_8230af5aAddress);
                                                            _24338 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_24338] = 26
                                                            mem[_24338 + 32] = 'SafeMath: division by zero'
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not uniswapV2PairAddress:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _24588 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_24588] = 38
                                                            mem[_24588 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_24588 + 70 len 26]
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                                            if balanceOf[stor7] > !(arg2 / 100):
                                                                revert with 0, 17
                                                            if balanceOf[stor7] + (arg2 / 100) < balanceOf[stor7]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = uniswapV2PairAddress
                                                            mem[32] = 1
                                                            balanceOf[stor7] += arg2 / 100
                                                            emit Transfer((arg2 / 100), msg.sender, uniswapV2PairAddress);
                                                            _25326 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_25326] = 26
                                                            mem[_25326 + 32] = 'SafeMath: division by zero'
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not this.address:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _25576 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_25576] = 38
                                                            mem[_25576 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if arg2 / 10 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_25576 + 70 len 26]
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < arg2 / 10:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2 / 10
                                                            if balanceOf[this.address] > !(arg2 / 10):
                                                                revert with 0, 17
                                                            if balanceOf[this.address] + (arg2 / 10) < balanceOf[this.address]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = this.address
                                                            mem[32] = 1
                                                            balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 10)
                                                            emit Transfer((arg2 / 10), msg.sender, this.address);
                                                            _26314 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_26314] = 26
                                                            mem[_26314 + 32] = 'SafeMath: division by zero'
                                                            if not arg2 / 100:
                                                                if not msg.sender:
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not arg1:
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                _26608 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_26608] = 38
                                                                mem[_26608 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                if 0 > balanceOf[address(msg.sender)]:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 38
                                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_26608 + 70 len 26]
                                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                if balanceOf[address(msg.sender)] < 0:
                                                                    revert with 0, 17
                                                                if balanceOf[arg1] > -1:
                                                                    revert with 0, 17
                                                                if balanceOf[arg1] < balanceOf[arg1]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                balanceOf[address(arg1)] = balanceOf[arg1]
                                                                emit Transfer(0, msg.sender, arg1);
                                                            else:
                                                                if arg2 / 100 and 87 > -1 / arg2 / 100:
                                                                    revert with 0, 17
                                                                if not arg2 / 100:
                                                                    revert with 0, 18
                                                                if 87 * arg2 / 100 / arg2 / 100 != 87:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if not msg.sender:
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not arg1:
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                _27210 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_27210] = 38
                                                                mem[_27210 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                if 87 * arg2 / 100 > balanceOf[address(msg.sender)]:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 38
                                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_27210 + 70 len 26]
                                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                if balanceOf[address(msg.sender)] < 87 * arg2 / 100:
                                                                    revert with 0, 17
                                                                balanceOf[address(msg.sender)] += -87 * arg2 / 100
                                                                if balanceOf[arg1] > !(87 * arg2 / 100):
                                                                    revert with 0, 17
                                                                if balanceOf[arg1] + (87 * arg2 / 100) < balanceOf[arg1]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                balanceOf[address(arg1)] = balanceOf[arg1] + (87 * arg2 / 100)
                                                                emit Transfer((87 * arg2 / 100), msg.sender, arg1);
                        else:
                            stor10 = 1
                            mem[0] = this.address
                            mem[32] = 1
                            mem[96] = 3
                            mem[128] = this.address
                            require ext_code.size(uniswapV2RouterAddress)
                            staticcall uniswapV2RouterAddress.WETH() with:
                                    gas gas_remaining wei
                            mem[224] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                            mem[160] = ext_call.return_data[12 len 20]
                            mem[192] = 0x7130d2a12b9bcbfae4f2634d864a1ee1ce3ead9c
                            mem[ceil32(return_data.size) + 224] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                            mem[ceil32(return_data.size) + 228] = balanceOf[address(this.address)]
                            mem[ceil32(return_data.size) + 260] = 0
                            mem[ceil32(return_data.size) + 292] = 160
                            mem[ceil32(return_data.size) + 388] = 3
                            idx = 0
                            s = ceil32(return_data.size) + 420
                            t = 128
                            while idx < 3:
                                mem[s] = mem[t + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[ceil32(return_data.size) + 324] = this.address
                            mem[ceil32(return_data.size) + 356] = block.timestamp
                            require ext_code.size(uniswapV2RouterAddress)
                            call uniswapV2RouterAddress.swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                 gas gas_remaining wei
                                args balanceOf[address(this.address)], 0, 160, address(this.address), block.timestamp, 3, mem[ceil32(return_data.size) + 420 len 96]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            stor10 = 0
                            mem[ceil32(return_data.size) + 228] = this.address
                            require ext_code.size(dogeAddress)
                            staticcall dogeAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[ceil32(return_data.size) + 224] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if ext_call.return_data[0] < 10^12:
                                if not msg.sender:
                                    revert with 0, 'ERC20: transfer from the zero address'
                                if stor14[address(msg.sender)]:
                                    if not arg1:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    if arg2 > balanceOf[address(msg.sender)]:
                                        revert with 0, 
                                                    32,
                                                    38,
                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[(2 * ceil32(return_data.size)) + 294 len 26] >> 48,
                                                    0
                                    if balanceOf[address(msg.sender)] < arg2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)] -= arg2
                                    if balanceOf[arg1] > !arg2:
                                        revert with 0, 17
                                    if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                    emit Transfer(arg2, msg.sender, arg1);
                                else:
                                    if stor14[address(arg1)]:
                                        if not arg1:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        if arg2 > balanceOf[address(msg.sender)]:
                                            revert with 0, 
                                                        32,
                                                        38,
                                                        0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[(2 * ceil32(return_data.size)) + 294 len 26] >> 48,
                                                        0
                                        if balanceOf[address(msg.sender)] < arg2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2
                                        if balanceOf[arg1] > !arg2:
                                            revert with 0, 17
                                        if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                        emit Transfer(arg2, msg.sender, arg1);
                                    else:
                                        if stor10:
                                            if not arg1:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            if arg2 > balanceOf[address(msg.sender)]:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[(2 * ceil32(return_data.size)) + 294 len 26] >> 48,
                                                            0
                                            if balanceOf[address(msg.sender)] < arg2:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2
                                            if balanceOf[arg1] > !arg2:
                                                revert with 0, 17
                                            if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                            emit Transfer(arg2, msg.sender, arg1);
                                        else:
                                            if not stor13:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[(2 * ceil32(return_data.size)) + 358 len 26] >> 48,
                                                            0
                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                            if balanceOf[stor13] > !(arg2 / 100):
                                                revert with 0, 17
                                            if balanceOf[stor13] + (arg2 / 100) < balanceOf[stor13]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[stor13] += arg2 / 100
                                            emit Transfer((arg2 / 100), msg.sender, stor13);
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not sub_8230af5aAddress:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                var107001 = 64
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[(2 * ceil32(return_data.size)) + 518 len 26] >> 48,
                                                            0
                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                            if balanceOf[stor9] > !(arg2 / 100):
                                                revert with 0, 17
                                            if balanceOf[stor9] + (arg2 / 100) < balanceOf[stor9]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[stor9] += arg2 / 100
                                            emit Transfer((arg2 / 100), msg.sender, sub_8230af5aAddress);
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not uniswapV2PairAddress:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[(2 * ceil32(return_data.size)) + 678 len 26] >> 48,
                                                            0
                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                            if balanceOf[stor7] > !(arg2 / 100):
                                                revert with 0, 17
                                            if balanceOf[stor7] + (arg2 / 100) < balanceOf[stor7]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[stor7] += arg2 / 100
                                            emit Transfer((arg2 / 100), msg.sender, uniswapV2PairAddress);
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not this.address:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            if arg2 / 10 > balanceOf[address(msg.sender)]:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[(2 * ceil32(return_data.size)) + 838 len 26] >> 48,
                                                            0
                                            if balanceOf[address(msg.sender)] < arg2 / 10:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2 / 10
                                            if balanceOf[this.address] > !(arg2 / 10):
                                                revert with 0, 17
                                            if balanceOf[this.address] + (arg2 / 10) < balanceOf[this.address]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 10)
                                            emit Transfer((arg2 / 10), msg.sender, this.address);
                                            if not arg2 / 100:
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not arg1:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                if 0 > balanceOf[address(msg.sender)]:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[(2 * ceil32(return_data.size)) + 998 len 26] >> 48,
                                                                0
                                                if balanceOf[address(msg.sender)] < 0:
                                                    revert with 0, 17
                                                if balanceOf[arg1] > -1:
                                                    revert with 0, 17
                                                if balanceOf[arg1] < balanceOf[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(arg1)] = balanceOf[arg1]
                                                emit Transfer(0, msg.sender, arg1);
                                            else:
                                                if arg2 / 100 and 87 > -1 / arg2 / 100:
                                                    revert with 0, 17
                                                if not arg2 / 100:
                                                    revert with 0, 18
                                                if 87 * arg2 / 100 / arg2 / 100 != 87:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not arg1:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                if 87 * arg2 / 100 > balanceOf[address(msg.sender)]:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[(2 * ceil32(return_data.size)) + 998 len 26] >> 48,
                                                                0
                                                if balanceOf[address(msg.sender)] < 87 * arg2 / 100:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] += -87 * arg2 / 100
                                                if balanceOf[arg1] > !(87 * arg2 / 100):
                                                    revert with 0, 17
                                                if balanceOf[arg1] + (87 * arg2 / 100) < balanceOf[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(arg1)] = balanceOf[arg1] + (87 * arg2 / 100)
                                                emit Transfer((87 * arg2 / 100), msg.sender, arg1);
                            else:
                                if not ext_call.return_data[0]:
                                    mem[64] = (2 * ceil32(return_data.size)) + 288
                                    mem[(2 * ceil32(return_data.size)) + 224] = 26
                                    mem[(2 * ceil32(return_data.size)) + 256] = 'SafeMath: division by zero'
                                    if not stor19.length:
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if stor14[address(msg.sender)]:
                                            if not arg1:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            if arg2 > balanceOf[address(msg.sender)]:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[(2 * ceil32(return_data.size)) + 358 len 26] >> 48,
                                                            0
                                            if balanceOf[address(msg.sender)] < arg2:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2
                                            if balanceOf[arg1] > !arg2:
                                                revert with 0, 17
                                            if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                            emit Transfer(arg2, msg.sender, arg1);
                                        else:
                                            if stor14[address(arg1)]:
                                                if not arg1:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                if arg2 > balanceOf[address(msg.sender)]:
                                                    var86001 = 64
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[(2 * ceil32(return_data.size)) + 358 len 26] >> 48,
                                                                0
                                                if balanceOf[address(msg.sender)] < arg2:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= arg2
                                                if balanceOf[arg1] > !arg2:
                                                    revert with 0, 17
                                                if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                emit Transfer(arg2, msg.sender, arg1);
                                            else:
                                                if stor10:
                                                    if not arg1:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    if arg2 > balanceOf[address(msg.sender)]:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[(2 * ceil32(return_data.size)) + 358 len 26] >> 48,
                                                                    0
                                                    if balanceOf[address(msg.sender)] < arg2:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2
                                                    if balanceOf[arg1] > !arg2:
                                                        revert with 0, 17
                                                    if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                    emit Transfer(arg2, msg.sender, arg1);
                                                else:
                                                    if not stor13:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[(2 * ceil32(return_data.size)) + 422 len 26] >> 48,
                                                                    0
                                                    if balanceOf[address(msg.sender)] < arg2 / 100:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2 / 100
                                                    if balanceOf[stor13] > !(arg2 / 100):
                                                        revert with 0, 17
                                                    if balanceOf[stor13] + (arg2 / 100) < balanceOf[stor13]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[stor13] += arg2 / 100
                                                    emit Transfer((arg2 / 100), msg.sender, stor13);
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not sub_8230af5aAddress:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[(2 * ceil32(return_data.size)) + 582 len 26] >> 48,
                                                                    0
                                                    if balanceOf[address(msg.sender)] < arg2 / 100:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2 / 100
                                                    if balanceOf[stor9] > !(arg2 / 100):
                                                        revert with 0, 17
                                                    if balanceOf[stor9] + (arg2 / 100) < balanceOf[stor9]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[stor9] += arg2 / 100
                                                    emit Transfer((arg2 / 100), msg.sender, sub_8230af5aAddress);
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not uniswapV2PairAddress:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[(2 * ceil32(return_data.size)) + 742 len 26] >> 48,
                                                                    0
                                                    if balanceOf[address(msg.sender)] < arg2 / 100:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2 / 100
                                                    if balanceOf[stor7] > !(arg2 / 100):
                                                        revert with 0, 17
                                                    if balanceOf[stor7] + (arg2 / 100) < balanceOf[stor7]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[stor7] += arg2 / 100
                                                    emit Transfer((arg2 / 100), msg.sender, uniswapV2PairAddress);
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not this.address:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    if arg2 / 10 > balanceOf[address(msg.sender)]:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[(2 * ceil32(return_data.size)) + 902 len 26] >> 48,
                                                                    0
                                                    if balanceOf[address(msg.sender)] < arg2 / 10:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2 / 10
                                                    if balanceOf[this.address] > !(arg2 / 10):
                                                        revert with 0, 17
                                                    if balanceOf[this.address] + (arg2 / 10) < balanceOf[this.address]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 10)
                                                    emit Transfer((arg2 / 10), msg.sender, this.address);
                                                    if not arg2 / 100:
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not arg1:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        if 0 > balanceOf[address(msg.sender)]:
                                                            revert with 0, 
                                                                        32,
                                                                        38,
                                                                        0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[(2 * ceil32(return_data.size)) + 1062 len 26] >> 48,
                                                                        0
                                                        if balanceOf[address(msg.sender)] < 0:
                                                            revert with 0, 17
                                                        if balanceOf[arg1] > -1:
                                                            revert with 0, 17
                                                        if balanceOf[arg1] < balanceOf[arg1]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(arg1)] = balanceOf[arg1]
                                                        emit Transfer(0, msg.sender, arg1);
                                                    else:
                                                        if arg2 / 100 and 87 > -1 / arg2 / 100:
                                                            revert with 0, 17
                                                        if not arg2 / 100:
                                                            revert with 0, 18
                                                        if 87 * arg2 / 100 / arg2 / 100 != 87:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not arg1:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        if 87 * arg2 / 100 > balanceOf[address(msg.sender)]:
                                                            revert with 0, 
                                                                        32,
                                                                        38,
                                                                        0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[(2 * ceil32(return_data.size)) + 1062 len 26] >> 48,
                                                                        0
                                                        if balanceOf[address(msg.sender)] < 87 * arg2 / 100:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] += -87 * arg2 / 100
                                                        if balanceOf[arg1] > !(87 * arg2 / 100):
                                                            revert with 0, 17
                                                        if balanceOf[arg1] + (87 * arg2 / 100) < balanceOf[arg1]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(arg1)] = balanceOf[arg1] + (87 * arg2 / 100)
                                                        emit Transfer((87 * arg2 / 100), msg.sender, arg1);
                                    else:
                                        if stor19.length <= 9:
                                            idx = 0
                                            s = 0
                                            t = 0
                                            while idx < stor19.length:
                                                mem[0] = stor19[idx]
                                                mem[32] = 1
                                                if s > !balanceOf[stor19[idx]]:
                                                    revert with 0, 17
                                                if s + balanceOf[stor19[idx]] < s:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if idx == -1:
                                                    revert with 0, 17
                                                idx = idx + 1
                                                s = s + balanceOf[stor19[idx]]
                                                t = stor19[idx]
                                                continue 
                                            if stor19.length <= 9:
                                                idx = 0
                                                t = 0
                                                u = 160 * stor19.length
                                                while idx < stor19.length:
                                                    mem[0] = stor19[idx]
                                                    mem[32] = 1
                                                    if balanceOf[stor19[idx]] < 10000000000 * 10^18:
                                                        if idx == -1:
                                                            revert with 0, 17
                                                        idx = idx + 1
                                                        t = t
                                                        u = stor19[idx]
                                                        continue 
                                                    mem[0] = stor19[idx]
                                                    mem[32] = 1
                                                    if not balanceOf[stor19[idx]]:
                                                        _30856 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_30856] = 26
                                                        mem[_30856 + 32] = 'SafeMath: division by zero'
                                                        if not s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                            _30936 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _30936 + 68] = mem[idx + _30856 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_30936 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _30936 + -mem[64] + 100
                                                        if 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                            _31354 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_31354] = 26
                                                            mem[_31354 + 32] = 'SafeMath: division by zero'
                                                            mem[mem[64] + 4] = stor19[idx]
                                                            mem[mem[64] + 36] = 0
                                                            require ext_code.size(dogeAddress)
                                                            call dogeAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args stor19[idx], 0
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _31637 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_31637] == bool(mem[_31637])
                                                        if idx == -1:
                                                            revert with 0, 17
                                                        idx = idx + 1
                                                        t = 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length
                                                        u = stor19[idx]
                                                        continue 
                                                    if balanceOf[stor19[idx]] and 10000 > -1 / balanceOf[stor19[idx]]:
                                                        revert with 0, 17
                                                    if not balanceOf[stor19[idx]]:
                                                        revert with 0, 18
                                                    if 10000 * balanceOf[stor19[idx]] / balanceOf[stor19[idx]] != 10000:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _31053 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_31053] = 26
                                                    mem[_31053 + 32] = 'SafeMath: division by zero'
                                                    if not s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                        _31161 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _31161 + 68] = mem[idx + _31053 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_31161 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _31161 + -mem[64] + 100
                                                    if 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                        _31493 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_31493] = 26
                                                        mem[_31493 + 32] = 'SafeMath: division by zero'
                                                        mem[mem[64] + 4] = stor19[idx]
                                                        mem[mem[64] + 36] = 0
                                                        require ext_code.size(dogeAddress)
                                                        call dogeAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args stor19[idx], 0
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _31755 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_31755] == bool(mem[_31755])
                                                    if idx == -1:
                                                        revert with 0, 17
                                                    idx = idx + 1
                                                    t = 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length
                                                    u = stor19[idx]
                                                    continue 
                                                mem[0] = msg.sender
                                                mem[32] = 14
                                                if stor14[address(msg.sender)]:
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not arg1:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _30849 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_30849] = 38
                                                    mem[_30849 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if arg2 > balanceOf[address(msg.sender)]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_30849 + 70 len 26]
                                                        var96001 = 64
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(msg.sender)] < arg2:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2
                                                    if balanceOf[arg1] > !arg2:
                                                        revert with 0, 17
                                                    if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                    emit Transfer(arg2, msg.sender, arg1);
                                                else:
                                                    mem[0] = arg1
                                                    mem[32] = 14
                                                    if stor14[address(arg1)]:
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not arg1:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        _30901 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_30901] = 38
                                                        mem[_30901 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if arg2 > balanceOf[address(msg.sender)]:
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 38
                                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_30901 + 70 len 26]
                                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                        if balanceOf[address(msg.sender)] < arg2:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] -= arg2
                                                        if balanceOf[arg1] > !arg2:
                                                            revert with 0, 17
                                                        if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                        emit Transfer(arg2, msg.sender, arg1);
                                                    else:
                                                        if stor10:
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not arg1:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _30852 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_30852] = 38
                                                            mem[_30852 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if arg2 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_30852 + 70 len 26]
                                                                var96001 = 64
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < arg2:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2
                                                            if balanceOf[arg1] > !arg2:
                                                                revert with 0, 17
                                                            if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                            emit Transfer(arg2, msg.sender, arg1);
                                                        else:
                                                            _30773 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_30773] = 26
                                                            mem[_30773 + 32] = 'SafeMath: division by zero'
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not stor13:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _31157 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_31157] = 38
                                                            mem[_31157 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_31157 + 70 len 26]
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                                            if balanceOf[stor13] > !(arg2 / 100):
                                                                revert with 0, 17
                                                            if balanceOf[stor13] + (arg2 / 100) < balanceOf[stor13]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = stor13
                                                            mem[32] = 1
                                                            balanceOf[stor13] += arg2 / 100
                                                            emit Transfer((arg2 / 100), msg.sender, stor13);
                                                            _31713 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_31713] = 26
                                                            mem[_31713 + 32] = 'SafeMath: division by zero'
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not sub_8230af5aAddress:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _31825 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_31825] = 38
                                                            mem[_31825 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_31825 + 70 len 26]
                                                                var131001 = 64
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                                            if balanceOf[stor9] > !(arg2 / 100):
                                                                revert with 0, 17
                                                            if balanceOf[stor9] + (arg2 / 100) < balanceOf[stor9]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = sub_8230af5aAddress
                                                            mem[32] = 1
                                                            balanceOf[stor9] += arg2 / 100
                                                            emit Transfer((arg2 / 100), msg.sender, sub_8230af5aAddress);
                                                            _31951 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_31951] = 26
                                                            mem[_31951 + 32] = 'SafeMath: division by zero'
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not uniswapV2PairAddress:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _31983 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_31983] = 38
                                                            mem[_31983 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_31983 + 70 len 26]
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                                            if balanceOf[stor7] > !(arg2 / 100):
                                                                revert with 0, 17
                                                            if balanceOf[stor7] + (arg2 / 100) < balanceOf[stor7]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = uniswapV2PairAddress
                                                            mem[32] = 1
                                                            balanceOf[stor7] += arg2 / 100
                                                            emit Transfer((arg2 / 100), msg.sender, uniswapV2PairAddress);
                                                            _32103 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_32103] = 26
                                                            mem[_32103 + 32] = 'SafeMath: division by zero'
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not this.address:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _32135 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_32135] = 38
                                                            mem[_32135 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if arg2 / 10 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_32135 + 70 len 26]
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < arg2 / 10:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2 / 10
                                                            if balanceOf[this.address] > !(arg2 / 10):
                                                                revert with 0, 17
                                                            if balanceOf[this.address] + (arg2 / 10) < balanceOf[this.address]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = this.address
                                                            mem[32] = 1
                                                            balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 10)
                                                            emit Transfer((arg2 / 10), msg.sender, this.address);
                                                            _32255 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_32255] = 26
                                                            mem[_32255 + 32] = 'SafeMath: division by zero'
                                                            if not arg2 / 100:
                                                                if not msg.sender:
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not arg1:
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                _32292 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_32292] = 38
                                                                mem[_32292 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                if 0 > balanceOf[address(msg.sender)]:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 38
                                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_32292 + 70 len 26]
                                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                if balanceOf[address(msg.sender)] < 0:
                                                                    revert with 0, 17
                                                                if balanceOf[arg1] > -1:
                                                                    revert with 0, 17
                                                                if balanceOf[arg1] < balanceOf[arg1]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                balanceOf[address(arg1)] = balanceOf[arg1]
                                                                emit Transfer(0, msg.sender, arg1);
                                                            else:
                                                                if arg2 / 100 and 87 > -1 / arg2 / 100:
                                                                    revert with 0, 17
                                                                if not arg2 / 100:
                                                                    revert with 0, 18
                                                                if 87 * arg2 / 100 / arg2 / 100 != 87:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if not msg.sender:
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not arg1:
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                _32383 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_32383] = 38
                                                                mem[_32383 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                if 87 * arg2 / 100 > balanceOf[address(msg.sender)]:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 38
                                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_32383 + 70 len 26]
                                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                if balanceOf[address(msg.sender)] < 87 * arg2 / 100:
                                                                    revert with 0, 17
                                                                balanceOf[address(msg.sender)] += -87 * arg2 / 100
                                                                if balanceOf[arg1] > !(87 * arg2 / 100):
                                                                    revert with 0, 17
                                                                if balanceOf[arg1] + (87 * arg2 / 100) < balanceOf[arg1]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                balanceOf[address(arg1)] = balanceOf[arg1] + (87 * arg2 / 100)
                                                                emit Transfer((87 * arg2 / 100), msg.sender, arg1);
                                            else:
                                                idx = 0
                                                t = 0
                                                u = 160 * stor19.length
                                                while idx < 9:
                                                    if 0 > !idx:
                                                        revert with 0, 17
                                                    if idx >= stor19.length:
                                                        revert with 0, 50
                                                    mem[0] = stor19[idx]
                                                    mem[32] = 1
                                                    if balanceOf[stor19[idx]] < 10000000000 * 10^18:
                                                        if idx == -1:
                                                            revert with 0, 17
                                                        idx = idx + 1
                                                        t = t
                                                        u = stor19[idx]
                                                        continue 
                                                    mem[0] = stor19[idx]
                                                    mem[32] = 1
                                                    if not balanceOf[stor19[idx]]:
                                                        _30970 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_30970] = 26
                                                        mem[_30970 + 32] = 'SafeMath: division by zero'
                                                        if not s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                            _31011 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _31011 + 68] = mem[idx + _30970 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_31011 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _31011 + -mem[64] + 100
                                                        if 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                            _31448 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_31448] = 26
                                                            mem[_31448 + 32] = 'SafeMath: division by zero'
                                                            mem[mem[64] + 4] = stor19[idx]
                                                            mem[mem[64] + 36] = 0
                                                            require ext_code.size(dogeAddress)
                                                            call dogeAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args stor19[idx], 0
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _31727 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_31727] == bool(mem[_31727])
                                                        if idx == -1:
                                                            revert with 0, 17
                                                        idx = idx + 1
                                                        t = 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length
                                                        u = stor19[idx]
                                                        continue 
                                                    if balanceOf[stor19[idx]] and 10000 > -1 / balanceOf[stor19[idx]]:
                                                        revert with 0, 17
                                                    if not balanceOf[stor19[idx]]:
                                                        revert with 0, 18
                                                    if 10000 * balanceOf[stor19[idx]] / balanceOf[stor19[idx]] != 10000:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _31204 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_31204] = 26
                                                    mem[_31204 + 32] = 'SafeMath: division by zero'
                                                    if not s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                        _31248 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _31248 + 68] = mem[idx + _31204 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_31248 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _31248 + -mem[64] + 100
                                                    if 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                        _31644 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_31644] = 26
                                                        mem[_31644 + 32] = 'SafeMath: division by zero'
                                                        mem[mem[64] + 4] = stor19[idx]
                                                        mem[mem[64] + 36] = 0
                                                        require ext_code.size(dogeAddress)
                                                        call dogeAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args stor19[idx], 0
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _31779 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_31779] == bool(mem[_31779])
                                                    if idx == -1:
                                                        revert with 0, 17
                                                    idx = idx + 1
                                                    t = 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length
                                                    u = stor19[idx]
                                                    continue 
                                                mem[0] = msg.sender
                                                mem[32] = 14
                                                if stor14[address(msg.sender)]:
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not arg1:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _30857 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_30857] = 38
                                                    mem[_30857 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if arg2 > balanceOf[address(msg.sender)]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_30857 + 70 len 26]
                                                        var96001 = 64
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(msg.sender)] < arg2:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2
                                                    if balanceOf[arg1] > !arg2:
                                                        revert with 0, 17
                                                    if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                    emit Transfer(arg2, msg.sender, arg1);
                                                else:
                                                    mem[0] = arg1
                                                    mem[32] = 14
                                                    if stor14[address(arg1)]:
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not arg1:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        _30906 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_30906] = 38
                                                        mem[_30906 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if arg2 > balanceOf[address(msg.sender)]:
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 38
                                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_30906 + 70 len 26]
                                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                        if balanceOf[address(msg.sender)] < arg2:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] -= arg2
                                                        if balanceOf[arg1] > !arg2:
                                                            revert with 0, 17
                                                        if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                        emit Transfer(arg2, msg.sender, arg1);
                                                    else:
                                                        if stor10:
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not arg1:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _30860 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_30860] = 38
                                                            mem[_30860 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if arg2 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_30860 + 70 len 26]
                                                                var96001 = 64
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < arg2:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2
                                                            if balanceOf[arg1] > !arg2:
                                                                revert with 0, 17
                                                            if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                            emit Transfer(arg2, msg.sender, arg1);
                                                        else:
                                                            _30774 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_30774] = 26
                                                            mem[_30774 + 32] = 'SafeMath: division by zero'
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not stor13:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _31165 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_31165] = 38
                                                            mem[_31165 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_31165 + 70 len 26]
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                                            if balanceOf[stor13] > !(arg2 / 100):
                                                                revert with 0, 17
                                                            if balanceOf[stor13] + (arg2 / 100) < balanceOf[stor13]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = stor13
                                                            mem[32] = 1
                                                            balanceOf[stor13] += arg2 / 100
                                                            emit Transfer((arg2 / 100), msg.sender, stor13);
                                                            _31716 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_31716] = 26
                                                            mem[_31716 + 32] = 'SafeMath: division by zero'
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not sub_8230af5aAddress:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _31828 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_31828] = 38
                                                            mem[_31828 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_31828 + 70 len 26]
                                                                var131001 = 64
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                                            if balanceOf[stor9] > !(arg2 / 100):
                                                                revert with 0, 17
                                                            if balanceOf[stor9] + (arg2 / 100) < balanceOf[stor9]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = sub_8230af5aAddress
                                                            mem[32] = 1
                                                            balanceOf[stor9] += arg2 / 100
                                                            emit Transfer((arg2 / 100), msg.sender, sub_8230af5aAddress);
                                                            _31952 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_31952] = 26
                                                            mem[_31952 + 32] = 'SafeMath: division by zero'
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not uniswapV2PairAddress:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _31986 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_31986] = 38
                                                            mem[_31986 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_31986 + 70 len 26]
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                                            if balanceOf[stor7] > !(arg2 / 100):
                                                                revert with 0, 17
                                                            if balanceOf[stor7] + (arg2 / 100) < balanceOf[stor7]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = uniswapV2PairAddress
                                                            mem[32] = 1
                                                            balanceOf[stor7] += arg2 / 100
                                                            emit Transfer((arg2 / 100), msg.sender, uniswapV2PairAddress);
                                                            _32104 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_32104] = 26
                                                            mem[_32104 + 32] = 'SafeMath: division by zero'
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not this.address:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _32138 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_32138] = 38
                                                            mem[_32138 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if arg2 / 10 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_32138 + 70 len 26]
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < arg2 / 10:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2 / 10
                                                            if balanceOf[this.address] > !(arg2 / 10):
                                                                revert with 0, 17
                                                            if balanceOf[this.address] + (arg2 / 10) < balanceOf[this.address]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = this.address
                                                            mem[32] = 1
                                                            balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 10)
                                                            emit Transfer((arg2 / 10), msg.sender, this.address);
                                                            _32256 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_32256] = 26
                                                            mem[_32256 + 32] = 'SafeMath: division by zero'
                                                            if not arg2 / 100:
                                                                if not msg.sender:
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not arg1:
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                _32296 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_32296] = 38
                                                                mem[_32296 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                if 0 > balanceOf[address(msg.sender)]:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 38
                                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_32296 + 70 len 26]
                                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                if balanceOf[address(msg.sender)] < 0:
                                                                    revert with 0, 17
                                                                if balanceOf[arg1] > -1:
                                                                    revert with 0, 17
                                                                if balanceOf[arg1] < balanceOf[arg1]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                balanceOf[address(arg1)] = balanceOf[arg1]
                                                                emit Transfer(0, msg.sender, arg1);
                                                            else:
                                                                if arg2 / 100 and 87 > -1 / arg2 / 100:
                                                                    revert with 0, 17
                                                                if not arg2 / 100:
                                                                    revert with 0, 18
                                                                if 87 * arg2 / 100 / arg2 / 100 != 87:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if not msg.sender:
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not arg1:
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                _32388 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_32388] = 38
                                                                mem[_32388 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                if 87 * arg2 / 100 > balanceOf[address(msg.sender)]:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 38
                                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_32388 + 70 len 26]
                                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                if balanceOf[address(msg.sender)] < 87 * arg2 / 100:
                                                                    revert with 0, 17
                                                                balanceOf[address(msg.sender)] += -87 * arg2 / 100
                                                                if balanceOf[arg1] > !(87 * arg2 / 100):
                                                                    revert with 0, 17
                                                                if balanceOf[arg1] + (87 * arg2 / 100) < balanceOf[arg1]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                balanceOf[address(arg1)] = balanceOf[arg1] + (87 * arg2 / 100)
                                                                emit Transfer((87 * arg2 / 100), msg.sender, arg1);
                                        else:
                                            if stor19.length < 9:
                                                revert with 0, 17
                                            mem[64] = (2 * ceil32(return_data.size)) + 352
                                            mem[(2 * ceil32(return_data.size)) + 288] = 24
                                            mem[(2 * ceil32(return_data.size)) + 320] = 'SafeMath: modulo by zero'
                                            if not stor19.length - 9:
                                                revert with 0, 'SafeMath: modulo by zero', 0
                                            idx = 0
                                            s = 0
                                            t = 0
                                            while idx < 9:
                                                if block.timestamp % stor19.length - 9 > !idx:
                                                    revert with 0, 17
                                                if (block.timestamp % stor19.length - 9) + idx >= stor19.length:
                                                    revert with 0, 50
                                                mem[0] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                                mem[32] = 1
                                                if s > !balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]]:
                                                    revert with 0, 17
                                                if s + balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] < s:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if idx == -1:
                                                    revert with 0, 17
                                                idx = idx + 1
                                                s = s + balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]]
                                                t = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                                continue 
                                            if stor19.length <= 9:
                                                idx = 0
                                                t = 0
                                                u = 1440
                                                while idx < stor19.length:
                                                    mem[0] = stor19[idx]
                                                    mem[32] = 1
                                                    if balanceOf[stor19[idx]] < 10000000000 * 10^18:
                                                        if idx == -1:
                                                            revert with 0, 17
                                                        idx = idx + 1
                                                        t = t
                                                        u = stor19[idx]
                                                        continue 
                                                    mem[0] = stor19[idx]
                                                    mem[32] = 1
                                                    if not balanceOf[stor19[idx]]:
                                                        _30871 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_30871] = 26
                                                        mem[_30871 + 32] = 'SafeMath: division by zero'
                                                        if not 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                            _30943 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _30943 + 68] = mem[idx + _30871 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_30943 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _30943 + -mem[64] + 100
                                                        if 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                            _31368 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_31368] = 26
                                                            mem[_31368 + 32] = 'SafeMath: division by zero'
                                                            mem[mem[64] + 4] = stor19[idx]
                                                            mem[mem[64] + 36] = 0
                                                            require ext_code.size(dogeAddress)
                                                            call dogeAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args stor19[idx], 0
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _31651 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_31651] == bool(mem[_31651])
                                                        if idx == -1:
                                                            revert with 0, 17
                                                        idx = idx + 1
                                                        t = 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s
                                                        u = stor19[idx]
                                                        continue 
                                                    if balanceOf[stor19[idx]] and 10000 > -1 / balanceOf[stor19[idx]]:
                                                        revert with 0, 17
                                                    if not balanceOf[stor19[idx]]:
                                                        revert with 0, 18
                                                    if 10000 * balanceOf[stor19[idx]] / balanceOf[stor19[idx]] != 10000:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _31067 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_31067] = 26
                                                    mem[_31067 + 32] = 'SafeMath: division by zero'
                                                    if not 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                        _31177 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _31177 + 68] = mem[idx + _31067 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_31177 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _31177 + -mem[64] + 100
                                                    if 10000 * balanceOf[stor19[idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                        _31498 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_31498] = 26
                                                        mem[_31498 + 32] = 'SafeMath: division by zero'
                                                        mem[mem[64] + 4] = stor19[idx]
                                                        mem[mem[64] + 36] = 0
                                                        require ext_code.size(dogeAddress)
                                                        call dogeAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args stor19[idx], 0
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _31756 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_31756] == bool(mem[_31756])
                                                    if idx == -1:
                                                        revert with 0, 17
                                                    idx = idx + 1
                                                    t = 10000 * balanceOf[stor19[idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s
                                                    u = stor19[idx]
                                                    continue 
                                                mem[0] = msg.sender
                                                mem[32] = 14
                                                if stor14[address(msg.sender)]:
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not arg1:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _30864 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_30864] = 38
                                                    mem[_30864 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if arg2 > balanceOf[address(msg.sender)]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_30864 + 70 len 26]
                                                        var107001 = 64
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(msg.sender)] < arg2:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2
                                                    if balanceOf[arg1] > !arg2:
                                                        revert with 0, 17
                                                    if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                    emit Transfer(arg2, msg.sender, arg1);
                                                else:
                                                    mem[0] = arg1
                                                    mem[32] = 14
                                                    if stor14[address(arg1)]:
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not arg1:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        _30911 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_30911] = 38
                                                        mem[_30911 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if arg2 > balanceOf[address(msg.sender)]:
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 38
                                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_30911 + 70 len 26]
                                                            var108001 = 64
                                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                        if balanceOf[address(msg.sender)] < arg2:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] -= arg2
                                                        if balanceOf[arg1] > !arg2:
                                                            revert with 0, 17
                                                        if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                        emit Transfer(arg2, msg.sender, arg1);
                                                    else:
                                                        if stor10:
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not arg1:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _30867 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_30867] = 38
                                                            mem[_30867 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if arg2 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_30867 + 70 len 26]
                                                                var107001 = 64
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < arg2:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2
                                                            if balanceOf[arg1] > !arg2:
                                                                revert with 0, 17
                                                            if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                            emit Transfer(arg2, msg.sender, arg1);
                                                        else:
                                                            _30776 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_30776] = 26
                                                            mem[_30776 + 32] = 'SafeMath: division by zero'
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not stor13:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _31173 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_31173] = 38
                                                            mem[_31173 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_31173 + 70 len 26]
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                                            if balanceOf[stor13] > !(arg2 / 100):
                                                                revert with 0, 17
                                                            if balanceOf[stor13] + (arg2 / 100) < balanceOf[stor13]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = stor13
                                                            mem[32] = 1
                                                            balanceOf[stor13] += arg2 / 100
                                                            emit Transfer((arg2 / 100), msg.sender, stor13);
                                                            _31718 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_31718] = 26
                                                            mem[_31718 + 32] = 'SafeMath: division by zero'
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not sub_8230af5aAddress:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _31831 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_31831] = 38
                                                            mem[_31831 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_31831 + 70 len 26]
                                                                var142001 = 64
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                                            if balanceOf[stor9] > !(arg2 / 100):
                                                                revert with 0, 17
                                                            if balanceOf[stor9] + (arg2 / 100) < balanceOf[stor9]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = sub_8230af5aAddress
                                                            mem[32] = 1
                                                            balanceOf[stor9] += arg2 / 100
                                                            emit Transfer((arg2 / 100), msg.sender, sub_8230af5aAddress);
                                                            _31953 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_31953] = 26
                                                            mem[_31953 + 32] = 'SafeMath: division by zero'
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not uniswapV2PairAddress:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _31989 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_31989] = 38
                                                            mem[_31989 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_31989 + 70 len 26]
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                                            if balanceOf[stor7] > !(arg2 / 100):
                                                                revert with 0, 17
                                                            if balanceOf[stor7] + (arg2 / 100) < balanceOf[stor7]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = uniswapV2PairAddress
                                                            mem[32] = 1
                                                            balanceOf[stor7] += arg2 / 100
                                                            emit Transfer((arg2 / 100), msg.sender, uniswapV2PairAddress);
                                                            _32105 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_32105] = 26
                                                            mem[_32105 + 32] = 'SafeMath: division by zero'
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not this.address:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _32141 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_32141] = 38
                                                            mem[_32141 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if arg2 / 10 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_32141 + 70 len 26]
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < arg2 / 10:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2 / 10
                                                            if balanceOf[this.address] > !(arg2 / 10):
                                                                revert with 0, 17
                                                            if balanceOf[this.address] + (arg2 / 10) < balanceOf[this.address]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = this.address
                                                            mem[32] = 1
                                                            balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 10)
                                                            emit Transfer((arg2 / 10), msg.sender, this.address);
                                                            _32257 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_32257] = 26
                                                            mem[_32257 + 32] = 'SafeMath: division by zero'
                                                            if not arg2 / 100:
                                                                if not msg.sender:
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not arg1:
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                _32300 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_32300] = 38
                                                                mem[_32300 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                if 0 > balanceOf[address(msg.sender)]:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 38
                                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_32300 + 70 len 26]
                                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                if balanceOf[address(msg.sender)] < 0:
                                                                    revert with 0, 17
                                                                if balanceOf[arg1] > -1:
                                                                    revert with 0, 17
                                                                if balanceOf[arg1] < balanceOf[arg1]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                balanceOf[address(arg1)] = balanceOf[arg1]
                                                                emit Transfer(0, msg.sender, arg1);
                                                            else:
                                                                if arg2 / 100 and 87 > -1 / arg2 / 100:
                                                                    revert with 0, 17
                                                                if not arg2 / 100:
                                                                    revert with 0, 18
                                                                if 87 * arg2 / 100 / arg2 / 100 != 87:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if not msg.sender:
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not arg1:
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                _32393 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_32393] = 38
                                                                mem[_32393 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                if 87 * arg2 / 100 > balanceOf[address(msg.sender)]:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 38
                                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_32393 + 70 len 26]
                                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                if balanceOf[address(msg.sender)] < 87 * arg2 / 100:
                                                                    revert with 0, 17
                                                                balanceOf[address(msg.sender)] += -87 * arg2 / 100
                                                                if balanceOf[arg1] > !(87 * arg2 / 100):
                                                                    revert with 0, 17
                                                                if balanceOf[arg1] + (87 * arg2 / 100) < balanceOf[arg1]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                balanceOf[address(arg1)] = balanceOf[arg1] + (87 * arg2 / 100)
                                                                emit Transfer((87 * arg2 / 100), msg.sender, arg1);
                                            else:
                                                idx = 0
                                                t = 0
                                                u = 1440
                                                while idx < 9:
                                                    if block.timestamp % stor19.length - 9 > !idx:
                                                        revert with 0, 17
                                                    if (block.timestamp % stor19.length - 9) + idx >= stor19.length:
                                                        revert with 0, 50
                                                    mem[0] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                                    mem[32] = 1
                                                    if balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] < 10000000000 * 10^18:
                                                        if idx == -1:
                                                            revert with 0, 17
                                                        idx = idx + 1
                                                        t = t
                                                        u = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                                        continue 
                                                    mem[0] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                                    mem[32] = 1
                                                    if not balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]]:
                                                        _30978 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_30978] = 26
                                                        mem[_30978 + 32] = 'SafeMath: division by zero'
                                                        if not 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                            _31018 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _31018 + 68] = mem[idx + _30978 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_31018 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _31018 + -mem[64] + 100
                                                        if 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                            _31454 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_31454] = 26
                                                            mem[_31454 + 32] = 'SafeMath: division by zero'
                                                            mem[mem[64] + 4] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                                            mem[mem[64] + 36] = 0
                                                            require ext_code.size(dogeAddress)
                                                            call dogeAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx], 0
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _31728 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_31728] == bool(mem[_31728])
                                                        if idx == -1:
                                                            revert with 0, 17
                                                        idx = idx + 1
                                                        t = 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s
                                                        u = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                                        continue 
                                                    if balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] and 10000 > -1 / balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]]:
                                                        revert with 0, 17
                                                    if not balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]]:
                                                        revert with 0, 18
                                                    if 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] != 10000:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _31210 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_31210] = 26
                                                    mem[_31210 + 32] = 'SafeMath: division by zero'
                                                    if not 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                        _31257 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _31257 + 68] = mem[idx + _31210 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_31257 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _31257 + -mem[64] + 100
                                                    if 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                        _31658 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_31658] = 26
                                                        mem[_31658 + 32] = 'SafeMath: division by zero'
                                                        mem[mem[64] + 4] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                                        mem[mem[64] + 36] = 0
                                                        require ext_code.size(dogeAddress)
                                                        call dogeAddress.0xa9059cbb with:
                                                             gas gas_remaining wei
                                                            args stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx], 0
                                                        mem[mem[64]] = ext_call.return_data[0]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _31780 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 32
                                                        require mem[_31780] == bool(mem[_31780])
                                                    if idx == -1:
                                                        revert with 0, 17
                                                    idx = idx + 1
                                                    t = 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s
                                                    u = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                                    continue 
                                                mem[0] = msg.sender
                                                mem[32] = 14
                                                if stor14[address(msg.sender)]:
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not arg1:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _30872 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_30872] = 38
                                                    mem[_30872 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if arg2 > balanceOf[address(msg.sender)]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_30872 + 70 len 26]
                                                        var107001 = 64
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(msg.sender)] < arg2:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2
                                                    if balanceOf[arg1] > !arg2:
                                                        revert with 0, 17
                                                    if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                    emit Transfer(arg2, msg.sender, arg1);
                                                else:
                                                    mem[0] = arg1
                                                    mem[32] = 14
                                                    if stor14[address(arg1)]:
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not arg1:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        _30916 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_30916] = 38
                                                        mem[_30916 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if arg2 > balanceOf[address(msg.sender)]:
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 38
                                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_30916 + 70 len 26]
                                                            var108001 = 64
                                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                        if balanceOf[address(msg.sender)] < arg2:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] -= arg2
                                                        if balanceOf[arg1] > !arg2:
                                                            revert with 0, 17
                                                        if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                        emit Transfer(arg2, msg.sender, arg1);
                                                    else:
                                                        if stor10:
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not arg1:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _30875 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_30875] = 38
                                                            mem[_30875 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if arg2 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_30875 + 70 len 26]
                                                                var107001 = 64
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < arg2:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2
                                                            if balanceOf[arg1] > !arg2:
                                                                revert with 0, 17
                                                            if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                            emit Transfer(arg2, msg.sender, arg1);
                                                        else:
                                                            _30777 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_30777] = 26
                                                            mem[_30777 + 32] = 'SafeMath: division by zero'
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not stor13:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _31181 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_31181] = 38
                                                            mem[_31181 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_31181 + 70 len 26]
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                                            if balanceOf[stor13] > !(arg2 / 100):
                                                                revert with 0, 17
                                                            if balanceOf[stor13] + (arg2 / 100) < balanceOf[stor13]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = stor13
                                                            mem[32] = 1
                                                            balanceOf[stor13] += arg2 / 100
                                                            emit Transfer((arg2 / 100), msg.sender, stor13);
                                                            _31721 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_31721] = 26
                                                            mem[_31721 + 32] = 'SafeMath: division by zero'
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not sub_8230af5aAddress:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _31834 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_31834] = 38
                                                            mem[_31834 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_31834 + 70 len 26]
                                                                var142001 = 64
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                                            if balanceOf[stor9] > !(arg2 / 100):
                                                                revert with 0, 17
                                                            if balanceOf[stor9] + (arg2 / 100) < balanceOf[stor9]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = sub_8230af5aAddress
                                                            mem[32] = 1
                                                            balanceOf[stor9] += arg2 / 100
                                                            emit Transfer((arg2 / 100), msg.sender, sub_8230af5aAddress);
                                                            _31954 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_31954] = 26
                                                            mem[_31954 + 32] = 'SafeMath: division by zero'
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not uniswapV2PairAddress:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _31992 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_31992] = 38
                                                            mem[_31992 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_31992 + 70 len 26]
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                                            if balanceOf[stor7] > !(arg2 / 100):
                                                                revert with 0, 17
                                                            if balanceOf[stor7] + (arg2 / 100) < balanceOf[stor7]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = uniswapV2PairAddress
                                                            mem[32] = 1
                                                            balanceOf[stor7] += arg2 / 100
                                                            emit Transfer((arg2 / 100), msg.sender, uniswapV2PairAddress);
                                                            _32106 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_32106] = 26
                                                            mem[_32106 + 32] = 'SafeMath: division by zero'
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not this.address:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _32144 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_32144] = 38
                                                            mem[_32144 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if arg2 / 10 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_32144 + 70 len 26]
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < arg2 / 10:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2 / 10
                                                            if balanceOf[this.address] > !(arg2 / 10):
                                                                revert with 0, 17
                                                            if balanceOf[this.address] + (arg2 / 10) < balanceOf[this.address]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = this.address
                                                            mem[32] = 1
                                                            balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 10)
                                                            emit Transfer((arg2 / 10), msg.sender, this.address);
                                                            _32258 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_32258] = 26
                                                            mem[_32258 + 32] = 'SafeMath: division by zero'
                                                            if not arg2 / 100:
                                                                if not msg.sender:
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not arg1:
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                _32304 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_32304] = 38
                                                                mem[_32304 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                if 0 > balanceOf[address(msg.sender)]:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 38
                                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_32304 + 70 len 26]
                                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                if balanceOf[address(msg.sender)] < 0:
                                                                    revert with 0, 17
                                                                if balanceOf[arg1] > -1:
                                                                    revert with 0, 17
                                                                if balanceOf[arg1] < balanceOf[arg1]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                balanceOf[address(arg1)] = balanceOf[arg1]
                                                                emit Transfer(0, msg.sender, arg1);
                                                            else:
                                                                if arg2 / 100 and 87 > -1 / arg2 / 100:
                                                                    revert with 0, 17
                                                                if not arg2 / 100:
                                                                    revert with 0, 18
                                                                if 87 * arg2 / 100 / arg2 / 100 != 87:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if not msg.sender:
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not arg1:
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                _32398 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_32398] = 38
                                                                mem[_32398 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                if 87 * arg2 / 100 > balanceOf[address(msg.sender)]:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 38
                                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_32398 + 70 len 26]
                                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                if balanceOf[address(msg.sender)] < 87 * arg2 / 100:
                                                                    revert with 0, 17
                                                                balanceOf[address(msg.sender)] += -87 * arg2 / 100
                                                                if balanceOf[arg1] > !(87 * arg2 / 100):
                                                                    revert with 0, 17
                                                                if balanceOf[arg1] + (87 * arg2 / 100) < balanceOf[arg1]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                balanceOf[address(arg1)] = balanceOf[arg1] + (87 * arg2 / 100)
                                                                emit Transfer((87 * arg2 / 100), msg.sender, arg1);
                                else:
                                    if ext_call.return_data[0] and 4 > -1 / ext_call.return_data[0]:
                                        revert with 0, 17
                                    if not ext_call.return_data[0]:
                                        revert with 0, 18
                                    if 4 * ext_call.return_data[0] / ext_call.return_data[0] != 4:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[64] = (2 * ceil32(return_data.size)) + 288
                                    mem[(2 * ceil32(return_data.size)) + 224] = 26
                                    mem[(2 * ceil32(return_data.size)) + 256] = 'SafeMath: division by zero'
                                    if not stor19.length:
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if stor14[address(msg.sender)]:
                                            if not arg1:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            if arg2 > balanceOf[address(msg.sender)]:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[(2 * ceil32(return_data.size)) + 358 len 26] >> 48,
                                                            0
                                            if balanceOf[address(msg.sender)] < arg2:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2
                                            if balanceOf[arg1] > !arg2:
                                                revert with 0, 17
                                            if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                            emit Transfer(arg2, msg.sender, arg1);
                                        else:
                                            if stor14[address(arg1)]:
                                                if not arg1:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                if arg2 > balanceOf[address(msg.sender)]:
                                                    var92001 = 64
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[(2 * ceil32(return_data.size)) + 358 len 26] >> 48,
                                                                0
                                                if balanceOf[address(msg.sender)] < arg2:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= arg2
                                                if balanceOf[arg1] > !arg2:
                                                    revert with 0, 17
                                                if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                emit Transfer(arg2, msg.sender, arg1);
                                            else:
                                                if stor10:
                                                    if not arg1:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    if arg2 > balanceOf[address(msg.sender)]:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[(2 * ceil32(return_data.size)) + 358 len 26] >> 48,
                                                                    0
                                                    if balanceOf[address(msg.sender)] < arg2:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2
                                                    if balanceOf[arg1] > !arg2:
                                                        revert with 0, 17
                                                    if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                    emit Transfer(arg2, msg.sender, arg1);
                                                else:
                                                    if not stor13:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                        var99001 = 64
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[(2 * ceil32(return_data.size)) + 422 len 26] >> 48,
                                                                    0
                                                    if balanceOf[address(msg.sender)] < arg2 / 100:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2 / 100
                                                    if balanceOf[stor13] > !(arg2 / 100):
                                                        revert with 0, 17
                                                    if balanceOf[stor13] + (arg2 / 100) < balanceOf[stor13]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[stor13] += arg2 / 100
                                                    emit Transfer((arg2 / 100), msg.sender, stor13);
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not sub_8230af5aAddress:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[(2 * ceil32(return_data.size)) + 582 len 26] >> 48,
                                                                    0
                                                    if balanceOf[address(msg.sender)] < arg2 / 100:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2 / 100
                                                    if balanceOf[stor9] > !(arg2 / 100):
                                                        revert with 0, 17
                                                    if balanceOf[stor9] + (arg2 / 100) < balanceOf[stor9]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[stor9] += arg2 / 100
                                                    emit Transfer((arg2 / 100), msg.sender, sub_8230af5aAddress);
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not uniswapV2PairAddress:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[(2 * ceil32(return_data.size)) + 742 len 26] >> 48,
                                                                    0
                                                    if balanceOf[address(msg.sender)] < arg2 / 100:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2 / 100
                                                    if balanceOf[stor7] > !(arg2 / 100):
                                                        revert with 0, 17
                                                    if balanceOf[stor7] + (arg2 / 100) < balanceOf[stor7]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[stor7] += arg2 / 100
                                                    emit Transfer((arg2 / 100), msg.sender, uniswapV2PairAddress);
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not this.address:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    if arg2 / 10 > balanceOf[address(msg.sender)]:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[(2 * ceil32(return_data.size)) + 902 len 26] >> 48,
                                                                    0
                                                    if balanceOf[address(msg.sender)] < arg2 / 10:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2 / 10
                                                    if balanceOf[this.address] > !(arg2 / 10):
                                                        revert with 0, 17
                                                    if balanceOf[this.address] + (arg2 / 10) < balanceOf[this.address]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 10)
                                                    emit Transfer((arg2 / 10), msg.sender, this.address);
                                                    if not arg2 / 100:
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not arg1:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        if 0 > balanceOf[address(msg.sender)]:
                                                            revert with 0, 
                                                                        32,
                                                                        38,
                                                                        0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[(2 * ceil32(return_data.size)) + 1062 len 26] >> 48,
                                                                        0
                                                        if balanceOf[address(msg.sender)] < 0:
                                                            revert with 0, 17
                                                        if balanceOf[arg1] > -1:
                                                            revert with 0, 17
                                                        if balanceOf[arg1] < balanceOf[arg1]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(arg1)] = balanceOf[arg1]
                                                        emit Transfer(0, msg.sender, arg1);
                                                    else:
                                                        if arg2 / 100 and 87 > -1 / arg2 / 100:
                                                            revert with 0, 17
                                                        if not arg2 / 100:
                                                            revert with 0, 18
                                                        if 87 * arg2 / 100 / arg2 / 100 != 87:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not arg1:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        if 87 * arg2 / 100 > balanceOf[address(msg.sender)]:
                                                            revert with 0, 
                                                                        32,
                                                                        38,
                                                                        0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[(2 * ceil32(return_data.size)) + 1062 len 26] >> 48,
                                                                        0
                                                        if balanceOf[address(msg.sender)] < 87 * arg2 / 100:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] += -87 * arg2 / 100
                                                        if balanceOf[arg1] > !(87 * arg2 / 100):
                                                            revert with 0, 17
                                                        if balanceOf[arg1] + (87 * arg2 / 100) < balanceOf[arg1]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(arg1)] = balanceOf[arg1] + (87 * arg2 / 100)
                                                        emit Transfer((87 * arg2 / 100), msg.sender, arg1);
                                    else:
                                        if stor19.length <= 9:
                                            idx = 0
                                            s = 0
                                            t = 0
                                            while idx < stor19.length:
                                                mem[0] = stor19[idx]
                                                mem[32] = 1
                                                if s > !balanceOf[stor19[idx]]:
                                                    revert with 0, 17
                                                if s + balanceOf[stor19[idx]] < s:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if idx == -1:
                                                    revert with 0, 17
                                                idx = idx + 1
                                                s = s + balanceOf[stor19[idx]]
                                                t = stor19[idx]
                                                continue 
                                            if stor19.length <= 9:
                                                idx = 0
                                                t = 0
                                                u = 160 * stor19.length
                                                while idx < stor19.length:
                                                    mem[0] = stor19[idx]
                                                    mem[32] = 1
                                                    if balanceOf[stor19[idx]] < 10000000000 * 10^18:
                                                        if idx == -1:
                                                            revert with 0, 17
                                                        idx = idx + 1
                                                        t = t
                                                        u = stor19[idx]
                                                        continue 
                                                    mem[0] = stor19[idx]
                                                    mem[32] = 1
                                                    if not balanceOf[stor19[idx]]:
                                                        _30826 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_30826] = 26
                                                        mem[_30826 + 32] = 'SafeMath: division by zero'
                                                        if not s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                            _30922 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _30922 + 68] = mem[idx + _30826 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_30922 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _30922 + -mem[64] + 100
                                                        if 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                            if not 4 * ext_call.return_data[0] / 5:
                                                                _31326 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_31326] = 26
                                                                mem[_31326 + 32] = 'SafeMath: division by zero'
                                                                mem[mem[64] + 4] = stor19[idx]
                                                                mem[mem[64] + 36] = 0
                                                                require ext_code.size(dogeAddress)
                                                                call dogeAddress.0xa9059cbb with:
                                                                     gas gas_remaining wei
                                                                    args stor19[idx], 0
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _31607 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_31607] == bool(mem[_31607])
                                                            else:
                                                                if 4 * ext_call.return_data[0] / 5 and 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length > -1 / 4 * ext_call.return_data[0] / 5:
                                                                    revert with 0, 17
                                                                if not 4 * ext_call.return_data[0] / 5:
                                                                    revert with 0, 18
                                                                if 4 * ext_call.return_data[0] / 5 * 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 4 * ext_call.return_data[0] / 5 != 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                _31482 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_31482] = 26
                                                                mem[_31482 + 32] = 'SafeMath: division by zero'
                                                                mem[mem[64] + 4] = stor19[idx]
                                                                mem[mem[64] + 36] = 4 * ext_call.return_data[0] / 5 * 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 10000
                                                                require ext_code.size(dogeAddress)
                                                                call dogeAddress.0xa9059cbb with:
                                                                     gas gas_remaining wei
                                                                    args stor19[idx], 4 * ext_call.return_data[0] / 5 * 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 10000
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _31750 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_31750] == bool(mem[_31750])
                                                        if idx == -1:
                                                            revert with 0, 17
                                                        idx = idx + 1
                                                        t = 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length
                                                        u = stor19[idx]
                                                        continue 
                                                    if balanceOf[stor19[idx]] and 10000 > -1 / balanceOf[stor19[idx]]:
                                                        revert with 0, 17
                                                    if not balanceOf[stor19[idx]]:
                                                        revert with 0, 18
                                                    if 10000 * balanceOf[stor19[idx]] / balanceOf[stor19[idx]] != 10000:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _31025 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_31025] = 26
                                                    mem[_31025 + 32] = 'SafeMath: division by zero'
                                                    if not s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                        _31129 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _31129 + 68] = mem[idx + _31025 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_31129 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _31129 + -mem[64] + 100
                                                    if 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                        if not 4 * ext_call.return_data[0] / 5:
                                                            _31481 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_31481] = 26
                                                            mem[_31481 + 32] = 'SafeMath: division by zero'
                                                            mem[mem[64] + 4] = stor19[idx]
                                                            mem[mem[64] + 36] = 0
                                                            require ext_code.size(dogeAddress)
                                                            call dogeAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args stor19[idx], 0
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _31749 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_31749] == bool(mem[_31749])
                                                        else:
                                                            if 4 * ext_call.return_data[0] / 5 and 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length > -1 / 4 * ext_call.return_data[0] / 5:
                                                                revert with 0, 17
                                                            if not 4 * ext_call.return_data[0] / 5:
                                                                revert with 0, 18
                                                            if 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 4 * ext_call.return_data[0] / 5 != 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _31723 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_31723] = 26
                                                            mem[_31723 + 32] = 'SafeMath: division by zero'
                                                            mem[mem[64] + 4] = stor19[idx]
                                                            mem[mem[64] + 36] = 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 10000
                                                            require ext_code.size(dogeAddress)
                                                            call dogeAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args stor19[idx], 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 10000
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _31800 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_31800] == bool(mem[_31800])
                                                    if idx == -1:
                                                        revert with 0, 17
                                                    idx = idx + 1
                                                    t = 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length
                                                    u = stor19[idx]
                                                    continue 
                                                mem[0] = msg.sender
                                                mem[32] = 14
                                                if stor14[address(msg.sender)]:
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not arg1:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _30819 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_30819] = 38
                                                    mem[_30819 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if arg2 > balanceOf[address(msg.sender)]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_30819 + 70 len 26]
                                                        var102001 = 64
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(msg.sender)] < arg2:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2
                                                    if balanceOf[arg1] > !arg2:
                                                        revert with 0, 17
                                                    if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                    emit Transfer(arg2, msg.sender, arg1);
                                                else:
                                                    mem[0] = arg1
                                                    mem[32] = 14
                                                    if stor14[address(arg1)]:
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not arg1:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        _30881 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_30881] = 38
                                                        mem[_30881 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if arg2 > balanceOf[address(msg.sender)]:
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 38
                                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_30881 + 70 len 26]
                                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                        if balanceOf[address(msg.sender)] < arg2:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] -= arg2
                                                        if balanceOf[arg1] > !arg2:
                                                            revert with 0, 17
                                                        if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                        emit Transfer(arg2, msg.sender, arg1);
                                                    else:
                                                        if stor10:
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not arg1:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _30822 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_30822] = 38
                                                            mem[_30822 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if arg2 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_30822 + 70 len 26]
                                                                var102001 = 64
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < arg2:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2
                                                            if balanceOf[arg1] > !arg2:
                                                                revert with 0, 17
                                                            if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                            emit Transfer(arg2, msg.sender, arg1);
                                                        else:
                                                            _30767 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_30767] = 26
                                                            mem[_30767 + 32] = 'SafeMath: division by zero'
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not stor13:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _31125 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_31125] = 38
                                                            mem[_31125 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_31125 + 70 len 26]
                                                                var110001 = 64
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                                            if balanceOf[stor13] > !(arg2 / 100):
                                                                revert with 0, 17
                                                            if balanceOf[stor13] + (arg2 / 100) < balanceOf[stor13]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = stor13
                                                            mem[32] = 1
                                                            balanceOf[stor13] += arg2 / 100
                                                            emit Transfer((arg2 / 100), msg.sender, stor13);
                                                            _31701 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_31701] = 26
                                                            mem[_31701 + 32] = 'SafeMath: division by zero'
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not sub_8230af5aAddress:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _31809 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_31809] = 38
                                                            mem[_31809 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_31809 + 70 len 26]
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                                            if balanceOf[stor9] > !(arg2 / 100):
                                                                revert with 0, 17
                                                            if balanceOf[stor9] + (arg2 / 100) < balanceOf[stor9]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = sub_8230af5aAddress
                                                            mem[32] = 1
                                                            balanceOf[stor9] += arg2 / 100
                                                            emit Transfer((arg2 / 100), msg.sender, sub_8230af5aAddress);
                                                            _31947 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_31947] = 26
                                                            mem[_31947 + 32] = 'SafeMath: division by zero'
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not uniswapV2PairAddress:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _31971 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_31971] = 38
                                                            mem[_31971 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_31971 + 70 len 26]
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                                            if balanceOf[stor7] > !(arg2 / 100):
                                                                revert with 0, 17
                                                            if balanceOf[stor7] + (arg2 / 100) < balanceOf[stor7]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = uniswapV2PairAddress
                                                            mem[32] = 1
                                                            balanceOf[stor7] += arg2 / 100
                                                            emit Transfer((arg2 / 100), msg.sender, uniswapV2PairAddress);
                                                            _32099 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_32099] = 26
                                                            mem[_32099 + 32] = 'SafeMath: division by zero'
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not this.address:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _32123 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_32123] = 38
                                                            mem[_32123 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if arg2 / 10 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_32123 + 70 len 26]
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < arg2 / 10:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2 / 10
                                                            if balanceOf[this.address] > !(arg2 / 10):
                                                                revert with 0, 17
                                                            if balanceOf[this.address] + (arg2 / 10) < balanceOf[this.address]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = this.address
                                                            mem[32] = 1
                                                            balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 10)
                                                            emit Transfer((arg2 / 10), msg.sender, this.address);
                                                            _32251 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_32251] = 26
                                                            mem[_32251 + 32] = 'SafeMath: division by zero'
                                                            if not arg2 / 100:
                                                                if not msg.sender:
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not arg1:
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                _32276 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_32276] = 38
                                                                mem[_32276 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                if 0 > balanceOf[address(msg.sender)]:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 38
                                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_32276 + 70 len 26]
                                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                if balanceOf[address(msg.sender)] < 0:
                                                                    revert with 0, 17
                                                                if balanceOf[arg1] > -1:
                                                                    revert with 0, 17
                                                                if balanceOf[arg1] < balanceOf[arg1]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                balanceOf[address(arg1)] = balanceOf[arg1]
                                                                emit Transfer(0, msg.sender, arg1);
                                                            else:
                                                                if arg2 / 100 and 87 > -1 / arg2 / 100:
                                                                    revert with 0, 17
                                                                if not arg2 / 100:
                                                                    revert with 0, 18
                                                                if 87 * arg2 / 100 / arg2 / 100 != 87:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if not msg.sender:
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not arg1:
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                _32363 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_32363] = 38
                                                                mem[_32363 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                if 87 * arg2 / 100 > balanceOf[address(msg.sender)]:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 38
                                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_32363 + 70 len 26]
                                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                if balanceOf[address(msg.sender)] < 87 * arg2 / 100:
                                                                    revert with 0, 17
                                                                balanceOf[address(msg.sender)] += -87 * arg2 / 100
                                                                if balanceOf[arg1] > !(87 * arg2 / 100):
                                                                    revert with 0, 17
                                                                if balanceOf[arg1] + (87 * arg2 / 100) < balanceOf[arg1]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                balanceOf[address(arg1)] = balanceOf[arg1] + (87 * arg2 / 100)
                                                                emit Transfer((87 * arg2 / 100), msg.sender, arg1);
                                            else:
                                                idx = 0
                                                t = 0
                                                u = 160 * stor19.length
                                                while idx < 9:
                                                    if 0 > !idx:
                                                        revert with 0, 17
                                                    if idx >= stor19.length:
                                                        revert with 0, 50
                                                    mem[0] = stor19[idx]
                                                    mem[32] = 1
                                                    if balanceOf[stor19[idx]] < 10000000000 * 10^18:
                                                        if idx == -1:
                                                            revert with 0, 17
                                                        idx = idx + 1
                                                        t = t
                                                        u = stor19[idx]
                                                        continue 
                                                    mem[0] = stor19[idx]
                                                    mem[32] = 1
                                                    if not balanceOf[stor19[idx]]:
                                                        _30954 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_30954] = 26
                                                        mem[_30954 + 32] = 'SafeMath: division by zero'
                                                        if not s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                            _30997 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _30997 + 68] = mem[idx + _30954 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_30997 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _30997 + -mem[64] + 100
                                                        if 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                            if not 4 * ext_call.return_data[0] / 5:
                                                                _31436 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_31436] = 26
                                                                mem[_31436 + 32] = 'SafeMath: division by zero'
                                                                mem[mem[64] + 4] = stor19[idx]
                                                                mem[mem[64] + 36] = 0
                                                                require ext_code.size(dogeAddress)
                                                                call dogeAddress.0xa9059cbb with:
                                                                     gas gas_remaining wei
                                                                    args stor19[idx], 0
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _31724 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_31724] == bool(mem[_31724])
                                                            else:
                                                                if 4 * ext_call.return_data[0] / 5 and 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length > -1 / 4 * ext_call.return_data[0] / 5:
                                                                    revert with 0, 17
                                                                if not 4 * ext_call.return_data[0] / 5:
                                                                    revert with 0, 18
                                                                if 4 * ext_call.return_data[0] / 5 * 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 4 * ext_call.return_data[0] / 5 != 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                _31615 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_31615] = 26
                                                                mem[_31615 + 32] = 'SafeMath: division by zero'
                                                                mem[mem[64] + 4] = stor19[idx]
                                                                mem[mem[64] + 36] = 4 * ext_call.return_data[0] / 5 * 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 10000
                                                                require ext_code.size(dogeAddress)
                                                                call dogeAddress.0xa9059cbb with:
                                                                     gas gas_remaining wei
                                                                    args stor19[idx], 4 * ext_call.return_data[0] / 5 * 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 10000
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _31776 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_31776] == bool(mem[_31776])
                                                        if idx == -1:
                                                            revert with 0, 17
                                                        idx = idx + 1
                                                        t = 0 / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length
                                                        u = stor19[idx]
                                                        continue 
                                                    if balanceOf[stor19[idx]] and 10000 > -1 / balanceOf[stor19[idx]]:
                                                        revert with 0, 17
                                                    if not balanceOf[stor19[idx]]:
                                                        revert with 0, 18
                                                    if 10000 * balanceOf[stor19[idx]] / balanceOf[stor19[idx]] != 10000:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _31192 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_31192] = 26
                                                    mem[_31192 + 32] = 'SafeMath: division by zero'
                                                    if not s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                        _31230 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _31230 + 68] = mem[idx + _31192 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_31230 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _31230 + -mem[64] + 100
                                                    if 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                        if not 4 * ext_call.return_data[0] / 5:
                                                            _31614 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_31614] = 26
                                                            mem[_31614 + 32] = 'SafeMath: division by zero'
                                                            mem[mem[64] + 4] = stor19[idx]
                                                            mem[mem[64] + 36] = 0
                                                            require ext_code.size(dogeAddress)
                                                            call dogeAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args stor19[idx], 0
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _31775 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_31775] == bool(mem[_31775])
                                                        else:
                                                            if 4 * ext_call.return_data[0] / 5 and 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length > -1 / 4 * ext_call.return_data[0] / 5:
                                                                revert with 0, 17
                                                            if not 4 * ext_call.return_data[0] / 5:
                                                                revert with 0, 18
                                                            if 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 4 * ext_call.return_data[0] / 5 != 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _31751 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_31751] = 26
                                                            mem[_31751 + 32] = 'SafeMath: division by zero'
                                                            mem[mem[64] + 4] = stor19[idx]
                                                            mem[mem[64] + 36] = 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 10000
                                                            require ext_code.size(dogeAddress)
                                                            call dogeAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args stor19[idx], 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length / 10000
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _31849 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_31849] == bool(mem[_31849])
                                                    if idx == -1:
                                                        revert with 0, 17
                                                    idx = idx + 1
                                                    t = 10000 * balanceOf[stor19[idx]] / s * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length * stor19.length
                                                    u = stor19[idx]
                                                    continue 
                                                mem[0] = msg.sender
                                                mem[32] = 14
                                                if stor14[address(msg.sender)]:
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not arg1:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _30827 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_30827] = 38
                                                    mem[_30827 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if arg2 > balanceOf[address(msg.sender)]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_30827 + 70 len 26]
                                                        var102001 = 64
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(msg.sender)] < arg2:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2
                                                    if balanceOf[arg1] > !arg2:
                                                        revert with 0, 17
                                                    if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                    emit Transfer(arg2, msg.sender, arg1);
                                                else:
                                                    mem[0] = arg1
                                                    mem[32] = 14
                                                    if stor14[address(arg1)]:
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not arg1:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        _30886 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_30886] = 38
                                                        mem[_30886 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if arg2 > balanceOf[address(msg.sender)]:
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 38
                                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_30886 + 70 len 26]
                                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                        if balanceOf[address(msg.sender)] < arg2:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] -= arg2
                                                        if balanceOf[arg1] > !arg2:
                                                            revert with 0, 17
                                                        if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                        emit Transfer(arg2, msg.sender, arg1);
                                                    else:
                                                        if stor10:
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not arg1:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _30830 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_30830] = 38
                                                            mem[_30830 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if arg2 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_30830 + 70 len 26]
                                                                var102001 = 64
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < arg2:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2
                                                            if balanceOf[arg1] > !arg2:
                                                                revert with 0, 17
                                                            if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                            emit Transfer(arg2, msg.sender, arg1);
                                                        else:
                                                            _30768 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_30768] = 26
                                                            mem[_30768 + 32] = 'SafeMath: division by zero'
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not stor13:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _31133 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_31133] = 38
                                                            mem[_31133 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_31133 + 70 len 26]
                                                                var110001 = 64
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                                            if balanceOf[stor13] > !(arg2 / 100):
                                                                revert with 0, 17
                                                            if balanceOf[stor13] + (arg2 / 100) < balanceOf[stor13]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = stor13
                                                            mem[32] = 1
                                                            balanceOf[stor13] += arg2 / 100
                                                            emit Transfer((arg2 / 100), msg.sender, stor13);
                                                            _31705 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_31705] = 26
                                                            mem[_31705 + 32] = 'SafeMath: division by zero'
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not sub_8230af5aAddress:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _31812 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_31812] = 38
                                                            mem[_31812 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_31812 + 70 len 26]
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                                            if balanceOf[stor9] > !(arg2 / 100):
                                                                revert with 0, 17
                                                            if balanceOf[stor9] + (arg2 / 100) < balanceOf[stor9]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = sub_8230af5aAddress
                                                            mem[32] = 1
                                                            balanceOf[stor9] += arg2 / 100
                                                            emit Transfer((arg2 / 100), msg.sender, sub_8230af5aAddress);
                                                            _31948 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_31948] = 26
                                                            mem[_31948 + 32] = 'SafeMath: division by zero'
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not uniswapV2PairAddress:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _31974 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_31974] = 38
                                                            mem[_31974 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_31974 + 70 len 26]
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                                            if balanceOf[stor7] > !(arg2 / 100):
                                                                revert with 0, 17
                                                            if balanceOf[stor7] + (arg2 / 100) < balanceOf[stor7]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = uniswapV2PairAddress
                                                            mem[32] = 1
                                                            balanceOf[stor7] += arg2 / 100
                                                            emit Transfer((arg2 / 100), msg.sender, uniswapV2PairAddress);
                                                            _32100 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_32100] = 26
                                                            mem[_32100 + 32] = 'SafeMath: division by zero'
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not this.address:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _32126 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_32126] = 38
                                                            mem[_32126 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if arg2 / 10 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_32126 + 70 len 26]
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < arg2 / 10:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2 / 10
                                                            if balanceOf[this.address] > !(arg2 / 10):
                                                                revert with 0, 17
                                                            if balanceOf[this.address] + (arg2 / 10) < balanceOf[this.address]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = this.address
                                                            mem[32] = 1
                                                            balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 10)
                                                            emit Transfer((arg2 / 10), msg.sender, this.address);
                                                            _32252 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_32252] = 26
                                                            mem[_32252 + 32] = 'SafeMath: division by zero'
                                                            if not arg2 / 100:
                                                                if not msg.sender:
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not arg1:
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                _32280 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_32280] = 38
                                                                mem[_32280 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                if 0 > balanceOf[address(msg.sender)]:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 38
                                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_32280 + 70 len 26]
                                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                if balanceOf[address(msg.sender)] < 0:
                                                                    revert with 0, 17
                                                                if balanceOf[arg1] > -1:
                                                                    revert with 0, 17
                                                                if balanceOf[arg1] < balanceOf[arg1]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                balanceOf[address(arg1)] = balanceOf[arg1]
                                                                emit Transfer(0, msg.sender, arg1);
                                                            else:
                                                                if arg2 / 100 and 87 > -1 / arg2 / 100:
                                                                    revert with 0, 17
                                                                if not arg2 / 100:
                                                                    revert with 0, 18
                                                                if 87 * arg2 / 100 / arg2 / 100 != 87:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if not msg.sender:
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not arg1:
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                _32368 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_32368] = 38
                                                                mem[_32368 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                if 87 * arg2 / 100 > balanceOf[address(msg.sender)]:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 38
                                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_32368 + 70 len 26]
                                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                if balanceOf[address(msg.sender)] < 87 * arg2 / 100:
                                                                    revert with 0, 17
                                                                balanceOf[address(msg.sender)] += -87 * arg2 / 100
                                                                if balanceOf[arg1] > !(87 * arg2 / 100):
                                                                    revert with 0, 17
                                                                if balanceOf[arg1] + (87 * arg2 / 100) < balanceOf[arg1]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                balanceOf[address(arg1)] = balanceOf[arg1] + (87 * arg2 / 100)
                                                                emit Transfer((87 * arg2 / 100), msg.sender, arg1);
                                        else:
                                            if stor19.length < 9:
                                                revert with 0, 17
                                            mem[64] = (2 * ceil32(return_data.size)) + 352
                                            mem[(2 * ceil32(return_data.size)) + 288] = 24
                                            mem[(2 * ceil32(return_data.size)) + 320] = 'SafeMath: modulo by zero'
                                            if not stor19.length - 9:
                                                revert with 0, 'SafeMath: modulo by zero', 0
                                            idx = 0
                                            s = 0
                                            t = 0
                                            while idx < 9:
                                                if block.timestamp % stor19.length - 9 > !idx:
                                                    revert with 0, 17
                                                if (block.timestamp % stor19.length - 9) + idx >= stor19.length:
                                                    revert with 0, 50
                                                mem[0] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                                mem[32] = 1
                                                if s > !balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]]:
                                                    revert with 0, 17
                                                if s + balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] < s:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if idx == -1:
                                                    revert with 0, 17
                                                idx = idx + 1
                                                s = s + balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]]
                                                t = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                                continue 
                                            if stor19.length <= 9:
                                                idx = 0
                                                t = 0
                                                u = 1440
                                                while idx < stor19.length:
                                                    mem[0] = stor19[idx]
                                                    mem[32] = 1
                                                    if balanceOf[stor19[idx]] < 10000000000 * 10^18:
                                                        if idx == -1:
                                                            revert with 0, 17
                                                        idx = idx + 1
                                                        t = t
                                                        u = stor19[idx]
                                                        continue 
                                                    mem[0] = stor19[idx]
                                                    mem[32] = 1
                                                    if not balanceOf[stor19[idx]]:
                                                        _30841 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_30841] = 26
                                                        mem[_30841 + 32] = 'SafeMath: division by zero'
                                                        if not 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                            _30929 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _30929 + 68] = mem[idx + _30841 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_30929 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _30929 + -mem[64] + 100
                                                        if 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                            if not 4 * ext_call.return_data[0] / 5:
                                                                _31340 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_31340] = 26
                                                                mem[_31340 + 32] = 'SafeMath: division by zero'
                                                                mem[mem[64] + 4] = stor19[idx]
                                                                mem[mem[64] + 36] = 0
                                                                require ext_code.size(dogeAddress)
                                                                call dogeAddress.0xa9059cbb with:
                                                                     gas gas_remaining wei
                                                                    args stor19[idx], 0
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _31622 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_31622] == bool(mem[_31622])
                                                            else:
                                                                if 4 * ext_call.return_data[0] / 5 and 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s > -1 / 4 * ext_call.return_data[0] / 5:
                                                                    revert with 0, 17
                                                                if not 4 * ext_call.return_data[0] / 5:
                                                                    revert with 0, 18
                                                                if 4 * ext_call.return_data[0] / 5 * 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 4 * ext_call.return_data[0] / 5 != 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                _31488 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_31488] = 26
                                                                mem[_31488 + 32] = 'SafeMath: division by zero'
                                                                mem[mem[64] + 4] = stor19[idx]
                                                                mem[mem[64] + 36] = 4 * ext_call.return_data[0] / 5 * 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 10000
                                                                require ext_code.size(dogeAddress)
                                                                call dogeAddress.0xa9059cbb with:
                                                                     gas gas_remaining wei
                                                                    args stor19[idx], 4 * ext_call.return_data[0] / 5 * 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 10000
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _31753 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_31753] == bool(mem[_31753])
                                                        if idx == -1:
                                                            revert with 0, 17
                                                        idx = idx + 1
                                                        t = 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s
                                                        u = stor19[idx]
                                                        continue 
                                                    if balanceOf[stor19[idx]] and 10000 > -1 / balanceOf[stor19[idx]]:
                                                        revert with 0, 17
                                                    if not balanceOf[stor19[idx]]:
                                                        revert with 0, 18
                                                    if 10000 * balanceOf[stor19[idx]] / balanceOf[stor19[idx]] != 10000:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _31039 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_31039] = 26
                                                    mem[_31039 + 32] = 'SafeMath: division by zero'
                                                    if not 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                        _31145 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _31145 + 68] = mem[idx + _31039 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_31145 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _31145 + -mem[64] + 100
                                                    if 10000 * balanceOf[stor19[idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                        if not 4 * ext_call.return_data[0] / 5:
                                                            _31487 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_31487] = 26
                                                            mem[_31487 + 32] = 'SafeMath: division by zero'
                                                            mem[mem[64] + 4] = stor19[idx]
                                                            mem[mem[64] + 36] = 0
                                                            require ext_code.size(dogeAddress)
                                                            call dogeAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args stor19[idx], 0
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _31752 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_31752] == bool(mem[_31752])
                                                        else:
                                                            if 4 * ext_call.return_data[0] / 5 and 10000 * balanceOf[stor19[idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s > -1 / 4 * ext_call.return_data[0] / 5:
                                                                revert with 0, 17
                                                            if not 4 * ext_call.return_data[0] / 5:
                                                                revert with 0, 18
                                                            if 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor19[idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 4 * ext_call.return_data[0] / 5 != 10000 * balanceOf[stor19[idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _31725 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_31725] = 26
                                                            mem[_31725 + 32] = 'SafeMath: division by zero'
                                                            mem[mem[64] + 4] = stor19[idx]
                                                            mem[mem[64] + 36] = 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor19[idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 10000
                                                            require ext_code.size(dogeAddress)
                                                            call dogeAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args stor19[idx], 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor19[idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 10000
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _31803 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_31803] == bool(mem[_31803])
                                                    if idx == -1:
                                                        revert with 0, 17
                                                    idx = idx + 1
                                                    t = 10000 * balanceOf[stor19[idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s
                                                    u = stor19[idx]
                                                    continue 
                                                mem[0] = msg.sender
                                                mem[32] = 14
                                                if stor14[address(msg.sender)]:
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not arg1:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _30834 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_30834] = 38
                                                    mem[_30834 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if arg2 > balanceOf[address(msg.sender)]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_30834 + 70 len 26]
                                                        var113001 = 64
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(msg.sender)] < arg2:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2
                                                    if balanceOf[arg1] > !arg2:
                                                        revert with 0, 17
                                                    if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                    emit Transfer(arg2, msg.sender, arg1);
                                                else:
                                                    mem[0] = arg1
                                                    mem[32] = 14
                                                    if stor14[address(arg1)]:
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not arg1:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        _30891 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_30891] = 38
                                                        mem[_30891 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if arg2 > balanceOf[address(msg.sender)]:
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 38
                                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_30891 + 70 len 26]
                                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                        if balanceOf[address(msg.sender)] < arg2:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] -= arg2
                                                        if balanceOf[arg1] > !arg2:
                                                            revert with 0, 17
                                                        if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                        emit Transfer(arg2, msg.sender, arg1);
                                                    else:
                                                        if stor10:
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not arg1:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _30837 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_30837] = 38
                                                            mem[_30837 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if arg2 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_30837 + 70 len 26]
                                                                var113001 = 64
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < arg2:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2
                                                            if balanceOf[arg1] > !arg2:
                                                                revert with 0, 17
                                                            if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                            emit Transfer(arg2, msg.sender, arg1);
                                                        else:
                                                            _30770 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_30770] = 26
                                                            mem[_30770 + 32] = 'SafeMath: division by zero'
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not stor13:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _31141 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_31141] = 38
                                                            mem[_31141 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_31141 + 70 len 26]
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                                            if balanceOf[stor13] > !(arg2 / 100):
                                                                revert with 0, 17
                                                            if balanceOf[stor13] + (arg2 / 100) < balanceOf[stor13]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = stor13
                                                            mem[32] = 1
                                                            balanceOf[stor13] += arg2 / 100
                                                            emit Transfer((arg2 / 100), msg.sender, stor13);
                                                            _31707 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_31707] = 26
                                                            mem[_31707 + 32] = 'SafeMath: division by zero'
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not sub_8230af5aAddress:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _31817 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_31817] = 38
                                                            mem[_31817 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_31817 + 70 len 26]
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                                            if balanceOf[stor9] > !(arg2 / 100):
                                                                revert with 0, 17
                                                            if balanceOf[stor9] + (arg2 / 100) < balanceOf[stor9]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = sub_8230af5aAddress
                                                            mem[32] = 1
                                                            balanceOf[stor9] += arg2 / 100
                                                            emit Transfer((arg2 / 100), msg.sender, sub_8230af5aAddress);
                                                            _31949 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_31949] = 26
                                                            mem[_31949 + 32] = 'SafeMath: division by zero'
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not uniswapV2PairAddress:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _31977 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_31977] = 38
                                                            mem[_31977 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_31977 + 70 len 26]
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                                            if balanceOf[stor7] > !(arg2 / 100):
                                                                revert with 0, 17
                                                            if balanceOf[stor7] + (arg2 / 100) < balanceOf[stor7]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = uniswapV2PairAddress
                                                            mem[32] = 1
                                                            balanceOf[stor7] += arg2 / 100
                                                            emit Transfer((arg2 / 100), msg.sender, uniswapV2PairAddress);
                                                            _32101 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_32101] = 26
                                                            mem[_32101 + 32] = 'SafeMath: division by zero'
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not this.address:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _32129 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_32129] = 38
                                                            mem[_32129 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if arg2 / 10 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_32129 + 70 len 26]
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < arg2 / 10:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2 / 10
                                                            if balanceOf[this.address] > !(arg2 / 10):
                                                                revert with 0, 17
                                                            if balanceOf[this.address] + (arg2 / 10) < balanceOf[this.address]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = this.address
                                                            mem[32] = 1
                                                            balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 10)
                                                            emit Transfer((arg2 / 10), msg.sender, this.address);
                                                            _32253 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_32253] = 26
                                                            mem[_32253 + 32] = 'SafeMath: division by zero'
                                                            if not arg2 / 100:
                                                                if not msg.sender:
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not arg1:
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                _32284 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_32284] = 38
                                                                mem[_32284 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                if 0 > balanceOf[address(msg.sender)]:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 38
                                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_32284 + 70 len 26]
                                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                if balanceOf[address(msg.sender)] < 0:
                                                                    revert with 0, 17
                                                                if balanceOf[arg1] > -1:
                                                                    revert with 0, 17
                                                                if balanceOf[arg1] < balanceOf[arg1]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                balanceOf[address(arg1)] = balanceOf[arg1]
                                                                emit Transfer(0, msg.sender, arg1);
                                                            else:
                                                                if arg2 / 100 and 87 > -1 / arg2 / 100:
                                                                    revert with 0, 17
                                                                if not arg2 / 100:
                                                                    revert with 0, 18
                                                                if 87 * arg2 / 100 / arg2 / 100 != 87:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if not msg.sender:
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not arg1:
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                _32373 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_32373] = 38
                                                                mem[_32373 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                if 87 * arg2 / 100 > balanceOf[address(msg.sender)]:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 38
                                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_32373 + 70 len 26]
                                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                if balanceOf[address(msg.sender)] < 87 * arg2 / 100:
                                                                    revert with 0, 17
                                                                balanceOf[address(msg.sender)] += -87 * arg2 / 100
                                                                if balanceOf[arg1] > !(87 * arg2 / 100):
                                                                    revert with 0, 17
                                                                if balanceOf[arg1] + (87 * arg2 / 100) < balanceOf[arg1]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                balanceOf[address(arg1)] = balanceOf[arg1] + (87 * arg2 / 100)
                                                                emit Transfer((87 * arg2 / 100), msg.sender, arg1);
                                            else:
                                                idx = 0
                                                t = 0
                                                u = 1440
                                                while idx < 9:
                                                    if block.timestamp % stor19.length - 9 > !idx:
                                                        revert with 0, 17
                                                    if (block.timestamp % stor19.length - 9) + idx >= stor19.length:
                                                        revert with 0, 50
                                                    mem[0] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                                    mem[32] = 1
                                                    if balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] < 10000000000 * 10^18:
                                                        if idx == -1:
                                                            revert with 0, 17
                                                        idx = idx + 1
                                                        t = t
                                                        u = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                                        continue 
                                                    mem[0] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                                    mem[32] = 1
                                                    if not balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]]:
                                                        _30962 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_30962] = 26
                                                        mem[_30962 + 32] = 'SafeMath: division by zero'
                                                        if not 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                            _31004 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _31004 + 68] = mem[idx + _30962 + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_31004 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _31004 + -mem[64] + 100
                                                        if 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                            if not 4 * ext_call.return_data[0] / 5:
                                                                _31442 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_31442] = 26
                                                                mem[_31442 + 32] = 'SafeMath: division by zero'
                                                                mem[mem[64] + 4] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                                                mem[mem[64] + 36] = 0
                                                                require ext_code.size(dogeAddress)
                                                                call dogeAddress.0xa9059cbb with:
                                                                     gas gas_remaining wei
                                                                    args stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx], 0
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _31726 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_31726] == bool(mem[_31726])
                                                            else:
                                                                if 4 * ext_call.return_data[0] / 5 and 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s > -1 / 4 * ext_call.return_data[0] / 5:
                                                                    revert with 0, 17
                                                                if not 4 * ext_call.return_data[0] / 5:
                                                                    revert with 0, 18
                                                                if 4 * ext_call.return_data[0] / 5 * 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 4 * ext_call.return_data[0] / 5 != 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                _31630 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_31630] = 26
                                                                mem[_31630 + 32] = 'SafeMath: division by zero'
                                                                mem[mem[64] + 4] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                                                mem[mem[64] + 36] = 4 * ext_call.return_data[0] / 5 * 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 10000
                                                                require ext_code.size(dogeAddress)
                                                                call dogeAddress.0xa9059cbb with:
                                                                     gas gas_remaining wei
                                                                    args stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx], 4 * ext_call.return_data[0] / 5 * 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 10000
                                                                mem[mem[64]] = ext_call.return_data[0]
                                                                if not ext_call.success:
                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                _31778 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 32
                                                                require mem[_31778] == bool(mem[_31778])
                                                        if idx == -1:
                                                            revert with 0, 17
                                                        idx = idx + 1
                                                        t = 0 / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s
                                                        u = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                                        continue 
                                                    if balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] and 10000 > -1 / balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]]:
                                                        revert with 0, 17
                                                    if not balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]]:
                                                        revert with 0, 18
                                                    if 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] != 10000:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _31198 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_31198] = 26
                                                    mem[_31198 + 32] = 'SafeMath: division by zero'
                                                    if not 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                        _31239 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _31239 + 68] = mem[idx + _31198 + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_31239 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _31239 + -mem[64] + 100
                                                    if 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                        if not 4 * ext_call.return_data[0] / 5:
                                                            _31629 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_31629] = 26
                                                            mem[_31629 + 32] = 'SafeMath: division by zero'
                                                            mem[mem[64] + 4] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                                            mem[mem[64] + 36] = 0
                                                            require ext_code.size(dogeAddress)
                                                            call dogeAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx], 0
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _31777 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_31777] == bool(mem[_31777])
                                                        else:
                                                            if 4 * ext_call.return_data[0] / 5 and 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s > -1 / 4 * ext_call.return_data[0] / 5:
                                                                revert with 0, 17
                                                            if not 4 * ext_call.return_data[0] / 5:
                                                                revert with 0, 18
                                                            if 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 4 * ext_call.return_data[0] / 5 != 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _31754 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_31754] = 26
                                                            mem[_31754 + 32] = 'SafeMath: division by zero'
                                                            mem[mem[64] + 4] = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                                            mem[mem[64] + 36] = 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 10000
                                                            require ext_code.size(dogeAddress)
                                                            call dogeAddress.0xa9059cbb with:
                                                                 gas gas_remaining wei
                                                                args stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx], 4 * ext_call.return_data[0] / 5 * 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s / 10000
                                                            mem[mem[64]] = ext_call.return_data[0]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _31852 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 32
                                                            require mem[_31852] == bool(mem[_31852])
                                                    if idx == -1:
                                                        revert with 0, 17
                                                    idx = idx + 1
                                                    t = 10000 * balanceOf[stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]] / 0x304d37f120d696c834550e63d9bb9c14b4f9165c9ede434e4644e3998d6db881 * s
                                                    u = stor[('name', 'stor19', 19) + (block.timestamp % stor19.length - 9) + idx]
                                                    continue 
                                                mem[0] = msg.sender
                                                mem[32] = 14
                                                if stor14[address(msg.sender)]:
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not arg1:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _30842 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_30842] = 38
                                                    mem[_30842 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if arg2 > balanceOf[address(msg.sender)]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_30842 + 70 len 26]
                                                        var113001 = 64
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(msg.sender)] < arg2:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2
                                                    if balanceOf[arg1] > !arg2:
                                                        revert with 0, 17
                                                    if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                    emit Transfer(arg2, msg.sender, arg1);
                                                else:
                                                    mem[0] = arg1
                                                    mem[32] = 14
                                                    if stor14[address(arg1)]:
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not arg1:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        _30896 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_30896] = 38
                                                        mem[_30896 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if arg2 > balanceOf[address(msg.sender)]:
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 38
                                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_30896 + 70 len 26]
                                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                        if balanceOf[address(msg.sender)] < arg2:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] -= arg2
                                                        if balanceOf[arg1] > !arg2:
                                                            revert with 0, 17
                                                        if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                        emit Transfer(arg2, msg.sender, arg1);
                                                    else:
                                                        if stor10:
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not arg1:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _30845 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_30845] = 38
                                                            mem[_30845 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if arg2 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_30845 + 70 len 26]
                                                                var113001 = 64
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < arg2:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2
                                                            if balanceOf[arg1] > !arg2:
                                                                revert with 0, 17
                                                            if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                            emit Transfer(arg2, msg.sender, arg1);
                                                        else:
                                                            _30771 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_30771] = 26
                                                            mem[_30771 + 32] = 'SafeMath: division by zero'
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not stor13:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _31149 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_31149] = 38
                                                            mem[_31149 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_31149 + 70 len 26]
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                                            if balanceOf[stor13] > !(arg2 / 100):
                                                                revert with 0, 17
                                                            if balanceOf[stor13] + (arg2 / 100) < balanceOf[stor13]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = stor13
                                                            mem[32] = 1
                                                            balanceOf[stor13] += arg2 / 100
                                                            emit Transfer((arg2 / 100), msg.sender, stor13);
                                                            _31711 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_31711] = 26
                                                            mem[_31711 + 32] = 'SafeMath: division by zero'
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not sub_8230af5aAddress:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _31820 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_31820] = 38
                                                            mem[_31820 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_31820 + 70 len 26]
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                                            if balanceOf[stor9] > !(arg2 / 100):
                                                                revert with 0, 17
                                                            if balanceOf[stor9] + (arg2 / 100) < balanceOf[stor9]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = sub_8230af5aAddress
                                                            mem[32] = 1
                                                            balanceOf[stor9] += arg2 / 100
                                                            emit Transfer((arg2 / 100), msg.sender, sub_8230af5aAddress);
                                                            _31950 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_31950] = 26
                                                            mem[_31950 + 32] = 'SafeMath: division by zero'
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not uniswapV2PairAddress:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _31980 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_31980] = 38
                                                            mem[_31980 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_31980 + 70 len 26]
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                                            if balanceOf[stor7] > !(arg2 / 100):
                                                                revert with 0, 17
                                                            if balanceOf[stor7] + (arg2 / 100) < balanceOf[stor7]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = uniswapV2PairAddress
                                                            mem[32] = 1
                                                            balanceOf[stor7] += arg2 / 100
                                                            emit Transfer((arg2 / 100), msg.sender, uniswapV2PairAddress);
                                                            _32102 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_32102] = 26
                                                            mem[_32102 + 32] = 'SafeMath: division by zero'
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not this.address:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            _32132 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_32132] = 38
                                                            mem[_32132 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                            if arg2 / 10 > balanceOf[address(msg.sender)]:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 38
                                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_32132 + 70 len 26]
                                                                revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                            if balanceOf[address(msg.sender)] < arg2 / 10:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2 / 10
                                                            if balanceOf[this.address] > !(arg2 / 10):
                                                                revert with 0, 17
                                                            if balanceOf[this.address] + (arg2 / 10) < balanceOf[this.address]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            mem[0] = this.address
                                                            mem[32] = 1
                                                            balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 10)
                                                            emit Transfer((arg2 / 10), msg.sender, this.address);
                                                            _32254 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_32254] = 26
                                                            mem[_32254 + 32] = 'SafeMath: division by zero'
                                                            if not arg2 / 100:
                                                                if not msg.sender:
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not arg1:
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                _32288 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_32288] = 38
                                                                mem[_32288 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                if 0 > balanceOf[address(msg.sender)]:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 38
                                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_32288 + 70 len 26]
                                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                if balanceOf[address(msg.sender)] < 0:
                                                                    revert with 0, 17
                                                                if balanceOf[arg1] > -1:
                                                                    revert with 0, 17
                                                                if balanceOf[arg1] < balanceOf[arg1]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                balanceOf[address(arg1)] = balanceOf[arg1]
                                                                emit Transfer(0, msg.sender, arg1);
                                                            else:
                                                                if arg2 / 100 and 87 > -1 / arg2 / 100:
                                                                    revert with 0, 17
                                                                if not arg2 / 100:
                                                                    revert with 0, 18
                                                                if 87 * arg2 / 100 / arg2 / 100 != 87:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if not msg.sender:
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not arg1:
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                _32378 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_32378] = 38
                                                                mem[_32378 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                if 87 * arg2 / 100 > balanceOf[address(msg.sender)]:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 38
                                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_32378 + 70 len 26]
                                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                if balanceOf[address(msg.sender)] < 87 * arg2 / 100:
                                                                    revert with 0, 17
                                                                balanceOf[address(msg.sender)] += -87 * arg2 / 100
                                                                if balanceOf[arg1] > !(87 * arg2 / 100):
                                                                    revert with 0, 17
                                                                if balanceOf[arg1] + (87 * arg2 / 100) < balanceOf[arg1]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                balanceOf[address(arg1)] = balanceOf[arg1] + (87 * arg2 / 100)
                                                                emit Transfer((87 * arg2 / 100), msg.sender, arg1);
    if not stor20[address(arg1)]:
        if uniswapV2PairAddress == msg.sender:
            stor20[address(arg1)] = 1
            stor19.length++
            stor19[stor19.length] = arg1
    return 1
}



}

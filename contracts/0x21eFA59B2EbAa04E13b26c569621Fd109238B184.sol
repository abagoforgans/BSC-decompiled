contract main {




// =====================  Runtime code  =====================


#
#  - transferFrom(address arg1, address arg2, uint256 arg3)
#
const totalSupply = 1000 * 10^18


address owner;
mapping of uint256 stor1;
mapping of uint256 stor2;
mapping of uint256 allowance;
mapping of uint8 stor4;
array of address stor5;
uint256 stor6;
uint256 totalFees;
array of struct stor8;
array of struct stor9;
uint8 decimals;
array of address stor1546678032441257452667456735582814959992782782816731922691272282333561699760;

function totalFees() payable {
    return totalFees
}

function decimals() payable {
    return decimals
}

function owner() payable {
    return owner
}

function isExcluded(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return bool(stor4[address(arg1)])
}

function allowance(address arg1, address arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    return allowance[address(arg1)][address(arg2)]
}

function _fallback() payable {
    revert
}

function renounceOwnership() payable {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    emit OwnershipTransferred(owner, 0);
    owner = 0
}

function transferOwnership(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Ownable: new owner is the zero address'
    emit OwnershipTransferred(owner, arg1);
    owner = arg1
}

function approve(address arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if not msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve from the zero address'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve to the zero address'
    allowance[address(msg.sender)][address(arg1)] = arg2
    emit Approval(arg2, msg.sender, arg1);
    return 1
}

function decreaseAllowance(address arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if arg2 > allowance[msg.sender][address(arg1)]:
        revert with 0, 32, 37, 0x6545524332303a2064656372656173656420616c6c6f77616e63652062656c6f77207a6572, mem[165 len 27] >> 40, 0
    if allowance[msg.sender][address(arg1)] < arg2:
        revert with 0, 17
    if not msg.sender:
        revert with 0, 'ERC20: approve from the zero address'
    if not arg1:
        revert with 0, 'ERC20: approve to the zero address'
    allowance[address(msg.sender)][address(arg1)] = allowance[msg.sender][address(arg1)] - arg2
    emit Approval((allowance[msg.sender][address(arg1)] - arg2), msg.sender, arg1);
    return 1
}

function increaseAllowance(address arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if allowance[msg.sender][address(arg1)] > !arg2:
        revert with 0, 17
    if allowance[msg.sender][address(arg1)] + arg2 < allowance[msg.sender][address(arg1)]:
        revert with 0, 'SafeMath: addition overflow'
    if not msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve from the zero address'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve to the zero address'
    allowance[address(msg.sender)][address(arg1)] = allowance[msg.sender][address(arg1)] + arg2
    emit Approval((allowance[msg.sender][address(arg1)] + arg2), msg.sender, arg1);
    return 1
}

function includeAccount(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not stor4[address(arg1)]:
        revert with 0, 'Account is not excluded'
    idx = 0
    while idx < stor5.length:
        mem[0] = 5
        if stor5[idx] != arg1:
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        if stor5.length < 1:
            revert with 0, 17
        if stor5.length - 1 >= stor5.length:
            revert with 0, 50
        if idx >= stor5.length:
            revert with 0, 50
        stor5[idx] = stor5[stor5.length]
        stor2[address(arg1)] = 0
        stor4[address(arg1)] = 0
        if not stor5.length:
            revert with 0, 49
        stor5[stor5.length] = 0
        stor5.length--
}

function name() payable {
    if bool(stor8.length):
        if bool(stor8.length) == uint255(stor8.length) * 0.5 < 32:
            revert with 0, 34
        if bool(stor8.length):
            if bool(stor8.length) == uint255(stor8.length) * 0.5 < 32:
                revert with 0, 34
            if Mask(256, -1, stor8.length):
                if 31 < uint255(stor8.length) * 0.5:
                    mem[128] = uint256(stor8.field_0)
                    idx = 128
                    s = 0
                    while (uint255(stor8.length) * 0.5) + 96 > idx:
                        mem[idx + 32] = stor8[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor8.length), data=mem[128 len ceil32(uint255(stor8.length) * 0.5)])
                mem[128] = 256 * stor8.length.field_8
        else:
            if bool(stor8.length) == stor8.length.field_1 < 32:
                revert with 0, 34
            if stor8.length.field_1:
                if 31 < stor8.length.field_1:
                    mem[128] = uint256(stor8.field_0)
                    idx = 128
                    s = 0
                    while stor8.length.field_1 + 96 > idx:
                        mem[idx + 32] = stor8[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor8.length), data=mem[128 len ceil32(uint255(stor8.length) * 0.5)])
                mem[128] = 256 * stor8.length.field_8
        mem[ceil32(uint255(stor8.length) * 0.5) + 192 len ceil32(uint255(stor8.length) * 0.5)] = mem[128 len ceil32(uint255(stor8.length) * 0.5)]
        if ceil32(uint255(stor8.length) * 0.5) > uint255(stor8.length) * 0.5:
            mem[ceil32(uint255(stor8.length) * 0.5) + (uint255(stor8.length) * 0.5) + 192] = 0
        return Array(len=2 * Mask(256, -1, stor8.length), data=mem[128 len ceil32(uint255(stor8.length) * 0.5)], mem[(2 * ceil32(uint255(stor8.length) * 0.5)) + 192 len 2 * ceil32(uint255(stor8.length) * 0.5)]), 
    if bool(stor8.length) == stor8.length.field_1 < 32:
        revert with 0, 34
    if bool(stor8.length):
        if bool(stor8.length) == uint255(stor8.length) * 0.5 < 32:
            revert with 0, 34
        if Mask(256, -1, stor8.length):
            if 31 < uint255(stor8.length) * 0.5:
                mem[128] = uint256(stor8.field_0)
                idx = 128
                s = 0
                while (uint255(stor8.length) * 0.5) + 96 > idx:
                    mem[idx + 32] = stor8[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor8.length % 128, data=mem[128 len ceil32(stor8.length.field_1)])
            mem[128] = 256 * stor8.length.field_8
    else:
        if bool(stor8.length) == stor8.length.field_1 < 32:
            revert with 0, 34
        if stor8.length.field_1:
            if 31 < stor8.length.field_1:
                mem[128] = uint256(stor8.field_0)
                idx = 128
                s = 0
                while stor8.length.field_1 + 96 > idx:
                    mem[idx + 32] = stor8[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor8.length % 128, data=mem[128 len ceil32(stor8.length.field_1)])
            mem[128] = 256 * stor8.length.field_8
    mem[ceil32(stor8.length.field_1) + 192 len ceil32(stor8.length.field_1)] = mem[128 len ceil32(stor8.length.field_1)]
    if ceil32(stor8.length.field_1) > stor8.length.field_1:
        mem[ceil32(stor8.length.field_1) + stor8.length.field_1 + 192] = 0
    return Array(len=stor8.length % 128, data=mem[128 len ceil32(stor8.length.field_1)], mem[(2 * ceil32(stor8.length.field_1)) + 192 len 2 * ceil32(stor8.length.field_1)]), 
}

function symbol() payable {
    if bool(stor9.length):
        if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
            revert with 0, 34
        if bool(stor9.length):
            if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                revert with 0, 34
            if Mask(256, -1, stor9.length):
                if 31 < uint255(stor9.length) * 0.5:
                    mem[128] = uint256(stor9.field_0)
                    idx = 128
                    s = 0
                    while (uint255(stor9.length) * 0.5) + 96 > idx:
                        mem[idx + 32] = stor9[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor9.length), data=mem[128 len ceil32(uint255(stor9.length) * 0.5)])
                mem[128] = 256 * stor9.length.field_8
        else:
            if bool(stor9.length) == stor9.length.field_1 < 32:
                revert with 0, 34
            if stor9.length.field_1:
                if 31 < stor9.length.field_1:
                    mem[128] = uint256(stor9.field_0)
                    idx = 128
                    s = 0
                    while stor9.length.field_1 + 96 > idx:
                        mem[idx + 32] = stor9[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor9.length), data=mem[128 len ceil32(uint255(stor9.length) * 0.5)])
                mem[128] = 256 * stor9.length.field_8
        mem[ceil32(uint255(stor9.length) * 0.5) + 192 len ceil32(uint255(stor9.length) * 0.5)] = mem[128 len ceil32(uint255(stor9.length) * 0.5)]
        if ceil32(uint255(stor9.length) * 0.5) > uint255(stor9.length) * 0.5:
            mem[ceil32(uint255(stor9.length) * 0.5) + (uint255(stor9.length) * 0.5) + 192] = 0
        return Array(len=2 * Mask(256, -1, stor9.length), data=mem[128 len ceil32(uint255(stor9.length) * 0.5)], mem[(2 * ceil32(uint255(stor9.length) * 0.5)) + 192 len 2 * ceil32(uint255(stor9.length) * 0.5)]), 
    if bool(stor9.length) == stor9.length.field_1 < 32:
        revert with 0, 34
    if bool(stor9.length):
        if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
            revert with 0, 34
        if Mask(256, -1, stor9.length):
            if 31 < uint255(stor9.length) * 0.5:
                mem[128] = uint256(stor9.field_0)
                idx = 128
                s = 0
                while (uint255(stor9.length) * 0.5) + 96 > idx:
                    mem[idx + 32] = stor9[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor9.length % 128, data=mem[128 len ceil32(stor9.length.field_1)])
            mem[128] = 256 * stor9.length.field_8
    else:
        if bool(stor9.length) == stor9.length.field_1 < 32:
            revert with 0, 34
        if stor9.length.field_1:
            if 31 < stor9.length.field_1:
                mem[128] = uint256(stor9.field_0)
                idx = 128
                s = 0
                while stor9.length.field_1 + 96 > idx:
                    mem[idx + 32] = stor9[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor9.length % 128, data=mem[128 len ceil32(stor9.length.field_1)])
            mem[128] = 256 * stor9.length.field_8
    mem[ceil32(stor9.length.field_1) + 192 len ceil32(stor9.length.field_1)] = mem[128 len ceil32(stor9.length.field_1)]
    if ceil32(stor9.length.field_1) > stor9.length.field_1:
        mem[ceil32(stor9.length.field_1) + stor9.length.field_1 + 192] = 0
    return Array(len=stor9.length % 128, data=mem[128 len ceil32(stor9.length.field_1)], mem[(2 * ceil32(stor9.length.field_1)) + 192 len 2 * ceil32(stor9.length.field_1)]), 
}

function tokenFromReflection(uint256 arg1) payable {
    mem[64] = 96
    require calldata.size - 4 >= 32
    if arg1 > stor6:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Amount must be less than total reflections'
    idx = 0
    s = 1000 * 10^18
    t = stor6
    while idx < stor5.length:
        mem[0] = stor5[idx]
        mem[32] = 1
        if stor1[stor5[idx]] > t:
            _65 = mem[64]
            mem[64] = mem[64] + 64
            mem[_65] = 26
            mem[_65 + 32] = 'SafeMath: division by zero'
            _77 = mem[64]
            mem[64] = mem[64] + 64
            mem[_77] = 26
            mem[_77 + 32] = 'SafeMath: division by zero'
            if stor6 / 1000 * 10^18:
                return (arg1 / stor6 / 1000 * 10^18)
            _83 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _83 + 68] = mem[idx + _77 + 32]
                idx = idx + 32
                continue 
            mem[_83 + 94] = 0
            revert with memory
              from mem[64]
               len _83 + -mem[64] + 100
        if idx >= stor5.length:
            revert with 0, 50
        mem[0] = stor5[idx]
        mem[32] = 2
        if stor2[stor5[idx]] > s:
            _69 = mem[64]
            mem[64] = mem[64] + 64
            mem[_69] = 26
            mem[_69 + 32] = 'SafeMath: division by zero'
            _85 = mem[64]
            mem[64] = mem[64] + 64
            mem[_85] = 26
            mem[_85 + 32] = 'SafeMath: division by zero'
            if stor6 / 1000 * 10^18:
                return (arg1 / stor6 / 1000 * 10^18)
            _89 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _89 + 68] = mem[idx + _85 + 32]
                idx = idx + 32
                continue 
            mem[_89 + 94] = 0
            revert with memory
              from mem[64]
               len _89 + -mem[64] + 100
        if idx >= stor5.length:
            revert with 0, 50
        mem[0] = stor5[idx]
        mem[32] = 1
        _68 = mem[64]
        mem[64] = mem[64] + 64
        mem[_68] = 30
        mem[_68 + 32] = 'SafeMath: subtraction overflow'
        if stor1[stor5[idx]] > t:
            _70 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _70 + 68] = mem[idx + _68 + 32]
                idx = idx + 32
                continue 
            mem[_70 + 98] = 0
            revert with memory
              from mem[64]
               len _70 + -mem[64] + 100
        if t < stor1[stor5[idx]]:
            revert with 0, 17
        if idx >= stor5.length:
            revert with 0, 50
        mem[0] = stor5[idx]
        mem[32] = 2
        _84 = mem[64]
        mem[64] = mem[64] + 64
        mem[_84] = 30
        mem[_84 + 32] = 'SafeMath: subtraction overflow'
        if stor2[stor5[idx]] <= s:
            if s < stor2[stor5[idx]]:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s - stor2[stor5[idx]]
            t = t - stor1[stor5[idx]]
            continue 
        _88 = mem[64]
        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 32
        mem[mem[64] + 36] = 30
        idx = 0
        while idx < 30:
            mem[idx + _88 + 68] = mem[idx + _84 + 32]
            idx = idx + 32
            continue 
        mem[_88 + 98] = 0
        revert with memory
          from mem[64]
           len _88 + -mem[64] + 100
    if t < stor6 / 1000 * 10^18:
        if not stor6 / 1000 * 10^18:
            revert with 0, 'SafeMath: division by zero', 0
        return (arg1 / stor6 / 1000 * 10^18)
    if not s:
        revert with 0, 'SafeMath: division by zero', 0
    if not t / s:
        revert with 0, 'SafeMath: division by zero', 0
    return (arg1 / t / s)
}

function balanceOf(address arg1) payable {
    mem[64] = 96
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if stor4[address(arg1)]:
        return stor2[address(arg1)]
    mem[0] = arg1
    mem[32] = 1
    if stor1[address(arg1)] > stor6:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Amount must be less than total reflections'
    idx = 0
    s = 1000 * 10^18
    t = stor6
    while idx < stor5.length:
        mem[0] = stor5[idx]
        mem[32] = 1
        if stor1[stor5[idx]] > t:
            _70 = mem[64]
            mem[64] = mem[64] + 64
            mem[_70] = 26
            mem[_70 + 32] = 'SafeMath: division by zero'
            _82 = mem[64]
            mem[64] = mem[64] + 64
            mem[_82] = 26
            mem[_82 + 32] = 'SafeMath: division by zero'
            if stor6 / 1000 * 10^18:
                return (stor1[address(arg1)] / stor6 / 1000 * 10^18)
            _88 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _88 + 68] = mem[idx + _82 + 32]
                idx = idx + 32
                continue 
            mem[_88 + 94] = 0
            revert with memory
              from mem[64]
               len _88 + -mem[64] + 100
        if idx >= stor5.length:
            revert with 0, 50
        mem[0] = stor5[idx]
        mem[32] = 2
        if stor2[stor5[idx]] > s:
            _74 = mem[64]
            mem[64] = mem[64] + 64
            mem[_74] = 26
            mem[_74 + 32] = 'SafeMath: division by zero'
            _90 = mem[64]
            mem[64] = mem[64] + 64
            mem[_90] = 26
            mem[_90 + 32] = 'SafeMath: division by zero'
            if stor6 / 1000 * 10^18:
                return (stor1[address(arg1)] / stor6 / 1000 * 10^18)
            _94 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _94 + 68] = mem[idx + _90 + 32]
                idx = idx + 32
                continue 
            mem[_94 + 94] = 0
            revert with memory
              from mem[64]
               len _94 + -mem[64] + 100
        if idx >= stor5.length:
            revert with 0, 50
        mem[0] = stor5[idx]
        mem[32] = 1
        _73 = mem[64]
        mem[64] = mem[64] + 64
        mem[_73] = 30
        mem[_73 + 32] = 'SafeMath: subtraction overflow'
        if stor1[stor5[idx]] > t:
            _75 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _75 + 68] = mem[idx + _73 + 32]
                idx = idx + 32
                continue 
            mem[_75 + 98] = 0
            revert with memory
              from mem[64]
               len _75 + -mem[64] + 100
        if t < stor1[stor5[idx]]:
            revert with 0, 17
        if idx >= stor5.length:
            revert with 0, 50
        mem[0] = stor5[idx]
        mem[32] = 2
        _89 = mem[64]
        mem[64] = mem[64] + 64
        mem[_89] = 30
        mem[_89 + 32] = 'SafeMath: subtraction overflow'
        if stor2[stor5[idx]] <= s:
            if s < stor2[stor5[idx]]:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s - stor2[stor5[idx]]
            t = t - stor1[stor5[idx]]
            continue 
        _93 = mem[64]
        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 32
        mem[mem[64] + 36] = 30
        idx = 0
        while idx < 30:
            mem[idx + _93 + 68] = mem[idx + _89 + 32]
            idx = idx + 32
            continue 
        mem[_93 + 98] = 0
        revert with memory
          from mem[64]
           len _93 + -mem[64] + 100
    if t < stor6 / 1000 * 10^18:
        if not stor6 / 1000 * 10^18:
            revert with 0, 'SafeMath: division by zero', 0
        return (stor1[address(arg1)] / stor6 / 1000 * 10^18)
    if not s:
        revert with 0, 'SafeMath: division by zero', 0
    if not t / s:
        revert with 0, 'SafeMath: division by zero', 0
    return (stor1[address(arg1)] / t / s)
}

function excludeAccount(address arg1) payable {
    mem[64] = 96
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if stor4[address(arg1)]:
        revert with 0, 'Account is not excluded'
    if stor1[address(arg1)]:
        mem[0] = arg1
        mem[32] = 1
        if stor1[address(arg1)] > stor6:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Amount must be less than total reflections'
        idx = 0
        s = 1000 * 10^18
        t = stor6
        while idx < stor5.length:
            mem[0] = stor5[idx]
            mem[32] = 1
            if stor1[stor5[idx]] > t:
                _73 = mem[64]
                mem[64] = mem[64] + 64
                mem[_73] = 26
                mem[_73 + 32] = 'SafeMath: division by zero'
                _85 = mem[64]
                mem[64] = mem[64] + 64
                mem[_85] = 26
                mem[_85 + 32] = 'SafeMath: division by zero'
                if stor6 / 1000 * 10^18:
                    stor2[address(arg1)] = stor1[address(arg1)] / stor6 / 1000 * 10^18
                    stor4[address(arg1)] = 1
                    stor5.length++
                    stor36B6[stor5.length] = arg1
                _91 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _91 + 68] = mem[idx + _85 + 32]
                    idx = idx + 32
                    continue 
                mem[_91 + 94] = 0
                revert with memory
                  from mem[64]
                   len _91 + -mem[64] + 100
            if idx >= stor5.length:
                revert with 0, 50
            mem[0] = stor5[idx]
            mem[32] = 2
            if stor2[stor5[idx]] > s:
                _77 = mem[64]
                mem[64] = mem[64] + 64
                mem[_77] = 26
                mem[_77 + 32] = 'SafeMath: division by zero'
                _93 = mem[64]
                mem[64] = mem[64] + 64
                mem[_93] = 26
                mem[_93 + 32] = 'SafeMath: division by zero'
                if stor6 / 1000 * 10^18:
                    stor2[address(arg1)] = stor1[address(arg1)] / stor6 / 1000 * 10^18
                    stor4[address(arg1)] = 1
                    stor5.length++
                    stor36B6[stor5.length] = arg1
                _97 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _97 + 68] = mem[idx + _93 + 32]
                    idx = idx + 32
                    continue 
                mem[_97 + 94] = 0
                revert with memory
                  from mem[64]
                   len _97 + -mem[64] + 100
            if idx >= stor5.length:
                revert with 0, 50
            mem[0] = stor5[idx]
            mem[32] = 1
            _76 = mem[64]
            mem[64] = mem[64] + 64
            mem[_76] = 30
            mem[_76 + 32] = 'SafeMath: subtraction overflow'
            if stor1[stor5[idx]] > t:
                _78 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _78 + 68] = mem[idx + _76 + 32]
                    idx = idx + 32
                    continue 
                mem[_78 + 98] = 0
                revert with memory
                  from mem[64]
                   len _78 + -mem[64] + 100
            if t < stor1[stor5[idx]]:
                revert with 0, 17
            if idx >= stor5.length:
                revert with 0, 50
            mem[0] = stor5[idx]
            mem[32] = 2
            _92 = mem[64]
            mem[64] = mem[64] + 64
            mem[_92] = 30
            mem[_92 + 32] = 'SafeMath: subtraction overflow'
            if stor2[stor5[idx]] <= s:
                if s < stor2[stor5[idx]]:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s - stor2[stor5[idx]]
                t = t - stor1[stor5[idx]]
                continue 
            _96 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _96 + 68] = mem[idx + _92 + 32]
                idx = idx + 32
                continue 
            mem[_96 + 98] = 0
            revert with memory
              from mem[64]
               len _96 + -mem[64] + 100
        if t < stor6 / 1000 * 10^18:
            if not stor6 / 1000 * 10^18:
                revert with 0, 'SafeMath: division by zero', 0
            stor2[address(arg1)] = stor1[address(arg1)] / stor6 / 1000 * 10^18
        else:
            if not s:
                revert with 0, 'SafeMath: division by zero', 0
            if not t / s:
                revert with 0, 'SafeMath: division by zero', 0
            stor2[address(arg1)] = stor1[address(arg1)] / t / s
    stor4[address(arg1)] = 1
    stor5.length++
    stor36B6[stor5.length] = arg1
}

function reflectionFromToken(uint256 arg1, bool arg2) payable {
    require calldata.size - 4 >= 64
    require arg2 == arg2
    if arg1 > 1000 * 10^18:
        revert with 0, 'Amount must be less than supply'
    mem[96] = 26
    mem[128] = 'SafeMath: division by zero'
    if arg2:
        if not arg1 / 100:
            mem[64] = 224
            mem[160] = 30
            mem[192] = 'SafeMath: subtraction overflow'
            if 0 > arg1:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 < 0:
                revert with 0, 17
            idx = 0
            s = 1000 * 10^18
            t = stor6
            while idx < stor5.length:
                mem[0] = stor5[idx]
                mem[32] = 1
                if stor1[stor5[idx]] > t:
                    _534 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_534] = 26
                    mem[_534 + 32] = 'SafeMath: division by zero'
                    if not arg1:
                        return 0
                    if arg1 and stor6 / 1000 * 10^18 > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor6 / 1000 * 10^18 / arg1 != stor6 / 1000 * 10^18:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _672 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_672] = 30
                    mem[_672 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= arg1 * stor6 / 1000 * 10^18:
                        if arg1 * stor6 / 1000 * 10^18 < 0:
                            revert with 0, 17
                        return (arg1 * stor6 / 1000 * 10^18)
                    _699 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _699 + 68] = mem[idx + _672 + 32]
                        idx = idx + 32
                        continue 
                    mem[_699 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _699 + -mem[64] + 100
                if idx >= stor5.length:
                    revert with 0, 50
                mem[0] = stor5[idx]
                mem[32] = 2
                if stor2[stor5[idx]] > s:
                    _548 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_548] = 26
                    mem[_548 + 32] = 'SafeMath: division by zero'
                    if not arg1:
                        return 0
                    if arg1 and stor6 / 1000 * 10^18 > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor6 / 1000 * 10^18 / arg1 != stor6 / 1000 * 10^18:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _700 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_700] = 30
                    mem[_700 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= arg1 * stor6 / 1000 * 10^18:
                        if arg1 * stor6 / 1000 * 10^18 < 0:
                            revert with 0, 17
                        return (arg1 * stor6 / 1000 * 10^18)
                    _718 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _718 + 68] = mem[idx + _700 + 32]
                        idx = idx + 32
                        continue 
                    mem[_718 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _718 + -mem[64] + 100
                if idx >= stor5.length:
                    revert with 0, 50
                mem[0] = stor5[idx]
                mem[32] = 1
                _547 = mem[64]
                mem[64] = mem[64] + 64
                mem[_547] = 30
                mem[_547 + 32] = 'SafeMath: subtraction overflow'
                if stor1[stor5[idx]] > t:
                    _554 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _554 + 68] = mem[idx + _547 + 32]
                        idx = idx + 32
                        continue 
                    mem[_554 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _554 + -mem[64] + 100
                if t < stor1[stor5[idx]]:
                    revert with 0, 17
                if idx >= stor5.length:
                    revert with 0, 50
                mem[0] = stor5[idx]
                mem[32] = 2
                _600 = mem[64]
                mem[64] = mem[64] + 64
                mem[_600] = 30
                mem[_600 + 32] = 'SafeMath: subtraction overflow'
                if stor2[stor5[idx]] <= s:
                    if s < stor2[stor5[idx]]:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s - stor2[stor5[idx]]
                    t = t - stor1[stor5[idx]]
                    continue 
                _608 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _608 + 68] = mem[idx + _600 + 32]
                    idx = idx + 32
                    continue 
                mem[_608 + 98] = 0
                revert with memory
                  from mem[64]
                   len _608 + -mem[64] + 100
            if t < stor6 / 1000 * 10^18:
                if not arg1:
                    return 0
                if arg1 and stor6 / 1000 * 10^18 > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor6 / 1000 * 10^18 / arg1 != stor6 / 1000 * 10^18:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * stor6 / 1000 * 10^18:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor6 / 1000 * 10^18 < 0:
                    revert with 0, 17
                return (arg1 * stor6 / 1000 * 10^18)
            if not s:
                revert with 0, 'SafeMath: division by zero', 0
            if not arg1:
                return 0
            if arg1 and t / s > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * t / s / arg1 != t / s:
                revert with 0, 'SafeMath: multiplication overflow'
            if 0 > arg1 * t / s:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * t / s < 0:
                revert with 0, 17
            return (arg1 * t / s)
        if arg1 / 100 and 5 > -1 / arg1 / 100:
            revert with 0, 17
        if not arg1 / 100:
            revert with 0, 18
        if 5 * arg1 / 100 / arg1 / 100 != 5:
            revert with 0, 'SafeMath: multiplication overflow'
        mem[64] = 224
        mem[160] = 30
        mem[192] = 'SafeMath: subtraction overflow'
        if 5 * arg1 / 100 > arg1:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if arg1 < 5 * arg1 / 100:
            revert with 0, 17
        idx = 0
        s = 1000 * 10^18
        t = stor6
        while idx < stor5.length:
            mem[0] = stor5[idx]
            mem[32] = 1
            if stor1[stor5[idx]] > t:
                _533 = mem[64]
                mem[64] = mem[64] + 64
                mem[_533] = 26
                mem[_533 + 32] = 'SafeMath: division by zero'
                if not arg1:
                    if not 5 * arg1 / 100:
                        return 0
                    if 5 * arg1 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg1 / 100:
                        revert with 0, 17
                    if not 5 * arg1 / 100:
                        revert with 0, 18
                    if 5 * arg1 / 100 * stor6 / 1000 * 10^18 / 5 * arg1 / 100 != stor6 / 1000 * 10^18:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _666 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_666] = 30
                    mem[_666 + 32] = 'SafeMath: subtraction overflow'
                    if 5 * arg1 / 100 * stor6 / 1000 * 10^18 <= 0:
                        if 0 < 5 * arg1 / 100 * stor6 / 1000 * 10^18:
                            revert with 0, 17
                        return (-5 * arg1 / 100 * stor6 / 1000 * 10^18)
                    _696 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _696 + 68] = mem[idx + _666 + 32]
                        idx = idx + 32
                        continue 
                    mem[_696 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _696 + -mem[64] + 100
                if arg1 and stor6 / 1000 * 10^18 > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor6 / 1000 * 10^18 / arg1 != stor6 / 1000 * 10^18:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 5 * arg1 / 100:
                    _665 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_665] = 30
                    mem[_665 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= arg1 * stor6 / 1000 * 10^18:
                        if arg1 * stor6 / 1000 * 10^18 < 0:
                            revert with 0, 17
                        return (arg1 * stor6 / 1000 * 10^18)
                    _695 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _695 + 68] = mem[idx + _665 + 32]
                        idx = idx + 32
                        continue 
                    mem[_695 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _695 + -mem[64] + 100
                if 5 * arg1 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg1 / 100:
                    revert with 0, 17
                if not 5 * arg1 / 100:
                    revert with 0, 18
                if 5 * arg1 / 100 * stor6 / 1000 * 10^18 / 5 * arg1 / 100 != stor6 / 1000 * 10^18:
                    revert with 0, 'SafeMath: multiplication overflow'
                _751 = mem[64]
                mem[64] = mem[64] + 64
                mem[_751] = 30
                mem[_751 + 32] = 'SafeMath: subtraction overflow'
                if 5 * arg1 / 100 * stor6 / 1000 * 10^18 <= arg1 * stor6 / 1000 * 10^18:
                    if arg1 * stor6 / 1000 * 10^18 < 5 * arg1 / 100 * stor6 / 1000 * 10^18:
                        revert with 0, 17
                    return ((arg1 * stor6 / 1000 * 10^18) - (5 * arg1 / 100 * stor6 / 1000 * 10^18))
                _789 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _789 + 68] = mem[idx + _751 + 32]
                    idx = idx + 32
                    continue 
                mem[_789 + 98] = 0
                revert with memory
                  from mem[64]
                   len _789 + -mem[64] + 100
            if idx >= stor5.length:
                revert with 0, 50
            mem[0] = stor5[idx]
            mem[32] = 2
            if stor2[stor5[idx]] <= s:
                if idx >= stor5.length:
                    revert with 0, 50
                mem[0] = stor5[idx]
                mem[32] = 1
                _545 = mem[64]
                mem[64] = mem[64] + 64
                mem[_545] = 30
                mem[_545 + 32] = 'SafeMath: subtraction overflow'
                if stor1[stor5[idx]] > t:
                    _553 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _553 + 68] = mem[idx + _545 + 32]
                        idx = idx + 32
                        continue 
                    mem[_553 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _553 + -mem[64] + 100
                if t < stor1[stor5[idx]]:
                    revert with 0, 17
                if idx >= stor5.length:
                    revert with 0, 50
                mem[0] = stor5[idx]
                mem[32] = 2
                _598 = mem[64]
                mem[64] = mem[64] + 64
                mem[_598] = 30
                mem[_598 + 32] = 'SafeMath: subtraction overflow'
                if stor2[stor5[idx]] <= s:
                    if s < stor2[stor5[idx]]:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s - stor2[stor5[idx]]
                    t = t - stor1[stor5[idx]]
                    continue 
                _606 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _606 + 68] = mem[idx + _598 + 32]
                    idx = idx + 32
                    continue 
                mem[_606 + 98] = 0
                revert with memory
                  from mem[64]
                   len _606 + -mem[64] + 100
            _546 = mem[64]
            mem[64] = mem[64] + 64
            mem[_546] = 26
            mem[_546 + 32] = 'SafeMath: division by zero'
            if not arg1:
                if not 5 * arg1 / 100:
                    return 0
                if 5 * arg1 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg1 / 100:
                    revert with 0, 17
                if not 5 * arg1 / 100:
                    revert with 0, 18
                if 5 * arg1 / 100 * stor6 / 1000 * 10^18 / 5 * arg1 / 100 != stor6 / 1000 * 10^18:
                    revert with 0, 'SafeMath: multiplication overflow'
                _698 = mem[64]
                mem[64] = mem[64] + 64
                mem[_698] = 30
                mem[_698 + 32] = 'SafeMath: subtraction overflow'
                if 5 * arg1 / 100 * stor6 / 1000 * 10^18 <= 0:
                    if 0 < 5 * arg1 / 100 * stor6 / 1000 * 10^18:
                        revert with 0, 17
                    return (-5 * arg1 / 100 * stor6 / 1000 * 10^18)
                _717 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _717 + 68] = mem[idx + _698 + 32]
                    idx = idx + 32
                    continue 
                mem[_717 + 98] = 0
                revert with memory
                  from mem[64]
                   len _717 + -mem[64] + 100
            if arg1 and stor6 / 1000 * 10^18 > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * stor6 / 1000 * 10^18 / arg1 != stor6 / 1000 * 10^18:
                revert with 0, 'SafeMath: multiplication overflow'
            if not 5 * arg1 / 100:
                _697 = mem[64]
                mem[64] = mem[64] + 64
                mem[_697] = 30
                mem[_697 + 32] = 'SafeMath: subtraction overflow'
                if 0 <= arg1 * stor6 / 1000 * 10^18:
                    if arg1 * stor6 / 1000 * 10^18 < 0:
                        revert with 0, 17
                    return (arg1 * stor6 / 1000 * 10^18)
                _716 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _716 + 68] = mem[idx + _697 + 32]
                    idx = idx + 32
                    continue 
                mem[_716 + 98] = 0
                revert with memory
                  from mem[64]
                   len _716 + -mem[64] + 100
            if 5 * arg1 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg1 / 100:
                revert with 0, 17
            if not 5 * arg1 / 100:
                revert with 0, 18
            if 5 * arg1 / 100 * stor6 / 1000 * 10^18 / 5 * arg1 / 100 != stor6 / 1000 * 10^18:
                revert with 0, 'SafeMath: multiplication overflow'
            _792 = mem[64]
            mem[64] = mem[64] + 64
            mem[_792] = 30
            mem[_792 + 32] = 'SafeMath: subtraction overflow'
            if 5 * arg1 / 100 * stor6 / 1000 * 10^18 <= arg1 * stor6 / 1000 * 10^18:
                if arg1 * stor6 / 1000 * 10^18 < 5 * arg1 / 100 * stor6 / 1000 * 10^18:
                    revert with 0, 17
                return ((arg1 * stor6 / 1000 * 10^18) - (5 * arg1 / 100 * stor6 / 1000 * 10^18))
            _833 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _833 + 68] = mem[idx + _792 + 32]
                idx = idx + 32
                continue 
            mem[_833 + 98] = 0
            revert with memory
              from mem[64]
               len _833 + -mem[64] + 100
        if t < stor6 / 1000 * 10^18:
            if not arg1:
                if not 5 * arg1 / 100:
                    return 0
                if 5 * arg1 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg1 / 100:
                    revert with 0, 17
                if not 5 * arg1 / 100:
                    revert with 0, 18
                if 5 * arg1 / 100 * stor6 / 1000 * 10^18 / 5 * arg1 / 100 != stor6 / 1000 * 10^18:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 5 * arg1 / 100 * stor6 / 1000 * 10^18 > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < 5 * arg1 / 100 * stor6 / 1000 * 10^18:
                    revert with 0, 17
                return (-5 * arg1 / 100 * stor6 / 1000 * 10^18)
            if arg1 and stor6 / 1000 * 10^18 > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * stor6 / 1000 * 10^18 / arg1 != stor6 / 1000 * 10^18:
                revert with 0, 'SafeMath: multiplication overflow'
            if not 5 * arg1 / 100:
                if 0 > arg1 * stor6 / 1000 * 10^18:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor6 / 1000 * 10^18 < 0:
                    revert with 0, 17
                return (arg1 * stor6 / 1000 * 10^18)
            if 5 * arg1 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg1 / 100:
                revert with 0, 17
            if not 5 * arg1 / 100:
                revert with 0, 18
            if 5 * arg1 / 100 * stor6 / 1000 * 10^18 / 5 * arg1 / 100 != stor6 / 1000 * 10^18:
                revert with 0, 'SafeMath: multiplication overflow'
            if 5 * arg1 / 100 * stor6 / 1000 * 10^18 > arg1 * stor6 / 1000 * 10^18:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * stor6 / 1000 * 10^18 < 5 * arg1 / 100 * stor6 / 1000 * 10^18:
                revert with 0, 17
            return ((arg1 * stor6 / 1000 * 10^18) - (5 * arg1 / 100 * stor6 / 1000 * 10^18))
        if not s:
            revert with 0, 'SafeMath: division by zero', 0
        if not arg1:
            if not 5 * arg1 / 100:
                return 0
            if 5 * arg1 / 100 and t / s > -1 / 5 * arg1 / 100:
                revert with 0, 17
            if not 5 * arg1 / 100:
                revert with 0, 18
            if 5 * arg1 / 100 * t / s / 5 * arg1 / 100 != t / s:
                revert with 0, 'SafeMath: multiplication overflow'
            if 5 * arg1 / 100 * t / s > 0:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if 0 < 5 * arg1 / 100 * t / s:
                revert with 0, 17
            return (-5 * arg1 / 100 * t / s)
        if arg1 and t / s > -1 / arg1:
            revert with 0, 17
        if not arg1:
            revert with 0, 18
        if arg1 * t / s / arg1 != t / s:
            revert with 0, 'SafeMath: multiplication overflow'
        if not 5 * arg1 / 100:
            if 0 > arg1 * t / s:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * t / s < 0:
                revert with 0, 17
            return (arg1 * t / s)
        if 5 * arg1 / 100 and t / s > -1 / 5 * arg1 / 100:
            revert with 0, 17
        if not 5 * arg1 / 100:
            revert with 0, 18
        if 5 * arg1 / 100 * t / s / 5 * arg1 / 100 != t / s:
            revert with 0, 'SafeMath: multiplication overflow'
        if 5 * arg1 / 100 * t / s > arg1 * t / s:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if arg1 * t / s < 5 * arg1 / 100 * t / s:
            revert with 0, 17
        return ((arg1 * t / s) - (5 * arg1 / 100 * t / s))
    if not arg1 / 100:
        mem[64] = 224
        mem[160] = 30
        mem[192] = 'SafeMath: subtraction overflow'
        if 0 > arg1:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if arg1 < 0:
            revert with 0, 17
        idx = 0
        s = 1000 * 10^18
        t = stor6
        while idx < stor5.length:
            mem[0] = stor5[idx]
            mem[32] = 1
            if stor1[stor5[idx]] > t:
                _536 = mem[64]
                mem[64] = mem[64] + 64
                mem[_536] = 26
                mem[_536 + 32] = 'SafeMath: division by zero'
                if not arg1:
                    return 0
                if arg1 and stor6 / 1000 * 10^18 > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor6 / 1000 * 10^18 / arg1 != stor6 / 1000 * 10^18:
                    revert with 0, 'SafeMath: multiplication overflow'
                _684 = mem[64]
                mem[64] = mem[64] + 64
                mem[_684] = 30
                mem[_684 + 32] = 'SafeMath: subtraction overflow'
                if 0 <= arg1 * stor6 / 1000 * 10^18:
                    if arg1 * stor6 / 1000 * 10^18 < 0:
                        revert with 0, 17
                    return (arg1 * stor6 / 1000 * 10^18)
                _705 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _705 + 68] = mem[idx + _684 + 32]
                    idx = idx + 32
                    continue 
                mem[_705 + 98] = 0
                revert with memory
                  from mem[64]
                   len _705 + -mem[64] + 100
            if idx >= stor5.length:
                revert with 0, 50
            mem[0] = stor5[idx]
            mem[32] = 2
            if stor2[stor5[idx]] > s:
                _552 = mem[64]
                mem[64] = mem[64] + 64
                mem[_552] = 26
                mem[_552 + 32] = 'SafeMath: division by zero'
                if not arg1:
                    return 0
                if arg1 and stor6 / 1000 * 10^18 > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor6 / 1000 * 10^18 / arg1 != stor6 / 1000 * 10^18:
                    revert with 0, 'SafeMath: multiplication overflow'
                _706 = mem[64]
                mem[64] = mem[64] + 64
                mem[_706] = 30
                mem[_706 + 32] = 'SafeMath: subtraction overflow'
                if 0 <= arg1 * stor6 / 1000 * 10^18:
                    if arg1 * stor6 / 1000 * 10^18 < 0:
                        revert with 0, 17
                    return (arg1 * stor6 / 1000 * 10^18)
                _724 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _724 + 68] = mem[idx + _706 + 32]
                    idx = idx + 32
                    continue 
                mem[_724 + 98] = 0
                revert with memory
                  from mem[64]
                   len _724 + -mem[64] + 100
            if idx >= stor5.length:
                revert with 0, 50
            mem[0] = stor5[idx]
            mem[32] = 1
            _551 = mem[64]
            mem[64] = mem[64] + 64
            mem[_551] = 30
            mem[_551 + 32] = 'SafeMath: subtraction overflow'
            if stor1[stor5[idx]] > t:
                _556 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _556 + 68] = mem[idx + _551 + 32]
                    idx = idx + 32
                    continue 
                mem[_556 + 98] = 0
                revert with memory
                  from mem[64]
                   len _556 + -mem[64] + 100
            if t < stor1[stor5[idx]]:
                revert with 0, 17
            if idx >= stor5.length:
                revert with 0, 50
            mem[0] = stor5[idx]
            mem[32] = 2
            _604 = mem[64]
            mem[64] = mem[64] + 64
            mem[_604] = 30
            mem[_604 + 32] = 'SafeMath: subtraction overflow'
            if stor2[stor5[idx]] <= s:
                if s < stor2[stor5[idx]]:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s - stor2[stor5[idx]]
                t = t - stor1[stor5[idx]]
                continue 
            _612 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _612 + 68] = mem[idx + _604 + 32]
                idx = idx + 32
                continue 
            mem[_612 + 98] = 0
            revert with memory
              from mem[64]
               len _612 + -mem[64] + 100
        if t < stor6 / 1000 * 10^18:
            if not arg1:
                return 0
            if arg1 and stor6 / 1000 * 10^18 > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * stor6 / 1000 * 10^18 / arg1 != stor6 / 1000 * 10^18:
                revert with 0, 'SafeMath: multiplication overflow'
            if 0 > arg1 * stor6 / 1000 * 10^18:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * stor6 / 1000 * 10^18 < 0:
                revert with 0, 17
            return (arg1 * stor6 / 1000 * 10^18)
        if not s:
            revert with 0, 'SafeMath: division by zero', 0
        if not arg1:
            return 0
        if arg1 and t / s > -1 / arg1:
            revert with 0, 17
        if not arg1:
            revert with 0, 18
        if arg1 * t / s / arg1 != t / s:
            revert with 0, 'SafeMath: multiplication overflow'
        if 0 > arg1 * t / s:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if arg1 * t / s < 0:
            revert with 0, 17
    else:
        if arg1 / 100 and 5 > -1 / arg1 / 100:
            revert with 0, 17
        if not arg1 / 100:
            revert with 0, 18
        if 5 * arg1 / 100 / arg1 / 100 != 5:
            revert with 0, 'SafeMath: multiplication overflow'
        mem[64] = 224
        mem[160] = 30
        mem[192] = 'SafeMath: subtraction overflow'
        if 5 * arg1 / 100 > arg1:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if arg1 < 5 * arg1 / 100:
            revert with 0, 17
        idx = 0
        s = 1000 * 10^18
        t = stor6
        while idx < stor5.length:
            mem[0] = stor5[idx]
            mem[32] = 1
            if stor1[stor5[idx]] > t:
                _535 = mem[64]
                mem[64] = mem[64] + 64
                mem[_535] = 26
                mem[_535 + 32] = 'SafeMath: division by zero'
                if not arg1:
                    if not 5 * arg1 / 100:
                        return 0
                    if 5 * arg1 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg1 / 100:
                        revert with 0, 17
                    if not 5 * arg1 / 100:
                        revert with 0, 18
                    if 5 * arg1 / 100 * stor6 / 1000 * 10^18 / 5 * arg1 / 100 != stor6 / 1000 * 10^18:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _678 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_678] = 30
                    mem[_678 + 32] = 'SafeMath: subtraction overflow'
                    if 5 * arg1 / 100 * stor6 / 1000 * 10^18 <= 0:
                        if 0 < 5 * arg1 / 100 * stor6 / 1000 * 10^18:
                            revert with 0, 17
                        else:
                            return 0
                    _702 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _702 + 68] = mem[idx + _678 + 32]
                        idx = idx + 32
                        continue 
                    mem[_702 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _702 + -mem[64] + 100
                if arg1 and stor6 / 1000 * 10^18 > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor6 / 1000 * 10^18 / arg1 != stor6 / 1000 * 10^18:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 5 * arg1 / 100:
                    _677 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_677] = 30
                    mem[_677 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= arg1 * stor6 / 1000 * 10^18:
                        if arg1 * stor6 / 1000 * 10^18 < 0:
                            revert with 0, 17
                        return (arg1 * stor6 / 1000 * 10^18)
                    _701 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _701 + 68] = mem[idx + _677 + 32]
                        idx = idx + 32
                        continue 
                    mem[_701 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _701 + -mem[64] + 100
                if 5 * arg1 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg1 / 100:
                    revert with 0, 17
                if not 5 * arg1 / 100:
                    revert with 0, 18
                if 5 * arg1 / 100 * stor6 / 1000 * 10^18 / 5 * arg1 / 100 != stor6 / 1000 * 10^18:
                    revert with 0, 'SafeMath: multiplication overflow'
                _761 = mem[64]
                mem[64] = mem[64] + 64
                mem[_761] = 30
                mem[_761 + 32] = 'SafeMath: subtraction overflow'
                if 5 * arg1 / 100 * stor6 / 1000 * 10^18 <= arg1 * stor6 / 1000 * 10^18:
                    if arg1 * stor6 / 1000 * 10^18 < 5 * arg1 / 100 * stor6 / 1000 * 10^18:
                        revert with 0, 17
                    return (arg1 * stor6 / 1000 * 10^18)
                _802 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _802 + 68] = mem[idx + _761 + 32]
                    idx = idx + 32
                    continue 
                mem[_802 + 98] = 0
                revert with memory
                  from mem[64]
                   len _802 + -mem[64] + 100
            if idx >= stor5.length:
                revert with 0, 50
            mem[0] = stor5[idx]
            mem[32] = 2
            if stor2[stor5[idx]] <= s:
                if idx >= stor5.length:
                    revert with 0, 50
                mem[0] = stor5[idx]
                mem[32] = 1
                _549 = mem[64]
                mem[64] = mem[64] + 64
                mem[_549] = 30
                mem[_549 + 32] = 'SafeMath: subtraction overflow'
                if stor1[stor5[idx]] > t:
                    _555 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _555 + 68] = mem[idx + _549 + 32]
                        idx = idx + 32
                        continue 
                    mem[_555 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _555 + -mem[64] + 100
                if t < stor1[stor5[idx]]:
                    revert with 0, 17
                if idx >= stor5.length:
                    revert with 0, 50
                mem[0] = stor5[idx]
                mem[32] = 2
                _602 = mem[64]
                mem[64] = mem[64] + 64
                mem[_602] = 30
                mem[_602 + 32] = 'SafeMath: subtraction overflow'
                if stor2[stor5[idx]] <= s:
                    if s < stor2[stor5[idx]]:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s - stor2[stor5[idx]]
                    t = t - stor1[stor5[idx]]
                    continue 
                _610 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _610 + 68] = mem[idx + _602 + 32]
                    idx = idx + 32
                    continue 
                mem[_610 + 98] = 0
                revert with memory
                  from mem[64]
                   len _610 + -mem[64] + 100
            _550 = mem[64]
            mem[64] = mem[64] + 64
            mem[_550] = 26
            mem[_550 + 32] = 'SafeMath: division by zero'
            if not arg1:
                if not 5 * arg1 / 100:
                    return 0
                if 5 * arg1 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg1 / 100:
                    revert with 0, 17
                if not 5 * arg1 / 100:
                    revert with 0, 18
                if 5 * arg1 / 100 * stor6 / 1000 * 10^18 / 5 * arg1 / 100 != stor6 / 1000 * 10^18:
                    revert with 0, 'SafeMath: multiplication overflow'
                _704 = mem[64]
                mem[64] = mem[64] + 64
                mem[_704] = 30
                mem[_704 + 32] = 'SafeMath: subtraction overflow'
                if 5 * arg1 / 100 * stor6 / 1000 * 10^18 <= 0:
                    if 0 < 5 * arg1 / 100 * stor6 / 1000 * 10^18:
                        revert with 0, 17
                    else:
                        return 0
                _723 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _723 + 68] = mem[idx + _704 + 32]
                    idx = idx + 32
                    continue 
                mem[_723 + 98] = 0
                revert with memory
                  from mem[64]
                   len _723 + -mem[64] + 100
            if arg1 and stor6 / 1000 * 10^18 > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * stor6 / 1000 * 10^18 / arg1 != stor6 / 1000 * 10^18:
                revert with 0, 'SafeMath: multiplication overflow'
            if not 5 * arg1 / 100:
                _703 = mem[64]
                mem[64] = mem[64] + 64
                mem[_703] = 30
                mem[_703 + 32] = 'SafeMath: subtraction overflow'
                if 0 <= arg1 * stor6 / 1000 * 10^18:
                    if arg1 * stor6 / 1000 * 10^18 < 0:
                        revert with 0, 17
                    return (arg1 * stor6 / 1000 * 10^18)
                _722 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _722 + 68] = mem[idx + _703 + 32]
                    idx = idx + 32
                    continue 
                mem[_722 + 98] = 0
                revert with memory
                  from mem[64]
                   len _722 + -mem[64] + 100
            if 5 * arg1 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg1 / 100:
                revert with 0, 17
            if not 5 * arg1 / 100:
                revert with 0, 18
            if 5 * arg1 / 100 * stor6 / 1000 * 10^18 / 5 * arg1 / 100 != stor6 / 1000 * 10^18:
                revert with 0, 'SafeMath: multiplication overflow'
            _805 = mem[64]
            mem[64] = mem[64] + 64
            mem[_805] = 30
            mem[_805 + 32] = 'SafeMath: subtraction overflow'
            if 5 * arg1 / 100 * stor6 / 1000 * 10^18 <= arg1 * stor6 / 1000 * 10^18:
                if arg1 * stor6 / 1000 * 10^18 < 5 * arg1 / 100 * stor6 / 1000 * 10^18:
                    revert with 0, 17
                return (arg1 * stor6 / 1000 * 10^18)
            _839 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _839 + 68] = mem[idx + _805 + 32]
                idx = idx + 32
                continue 
            mem[_839 + 98] = 0
            revert with memory
              from mem[64]
               len _839 + -mem[64] + 100
        if t < stor6 / 1000 * 10^18:
            if not arg1:
                if 5 * arg1 / 100:
                    if 5 * arg1 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg1 / 100:
                        revert with 0, 17
                    if not 5 * arg1 / 100:
                        revert with 0, 18
                    if 5 * arg1 / 100 * stor6 / 1000 * 10^18 / 5 * arg1 / 100 != stor6 / 1000 * 10^18:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 5 * arg1 / 100 * stor6 / 1000 * 10^18 > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < 5 * arg1 / 100 * stor6 / 1000 * 10^18:
                        revert with 0, 17
                    else:
                        return 0
                else:
                    return 0
            if arg1 and stor6 / 1000 * 10^18 > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * stor6 / 1000 * 10^18 / arg1 != stor6 / 1000 * 10^18:
                revert with 0, 'SafeMath: multiplication overflow'
            if not 5 * arg1 / 100:
                if 0 > arg1 * stor6 / 1000 * 10^18:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor6 / 1000 * 10^18 < 0:
                    revert with 0, 17
            else:
                if 5 * arg1 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg1 / 100:
                    revert with 0, 17
                if not 5 * arg1 / 100:
                    revert with 0, 18
                if 5 * arg1 / 100 * stor6 / 1000 * 10^18 / 5 * arg1 / 100 != stor6 / 1000 * 10^18:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 5 * arg1 / 100 * stor6 / 1000 * 10^18 > arg1 * stor6 / 1000 * 10^18:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor6 / 1000 * 10^18 < 5 * arg1 / 100 * stor6 / 1000 * 10^18:
                    revert with 0, 17
            return (arg1 * stor6 / 1000 * 10^18)
        if not s:
            revert with 0, 'SafeMath: division by zero', 0
        if not arg1:
            if 5 * arg1 / 100:
                if 5 * arg1 / 100 and t / s > -1 / 5 * arg1 / 100:
                    revert with 0, 17
                if not 5 * arg1 / 100:
                    revert with 0, 18
                if 5 * arg1 / 100 * t / s / 5 * arg1 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 5 * arg1 / 100 * t / s > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < 5 * arg1 / 100 * t / s:
                    revert with 0, 17
                else:
                    return 0
            else:
                return 0
        if arg1 and t / s > -1 / arg1:
            revert with 0, 17
        if not arg1:
            revert with 0, 18
        if arg1 * t / s / arg1 != t / s:
            revert with 0, 'SafeMath: multiplication overflow'
        if not 5 * arg1 / 100:
            if 0 > arg1 * t / s:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * t / s < 0:
                revert with 0, 17
        else:
            if 5 * arg1 / 100 and t / s > -1 / 5 * arg1 / 100:
                revert with 0, 17
            if not 5 * arg1 / 100:
                revert with 0, 18
            if 5 * arg1 / 100 * t / s / 5 * arg1 / 100 != t / s:
                revert with 0, 'SafeMath: multiplication overflow'
            if 5 * arg1 / 100 * t / s > arg1 * t / s:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * t / s < 5 * arg1 / 100 * t / s:
                revert with 0, 17
    return (arg1 * t / s)
}

function reflect(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    mem[0] = msg.sender
    mem[32] = 4
    if stor4[msg.sender]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Excluded addresses cannot call this function'
    mem[96] = 26
    mem[128] = 'SafeMath: division by zero'
    if not arg1 / 100:
        mem[64] = 224
        mem[160] = 30
        mem[192] = 'SafeMath: subtraction overflow'
        if 0 > arg1:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if arg1 < 0:
            revert with 0, 17
        idx = 0
        s = 1000 * 10^18
        t = stor6
        while idx < stor5.length:
            mem[0] = stor5[idx]
            mem[32] = 1
            if stor1[stor5[idx]] > t:
                _606 = mem[64]
                mem[64] = mem[64] + 64
                mem[_606] = 26
                mem[_606 + 32] = 'SafeMath: division by zero'
                if not arg1:
                    _655 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_655] = 30
                    mem[_655 + 32] = 'SafeMath: subtraction overflow'
                    mem[0] = msg.sender
                    mem[32] = 1
                    _703 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_703] = 30
                    mem[_703 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > stor1[address(msg.sender)]:
                        _726 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _726 + 68] = mem[idx + _703 + 32]
                            idx = idx + 32
                            continue 
                        mem[_726 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _726 + -mem[64] + 100
                    if stor1[address(msg.sender)] < 0:
                        revert with 0, 17
                    mem[0] = msg.sender
                    mem[32] = 1
                    _816 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_816] = 30
                    mem[_816 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= stor6:
                        if stor6 < 0:
                            revert with 0, 17
                        if totalFees > !arg1:
                            revert with 0, 17
                        if totalFees + arg1 < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        totalFees += arg1
                    _852 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _852 + 68] = mem[idx + _816 + 32]
                        idx = idx + 32
                        continue 
                    mem[_852 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _852 + -mem[64] + 100
                if arg1 and stor6 / 1000 * 10^18 > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor6 / 1000 * 10^18 / arg1 != stor6 / 1000 * 10^18:
                    revert with 0, 'SafeMath: multiplication overflow'
                _680 = mem[64]
                mem[64] = mem[64] + 64
                mem[_680] = 30
                mem[_680 + 32] = 'SafeMath: subtraction overflow'
                if 0 > arg1 * stor6 / 1000 * 10^18:
                    _690 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _690 + 68] = mem[idx + _680 + 32]
                        idx = idx + 32
                        continue 
                    mem[_690 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _690 + -mem[64] + 100
                if arg1 * stor6 / 1000 * 10^18 < 0:
                    revert with 0, 17
                mem[0] = msg.sender
                mem[32] = 1
                _782 = mem[64]
                mem[64] = mem[64] + 64
                mem[_782] = 30
                mem[_782 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                    _815 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _815 + 68] = mem[idx + _782 + 32]
                        idx = idx + 32
                        continue 
                    mem[_815 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _815 + -mem[64] + 100
                if stor1[address(msg.sender)] < arg1 * stor6 / 1000 * 10^18:
                    revert with 0, 17
                mem[0] = msg.sender
                mem[32] = 1
                stor1[address(msg.sender)] += -1 * arg1 * stor6 / 1000 * 10^18
                _932 = mem[64]
                mem[64] = mem[64] + 64
                mem[_932] = 30
                mem[_932 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor6 / 1000 * 10^18 <= stor6:
                    if stor6 < arg1 * stor6 / 1000 * 10^18:
                        revert with 0, 17
                    stor6 += -1 * arg1 * stor6 / 1000 * 10^18
                    if totalFees > !arg1:
                        revert with 0, 17
                    if totalFees + arg1 < totalFees:
                        revert with 0, 'SafeMath: addition overflow'
                    totalFees += arg1
                _967 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _967 + 68] = mem[idx + _932 + 32]
                    idx = idx + 32
                    continue 
                mem[_967 + 98] = 0
                revert with memory
                  from mem[64]
                   len _967 + -mem[64] + 100
            if idx >= stor5.length:
                revert with 0, 50
            mem[0] = stor5[idx]
            mem[32] = 2
            if stor2[stor5[idx]] <= s:
                if idx >= stor5.length:
                    revert with 0, 50
                mem[0] = stor5[idx]
                mem[32] = 1
                _613 = mem[64]
                mem[64] = mem[64] + 64
                mem[_613] = 30
                mem[_613 + 32] = 'SafeMath: subtraction overflow'
                if stor1[stor5[idx]] > t:
                    _616 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _616 + 68] = mem[idx + _613 + 32]
                        idx = idx + 32
                        continue 
                    mem[_616 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _616 + -mem[64] + 100
                if t < stor1[stor5[idx]]:
                    revert with 0, 17
                if idx >= stor5.length:
                    revert with 0, 50
                mem[0] = stor5[idx]
                mem[32] = 2
                _640 = mem[64]
                mem[64] = mem[64] + 64
                mem[_640] = 30
                mem[_640 + 32] = 'SafeMath: subtraction overflow'
                if stor2[stor5[idx]] <= s:
                    if s < stor2[stor5[idx]]:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s - stor2[stor5[idx]]
                    t = t - stor1[stor5[idx]]
                    continue 
                _644 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _644 + 68] = mem[idx + _640 + 32]
                    idx = idx + 32
                    continue 
                mem[_644 + 98] = 0
                revert with memory
                  from mem[64]
                   len _644 + -mem[64] + 100
            _614 = mem[64]
            mem[64] = mem[64] + 64
            mem[_614] = 26
            mem[_614 + 32] = 'SafeMath: division by zero'
            if not arg1:
                _664 = mem[64]
                mem[64] = mem[64] + 64
                mem[_664] = 30
                mem[_664 + 32] = 'SafeMath: subtraction overflow'
                mem[0] = msg.sender
                mem[32] = 1
                _727 = mem[64]
                mem[64] = mem[64] + 64
                mem[_727] = 30
                mem[_727 + 32] = 'SafeMath: subtraction overflow'
                if 0 > stor1[address(msg.sender)]:
                    _749 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _749 + 68] = mem[idx + _727 + 32]
                        idx = idx + 32
                        continue 
                    mem[_749 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _749 + -mem[64] + 100
                if stor1[address(msg.sender)] < 0:
                    revert with 0, 17
                mem[0] = msg.sender
                mem[32] = 1
                _854 = mem[64]
                mem[64] = mem[64] + 64
                mem[_854] = 30
                mem[_854 + 32] = 'SafeMath: subtraction overflow'
                if 0 <= stor6:
                    if stor6 < 0:
                        revert with 0, 17
                    if totalFees > !arg1:
                        revert with 0, 17
                    if totalFees + arg1 < totalFees:
                        revert with 0, 'SafeMath: addition overflow'
                    totalFees += arg1
                _887 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _887 + 68] = mem[idx + _854 + 32]
                    idx = idx + 32
                    continue 
                mem[_887 + 98] = 0
                revert with memory
                  from mem[64]
                   len _887 + -mem[64] + 100
            if arg1 and stor6 / 1000 * 10^18 > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * stor6 / 1000 * 10^18 / arg1 != stor6 / 1000 * 10^18:
                revert with 0, 'SafeMath: multiplication overflow'
            _691 = mem[64]
            mem[64] = mem[64] + 64
            mem[_691] = 30
            mem[_691 + 32] = 'SafeMath: subtraction overflow'
            if 0 > arg1 * stor6 / 1000 * 10^18:
                _704 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _704 + 68] = mem[idx + _691 + 32]
                    idx = idx + 32
                    continue 
                mem[_704 + 98] = 0
                revert with memory
                  from mem[64]
                   len _704 + -mem[64] + 100
            if arg1 * stor6 / 1000 * 10^18 < 0:
                revert with 0, 17
            mem[0] = msg.sender
            mem[32] = 1
            _818 = mem[64]
            mem[64] = mem[64] + 64
            mem[_818] = 30
            mem[_818 + 32] = 'SafeMath: subtraction overflow'
            if arg1 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                _853 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _853 + 68] = mem[idx + _818 + 32]
                    idx = idx + 32
                    continue 
                mem[_853 + 98] = 0
                revert with memory
                  from mem[64]
                   len _853 + -mem[64] + 100
            if stor1[address(msg.sender)] < arg1 * stor6 / 1000 * 10^18:
                revert with 0, 17
            mem[0] = msg.sender
            mem[32] = 1
            stor1[address(msg.sender)] += -1 * arg1 * stor6 / 1000 * 10^18
            _969 = mem[64]
            mem[64] = mem[64] + 64
            mem[_969] = 30
            mem[_969 + 32] = 'SafeMath: subtraction overflow'
            if arg1 * stor6 / 1000 * 10^18 <= stor6:
                if stor6 < arg1 * stor6 / 1000 * 10^18:
                    revert with 0, 17
                stor6 += -1 * arg1 * stor6 / 1000 * 10^18
                if totalFees > !arg1:
                    revert with 0, 17
                if totalFees + arg1 < totalFees:
                    revert with 0, 'SafeMath: addition overflow'
                totalFees += arg1
            _995 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _995 + 68] = mem[idx + _969 + 32]
                idx = idx + 32
                continue 
            mem[_995 + 98] = 0
            revert with memory
              from mem[64]
               len _995 + -mem[64] + 100
        if t < stor6 / 1000 * 10^18:
            if not arg1:
                if 0 > stor1[address(msg.sender)]:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if stor1[address(msg.sender)] < 0:
                    revert with 0, 17
                if 0 > stor6:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if stor6 < 0:
                    revert with 0, 17
            else:
                if arg1 and stor6 / 1000 * 10^18 > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor6 / 1000 * 10^18 / arg1 != stor6 / 1000 * 10^18:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * stor6 / 1000 * 10^18:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor6 / 1000 * 10^18 < 0:
                    revert with 0, 17
                if arg1 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if stor1[address(msg.sender)] < arg1 * stor6 / 1000 * 10^18:
                    revert with 0, 17
                stor1[address(msg.sender)] += -1 * arg1 * stor6 / 1000 * 10^18
                if arg1 * stor6 / 1000 * 10^18 > stor6:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if stor6 < arg1 * stor6 / 1000 * 10^18:
                    revert with 0, 17
                stor6 += -1 * arg1 * stor6 / 1000 * 10^18
        else:
            if not s:
                revert with 0, 'SafeMath: division by zero', 0
            if not arg1:
                if 0 > stor1[address(msg.sender)]:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if stor1[address(msg.sender)] < 0:
                    revert with 0, 17
                if 0 > stor6:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if stor6 < 0:
                    revert with 0, 17
            else:
                if arg1 and t / s > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * t / s / arg1 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < 0:
                    revert with 0, 17
                if arg1 * t / s > stor1[address(msg.sender)]:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if stor1[address(msg.sender)] < arg1 * t / s:
                    revert with 0, 17
                stor1[address(msg.sender)] += -1 * arg1 * t / s
                if arg1 * t / s > stor6:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if stor6 < arg1 * t / s:
                    revert with 0, 17
                stor6 += -1 * arg1 * t / s
    else:
        if arg1 / 100 and 5 > -1 / arg1 / 100:
            revert with 0, 17
        if not arg1 / 100:
            revert with 0, 18
        if 5 * arg1 / 100 / arg1 / 100 != 5:
            revert with 0, 'SafeMath: multiplication overflow'
        mem[64] = 224
        mem[160] = 30
        mem[192] = 'SafeMath: subtraction overflow'
        if 5 * arg1 / 100 > arg1:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if arg1 < 5 * arg1 / 100:
            revert with 0, 17
        idx = 0
        s = 1000 * 10^18
        t = stor6
        while idx < stor5.length:
            mem[0] = stor5[idx]
            mem[32] = 1
            if stor1[stor5[idx]] > t:
                _605 = mem[64]
                mem[64] = mem[64] + 64
                mem[_605] = 26
                mem[_605 + 32] = 'SafeMath: division by zero'
                if not arg1:
                    if not 5 * arg1 / 100:
                        _652 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_652] = 30
                        mem[_652 + 32] = 'SafeMath: subtraction overflow'
                        mem[0] = msg.sender
                        mem[32] = 1
                        _700 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_700] = 30
                        mem[_700 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor1[address(msg.sender)]:
                            _721 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _721 + 68] = mem[idx + _700 + 32]
                                idx = idx + 32
                                continue 
                            mem[_721 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _721 + -mem[64] + 100
                        if stor1[address(msg.sender)] < 0:
                            revert with 0, 17
                        mem[0] = msg.sender
                        mem[32] = 1
                        _809 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_809] = 30
                        mem[_809 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= stor6:
                            if stor6 < 0:
                                revert with 0, 17
                            if totalFees > !arg1:
                                revert with 0, 17
                            if totalFees + arg1 < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += arg1
                        _845 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _845 + 68] = mem[idx + _809 + 32]
                            idx = idx + 32
                            continue 
                        mem[_845 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _845 + -mem[64] + 100
                    if 5 * arg1 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg1 / 100:
                        revert with 0, 17
                    if not 5 * arg1 / 100:
                        revert with 0, 18
                    if 5 * arg1 / 100 * stor6 / 1000 * 10^18 / 5 * arg1 / 100 != stor6 / 1000 * 10^18:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _674 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_674] = 30
                    mem[_674 + 32] = 'SafeMath: subtraction overflow'
                    if 5 * arg1 / 100 * stor6 / 1000 * 10^18 > 0:
                        _687 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _687 + 68] = mem[idx + _674 + 32]
                            idx = idx + 32
                            continue 
                        mem[_687 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _687 + -mem[64] + 100
                    if 0 < 5 * arg1 / 100 * stor6 / 1000 * 10^18:
                        revert with 0, 17
                    mem[0] = msg.sender
                    mem[32] = 1
                    _776 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_776] = 30
                    mem[_776 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > stor1[address(msg.sender)]:
                        _808 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _808 + 68] = mem[idx + _776 + 32]
                            idx = idx + 32
                            continue 
                        mem[_808 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _808 + -mem[64] + 100
                    if stor1[address(msg.sender)] < 0:
                        revert with 0, 17
                    mem[0] = msg.sender
                    mem[32] = 1
                    _923 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_923] = 30
                    mem[_923 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= stor6:
                        if stor6 < 0:
                            revert with 0, 17
                        if totalFees > !arg1:
                            revert with 0, 17
                        if totalFees + arg1 < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        totalFees += arg1
                    _958 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _958 + 68] = mem[idx + _923 + 32]
                        idx = idx + 32
                        continue 
                    mem[_958 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _958 + -mem[64] + 100
                if arg1 and stor6 / 1000 * 10^18 > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor6 / 1000 * 10^18 / arg1 != stor6 / 1000 * 10^18:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 5 * arg1 / 100:
                    _673 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_673] = 30
                    mem[_673 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor6 / 1000 * 10^18:
                        _686 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _686 + 68] = mem[idx + _673 + 32]
                            idx = idx + 32
                            continue 
                        mem[_686 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _686 + -mem[64] + 100
                    if arg1 * stor6 / 1000 * 10^18 < 0:
                        revert with 0, 17
                    mem[0] = msg.sender
                    mem[32] = 1
                    _775 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_775] = 30
                    mem[_775 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                        _807 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _807 + 68] = mem[idx + _775 + 32]
                            idx = idx + 32
                            continue 
                        mem[_807 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _807 + -mem[64] + 100
                    if stor1[address(msg.sender)] < arg1 * stor6 / 1000 * 10^18:
                        revert with 0, 17
                    mem[0] = msg.sender
                    mem[32] = 1
                    stor1[address(msg.sender)] += -1 * arg1 * stor6 / 1000 * 10^18
                    _921 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_921] = 30
                    mem[_921 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor6 / 1000 * 10^18 <= stor6:
                        if stor6 < arg1 * stor6 / 1000 * 10^18:
                            revert with 0, 17
                        stor6 += -1 * arg1 * stor6 / 1000 * 10^18
                        if totalFees > !arg1:
                            revert with 0, 17
                        if totalFees + arg1 < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        totalFees += arg1
                    _957 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _957 + 68] = mem[idx + _921 + 32]
                        idx = idx + 32
                        continue 
                    mem[_957 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _957 + -mem[64] + 100
                if 5 * arg1 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg1 / 100:
                    revert with 0, 17
                if not 5 * arg1 / 100:
                    revert with 0, 18
                if 5 * arg1 / 100 * stor6 / 1000 * 10^18 / 5 * arg1 / 100 != stor6 / 1000 * 10^18:
                    revert with 0, 'SafeMath: multiplication overflow'
                _720 = mem[64]
                mem[64] = mem[64] + 64
                mem[_720] = 30
                mem[_720 + 32] = 'SafeMath: subtraction overflow'
                if 5 * arg1 / 100 * stor6 / 1000 * 10^18 > arg1 * stor6 / 1000 * 10^18:
                    _741 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _741 + 68] = mem[idx + _720 + 32]
                        idx = idx + 32
                        continue 
                    mem[_741 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _741 + -mem[64] + 100
                if arg1 * stor6 / 1000 * 10^18 < 5 * arg1 / 100 * stor6 / 1000 * 10^18:
                    revert with 0, 17
                mem[0] = msg.sender
                mem[32] = 1
                _882 = mem[64]
                mem[64] = mem[64] + 64
                mem[_882] = 30
                mem[_882 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                    _920 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _920 + 68] = mem[idx + _882 + 32]
                        idx = idx + 32
                        continue 
                    mem[_920 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _920 + -mem[64] + 100
                if stor1[address(msg.sender)] < arg1 * stor6 / 1000 * 10^18:
                    revert with 0, 17
                mem[0] = msg.sender
                mem[32] = 1
                stor1[address(msg.sender)] += -1 * arg1 * stor6 / 1000 * 10^18
                _1032 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1032] = 30
                mem[_1032 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor6 / 1000 * 10^18 <= stor6:
                    if stor6 < arg1 * stor6 / 1000 * 10^18:
                        revert with 0, 17
                    stor6 += -1 * arg1 * stor6 / 1000 * 10^18
                    if totalFees > !arg1:
                        revert with 0, 17
                    if totalFees + arg1 < totalFees:
                        revert with 0, 'SafeMath: addition overflow'
                    totalFees += arg1
                _1062 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _1062 + 68] = mem[idx + _1032 + 32]
                    idx = idx + 32
                    continue 
                mem[_1062 + 98] = 0
                revert with memory
                  from mem[64]
                   len _1062 + -mem[64] + 100
            if idx >= stor5.length:
                revert with 0, 50
            mem[0] = stor5[idx]
            mem[32] = 2
            if stor2[stor5[idx]] <= s:
                if idx >= stor5.length:
                    revert with 0, 50
                mem[0] = stor5[idx]
                mem[32] = 1
                _611 = mem[64]
                mem[64] = mem[64] + 64
                mem[_611] = 30
                mem[_611 + 32] = 'SafeMath: subtraction overflow'
                if stor1[stor5[idx]] > t:
                    _615 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _615 + 68] = mem[idx + _611 + 32]
                        idx = idx + 32
                        continue 
                    mem[_615 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _615 + -mem[64] + 100
                if t < stor1[stor5[idx]]:
                    revert with 0, 17
                if idx >= stor5.length:
                    revert with 0, 50
                mem[0] = stor5[idx]
                mem[32] = 2
                _638 = mem[64]
                mem[64] = mem[64] + 64
                mem[_638] = 30
                mem[_638 + 32] = 'SafeMath: subtraction overflow'
                if stor2[stor5[idx]] <= s:
                    if s < stor2[stor5[idx]]:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s - stor2[stor5[idx]]
                    t = t - stor1[stor5[idx]]
                    continue 
                _642 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _642 + 68] = mem[idx + _638 + 32]
                    idx = idx + 32
                    continue 
                mem[_642 + 98] = 0
                revert with memory
                  from mem[64]
                   len _642 + -mem[64] + 100
            _612 = mem[64]
            mem[64] = mem[64] + 64
            mem[_612] = 26
            mem[_612 + 32] = 'SafeMath: division by zero'
            if not arg1:
                if not 5 * arg1 / 100:
                    _662 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_662] = 30
                    mem[_662 + 32] = 'SafeMath: subtraction overflow'
                    mem[0] = msg.sender
                    mem[32] = 1
                    _723 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_723] = 30
                    mem[_723 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > stor1[address(msg.sender)]:
                        _745 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _745 + 68] = mem[idx + _723 + 32]
                            idx = idx + 32
                            continue 
                        mem[_745 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _745 + -mem[64] + 100
                    if stor1[address(msg.sender)] < 0:
                        revert with 0, 17
                    mem[0] = msg.sender
                    mem[32] = 1
                    _848 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_848] = 30
                    mem[_848 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= stor6:
                        if stor6 < 0:
                            revert with 0, 17
                        if totalFees > !arg1:
                            revert with 0, 17
                        if totalFees + arg1 < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        totalFees += arg1
                    _884 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _884 + 68] = mem[idx + _848 + 32]
                        idx = idx + 32
                        continue 
                    mem[_884 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _884 + -mem[64] + 100
                if 5 * arg1 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg1 / 100:
                    revert with 0, 17
                if not 5 * arg1 / 100:
                    revert with 0, 18
                if 5 * arg1 / 100 * stor6 / 1000 * 10^18 / 5 * arg1 / 100 != stor6 / 1000 * 10^18:
                    revert with 0, 'SafeMath: multiplication overflow'
                _689 = mem[64]
                mem[64] = mem[64] + 64
                mem[_689] = 30
                mem[_689 + 32] = 'SafeMath: subtraction overflow'
                if 5 * arg1 / 100 * stor6 / 1000 * 10^18 > 0:
                    _702 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _702 + 68] = mem[idx + _689 + 32]
                        idx = idx + 32
                        continue 
                    mem[_702 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _702 + -mem[64] + 100
                if 0 < 5 * arg1 / 100 * stor6 / 1000 * 10^18:
                    revert with 0, 17
                mem[0] = msg.sender
                mem[32] = 1
                _812 = mem[64]
                mem[64] = mem[64] + 64
                mem[_812] = 30
                mem[_812 + 32] = 'SafeMath: subtraction overflow'
                if 0 > stor1[address(msg.sender)]:
                    _847 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _847 + 68] = mem[idx + _812 + 32]
                        idx = idx + 32
                        continue 
                    mem[_847 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _847 + -mem[64] + 100
                if stor1[address(msg.sender)] < 0:
                    revert with 0, 17
                mem[0] = msg.sender
                mem[32] = 1
                _963 = mem[64]
                mem[64] = mem[64] + 64
                mem[_963] = 30
                mem[_963 + 32] = 'SafeMath: subtraction overflow'
                if 0 <= stor6:
                    if stor6 < 0:
                        revert with 0, 17
                    if totalFees > !arg1:
                        revert with 0, 17
                    if totalFees + arg1 < totalFees:
                        revert with 0, 'SafeMath: addition overflow'
                    totalFees += arg1
                _993 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _993 + 68] = mem[idx + _963 + 32]
                    idx = idx + 32
                    continue 
                mem[_993 + 98] = 0
                revert with memory
                  from mem[64]
                   len _993 + -mem[64] + 100
            if arg1 and stor6 / 1000 * 10^18 > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * stor6 / 1000 * 10^18 / arg1 != stor6 / 1000 * 10^18:
                revert with 0, 'SafeMath: multiplication overflow'
            if not 5 * arg1 / 100:
                _688 = mem[64]
                mem[64] = mem[64] + 64
                mem[_688] = 30
                mem[_688 + 32] = 'SafeMath: subtraction overflow'
                if 0 > arg1 * stor6 / 1000 * 10^18:
                    _701 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _701 + 68] = mem[idx + _688 + 32]
                        idx = idx + 32
                        continue 
                    mem[_701 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _701 + -mem[64] + 100
                if arg1 * stor6 / 1000 * 10^18 < 0:
                    revert with 0, 17
                mem[0] = msg.sender
                mem[32] = 1
                _811 = mem[64]
                mem[64] = mem[64] + 64
                mem[_811] = 30
                mem[_811 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                    _846 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _846 + 68] = mem[idx + _811 + 32]
                        idx = idx + 32
                        continue 
                    mem[_846 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _846 + -mem[64] + 100
                if stor1[address(msg.sender)] < arg1 * stor6 / 1000 * 10^18:
                    revert with 0, 17
                mem[0] = msg.sender
                mem[32] = 1
                stor1[address(msg.sender)] += -1 * arg1 * stor6 / 1000 * 10^18
                _961 = mem[64]
                mem[64] = mem[64] + 64
                mem[_961] = 30
                mem[_961 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor6 / 1000 * 10^18 <= stor6:
                    if stor6 < arg1 * stor6 / 1000 * 10^18:
                        revert with 0, 17
                    stor6 += -1 * arg1 * stor6 / 1000 * 10^18
                    if totalFees > !arg1:
                        revert with 0, 17
                    if totalFees + arg1 < totalFees:
                        revert with 0, 'SafeMath: addition overflow'
                    totalFees += arg1
                _992 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _992 + 68] = mem[idx + _961 + 32]
                    idx = idx + 32
                    continue 
                mem[_992 + 98] = 0
                revert with memory
                  from mem[64]
                   len _992 + -mem[64] + 100
            if 5 * arg1 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg1 / 100:
                revert with 0, 17
            if not 5 * arg1 / 100:
                revert with 0, 18
            if 5 * arg1 / 100 * stor6 / 1000 * 10^18 / 5 * arg1 / 100 != stor6 / 1000 * 10^18:
                revert with 0, 'SafeMath: multiplication overflow'
            _744 = mem[64]
            mem[64] = mem[64] + 64
            mem[_744] = 30
            mem[_744 + 32] = 'SafeMath: subtraction overflow'
            if 5 * arg1 / 100 * stor6 / 1000 * 10^18 > arg1 * stor6 / 1000 * 10^18:
                _777 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _777 + 68] = mem[idx + _744 + 32]
                    idx = idx + 32
                    continue 
                mem[_777 + 98] = 0
                revert with memory
                  from mem[64]
                   len _777 + -mem[64] + 100
            if arg1 * stor6 / 1000 * 10^18 < 5 * arg1 / 100 * stor6 / 1000 * 10^18:
                revert with 0, 17
            mem[0] = msg.sender
            mem[32] = 1
            _925 = mem[64]
            mem[64] = mem[64] + 64
            mem[_925] = 30
            mem[_925 + 32] = 'SafeMath: subtraction overflow'
            if arg1 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                _960 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _960 + 68] = mem[idx + _925 + 32]
                    idx = idx + 32
                    continue 
                mem[_960 + 98] = 0
                revert with memory
                  from mem[64]
                   len _960 + -mem[64] + 100
            if stor1[address(msg.sender)] < arg1 * stor6 / 1000 * 10^18:
                revert with 0, 17
            mem[0] = msg.sender
            mem[32] = 1
            stor1[address(msg.sender)] += -1 * arg1 * stor6 / 1000 * 10^18
            _1065 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1065] = 30
            mem[_1065 + 32] = 'SafeMath: subtraction overflow'
            if arg1 * stor6 / 1000 * 10^18 <= stor6:
                if stor6 < arg1 * stor6 / 1000 * 10^18:
                    revert with 0, 17
                stor6 += -1 * arg1 * stor6 / 1000 * 10^18
                if totalFees > !arg1:
                    revert with 0, 17
                if totalFees + arg1 < totalFees:
                    revert with 0, 'SafeMath: addition overflow'
                totalFees += arg1
            _1088 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _1088 + 68] = mem[idx + _1065 + 32]
                idx = idx + 32
                continue 
            mem[_1088 + 98] = 0
            revert with memory
              from mem[64]
               len _1088 + -mem[64] + 100
        if t < stor6 / 1000 * 10^18:
            if not arg1:
                if 5 * arg1 / 100:
                    if 5 * arg1 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg1 / 100:
                        revert with 0, 17
                    if not 5 * arg1 / 100:
                        revert with 0, 18
                    if 5 * arg1 / 100 * stor6 / 1000 * 10^18 / 5 * arg1 / 100 != stor6 / 1000 * 10^18:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 5 * arg1 / 100 * stor6 / 1000 * 10^18 > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < 5 * arg1 / 100 * stor6 / 1000 * 10^18:
                        revert with 0, 17
                if 0 > stor1[address(msg.sender)]:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if stor1[address(msg.sender)] < 0:
                    revert with 0, 17
                if 0 > stor6:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if stor6 < 0:
                    revert with 0, 17
            else:
                if arg1 and stor6 / 1000 * 10^18 > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor6 / 1000 * 10^18 / arg1 != stor6 / 1000 * 10^18:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 5 * arg1 / 100:
                    if 0 > arg1 * stor6 / 1000 * 10^18:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor6 / 1000 * 10^18 < 0:
                        revert with 0, 17
                else:
                    if 5 * arg1 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg1 / 100:
                        revert with 0, 17
                    if not 5 * arg1 / 100:
                        revert with 0, 18
                    if 5 * arg1 / 100 * stor6 / 1000 * 10^18 / 5 * arg1 / 100 != stor6 / 1000 * 10^18:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 5 * arg1 / 100 * stor6 / 1000 * 10^18 > arg1 * stor6 / 1000 * 10^18:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor6 / 1000 * 10^18 < 5 * arg1 / 100 * stor6 / 1000 * 10^18:
                        revert with 0, 17
                if arg1 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if stor1[address(msg.sender)] < arg1 * stor6 / 1000 * 10^18:
                    revert with 0, 17
                stor1[address(msg.sender)] += -1 * arg1 * stor6 / 1000 * 10^18
                if arg1 * stor6 / 1000 * 10^18 > stor6:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if stor6 < arg1 * stor6 / 1000 * 10^18:
                    revert with 0, 17
                stor6 += -1 * arg1 * stor6 / 1000 * 10^18
        else:
            if not s:
                revert with 0, 'SafeMath: division by zero', 0
            if not arg1:
                if 5 * arg1 / 100:
                    if 5 * arg1 / 100 and t / s > -1 / 5 * arg1 / 100:
                        revert with 0, 17
                    if not 5 * arg1 / 100:
                        revert with 0, 18
                    if 5 * arg1 / 100 * t / s / 5 * arg1 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 5 * arg1 / 100 * t / s > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < 5 * arg1 / 100 * t / s:
                        revert with 0, 17
                if 0 > stor1[address(msg.sender)]:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if stor1[address(msg.sender)] < 0:
                    revert with 0, 17
                if 0 > stor6:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if stor6 < 0:
                    revert with 0, 17
            else:
                if arg1 and t / s > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * t / s / arg1 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 5 * arg1 / 100:
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 0, 17
                else:
                    if 5 * arg1 / 100 and t / s > -1 / 5 * arg1 / 100:
                        revert with 0, 17
                    if not 5 * arg1 / 100:
                        revert with 0, 18
                    if 5 * arg1 / 100 * t / s / 5 * arg1 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 5 * arg1 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 5 * arg1 / 100 * t / s:
                        revert with 0, 17
                if arg1 * t / s > stor1[address(msg.sender)]:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if stor1[address(msg.sender)] < arg1 * t / s:
                    revert with 0, 17
                stor1[address(msg.sender)] += -1 * arg1 * t / s
                if arg1 * t / s > stor6:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if stor6 < arg1 * t / s:
                    revert with 0, 17
                stor6 += -1 * arg1 * t / s
    if totalFees > !arg1:
        revert with 0, 17
    if totalFees + arg1 < totalFees:
        revert with 0, 'SafeMath: addition overflow'
    totalFees += arg1
}

function transfer(address arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if not msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer from the zero address'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer to the zero address'
    if arg2 <= 0:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Transfer amount must be greater than zero'
    if not stor4[address(msg.sender)]:
        if stor4[address(msg.sender)]:
            mem[0] = msg.sender
            mem[32] = 4
            if stor4[address(msg.sender)]:
                mem[96] = 26
                mem[128] = 'SafeMath: division by zero'
                if not arg2 / 100:
                    mem[64] = 224
                    mem[160] = 30
                    mem[192] = 'SafeMath: subtraction overflow'
                    if 0 > arg2:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg2 < 0:
                        revert with 0, 17
                    idx = 0
                    s = 1000 * 10^18
                    t = stor6
                    while idx < stor5.length:
                        mem[0] = stor5[idx]
                        mem[32] = 1
                        if stor1[stor5[idx]] > t:
                            _12301 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12301] = 26
                            mem[_12301 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                _12994 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12994] = 30
                                mem[_12994 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = msg.sender
                                mem[32] = 1
                                _13686 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13686] = 30
                                mem[_13686 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _13975 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13975 + 68] = mem[idx + _13686 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13975 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13975 + -mem[64] + 100
                                if stor1[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor1[arg1] > -1:
                                    revert with 0, 17
                                if stor1[arg1] < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[arg1]
                                _17240 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17240] = 30
                                mem[_17240 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > -1:
                                        revert with 0, 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _17698 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _17698 + 68] = mem[idx + _17240 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_17698 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _17698 + -mem[64] + 100
                            if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                                revert with 0, 17
                            if not arg2:
                                revert with 0, 18
                            if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _13271 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13271] = 30
                            mem[_13271 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg2 * stor6 / 1000 * 10^18:
                                _13519 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13519 + 68] = mem[idx + _13271 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13519 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13519 + -mem[64] + 100
                            if arg2 * stor6 / 1000 * 10^18 < 0:
                                revert with 0, 17
                            mem[0] = msg.sender
                            mem[32] = 1
                            _14801 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14801] = 30
                            mem[_14801 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                _15311 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15311 + 68] = mem[idx + _14801 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15311 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15311 + -mem[64] + 100
                            if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                revert with 0, 17
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                            if stor1[arg1] > !(arg2 * stor6 / 1000 * 10^18):
                                revert with 0, 17
                            if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18)
                            _18893 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_18893] = 30
                            mem[_18893 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor6:
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > -1:
                                    revert with 0, 17
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg2, msg.sender, arg1);
                                return 1
                            _19258 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _19258 + 68] = mem[idx + _18893 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19258 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19258 + -mem[64] + 100
                        if idx >= stor5.length:
                            revert with 0, 50
                        mem[0] = stor5[idx]
                        mem[32] = 2
                        if stor2[stor5[idx]] <= s:
                            if idx >= stor5.length:
                                revert with 0, 50
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            _12392 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12392] = 30
                            mem[_12392 + 32] = 'SafeMath: subtraction overflow'
                            if stor1[stor5[idx]] > t:
                                _12451 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _12451 + 68] = mem[idx + _12392 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12451 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12451 + -mem[64] + 100
                            if t < stor1[stor5[idx]]:
                                revert with 0, 17
                            if idx >= stor5.length:
                                revert with 0, 50
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            _12783 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12783] = 30
                            mem[_12783 + 32] = 'SafeMath: subtraction overflow'
                            if stor2[stor5[idx]] <= s:
                                if s < stor2[stor5[idx]]:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s - stor2[stor5[idx]]
                                t = t - stor1[stor5[idx]]
                                continue 
                            _12843 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12843 + 68] = mem[idx + _12783 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12843 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12843 + -mem[64] + 100
                        _12393 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12393] = 26
                        mem[_12393 + 32] = 'SafeMath: division by zero'
                        if not arg2:
                            _13143 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13143] = 30
                            mem[_13143 + 32] = 'SafeMath: subtraction overflow'
                            mem[0] = msg.sender
                            mem[32] = 1
                            _13976 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13976] = 30
                            mem[_13976 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor1[address(msg.sender)]:
                                _14292 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14292 + 68] = mem[idx + _13976 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14292 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14292 + -mem[64] + 100
                            if stor1[address(msg.sender)] < 0:
                                revert with 0, 17
                            if stor1[arg1] > -1:
                                revert with 0, 17
                            if stor1[arg1] < stor1[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] = stor1[arg1]
                            _17699 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_17699] = 30
                            mem[_17699 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor6:
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > -1:
                                    revert with 0, 17
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg2, msg.sender, arg1);
                                return 1
                            _18095 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _18095 + 68] = mem[idx + _17699 + 32]
                                idx = idx + 32
                                continue 
                            mem[_18095 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _18095 + -mem[64] + 100
                        if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                            revert with 0, 17
                        if not arg2:
                            revert with 0, 18
                        if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _13520 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13520] = 30
                        mem[_13520 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg2 * stor6 / 1000 * 10^18:
                            _13687 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13687 + 68] = mem[idx + _13520 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13687 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13687 + -mem[64] + 100
                        if arg2 * stor6 / 1000 * 10^18 < 0:
                            revert with 0, 17
                        mem[0] = msg.sender
                        mem[32] = 1
                        _15313 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15313] = 30
                        mem[_15313 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                            _15839 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _15839 + 68] = mem[idx + _15313 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15839 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _15839 + -mem[64] + 100
                        if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                            revert with 0, 17
                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                        if stor1[arg1] > !(arg2 * stor6 / 1000 * 10^18):
                            revert with 0, 17
                        if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) < stor1[arg1]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg1
                        mem[32] = 1
                        stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18)
                        _19260 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19260] = 30
                        mem[_19260 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= stor6:
                            if stor6 < 0:
                                revert with 0, 17
                            if totalFees > -1:
                                revert with 0, 17
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(arg2, msg.sender, arg1);
                            return 1
                        _19702 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _19702 + 68] = mem[idx + _19260 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19702 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _19702 + -mem[64] + 100
                    if t < stor6 / 1000 * 10^18:
                        if not arg2:
                            if 0 > stor1[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor1[address(msg.sender)] < 0:
                                revert with 0, 17
                            if stor1[arg1] > -1:
                                revert with 0, 17
                            if stor1[arg1] < stor1[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor1[address(arg1)] = stor1[arg1]
                        else:
                            if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                                revert with 0, 17
                            if not arg2:
                                revert with 0, 18
                            if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg2 * stor6 / 1000 * 10^18:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg2 * stor6 / 1000 * 10^18 < 0:
                                revert with 0, 17
                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                revert with 0, 17
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                            if stor1[arg1] > !(arg2 * stor6 / 1000 * 10^18):
                                revert with 0, 17
                            if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18)
                    else:
                        if not s:
                            revert with 0, 'SafeMath: division by zero', 0
                        if not arg2:
                            if 0 > stor1[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor1[address(msg.sender)] < 0:
                                revert with 0, 17
                            if stor1[arg1] > -1:
                                revert with 0, 17
                            if stor1[arg1] < stor1[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor1[address(arg1)] = stor1[arg1]
                        else:
                            if arg2 and t / s > -1 / arg2:
                                revert with 0, 17
                            if not arg2:
                                revert with 0, 18
                            if arg2 * t / s / arg2 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg2 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg2 * t / s < 0:
                                revert with 0, 17
                            if arg2 * t / s > stor1[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor1[address(msg.sender)] < arg2 * t / s:
                                revert with 0, 17
                            stor1[address(msg.sender)] += -1 * arg2 * t / s
                            if stor1[arg1] > !(arg2 * t / s):
                                revert with 0, 17
                            if stor1[arg1] + (arg2 * t / s) < stor1[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor1[address(arg1)] = stor1[arg1] + (arg2 * t / s)
                    if 0 > stor6:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if stor6 < 0:
                        revert with 0, 17
                    if totalFees > -1:
                        revert with 0, 17
                    if totalFees < totalFees:
                        revert with 0, 'SafeMath: addition overflow'
                    emit Transfer(arg2, msg.sender, arg1);
                else:
                    if arg2 / 100 and 5 > -1 / arg2 / 100:
                        revert with 0, 17
                    if not arg2 / 100:
                        revert with 0, 18
                    if 5 * arg2 / 100 / arg2 / 100 != 5:
                        revert with 0, 'SafeMath: multiplication overflow'
                    mem[64] = 224
                    mem[160] = 30
                    mem[192] = 'SafeMath: subtraction overflow'
                    if 5 * arg2 / 100 > arg2:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg2 < 5 * arg2 / 100:
                        revert with 0, 17
                    idx = 0
                    s = 1000 * 10^18
                    t = stor6
                    while idx < stor5.length:
                        mem[0] = stor5[idx]
                        mem[32] = 1
                        if stor1[stor5[idx]] > t:
                            _12300 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12300] = 26
                            mem[_12300 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                if not 5 * arg2 / 100:
                                    _12991 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12991] = 30
                                    mem[_12991 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _13683 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13683] = 30
                                    mem[_13683 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _13970 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13970 + 68] = mem[idx + _13683 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13970 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13970 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > -1:
                                        revert with 0, 17
                                    if stor1[arg1] < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1]
                                    _17229 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17229] = 30
                                    mem[_17229 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > !(5 * arg2 / 100):
                                            revert with 0, 17
                                        if totalFees + (5 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 5 * arg2 / 100
                                        emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _17693 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _17693 + 68] = mem[idx + _17229 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_17693 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _17693 + -mem[64] + 100
                                if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                    revert with 0, 17
                                if not 5 * arg2 / 100:
                                    revert with 0, 18
                                if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _13265 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13265] = 30
                                mem[_13265 + 32] = 'SafeMath: subtraction overflow'
                                if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > 0:
                                    _13516 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13516 + 68] = mem[idx + _13265 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13516 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13516 + -mem[64] + 100
                                if 0 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                    revert with 0, 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _14795 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14795] = 30
                                mem[_14795 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _15305 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _15305 + 68] = mem[idx + _14795 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15305 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _15305 + -mem[64] + 100
                                if stor1[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor1[arg1] > !(-5 * arg2 / 100 * stor6 / 1000 * 10^18):
                                    revert with 0, 17
                                if stor1[arg1] - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[arg1] - (5 * arg2 / 100 * stor6 / 1000 * 10^18)
                                _18883 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18883] = 30
                                mem[_18883 + 32] = 'SafeMath: subtraction overflow'
                                if 5 * arg2 / 100 * stor6 / 1000 * 10^18 <= stor6:
                                    if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                                    if totalFees > !(5 * arg2 / 100):
                                        revert with 0, 17
                                    if totalFees + (5 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 5 * arg2 / 100
                                    emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _19252 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _19252 + 68] = mem[idx + _18883 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19252 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _19252 + -mem[64] + 100
                            if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                                revert with 0, 17
                            if not arg2:
                                revert with 0, 18
                            if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 5 * arg2 / 100:
                                _13264 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13264] = 30
                                mem[_13264 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor6 / 1000 * 10^18:
                                    _13515 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13515 + 68] = mem[idx + _13264 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13515 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13515 + -mem[64] + 100
                                if arg2 * stor6 / 1000 * 10^18 < 0:
                                    revert with 0, 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _14794 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14794] = 30
                                mem[_14794 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                    _15304 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _15304 + 68] = mem[idx + _14794 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15304 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _15304 + -mem[64] + 100
                                if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                if stor1[arg1] > !(arg2 * stor6 / 1000 * 10^18):
                                    revert with 0, 17
                                if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18)
                                _18882 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18882] = 30
                                mem[_18882 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > !(5 * arg2 / 100):
                                        revert with 0, 17
                                    if totalFees + (5 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 5 * arg2 / 100
                                    emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _19251 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _19251 + 68] = mem[idx + _18882 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19251 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _19251 + -mem[64] + 100
                            if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                revert with 0, 17
                            if not 5 * arg2 / 100:
                                revert with 0, 18
                            if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _13969 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13969] = 30
                            mem[_13969 + 32] = 'SafeMath: subtraction overflow'
                            if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                _14284 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14284 + 68] = mem[idx + _13969 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14284 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14284 + -mem[64] + 100
                            if arg2 * stor6 / 1000 * 10^18 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                revert with 0, 17
                            mem[0] = msg.sender
                            mem[32] = 1
                            _16347 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16347] = 30
                            mem[_16347 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                _16968 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _16968 + 68] = mem[idx + _16347 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_16968 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _16968 + -mem[64] + 100
                            if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                revert with 0, 17
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                            if stor1[arg1] > !((arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)):
                                revert with 0, 17
                            if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)
                            _20276 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20276] = 30
                            mem[_20276 + 32] = 'SafeMath: subtraction overflow'
                            if 5 * arg2 / 100 * stor6 / 1000 * 10^18 <= stor6:
                                if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                    revert with 0, 17
                                stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                                if totalFees > !(5 * arg2 / 100):
                                    revert with 0, 17
                                if totalFees + (5 * arg2 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 5 * arg2 / 100
                                emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                return 1
                            _20648 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _20648 + 68] = mem[idx + _20276 + 32]
                                idx = idx + 32
                                continue 
                            mem[_20648 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _20648 + -mem[64] + 100
                        if idx >= stor5.length:
                            revert with 0, 50
                        mem[0] = stor5[idx]
                        mem[32] = 2
                        if stor2[stor5[idx]] <= s:
                            if idx >= stor5.length:
                                revert with 0, 50
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            _12390 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12390] = 30
                            mem[_12390 + 32] = 'SafeMath: subtraction overflow'
                            if stor1[stor5[idx]] > t:
                                _12450 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _12450 + 68] = mem[idx + _12390 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12450 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12450 + -mem[64] + 100
                            if t < stor1[stor5[idx]]:
                                revert with 0, 17
                            if idx >= stor5.length:
                                revert with 0, 50
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            _12781 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12781] = 30
                            mem[_12781 + 32] = 'SafeMath: subtraction overflow'
                            if stor2[stor5[idx]] <= s:
                                if s < stor2[stor5[idx]]:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s - stor2[stor5[idx]]
                                t = t - stor1[stor5[idx]]
                                continue 
                            _12841 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12841 + 68] = mem[idx + _12781 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12841 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12841 + -mem[64] + 100
                        _12391 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12391] = 26
                        mem[_12391 + 32] = 'SafeMath: division by zero'
                        if not arg2:
                            if not 5 * arg2 / 100:
                                _13141 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13141] = 30
                                mem[_13141 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = msg.sender
                                mem[32] = 1
                                _13972 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13972] = 30
                                mem[_13972 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _14288 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _14288 + 68] = mem[idx + _13972 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14288 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14288 + -mem[64] + 100
                                if stor1[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor1[arg1] > -1:
                                    revert with 0, 17
                                if stor1[arg1] < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[arg1]
                                _17695 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17695] = 30
                                mem[_17695 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > !(5 * arg2 / 100):
                                        revert with 0, 17
                                    if totalFees + (5 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 5 * arg2 / 100
                                    emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _18082 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _18082 + 68] = mem[idx + _17695 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_18082 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _18082 + -mem[64] + 100
                            if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                revert with 0, 17
                            if not 5 * arg2 / 100:
                                revert with 0, 18
                            if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _13518 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13518] = 30
                            mem[_13518 + 32] = 'SafeMath: subtraction overflow'
                            if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > 0:
                                _13685 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13685 + 68] = mem[idx + _13518 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13685 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13685 + -mem[64] + 100
                            if 0 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                revert with 0, 17
                            mem[0] = msg.sender
                            mem[32] = 1
                            _15308 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15308] = 30
                            mem[_15308 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor1[address(msg.sender)]:
                                _15835 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15835 + 68] = mem[idx + _15308 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15835 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15835 + -mem[64] + 100
                            if stor1[address(msg.sender)] < 0:
                                revert with 0, 17
                            if stor1[arg1] > !(-5 * arg2 / 100 * stor6 / 1000 * 10^18):
                                revert with 0, 17
                            if stor1[arg1] - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] = stor1[arg1] - (5 * arg2 / 100 * stor6 / 1000 * 10^18)
                            _19255 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19255] = 30
                            mem[_19255 + 32] = 'SafeMath: subtraction overflow'
                            if 5 * arg2 / 100 * stor6 / 1000 * 10^18 <= stor6:
                                if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                    revert with 0, 17
                                stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                                if totalFees > !(5 * arg2 / 100):
                                    revert with 0, 17
                                if totalFees + (5 * arg2 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 5 * arg2 / 100
                                emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                return 1
                            _19696 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _19696 + 68] = mem[idx + _19255 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19696 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19696 + -mem[64] + 100
                        if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                            revert with 0, 17
                        if not arg2:
                            revert with 0, 18
                        if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 5 * arg2 / 100:
                            _13517 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13517] = 30
                            mem[_13517 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg2 * stor6 / 1000 * 10^18:
                                _13684 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13684 + 68] = mem[idx + _13517 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13684 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13684 + -mem[64] + 100
                            if arg2 * stor6 / 1000 * 10^18 < 0:
                                revert with 0, 17
                            mem[0] = msg.sender
                            mem[32] = 1
                            _15307 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15307] = 30
                            mem[_15307 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                _15834 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15834 + 68] = mem[idx + _15307 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15834 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15834 + -mem[64] + 100
                            if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                revert with 0, 17
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                            if stor1[arg1] > !(arg2 * stor6 / 1000 * 10^18):
                                revert with 0, 17
                            if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18)
                            _19254 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19254] = 30
                            mem[_19254 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor6:
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > !(5 * arg2 / 100):
                                    revert with 0, 17
                                if totalFees + (5 * arg2 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 5 * arg2 / 100
                                emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                return 1
                            _19695 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _19695 + 68] = mem[idx + _19254 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19695 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19695 + -mem[64] + 100
                        if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                            revert with 0, 17
                        if not 5 * arg2 / 100:
                            revert with 0, 18
                        if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _14287 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14287] = 30
                        mem[_14287 + 32] = 'SafeMath: subtraction overflow'
                        if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                            _14796 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _14796 + 68] = mem[idx + _14287 + 32]
                                idx = idx + 32
                                continue 
                            mem[_14796 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14796 + -mem[64] + 100
                        if arg2 * stor6 / 1000 * 10^18 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                            revert with 0, 17
                        mem[0] = msg.sender
                        mem[32] = 1
                        _16971 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16971] = 30
                        mem[_16971 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                            _17586 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _17586 + 68] = mem[idx + _16971 + 32]
                                idx = idx + 32
                                continue 
                            mem[_17586 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _17586 + -mem[64] + 100
                        if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                            revert with 0, 17
                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                        if stor1[arg1] > !((arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)):
                            revert with 0, 17
                        if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[arg1]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg1
                        mem[32] = 1
                        stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)
                        _20652 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_20652] = 30
                        mem[_20652 + 32] = 'SafeMath: subtraction overflow'
                        if 5 * arg2 / 100 * stor6 / 1000 * 10^18 <= stor6:
                            if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                revert with 0, 17
                            stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                            if totalFees > !(5 * arg2 / 100):
                                revert with 0, 17
                            if totalFees + (5 * arg2 / 100) < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += 5 * arg2 / 100
                            emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                            return 1
                        _21149 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _21149 + 68] = mem[idx + _20652 + 32]
                            idx = idx + 32
                            continue 
                        mem[_21149 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _21149 + -mem[64] + 100
                    if t < stor6 / 1000 * 10^18:
                        if not arg2:
                            if not 5 * arg2 / 100:
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor1[arg1] > -1:
                                    revert with 0, 17
                                if stor1[arg1] < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] = stor1[arg1]
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 0:
                                    revert with 0, 17
                            else:
                                if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                    revert with 0, 17
                                if not 5 * arg2 / 100:
                                    revert with 0, 18
                                if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                    revert with 0, 17
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor1[arg1] > !(-5 * arg2 / 100 * stor6 / 1000 * 10^18):
                                    revert with 0, 17
                                if stor1[arg1] - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] = stor1[arg1] - (5 * arg2 / 100 * stor6 / 1000 * 10^18)
                                if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                    revert with 0, 17
                                stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                        else:
                            if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                                revert with 0, 17
                            if not arg2:
                                revert with 0, 18
                            if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 5 * arg2 / 100:
                                if 0 > arg2 * stor6 / 1000 * 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg2 * stor6 / 1000 * 10^18 < 0:
                                    revert with 0, 17
                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                if stor1[arg1] > !(arg2 * stor6 / 1000 * 10^18):
                                    revert with 0, 17
                                if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18)
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 0:
                                    revert with 0, 17
                            else:
                                if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                    revert with 0, 17
                                if not 5 * arg2 / 100:
                                    revert with 0, 18
                                if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg2 * stor6 / 1000 * 10^18 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                    revert with 0, 17
                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                if stor1[arg1] > !((arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)):
                                    revert with 0, 17
                                if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)
                                if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                    revert with 0, 17
                                stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                    else:
                        if not s:
                            revert with 0, 'SafeMath: division by zero', 0
                        if not arg2:
                            if not 5 * arg2 / 100:
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor1[arg1] > -1:
                                    revert with 0, 17
                                if stor1[arg1] < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] = stor1[arg1]
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 0:
                                    revert with 0, 17
                            else:
                                if 5 * arg2 / 100 and t / s > -1 / 5 * arg2 / 100:
                                    revert with 0, 17
                                if not 5 * arg2 / 100:
                                    revert with 0, 18
                                if 5 * arg2 / 100 * t / s / 5 * arg2 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 5 * arg2 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 5 * arg2 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor1[arg1] > !(-5 * arg2 / 100 * t / s):
                                    revert with 0, 17
                                if stor1[arg1] - (5 * arg2 / 100 * t / s) < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] = stor1[arg1] - (5 * arg2 / 100 * t / s)
                                if 5 * arg2 / 100 * t / s > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 5 * arg2 / 100 * t / s:
                                    revert with 0, 17
                                stor6 += -5 * arg2 / 100 * t / s
                        else:
                            if arg2 and t / s > -1 / arg2:
                                revert with 0, 17
                            if not arg2:
                                revert with 0, 18
                            if arg2 * t / s / arg2 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 5 * arg2 / 100:
                                if 0 > arg2 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg2 * t / s < 0:
                                    revert with 0, 17
                                if arg2 * t / s > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < arg2 * t / s:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * t / s
                                if stor1[arg1] > !(arg2 * t / s):
                                    revert with 0, 17
                                if stor1[arg1] + (arg2 * t / s) < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] = stor1[arg1] + (arg2 * t / s)
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 0:
                                    revert with 0, 17
                            else:
                                if 5 * arg2 / 100 and t / s > -1 / 5 * arg2 / 100:
                                    revert with 0, 17
                                if not 5 * arg2 / 100:
                                    revert with 0, 18
                                if 5 * arg2 / 100 * t / s / 5 * arg2 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 5 * arg2 / 100 * t / s > arg2 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg2 * t / s < 5 * arg2 / 100 * t / s:
                                    revert with 0, 17
                                if arg2 * t / s > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < arg2 * t / s:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * t / s
                                if stor1[arg1] > !((arg2 * t / s) - (5 * arg2 / 100 * t / s)):
                                    revert with 0, 17
                                if stor1[arg1] + (arg2 * t / s) - (5 * arg2 / 100 * t / s) < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] = stor1[arg1] + (arg2 * t / s) - (5 * arg2 / 100 * t / s)
                                if 5 * arg2 / 100 * t / s > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 5 * arg2 / 100 * t / s:
                                    revert with 0, 17
                                stor6 += -5 * arg2 / 100 * t / s
                    if totalFees > !(5 * arg2 / 100):
                        revert with 0, 17
                    if totalFees + (5 * arg2 / 100) < totalFees:
                        revert with 0, 'SafeMath: addition overflow'
                    totalFees += 5 * arg2 / 100
                    emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
            else:
                mem[0] = arg1
                mem[32] = 4
                mem[96] = 26
                mem[128] = 'SafeMath: division by zero'
                if stor4[address(arg1)]:
                    if not arg2 / 100:
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if 0 > arg2:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg2 < 0:
                            revert with 0, 17
                        idx = 0
                        s = 1000 * 10^18
                        t = stor6
                        while idx < stor5.length:
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            if stor1[stor5[idx]] > t:
                                _12303 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12303] = 26
                                mem[_12303 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    _13000 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13000] = 30
                                    mem[_13000 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _13694 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13694] = 30
                                    mem[_13694 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _13987 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13987 + 68] = mem[idx + _13694 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13987 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13987 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > -1:
                                        revert with 0, 17
                                    if stor1[arg1] < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1]
                                    _17264 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17264] = 30
                                    mem[_17264 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > -1:
                                            revert with 0, 17
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _17712 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _17712 + 68] = mem[idx + _17264 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_17712 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _17712 + -mem[64] + 100
                                if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _13283 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13283] = 30
                                mem[_13283 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor6 / 1000 * 10^18:
                                    _13525 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13525 + 68] = mem[idx + _13283 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13525 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13525 + -mem[64] + 100
                                if arg2 * stor6 / 1000 * 10^18 < 0:
                                    revert with 0, 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _14814 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14814] = 30
                                mem[_14814 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                    _15325 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _15325 + 68] = mem[idx + _14814 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15325 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _15325 + -mem[64] + 100
                                if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                if stor1[arg1] > !(arg2 * stor6 / 1000 * 10^18):
                                    revert with 0, 17
                                if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18)
                                _18911 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18911] = 30
                                mem[_18911 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > -1:
                                        revert with 0, 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _19272 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _19272 + 68] = mem[idx + _18911 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19272 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _19272 + -mem[64] + 100
                            if idx >= stor5.length:
                                revert with 0, 50
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            if stor2[stor5[idx]] <= s:
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                _12396 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12396] = 30
                                mem[_12396 + 32] = 'SafeMath: subtraction overflow'
                                if stor1[stor5[idx]] > t:
                                    _12453 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _12453 + 68] = mem[idx + _12396 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12453 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12453 + -mem[64] + 100
                                if t < stor1[stor5[idx]]:
                                    revert with 0, 17
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                _12787 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12787] = 30
                                mem[_12787 + 32] = 'SafeMath: subtraction overflow'
                                if stor2[stor5[idx]] <= s:
                                    if s < stor2[stor5[idx]]:
                                        revert with 0, 17
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s - stor2[stor5[idx]]
                                    t = t - stor1[stor5[idx]]
                                    continue 
                                _12847 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _12847 + 68] = mem[idx + _12787 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12847 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12847 + -mem[64] + 100
                            _12397 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12397] = 26
                            mem[_12397 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                _13147 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13147] = 30
                                mem[_13147 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = msg.sender
                                mem[32] = 1
                                _13988 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13988] = 30
                                mem[_13988 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _14305 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _14305 + 68] = mem[idx + _13988 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14305 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14305 + -mem[64] + 100
                                if stor1[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor1[arg1] > -1:
                                    revert with 0, 17
                                if stor1[arg1] < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[arg1]
                                _17713 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17713] = 30
                                mem[_17713 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > -1:
                                        revert with 0, 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _18133 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _18133 + 68] = mem[idx + _17713 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_18133 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _18133 + -mem[64] + 100
                            if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                                revert with 0, 17
                            if not arg2:
                                revert with 0, 18
                            if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _13526 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13526] = 30
                            mem[_13526 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg2 * stor6 / 1000 * 10^18:
                                _13695 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13695 + 68] = mem[idx + _13526 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13695 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13695 + -mem[64] + 100
                            if arg2 * stor6 / 1000 * 10^18 < 0:
                                revert with 0, 17
                            mem[0] = msg.sender
                            mem[32] = 1
                            _15327 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15327] = 30
                            mem[_15327 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                _15853 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15853 + 68] = mem[idx + _15327 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15853 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15853 + -mem[64] + 100
                            if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                revert with 0, 17
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                            if stor1[arg1] > !(arg2 * stor6 / 1000 * 10^18):
                                revert with 0, 17
                            if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18)
                            _19274 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19274] = 30
                            mem[_19274 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor6:
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > -1:
                                    revert with 0, 17
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg2, msg.sender, arg1);
                                return 1
                            _19727 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _19727 + 68] = mem[idx + _19274 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19727 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19727 + -mem[64] + 100
                        if t < stor6 / 1000 * 10^18:
                            if not arg2:
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor1[arg1] > -1:
                                    revert with 0, 17
                                if stor1[arg1] < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] = stor1[arg1]
                            else:
                                if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > arg2 * stor6 / 1000 * 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg2 * stor6 / 1000 * 10^18 < 0:
                                    revert with 0, 17
                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                if stor1[arg1] > !(arg2 * stor6 / 1000 * 10^18):
                                    revert with 0, 17
                                if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18)
                        else:
                            if not s:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not arg2:
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor1[arg1] > -1:
                                    revert with 0, 17
                                if stor1[arg1] < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] = stor1[arg1]
                            else:
                                if arg2 and t / s > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * t / s / arg2 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > arg2 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg2 * t / s < 0:
                                    revert with 0, 17
                                if arg2 * t / s > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < arg2 * t / s:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * t / s
                                if stor1[arg1] > !(arg2 * t / s):
                                    revert with 0, 17
                                if stor1[arg1] + (arg2 * t / s) < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] = stor1[arg1] + (arg2 * t / s)
                        if 0 > stor6:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor6 < 0:
                            revert with 0, 17
                        if totalFees > -1:
                            revert with 0, 17
                        if totalFees < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        emit Transfer(arg2, msg.sender, arg1);
                    else:
                        if arg2 / 100 and 5 > -1 / arg2 / 100:
                            revert with 0, 17
                        if not arg2 / 100:
                            revert with 0, 18
                        if 5 * arg2 / 100 / arg2 / 100 != 5:
                            revert with 0, 'SafeMath: multiplication overflow'
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if 5 * arg2 / 100 > arg2:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg2 < 5 * arg2 / 100:
                            revert with 0, 17
                        idx = 0
                        s = 1000 * 10^18
                        t = stor6
                        while idx < stor5.length:
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            if stor1[stor5[idx]] > t:
                                _12302 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12302] = 26
                                mem[_12302 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not 5 * arg2 / 100:
                                        _12997 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12997] = 30
                                        mem[_12997 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _13691 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13691] = 30
                                        mem[_13691 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _13982 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _13982 + 68] = mem[idx + _13691 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_13982 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _13982 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > -1:
                                            revert with 0, 17
                                        if stor1[arg1] < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[arg1]
                                        _17253 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17253] = 30
                                        mem[_17253 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > !(5 * arg2 / 100):
                                                revert with 0, 17
                                            if totalFees + (5 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 5 * arg2 / 100
                                            emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _17707 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _17707 + 68] = mem[idx + _17253 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17707 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _17707 + -mem[64] + 100
                                    if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                        revert with 0, 17
                                    if not 5 * arg2 / 100:
                                        revert with 0, 18
                                    if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _13277 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13277] = 30
                                    mem[_13277 + 32] = 'SafeMath: subtraction overflow'
                                    if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > 0:
                                        _13522 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13522 + 68] = mem[idx + _13277 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13522 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13522 + -mem[64] + 100
                                    if 0 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _14808 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14808] = 30
                                    mem[_14808 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _15319 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _15319 + 68] = mem[idx + _14808 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_15319 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _15319 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > !(-5 * arg2 / 100 * stor6 / 1000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg1] - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1] - (5 * arg2 / 100 * stor6 / 1000 * 10^18)
                                    _18901 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18901] = 30
                                    mem[_18901 + 32] = 'SafeMath: subtraction overflow'
                                    if 5 * arg2 / 100 * stor6 / 1000 * 10^18 <= stor6:
                                        if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                            revert with 0, 17
                                        stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                                        if totalFees > !(5 * arg2 / 100):
                                            revert with 0, 17
                                        if totalFees + (5 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 5 * arg2 / 100
                                        emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _19266 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19266 + 68] = mem[idx + _18901 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19266 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19266 + -mem[64] + 100
                                if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 5 * arg2 / 100:
                                    _13276 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13276] = 30
                                    mem[_13276 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 1000 * 10^18:
                                        _13521 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13521 + 68] = mem[idx + _13276 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13521 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13521 + -mem[64] + 100
                                    if arg2 * stor6 / 1000 * 10^18 < 0:
                                        revert with 0, 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _14807 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14807] = 30
                                    mem[_14807 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        _15318 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _15318 + 68] = mem[idx + _14807 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_15318 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _15318 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor1[arg1] > !(arg2 * stor6 / 1000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18)
                                    _18900 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18900] = 30
                                    mem[_18900 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > !(5 * arg2 / 100):
                                            revert with 0, 17
                                        if totalFees + (5 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 5 * arg2 / 100
                                        emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _19265 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19265 + 68] = mem[idx + _18900 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19265 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19265 + -mem[64] + 100
                                if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                    revert with 0, 17
                                if not 5 * arg2 / 100:
                                    revert with 0, 18
                                if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _13981 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13981] = 30
                                mem[_13981 + 32] = 'SafeMath: subtraction overflow'
                                if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                    _14297 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _14297 + 68] = mem[idx + _13981 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14297 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14297 + -mem[64] + 100
                                if arg2 * stor6 / 1000 * 10^18 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                    revert with 0, 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _16357 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16357] = 30
                                mem[_16357 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                    _16985 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _16985 + 68] = mem[idx + _16357 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_16985 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _16985 + -mem[64] + 100
                                if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                if stor1[arg1] > !((arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)):
                                    revert with 0, 17
                                if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)
                                _20287 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20287] = 30
                                mem[_20287 + 32] = 'SafeMath: subtraction overflow'
                                if 5 * arg2 / 100 * stor6 / 1000 * 10^18 <= stor6:
                                    if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                                    if totalFees > !(5 * arg2 / 100):
                                        revert with 0, 17
                                    if totalFees + (5 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 5 * arg2 / 100
                                    emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _20667 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20667 + 68] = mem[idx + _20287 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20667 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20667 + -mem[64] + 100
                            if idx >= stor5.length:
                                revert with 0, 50
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            if stor2[stor5[idx]] <= s:
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                _12394 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12394] = 30
                                mem[_12394 + 32] = 'SafeMath: subtraction overflow'
                                if stor1[stor5[idx]] > t:
                                    _12452 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _12452 + 68] = mem[idx + _12394 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12452 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12452 + -mem[64] + 100
                                if t < stor1[stor5[idx]]:
                                    revert with 0, 17
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                _12785 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12785] = 30
                                mem[_12785 + 32] = 'SafeMath: subtraction overflow'
                                if stor2[stor5[idx]] <= s:
                                    if s < stor2[stor5[idx]]:
                                        revert with 0, 17
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s - stor2[stor5[idx]]
                                    t = t - stor1[stor5[idx]]
                                    continue 
                                _12845 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _12845 + 68] = mem[idx + _12785 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12845 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12845 + -mem[64] + 100
                            _12395 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12395] = 26
                            mem[_12395 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                if not 5 * arg2 / 100:
                                    _13145 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13145] = 30
                                    mem[_13145 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _13984 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13984] = 30
                                    mem[_13984 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _14301 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _14301 + 68] = mem[idx + _13984 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14301 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14301 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > -1:
                                        revert with 0, 17
                                    if stor1[arg1] < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1]
                                    _17709 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17709] = 30
                                    mem[_17709 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > !(5 * arg2 / 100):
                                            revert with 0, 17
                                        if totalFees + (5 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 5 * arg2 / 100
                                        emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _18120 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _18120 + 68] = mem[idx + _17709 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18120 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _18120 + -mem[64] + 100
                                if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                    revert with 0, 17
                                if not 5 * arg2 / 100:
                                    revert with 0, 18
                                if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _13524 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13524] = 30
                                mem[_13524 + 32] = 'SafeMath: subtraction overflow'
                                if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > 0:
                                    _13693 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13693 + 68] = mem[idx + _13524 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13693 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13693 + -mem[64] + 100
                                if 0 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                    revert with 0, 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _15322 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15322] = 30
                                mem[_15322 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _15849 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _15849 + 68] = mem[idx + _15322 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15849 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _15849 + -mem[64] + 100
                                if stor1[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor1[arg1] > !(-5 * arg2 / 100 * stor6 / 1000 * 10^18):
                                    revert with 0, 17
                                if stor1[arg1] - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[arg1] - (5 * arg2 / 100 * stor6 / 1000 * 10^18)
                                _19269 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19269] = 30
                                mem[_19269 + 32] = 'SafeMath: subtraction overflow'
                                if 5 * arg2 / 100 * stor6 / 1000 * 10^18 <= stor6:
                                    if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                                    if totalFees > !(5 * arg2 / 100):
                                        revert with 0, 17
                                    if totalFees + (5 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 5 * arg2 / 100
                                    emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _19721 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _19721 + 68] = mem[idx + _19269 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19721 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _19721 + -mem[64] + 100
                            if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                                revert with 0, 17
                            if not arg2:
                                revert with 0, 18
                            if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 5 * arg2 / 100:
                                _13523 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13523] = 30
                                mem[_13523 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor6 / 1000 * 10^18:
                                    _13692 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13692 + 68] = mem[idx + _13523 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13692 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13692 + -mem[64] + 100
                                if arg2 * stor6 / 1000 * 10^18 < 0:
                                    revert with 0, 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _15321 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15321] = 30
                                mem[_15321 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                    _15848 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _15848 + 68] = mem[idx + _15321 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15848 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _15848 + -mem[64] + 100
                                if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                if stor1[arg1] > !(arg2 * stor6 / 1000 * 10^18):
                                    revert with 0, 17
                                if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18)
                                _19268 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19268] = 30
                                mem[_19268 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > !(5 * arg2 / 100):
                                        revert with 0, 17
                                    if totalFees + (5 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 5 * arg2 / 100
                                    emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _19720 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _19720 + 68] = mem[idx + _19268 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19720 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _19720 + -mem[64] + 100
                            if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                revert with 0, 17
                            if not 5 * arg2 / 100:
                                revert with 0, 18
                            if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _14300 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14300] = 30
                            mem[_14300 + 32] = 'SafeMath: subtraction overflow'
                            if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                _14809 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14809 + 68] = mem[idx + _14300 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14809 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14809 + -mem[64] + 100
                            if arg2 * stor6 / 1000 * 10^18 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                revert with 0, 17
                            mem[0] = msg.sender
                            mem[32] = 1
                            _16988 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16988] = 30
                            mem[_16988 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                _17592 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _17592 + 68] = mem[idx + _16988 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_17592 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _17592 + -mem[64] + 100
                            if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                revert with 0, 17
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                            if stor1[arg1] > !((arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)):
                                revert with 0, 17
                            if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)
                            _20671 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20671] = 30
                            mem[_20671 + 32] = 'SafeMath: subtraction overflow'
                            if 5 * arg2 / 100 * stor6 / 1000 * 10^18 <= stor6:
                                if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                    revert with 0, 17
                                stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                                if totalFees > !(5 * arg2 / 100):
                                    revert with 0, 17
                                if totalFees + (5 * arg2 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 5 * arg2 / 100
                                emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                return 1
                            _21159 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _21159 + 68] = mem[idx + _20671 + 32]
                                idx = idx + 32
                                continue 
                            mem[_21159 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _21159 + -mem[64] + 100
                        if t < stor6 / 1000 * 10^18:
                            if not arg2:
                                if not 5 * arg2 / 100:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > -1:
                                        revert with 0, 17
                                    if stor1[arg1] < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1]
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 0, 17
                                else:
                                    if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                        revert with 0, 17
                                    if not 5 * arg2 / 100:
                                        revert with 0, 18
                                    if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > !(-5 * arg2 / 100 * stor6 / 1000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg1] - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1] - (5 * arg2 / 100 * stor6 / 1000 * 10^18)
                                    if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                            else:
                                if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 5 * arg2 / 100:
                                    if 0 > arg2 * stor6 / 1000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * stor6 / 1000 * 10^18 < 0:
                                        revert with 0, 17
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor1[arg1] > !(arg2 * stor6 / 1000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18)
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 0, 17
                                else:
                                    if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                        revert with 0, 17
                                    if not 5 * arg2 / 100:
                                        revert with 0, 18
                                    if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * stor6 / 1000 * 10^18 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor1[arg1] > !((arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)
                                    if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                        else:
                            if not s:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not arg2:
                                if not 5 * arg2 / 100:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > -1:
                                        revert with 0, 17
                                    if stor1[arg1] < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1]
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 0, 17
                                else:
                                    if 5 * arg2 / 100 and t / s > -1 / 5 * arg2 / 100:
                                        revert with 0, 17
                                    if not 5 * arg2 / 100:
                                        revert with 0, 18
                                    if 5 * arg2 / 100 * t / s / 5 * arg2 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 5 * arg2 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 5 * arg2 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > !(-5 * arg2 / 100 * t / s):
                                        revert with 0, 17
                                    if stor1[arg1] - (5 * arg2 / 100 * t / s) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1] - (5 * arg2 / 100 * t / s)
                                    if 5 * arg2 / 100 * t / s > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 5 * arg2 / 100 * t / s:
                                        revert with 0, 17
                                    stor6 += -5 * arg2 / 100 * t / s
                            else:
                                if arg2 and t / s > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * t / s / arg2 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 5 * arg2 / 100:
                                    if 0 > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * t / s < 0:
                                        revert with 0, 17
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * t / s:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor1[arg1] > !(arg2 * t / s):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * t / s) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * t / s)
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 0, 17
                                else:
                                    if 5 * arg2 / 100 and t / s > -1 / 5 * arg2 / 100:
                                        revert with 0, 17
                                    if not 5 * arg2 / 100:
                                        revert with 0, 18
                                    if 5 * arg2 / 100 * t / s / 5 * arg2 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 5 * arg2 / 100 * t / s > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * t / s < 5 * arg2 / 100 * t / s:
                                        revert with 0, 17
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * t / s:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor1[arg1] > !((arg2 * t / s) - (5 * arg2 / 100 * t / s)):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * t / s) - (5 * arg2 / 100 * t / s) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * t / s) - (5 * arg2 / 100 * t / s)
                                    if 5 * arg2 / 100 * t / s > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 5 * arg2 / 100 * t / s:
                                        revert with 0, 17
                                    stor6 += -5 * arg2 / 100 * t / s
                        if totalFees > !(5 * arg2 / 100):
                            revert with 0, 17
                        if totalFees + (5 * arg2 / 100) < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        totalFees += 5 * arg2 / 100
                        emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                else:
                    if not arg2 / 100:
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if 0 > arg2:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg2 < 0:
                            revert with 0, 17
                        idx = 0
                        s = 1000 * 10^18
                        t = stor6
                        while idx < stor5.length:
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            if stor1[stor5[idx]] > t:
                                _12305 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12305] = 26
                                mem[_12305 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    _13006 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13006] = 30
                                    mem[_13006 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _13702 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13702] = 30
                                    mem[_13702 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _13999 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13999 + 68] = mem[idx + _13702 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13999 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13999 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > -1:
                                        revert with 0, 17
                                    if stor1[arg1] < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1]
                                    _17288 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17288] = 30
                                    mem[_17288 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > -1:
                                            revert with 0, 17
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _17726 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _17726 + 68] = mem[idx + _17288 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_17726 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _17726 + -mem[64] + 100
                                if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _13295 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13295] = 30
                                mem[_13295 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor6 / 1000 * 10^18:
                                    _13531 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13531 + 68] = mem[idx + _13295 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13531 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13531 + -mem[64] + 100
                                if arg2 * stor6 / 1000 * 10^18 < 0:
                                    revert with 0, 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _14827 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14827] = 30
                                mem[_14827 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                    _15339 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _15339 + 68] = mem[idx + _14827 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15339 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _15339 + -mem[64] + 100
                                if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                if stor1[arg1] > !(arg2 * stor6 / 1000 * 10^18):
                                    revert with 0, 17
                                if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18)
                                _18929 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18929] = 30
                                mem[_18929 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > -1:
                                        revert with 0, 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _19286 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _19286 + 68] = mem[idx + _18929 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19286 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _19286 + -mem[64] + 100
                            if idx >= stor5.length:
                                revert with 0, 50
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            if stor2[stor5[idx]] <= s:
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                _12400 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12400] = 30
                                mem[_12400 + 32] = 'SafeMath: subtraction overflow'
                                if stor1[stor5[idx]] > t:
                                    _12455 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _12455 + 68] = mem[idx + _12400 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12455 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12455 + -mem[64] + 100
                                if t < stor1[stor5[idx]]:
                                    revert with 0, 17
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                _12791 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12791] = 30
                                mem[_12791 + 32] = 'SafeMath: subtraction overflow'
                                if stor2[stor5[idx]] <= s:
                                    if s < stor2[stor5[idx]]:
                                        revert with 0, 17
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s - stor2[stor5[idx]]
                                    t = t - stor1[stor5[idx]]
                                    continue 
                                _12851 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _12851 + 68] = mem[idx + _12791 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12851 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12851 + -mem[64] + 100
                            _12401 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12401] = 26
                            mem[_12401 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                _13151 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13151] = 30
                                mem[_13151 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = msg.sender
                                mem[32] = 1
                                _14000 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14000] = 30
                                mem[_14000 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _14318 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _14318 + 68] = mem[idx + _14000 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14318 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14318 + -mem[64] + 100
                                if stor1[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor1[arg1] > -1:
                                    revert with 0, 17
                                if stor1[arg1] < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[arg1]
                                _17727 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17727] = 30
                                mem[_17727 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > -1:
                                        revert with 0, 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _18171 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _18171 + 68] = mem[idx + _17727 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_18171 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _18171 + -mem[64] + 100
                            if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                                revert with 0, 17
                            if not arg2:
                                revert with 0, 18
                            if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _13532 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13532] = 30
                            mem[_13532 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg2 * stor6 / 1000 * 10^18:
                                _13703 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13703 + 68] = mem[idx + _13532 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13703 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13703 + -mem[64] + 100
                            if arg2 * stor6 / 1000 * 10^18 < 0:
                                revert with 0, 17
                            mem[0] = msg.sender
                            mem[32] = 1
                            _15341 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15341] = 30
                            mem[_15341 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                _15867 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15867 + 68] = mem[idx + _15341 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15867 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15867 + -mem[64] + 100
                            if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                revert with 0, 17
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                            if stor1[arg1] > !(arg2 * stor6 / 1000 * 10^18):
                                revert with 0, 17
                            if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18)
                            _19288 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19288] = 30
                            mem[_19288 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor6:
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > -1:
                                    revert with 0, 17
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg2, msg.sender, arg1);
                                return 1
                            _19752 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _19752 + 68] = mem[idx + _19288 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19752 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19752 + -mem[64] + 100
                        if t < stor6 / 1000 * 10^18:
                            if not arg2:
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor1[arg1] > -1:
                                    revert with 0, 17
                                if stor1[arg1] < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] = stor1[arg1]
                            else:
                                if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > arg2 * stor6 / 1000 * 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg2 * stor6 / 1000 * 10^18 < 0:
                                    revert with 0, 17
                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                if stor1[arg1] > !(arg2 * stor6 / 1000 * 10^18):
                                    revert with 0, 17
                                if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18)
                        else:
                            if not s:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not arg2:
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor1[arg1] > -1:
                                    revert with 0, 17
                                if stor1[arg1] < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] = stor1[arg1]
                            else:
                                if arg2 and t / s > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * t / s / arg2 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > arg2 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg2 * t / s < 0:
                                    revert with 0, 17
                                if arg2 * t / s > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < arg2 * t / s:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * t / s
                                if stor1[arg1] > !(arg2 * t / s):
                                    revert with 0, 17
                                if stor1[arg1] + (arg2 * t / s) < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] = stor1[arg1] + (arg2 * t / s)
                        if 0 > stor6:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor6 < 0:
                            revert with 0, 17
                        if totalFees > -1:
                            revert with 0, 17
                        if totalFees < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        emit Transfer(arg2, msg.sender, arg1);
                    else:
                        if arg2 / 100 and 5 > -1 / arg2 / 100:
                            revert with 0, 17
                        if not arg2 / 100:
                            revert with 0, 18
                        if 5 * arg2 / 100 / arg2 / 100 != 5:
                            revert with 0, 'SafeMath: multiplication overflow'
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if 5 * arg2 / 100 > arg2:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg2 < 5 * arg2 / 100:
                            revert with 0, 17
                        idx = 0
                        s = 1000 * 10^18
                        t = stor6
                        while idx < stor5.length:
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            if stor1[stor5[idx]] > t:
                                _12304 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12304] = 26
                                mem[_12304 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not 5 * arg2 / 100:
                                        _13003 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13003] = 30
                                        mem[_13003 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _13699 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13699] = 30
                                        mem[_13699 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _13994 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _13994 + 68] = mem[idx + _13699 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_13994 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _13994 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > -1:
                                            revert with 0, 17
                                        if stor1[arg1] < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[arg1]
                                        _17277 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17277] = 30
                                        mem[_17277 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > !(5 * arg2 / 100):
                                                revert with 0, 17
                                            if totalFees + (5 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 5 * arg2 / 100
                                            emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _17721 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _17721 + 68] = mem[idx + _17277 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17721 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _17721 + -mem[64] + 100
                                    if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                        revert with 0, 17
                                    if not 5 * arg2 / 100:
                                        revert with 0, 18
                                    if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _13289 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13289] = 30
                                    mem[_13289 + 32] = 'SafeMath: subtraction overflow'
                                    if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > 0:
                                        _13528 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13528 + 68] = mem[idx + _13289 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13528 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13528 + -mem[64] + 100
                                    if 0 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _14821 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14821] = 30
                                    mem[_14821 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _15333 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _15333 + 68] = mem[idx + _14821 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_15333 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _15333 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > !(-5 * arg2 / 100 * stor6 / 1000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg1] - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1] - (5 * arg2 / 100 * stor6 / 1000 * 10^18)
                                    _18919 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18919] = 30
                                    mem[_18919 + 32] = 'SafeMath: subtraction overflow'
                                    if 5 * arg2 / 100 * stor6 / 1000 * 10^18 <= stor6:
                                        if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                            revert with 0, 17
                                        stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                                        if totalFees > !(5 * arg2 / 100):
                                            revert with 0, 17
                                        if totalFees + (5 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 5 * arg2 / 100
                                        emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _19280 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19280 + 68] = mem[idx + _18919 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19280 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19280 + -mem[64] + 100
                                if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 5 * arg2 / 100:
                                    _13288 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13288] = 30
                                    mem[_13288 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 1000 * 10^18:
                                        _13527 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13527 + 68] = mem[idx + _13288 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13527 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13527 + -mem[64] + 100
                                    if arg2 * stor6 / 1000 * 10^18 < 0:
                                        revert with 0, 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _14820 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14820] = 30
                                    mem[_14820 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        _15332 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _15332 + 68] = mem[idx + _14820 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_15332 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _15332 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor1[arg1] > !(arg2 * stor6 / 1000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18)
                                    _18918 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18918] = 30
                                    mem[_18918 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > !(5 * arg2 / 100):
                                            revert with 0, 17
                                        if totalFees + (5 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 5 * arg2 / 100
                                        emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _19279 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19279 + 68] = mem[idx + _18918 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19279 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19279 + -mem[64] + 100
                                if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                    revert with 0, 17
                                if not 5 * arg2 / 100:
                                    revert with 0, 18
                                if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _13993 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13993] = 30
                                mem[_13993 + 32] = 'SafeMath: subtraction overflow'
                                if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                    _14310 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _14310 + 68] = mem[idx + _13993 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14310 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14310 + -mem[64] + 100
                                if arg2 * stor6 / 1000 * 10^18 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                    revert with 0, 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _16367 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16367] = 30
                                mem[_16367 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                    _17002 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _17002 + 68] = mem[idx + _16367 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_17002 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _17002 + -mem[64] + 100
                                if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                if stor1[arg1] > !((arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)):
                                    revert with 0, 17
                                if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)
                                _20298 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20298] = 30
                                mem[_20298 + 32] = 'SafeMath: subtraction overflow'
                                if 5 * arg2 / 100 * stor6 / 1000 * 10^18 <= stor6:
                                    if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                                    if totalFees > !(5 * arg2 / 100):
                                        revert with 0, 17
                                    if totalFees + (5 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 5 * arg2 / 100
                                    emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _20686 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20686 + 68] = mem[idx + _20298 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20686 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20686 + -mem[64] + 100
                            if idx >= stor5.length:
                                revert with 0, 50
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            if stor2[stor5[idx]] <= s:
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                _12398 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12398] = 30
                                mem[_12398 + 32] = 'SafeMath: subtraction overflow'
                                if stor1[stor5[idx]] > t:
                                    _12454 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _12454 + 68] = mem[idx + _12398 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12454 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12454 + -mem[64] + 100
                                if t < stor1[stor5[idx]]:
                                    revert with 0, 17
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                _12789 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12789] = 30
                                mem[_12789 + 32] = 'SafeMath: subtraction overflow'
                                if stor2[stor5[idx]] <= s:
                                    if s < stor2[stor5[idx]]:
                                        revert with 0, 17
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s - stor2[stor5[idx]]
                                    t = t - stor1[stor5[idx]]
                                    continue 
                                _12849 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _12849 + 68] = mem[idx + _12789 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12849 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12849 + -mem[64] + 100
                            _12399 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12399] = 26
                            mem[_12399 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                if not 5 * arg2 / 100:
                                    _13149 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13149] = 30
                                    mem[_13149 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _13996 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13996] = 30
                                    mem[_13996 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _14314 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _14314 + 68] = mem[idx + _13996 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14314 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14314 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > -1:
                                        revert with 0, 17
                                    if stor1[arg1] < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1]
                                    _17723 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17723] = 30
                                    mem[_17723 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > !(5 * arg2 / 100):
                                            revert with 0, 17
                                        if totalFees + (5 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 5 * arg2 / 100
                                        emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _18158 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _18158 + 68] = mem[idx + _17723 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18158 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _18158 + -mem[64] + 100
                                if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                    revert with 0, 17
                                if not 5 * arg2 / 100:
                                    revert with 0, 18
                                if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _13530 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13530] = 30
                                mem[_13530 + 32] = 'SafeMath: subtraction overflow'
                                if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > 0:
                                    _13701 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13701 + 68] = mem[idx + _13530 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13701 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13701 + -mem[64] + 100
                                if 0 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                    revert with 0, 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _15336 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15336] = 30
                                mem[_15336 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _15863 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _15863 + 68] = mem[idx + _15336 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15863 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _15863 + -mem[64] + 100
                                if stor1[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor1[arg1] > !(-5 * arg2 / 100 * stor6 / 1000 * 10^18):
                                    revert with 0, 17
                                if stor1[arg1] - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[arg1] - (5 * arg2 / 100 * stor6 / 1000 * 10^18)
                                _19283 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19283] = 30
                                mem[_19283 + 32] = 'SafeMath: subtraction overflow'
                                if 5 * arg2 / 100 * stor6 / 1000 * 10^18 <= stor6:
                                    if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                                    if totalFees > !(5 * arg2 / 100):
                                        revert with 0, 17
                                    if totalFees + (5 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 5 * arg2 / 100
                                    emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _19746 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _19746 + 68] = mem[idx + _19283 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19746 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _19746 + -mem[64] + 100
                            if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                                revert with 0, 17
                            if not arg2:
                                revert with 0, 18
                            if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 5 * arg2 / 100:
                                _13529 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13529] = 30
                                mem[_13529 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor6 / 1000 * 10^18:
                                    _13700 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13700 + 68] = mem[idx + _13529 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13700 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13700 + -mem[64] + 100
                                if arg2 * stor6 / 1000 * 10^18 < 0:
                                    revert with 0, 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _15335 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15335] = 30
                                mem[_15335 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                    _15862 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _15862 + 68] = mem[idx + _15335 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15862 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _15862 + -mem[64] + 100
                                if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                if stor1[arg1] > !(arg2 * stor6 / 1000 * 10^18):
                                    revert with 0, 17
                                if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18)
                                _19282 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19282] = 30
                                mem[_19282 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > !(5 * arg2 / 100):
                                        revert with 0, 17
                                    if totalFees + (5 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 5 * arg2 / 100
                                    emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _19745 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _19745 + 68] = mem[idx + _19282 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19745 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _19745 + -mem[64] + 100
                            if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                revert with 0, 17
                            if not 5 * arg2 / 100:
                                revert with 0, 18
                            if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _14313 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14313] = 30
                            mem[_14313 + 32] = 'SafeMath: subtraction overflow'
                            if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                _14822 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14822 + 68] = mem[idx + _14313 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14822 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14822 + -mem[64] + 100
                            if arg2 * stor6 / 1000 * 10^18 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                revert with 0, 17
                            mem[0] = msg.sender
                            mem[32] = 1
                            _17005 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_17005] = 30
                            mem[_17005 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                _17598 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _17598 + 68] = mem[idx + _17005 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_17598 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _17598 + -mem[64] + 100
                            if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                revert with 0, 17
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                            if stor1[arg1] > !((arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)):
                                revert with 0, 17
                            if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)
                            _20690 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20690] = 30
                            mem[_20690 + 32] = 'SafeMath: subtraction overflow'
                            if 5 * arg2 / 100 * stor6 / 1000 * 10^18 <= stor6:
                                if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                    revert with 0, 17
                                stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                                if totalFees > !(5 * arg2 / 100):
                                    revert with 0, 17
                                if totalFees + (5 * arg2 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 5 * arg2 / 100
                                emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                return 1
                            _21169 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _21169 + 68] = mem[idx + _20690 + 32]
                                idx = idx + 32
                                continue 
                            mem[_21169 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _21169 + -mem[64] + 100
                        if t < stor6 / 1000 * 10^18:
                            if not arg2:
                                if not 5 * arg2 / 100:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > -1:
                                        revert with 0, 17
                                    if stor1[arg1] < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1]
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 0, 17
                                else:
                                    if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                        revert with 0, 17
                                    if not 5 * arg2 / 100:
                                        revert with 0, 18
                                    if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > !(-5 * arg2 / 100 * stor6 / 1000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg1] - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1] - (5 * arg2 / 100 * stor6 / 1000 * 10^18)
                                    if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                            else:
                                if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 5 * arg2 / 100:
                                    if 0 > arg2 * stor6 / 1000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * stor6 / 1000 * 10^18 < 0:
                                        revert with 0, 17
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor1[arg1] > !(arg2 * stor6 / 1000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18)
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 0, 17
                                else:
                                    if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                        revert with 0, 17
                                    if not 5 * arg2 / 100:
                                        revert with 0, 18
                                    if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * stor6 / 1000 * 10^18 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor1[arg1] > !((arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)
                                    if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                        else:
                            if not s:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not arg2:
                                if not 5 * arg2 / 100:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > -1:
                                        revert with 0, 17
                                    if stor1[arg1] < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1]
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 0, 17
                                else:
                                    if 5 * arg2 / 100 and t / s > -1 / 5 * arg2 / 100:
                                        revert with 0, 17
                                    if not 5 * arg2 / 100:
                                        revert with 0, 18
                                    if 5 * arg2 / 100 * t / s / 5 * arg2 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 5 * arg2 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 5 * arg2 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > !(-5 * arg2 / 100 * t / s):
                                        revert with 0, 17
                                    if stor1[arg1] - (5 * arg2 / 100 * t / s) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1] - (5 * arg2 / 100 * t / s)
                                    if 5 * arg2 / 100 * t / s > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 5 * arg2 / 100 * t / s:
                                        revert with 0, 17
                                    stor6 += -5 * arg2 / 100 * t / s
                            else:
                                if arg2 and t / s > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * t / s / arg2 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 5 * arg2 / 100:
                                    if 0 > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * t / s < 0:
                                        revert with 0, 17
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * t / s:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor1[arg1] > !(arg2 * t / s):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * t / s) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * t / s)
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 0, 17
                                else:
                                    if 5 * arg2 / 100 and t / s > -1 / 5 * arg2 / 100:
                                        revert with 0, 17
                                    if not 5 * arg2 / 100:
                                        revert with 0, 18
                                    if 5 * arg2 / 100 * t / s / 5 * arg2 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 5 * arg2 / 100 * t / s > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * t / s < 5 * arg2 / 100 * t / s:
                                        revert with 0, 17
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * t / s:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor1[arg1] > !((arg2 * t / s) - (5 * arg2 / 100 * t / s)):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * t / s) - (5 * arg2 / 100 * t / s) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * t / s) - (5 * arg2 / 100 * t / s)
                                    if 5 * arg2 / 100 * t / s > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 5 * arg2 / 100 * t / s:
                                        revert with 0, 17
                                    stor6 += -5 * arg2 / 100 * t / s
                        if totalFees > !(5 * arg2 / 100):
                            revert with 0, 17
                        if totalFees + (5 * arg2 / 100) < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        totalFees += 5 * arg2 / 100
                        emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
        else:
            mem[0] = arg1
            mem[32] = 4
            if stor4[address(arg1)]:
                mem[96] = 26
                mem[128] = 'SafeMath: division by zero'
                if not arg2 / 100:
                    mem[64] = 224
                    mem[160] = 30
                    mem[192] = 'SafeMath: subtraction overflow'
                    if 0 > arg2:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg2 < 0:
                        revert with 0, 17
                    idx = 0
                    s = 1000 * 10^18
                    t = stor6
                    while idx < stor5.length:
                        mem[0] = stor5[idx]
                        mem[32] = 1
                        if stor1[stor5[idx]] > t:
                            _12313 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12313] = 26
                            mem[_12313 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                _13030 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13030] = 30
                                mem[_13030 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = msg.sender
                                mem[32] = 1
                                _13734 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13734] = 30
                                mem[_13734 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _14047 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _14047 + 68] = mem[idx + _13734 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14047 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14047 + -mem[64] + 100
                                if stor1[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor2[address(arg1)] > !arg2:
                                    revert with 0, 17
                                if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] += arg2
                                if stor1[address(arg1)] > -1:
                                    revert with 0, 17
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                _19000 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19000] = 30
                                mem[_19000 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > -1:
                                        revert with 0, 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _19335 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _19335 + 68] = mem[idx + _19000 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19335 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _19335 + -mem[64] + 100
                            if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                                revert with 0, 17
                            if not arg2:
                                revert with 0, 18
                            if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _13343 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13343] = 30
                            mem[_13343 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg2 * stor6 / 1000 * 10^18:
                                _13555 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13555 + 68] = mem[idx + _13343 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13555 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13555 + -mem[64] + 100
                            if arg2 * stor6 / 1000 * 10^18 < 0:
                                revert with 0, 17
                            mem[0] = msg.sender
                            mem[32] = 1
                            _14879 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14879] = 30
                            mem[_14879 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                _15395 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15395 + 68] = mem[idx + _14879 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15395 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15395 + -mem[64] + 100
                            if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                revert with 0, 17
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                            if stor2[address(arg1)] > !arg2:
                                revert with 0, 17
                            if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(arg1)] += arg2
                            if stor1[address(arg1)] > !(arg2 * stor6 / 1000 * 10^18):
                                revert with 0, 17
                            if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                            _20351 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20351] = 30
                            mem[_20351 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor6:
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > -1:
                                    revert with 0, 17
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg2, msg.sender, arg1);
                                return 1
                            _20765 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _20765 + 68] = mem[idx + _20351 + 32]
                                idx = idx + 32
                                continue 
                            mem[_20765 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _20765 + -mem[64] + 100
                        if idx >= stor5.length:
                            revert with 0, 50
                        mem[0] = stor5[idx]
                        mem[32] = 2
                        if stor2[stor5[idx]] <= s:
                            if idx >= stor5.length:
                                revert with 0, 50
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            _12416 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12416] = 30
                            mem[_12416 + 32] = 'SafeMath: subtraction overflow'
                            if stor1[stor5[idx]] > t:
                                _12463 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _12463 + 68] = mem[idx + _12416 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12463 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12463 + -mem[64] + 100
                            if t < stor1[stor5[idx]]:
                                revert with 0, 17
                            if idx >= stor5.length:
                                revert with 0, 50
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            _12807 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12807] = 30
                            mem[_12807 + 32] = 'SafeMath: subtraction overflow'
                            if stor2[stor5[idx]] <= s:
                                if s < stor2[stor5[idx]]:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s - stor2[stor5[idx]]
                                t = t - stor1[stor5[idx]]
                                continue 
                            _12867 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12867 + 68] = mem[idx + _12807 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12867 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12867 + -mem[64] + 100
                        _12417 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12417] = 26
                        mem[_12417 + 32] = 'SafeMath: division by zero'
                        if not arg2:
                            _13167 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13167] = 30
                            mem[_13167 + 32] = 'SafeMath: subtraction overflow'
                            mem[0] = msg.sender
                            mem[32] = 1
                            _14048 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14048] = 30
                            mem[_14048 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor1[address(msg.sender)]:
                                _14370 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14370 + 68] = mem[idx + _14048 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14370 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14370 + -mem[64] + 100
                            if stor1[address(msg.sender)] < 0:
                                revert with 0, 17
                            if stor2[address(arg1)] > !arg2:
                                revert with 0, 17
                            if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(arg1)] += arg2
                            if stor1[address(arg1)] > -1:
                                revert with 0, 17
                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            _19336 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19336] = 30
                            mem[_19336 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor6:
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > -1:
                                    revert with 0, 17
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg2, msg.sender, arg1);
                                return 1
                            _19871 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _19871 + 68] = mem[idx + _19336 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19871 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19871 + -mem[64] + 100
                        if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                            revert with 0, 17
                        if not arg2:
                            revert with 0, 18
                        if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _13556 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13556] = 30
                        mem[_13556 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg2 * stor6 / 1000 * 10^18:
                            _13735 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13735 + 68] = mem[idx + _13556 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13735 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13735 + -mem[64] + 100
                        if arg2 * stor6 / 1000 * 10^18 < 0:
                            revert with 0, 17
                        mem[0] = msg.sender
                        mem[32] = 1
                        _15397 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15397] = 30
                        mem[_15397 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                            _15923 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _15923 + 68] = mem[idx + _15397 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15923 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _15923 + -mem[64] + 100
                        if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                            revert with 0, 17
                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                        if stor2[address(arg1)] > !arg2:
                            revert with 0, 17
                        if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor2[address(arg1)] += arg2
                        if stor1[address(arg1)] > !(arg2 * stor6 / 1000 * 10^18):
                            revert with 0, 17
                        if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg1
                        mem[32] = 1
                        stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                        _20767 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_20767] = 30
                        mem[_20767 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= stor6:
                            if stor6 < 0:
                                revert with 0, 17
                            if totalFees > -1:
                                revert with 0, 17
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(arg2, msg.sender, arg1);
                            return 1
                        _21228 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _21228 + 68] = mem[idx + _20767 + 32]
                            idx = idx + 32
                            continue 
                        mem[_21228 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _21228 + -mem[64] + 100
                    if t < stor6 / 1000 * 10^18:
                        if not arg2:
                            if 0 > stor1[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor1[address(msg.sender)] < 0:
                                revert with 0, 17
                            if stor2[address(arg1)] > !arg2:
                                revert with 0, 17
                            if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(arg1)] += arg2
                            if stor1[address(arg1)] > -1:
                                revert with 0, 17
                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                        else:
                            if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                                revert with 0, 17
                            if not arg2:
                                revert with 0, 18
                            if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg2 * stor6 / 1000 * 10^18:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg2 * stor6 / 1000 * 10^18 < 0:
                                revert with 0, 17
                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                revert with 0, 17
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                            if stor2[address(arg1)] > !arg2:
                                revert with 0, 17
                            if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(arg1)] += arg2
                            if stor1[address(arg1)] > !(arg2 * stor6 / 1000 * 10^18):
                                revert with 0, 17
                            if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                    else:
                        if not s:
                            revert with 0, 'SafeMath: division by zero', 0
                        if not arg2:
                            if 0 > stor1[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor1[address(msg.sender)] < 0:
                                revert with 0, 17
                            if stor2[address(arg1)] > !arg2:
                                revert with 0, 17
                            if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(arg1)] += arg2
                            if stor1[address(arg1)] > -1:
                                revert with 0, 17
                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                        else:
                            if arg2 and t / s > -1 / arg2:
                                revert with 0, 17
                            if not arg2:
                                revert with 0, 18
                            if arg2 * t / s / arg2 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg2 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg2 * t / s < 0:
                                revert with 0, 17
                            if arg2 * t / s > stor1[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor1[address(msg.sender)] < arg2 * t / s:
                                revert with 0, 17
                            stor1[address(msg.sender)] += -1 * arg2 * t / s
                            if stor2[address(arg1)] > !arg2:
                                revert with 0, 17
                            if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(arg1)] += arg2
                            if stor1[address(arg1)] > !(arg2 * t / s):
                                revert with 0, 17
                            if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor1[address(arg1)] += arg2 * t / s
                    if 0 > stor6:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if stor6 < 0:
                        revert with 0, 17
                    if totalFees > -1:
                        revert with 0, 17
                    if totalFees < totalFees:
                        revert with 0, 'SafeMath: addition overflow'
                    emit Transfer(arg2, msg.sender, arg1);
                else:
                    if arg2 / 100 and 5 > -1 / arg2 / 100:
                        revert with 0, 17
                    if not arg2 / 100:
                        revert with 0, 18
                    if 5 * arg2 / 100 / arg2 / 100 != 5:
                        revert with 0, 'SafeMath: multiplication overflow'
                    mem[64] = 224
                    mem[160] = 30
                    mem[192] = 'SafeMath: subtraction overflow'
                    if 5 * arg2 / 100 > arg2:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg2 < 5 * arg2 / 100:
                        revert with 0, 17
                    idx = 0
                    s = 1000 * 10^18
                    t = stor6
                    while idx < stor5.length:
                        mem[0] = stor5[idx]
                        mem[32] = 1
                        if stor1[stor5[idx]] > t:
                            _12312 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12312] = 26
                            mem[_12312 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                if not 5 * arg2 / 100:
                                    _13027 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13027] = 30
                                    mem[_13027 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _13731 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13731] = 30
                                    mem[_13731 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _14042 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _14042 + 68] = mem[idx + _13731 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14042 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14042 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor2[address(arg1)] > !(arg2 - (5 * arg2 / 100)):
                                        revert with 0, 17
                                    if stor2[address(arg1)] + arg2 - (5 * arg2 / 100) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (5 * arg2 / 100)
                                    if stor1[address(arg1)] > -1:
                                        revert with 0, 17
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _18988 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18988] = 30
                                    mem[_18988 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > !(5 * arg2 / 100):
                                            revert with 0, 17
                                        if totalFees + (5 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 5 * arg2 / 100
                                        emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _19333 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19333 + 68] = mem[idx + _18988 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19333 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19333 + -mem[64] + 100
                                if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                    revert with 0, 17
                                if not 5 * arg2 / 100:
                                    revert with 0, 18
                                if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _13337 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13337] = 30
                                mem[_13337 + 32] = 'SafeMath: subtraction overflow'
                                if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > 0:
                                    _13552 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13552 + 68] = mem[idx + _13337 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13552 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13552 + -mem[64] + 100
                                if 0 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                    revert with 0, 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _14873 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14873] = 30
                                mem[_14873 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _15389 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _15389 + 68] = mem[idx + _14873 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15389 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _15389 + -mem[64] + 100
                                if stor1[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor2[address(arg1)] > !(arg2 - (5 * arg2 / 100)):
                                    revert with 0, 17
                                if stor2[address(arg1)] + arg2 - (5 * arg2 / 100) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (5 * arg2 / 100)
                                if stor1[address(arg1)] > !(-5 * arg2 / 100 * stor6 / 1000 * 10^18):
                                    revert with 0, 17
                                if stor1[address(arg1)] - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                                _20341 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20341] = 30
                                mem[_20341 + 32] = 'SafeMath: subtraction overflow'
                                if 5 * arg2 / 100 * stor6 / 1000 * 10^18 <= stor6:
                                    if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                                    if totalFees > !(5 * arg2 / 100):
                                        revert with 0, 17
                                    if totalFees + (5 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 5 * arg2 / 100
                                    emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _20759 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20759 + 68] = mem[idx + _20341 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20759 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20759 + -mem[64] + 100
                            if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                                revert with 0, 17
                            if not arg2:
                                revert with 0, 18
                            if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 5 * arg2 / 100:
                                _13336 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13336] = 30
                                mem[_13336 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor6 / 1000 * 10^18:
                                    _13551 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13551 + 68] = mem[idx + _13336 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13551 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13551 + -mem[64] + 100
                                if arg2 * stor6 / 1000 * 10^18 < 0:
                                    revert with 0, 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _14872 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14872] = 30
                                mem[_14872 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                    _15388 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _15388 + 68] = mem[idx + _14872 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15388 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _15388 + -mem[64] + 100
                                if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                if stor2[address(arg1)] > !(arg2 - (5 * arg2 / 100)):
                                    revert with 0, 17
                                if stor2[address(arg1)] + arg2 - (5 * arg2 / 100) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (5 * arg2 / 100)
                                if stor1[address(arg1)] > !(arg2 * stor6 / 1000 * 10^18):
                                    revert with 0, 17
                                if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                _20340 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20340] = 30
                                mem[_20340 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > !(5 * arg2 / 100):
                                        revert with 0, 17
                                    if totalFees + (5 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 5 * arg2 / 100
                                    emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _20758 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20758 + 68] = mem[idx + _20340 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20758 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20758 + -mem[64] + 100
                            if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                revert with 0, 17
                            if not 5 * arg2 / 100:
                                revert with 0, 18
                            if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _14041 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14041] = 30
                            mem[_14041 + 32] = 'SafeMath: subtraction overflow'
                            if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                _14362 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14362 + 68] = mem[idx + _14041 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14362 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14362 + -mem[64] + 100
                            if arg2 * stor6 / 1000 * 10^18 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                revert with 0, 17
                            mem[0] = msg.sender
                            mem[32] = 1
                            _16407 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16407] = 30
                            mem[_16407 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                _17070 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _17070 + 68] = mem[idx + _16407 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_17070 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _17070 + -mem[64] + 100
                            if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                revert with 0, 17
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                            if stor2[address(arg1)] > !(arg2 - (5 * arg2 / 100)):
                                revert with 0, 17
                            if stor2[address(arg1)] + arg2 - (5 * arg2 / 100) < stor2[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (5 * arg2 / 100)
                            if stor1[address(arg1)] > !((arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)):
                                revert with 0, 17
                            if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)
                            _21545 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21545] = 30
                            mem[_21545 + 32] = 'SafeMath: subtraction overflow'
                            if 5 * arg2 / 100 * stor6 / 1000 * 10^18 <= stor6:
                                if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                    revert with 0, 17
                                stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                                if totalFees > !(5 * arg2 / 100):
                                    revert with 0, 17
                                if totalFees + (5 * arg2 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 5 * arg2 / 100
                                emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                return 1
                            _22015 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _22015 + 68] = mem[idx + _21545 + 32]
                                idx = idx + 32
                                continue 
                            mem[_22015 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _22015 + -mem[64] + 100
                        if idx >= stor5.length:
                            revert with 0, 50
                        mem[0] = stor5[idx]
                        mem[32] = 2
                        if stor2[stor5[idx]] <= s:
                            if idx >= stor5.length:
                                revert with 0, 50
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            _12414 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12414] = 30
                            mem[_12414 + 32] = 'SafeMath: subtraction overflow'
                            if stor1[stor5[idx]] > t:
                                _12462 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _12462 + 68] = mem[idx + _12414 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12462 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12462 + -mem[64] + 100
                            if t < stor1[stor5[idx]]:
                                revert with 0, 17
                            if idx >= stor5.length:
                                revert with 0, 50
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            _12805 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12805] = 30
                            mem[_12805 + 32] = 'SafeMath: subtraction overflow'
                            if stor2[stor5[idx]] <= s:
                                if s < stor2[stor5[idx]]:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s - stor2[stor5[idx]]
                                t = t - stor1[stor5[idx]]
                                continue 
                            _12865 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12865 + 68] = mem[idx + _12805 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12865 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12865 + -mem[64] + 100
                        _12415 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12415] = 26
                        mem[_12415 + 32] = 'SafeMath: division by zero'
                        if not arg2:
                            if not 5 * arg2 / 100:
                                _13165 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13165] = 30
                                mem[_13165 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = msg.sender
                                mem[32] = 1
                                _14044 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14044] = 30
                                mem[_14044 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _14366 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _14366 + 68] = mem[idx + _14044 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14366 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14366 + -mem[64] + 100
                                if stor1[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor2[address(arg1)] > !(arg2 - (5 * arg2 / 100)):
                                    revert with 0, 17
                                if stor2[address(arg1)] + arg2 - (5 * arg2 / 100) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (5 * arg2 / 100)
                                if stor1[address(arg1)] > -1:
                                    revert with 0, 17
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                _19334 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19334] = 30
                                mem[_19334 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > !(5 * arg2 / 100):
                                        revert with 0, 17
                                    if totalFees + (5 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 5 * arg2 / 100
                                    emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _19858 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _19858 + 68] = mem[idx + _19334 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19858 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _19858 + -mem[64] + 100
                            if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                revert with 0, 17
                            if not 5 * arg2 / 100:
                                revert with 0, 18
                            if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _13554 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13554] = 30
                            mem[_13554 + 32] = 'SafeMath: subtraction overflow'
                            if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > 0:
                                _13733 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13733 + 68] = mem[idx + _13554 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13733 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13733 + -mem[64] + 100
                            if 0 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                revert with 0, 17
                            mem[0] = msg.sender
                            mem[32] = 1
                            _15392 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15392] = 30
                            mem[_15392 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor1[address(msg.sender)]:
                                _15919 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15919 + 68] = mem[idx + _15392 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15919 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15919 + -mem[64] + 100
                            if stor1[address(msg.sender)] < 0:
                                revert with 0, 17
                            if stor2[address(arg1)] > !(arg2 - (5 * arg2 / 100)):
                                revert with 0, 17
                            if stor2[address(arg1)] + arg2 - (5 * arg2 / 100) < stor2[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (5 * arg2 / 100)
                            if stor1[address(arg1)] > !(-5 * arg2 / 100 * stor6 / 1000 * 10^18):
                                revert with 0, 17
                            if stor1[address(arg1)] - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                            _20762 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20762] = 30
                            mem[_20762 + 32] = 'SafeMath: subtraction overflow'
                            if 5 * arg2 / 100 * stor6 / 1000 * 10^18 <= stor6:
                                if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                    revert with 0, 17
                                stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                                if totalFees > !(5 * arg2 / 100):
                                    revert with 0, 17
                                if totalFees + (5 * arg2 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 5 * arg2 / 100
                                emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                return 1
                            _21222 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _21222 + 68] = mem[idx + _20762 + 32]
                                idx = idx + 32
                                continue 
                            mem[_21222 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _21222 + -mem[64] + 100
                        if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                            revert with 0, 17
                        if not arg2:
                            revert with 0, 18
                        if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 5 * arg2 / 100:
                            _13553 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13553] = 30
                            mem[_13553 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg2 * stor6 / 1000 * 10^18:
                                _13732 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13732 + 68] = mem[idx + _13553 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13732 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13732 + -mem[64] + 100
                            if arg2 * stor6 / 1000 * 10^18 < 0:
                                revert with 0, 17
                            mem[0] = msg.sender
                            mem[32] = 1
                            _15391 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15391] = 30
                            mem[_15391 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                _15918 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15918 + 68] = mem[idx + _15391 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15918 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15918 + -mem[64] + 100
                            if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                revert with 0, 17
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                            if stor2[address(arg1)] > !(arg2 - (5 * arg2 / 100)):
                                revert with 0, 17
                            if stor2[address(arg1)] + arg2 - (5 * arg2 / 100) < stor2[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (5 * arg2 / 100)
                            if stor1[address(arg1)] > !(arg2 * stor6 / 1000 * 10^18):
                                revert with 0, 17
                            if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                            _20761 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20761] = 30
                            mem[_20761 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor6:
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > !(5 * arg2 / 100):
                                    revert with 0, 17
                                if totalFees + (5 * arg2 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 5 * arg2 / 100
                                emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                return 1
                            _21221 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _21221 + 68] = mem[idx + _20761 + 32]
                                idx = idx + 32
                                continue 
                            mem[_21221 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _21221 + -mem[64] + 100
                        if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                            revert with 0, 17
                        if not 5 * arg2 / 100:
                            revert with 0, 18
                        if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _14365 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14365] = 30
                        mem[_14365 + 32] = 'SafeMath: subtraction overflow'
                        if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                            _14874 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _14874 + 68] = mem[idx + _14365 + 32]
                                idx = idx + 32
                                continue 
                            mem[_14874 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14874 + -mem[64] + 100
                        if arg2 * stor6 / 1000 * 10^18 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                            revert with 0, 17
                        mem[0] = msg.sender
                        mem[32] = 1
                        _17073 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_17073] = 30
                        mem[_17073 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                            _17622 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _17622 + 68] = mem[idx + _17073 + 32]
                                idx = idx + 32
                                continue 
                            mem[_17622 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _17622 + -mem[64] + 100
                        if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                            revert with 0, 17
                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                        if stor2[address(arg1)] > !(arg2 - (5 * arg2 / 100)):
                            revert with 0, 17
                        if stor2[address(arg1)] + arg2 - (5 * arg2 / 100) < stor2[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (5 * arg2 / 100)
                        if stor1[address(arg1)] > !((arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)):
                            revert with 0, 17
                        if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg1
                        mem[32] = 1
                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)
                        _22019 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_22019] = 30
                        mem[_22019 + 32] = 'SafeMath: subtraction overflow'
                        if 5 * arg2 / 100 * stor6 / 1000 * 10^18 <= stor6:
                            if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                revert with 0, 17
                            stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                            if totalFees > !(5 * arg2 / 100):
                                revert with 0, 17
                            if totalFees + (5 * arg2 / 100) < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += 5 * arg2 / 100
                            emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                            return 1
                        _22448 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _22448 + 68] = mem[idx + _22019 + 32]
                            idx = idx + 32
                            continue 
                        mem[_22448 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _22448 + -mem[64] + 100
                    if t < stor6 / 1000 * 10^18:
                        if not arg2:
                            if not 5 * arg2 / 100:
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor2[address(arg1)] > !(arg2 - (5 * arg2 / 100)):
                                    revert with 0, 17
                                if stor2[address(arg1)] + arg2 - (5 * arg2 / 100) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (5 * arg2 / 100)
                                if stor1[address(arg1)] > -1:
                                    revert with 0, 17
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 0:
                                    revert with 0, 17
                            else:
                                if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                    revert with 0, 17
                                if not 5 * arg2 / 100:
                                    revert with 0, 18
                                if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                    revert with 0, 17
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor2[address(arg1)] > !(arg2 - (5 * arg2 / 100)):
                                    revert with 0, 17
                                if stor2[address(arg1)] + arg2 - (5 * arg2 / 100) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (5 * arg2 / 100)
                                if stor1[address(arg1)] > !(-5 * arg2 / 100 * stor6 / 1000 * 10^18):
                                    revert with 0, 17
                                if stor1[address(arg1)] - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                                if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                    revert with 0, 17
                                stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                        else:
                            if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                                revert with 0, 17
                            if not arg2:
                                revert with 0, 18
                            if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 5 * arg2 / 100:
                                if 0 > arg2 * stor6 / 1000 * 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg2 * stor6 / 1000 * 10^18 < 0:
                                    revert with 0, 17
                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                if stor2[address(arg1)] > !(arg2 - (5 * arg2 / 100)):
                                    revert with 0, 17
                                if stor2[address(arg1)] + arg2 - (5 * arg2 / 100) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (5 * arg2 / 100)
                                if stor1[address(arg1)] > !(arg2 * stor6 / 1000 * 10^18):
                                    revert with 0, 17
                                if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 0:
                                    revert with 0, 17
                            else:
                                if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                    revert with 0, 17
                                if not 5 * arg2 / 100:
                                    revert with 0, 18
                                if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg2 * stor6 / 1000 * 10^18 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                    revert with 0, 17
                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                if stor2[address(arg1)] > !(arg2 - (5 * arg2 / 100)):
                                    revert with 0, 17
                                if stor2[address(arg1)] + arg2 - (5 * arg2 / 100) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (5 * arg2 / 100)
                                if stor1[address(arg1)] > !((arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)):
                                    revert with 0, 17
                                if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)
                                if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                    revert with 0, 17
                                stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                    else:
                        if not s:
                            revert with 0, 'SafeMath: division by zero', 0
                        if not arg2:
                            if not 5 * arg2 / 100:
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor2[address(arg1)] > !(arg2 - (5 * arg2 / 100)):
                                    revert with 0, 17
                                if stor2[address(arg1)] + arg2 - (5 * arg2 / 100) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (5 * arg2 / 100)
                                if stor1[address(arg1)] > -1:
                                    revert with 0, 17
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 0:
                                    revert with 0, 17
                            else:
                                if 5 * arg2 / 100 and t / s > -1 / 5 * arg2 / 100:
                                    revert with 0, 17
                                if not 5 * arg2 / 100:
                                    revert with 0, 18
                                if 5 * arg2 / 100 * t / s / 5 * arg2 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 5 * arg2 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 5 * arg2 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor2[address(arg1)] > !(arg2 - (5 * arg2 / 100)):
                                    revert with 0, 17
                                if stor2[address(arg1)] + arg2 - (5 * arg2 / 100) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (5 * arg2 / 100)
                                if stor1[address(arg1)] > !(-5 * arg2 / 100 * t / s):
                                    revert with 0, 17
                                if stor1[address(arg1)] - (5 * arg2 / 100 * t / s) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] += -5 * arg2 / 100 * t / s
                                if 5 * arg2 / 100 * t / s > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 5 * arg2 / 100 * t / s:
                                    revert with 0, 17
                                stor6 += -5 * arg2 / 100 * t / s
                        else:
                            if arg2 and t / s > -1 / arg2:
                                revert with 0, 17
                            if not arg2:
                                revert with 0, 18
                            if arg2 * t / s / arg2 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 5 * arg2 / 100:
                                if 0 > arg2 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg2 * t / s < 0:
                                    revert with 0, 17
                                if arg2 * t / s > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < arg2 * t / s:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * t / s
                                if stor2[address(arg1)] > !(arg2 - (5 * arg2 / 100)):
                                    revert with 0, 17
                                if stor2[address(arg1)] + arg2 - (5 * arg2 / 100) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (5 * arg2 / 100)
                                if stor1[address(arg1)] > !(arg2 * t / s):
                                    revert with 0, 17
                                if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] += arg2 * t / s
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 0:
                                    revert with 0, 17
                            else:
                                if 5 * arg2 / 100 and t / s > -1 / 5 * arg2 / 100:
                                    revert with 0, 17
                                if not 5 * arg2 / 100:
                                    revert with 0, 18
                                if 5 * arg2 / 100 * t / s / 5 * arg2 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 5 * arg2 / 100 * t / s > arg2 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg2 * t / s < 5 * arg2 / 100 * t / s:
                                    revert with 0, 17
                                if arg2 * t / s > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < arg2 * t / s:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * t / s
                                if stor2[address(arg1)] > !(arg2 - (5 * arg2 / 100)):
                                    revert with 0, 17
                                if stor2[address(arg1)] + arg2 - (5 * arg2 / 100) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (5 * arg2 / 100)
                                if stor1[address(arg1)] > !((arg2 * t / s) - (5 * arg2 / 100 * t / s)):
                                    revert with 0, 17
                                if stor1[address(arg1)] + (arg2 * t / s) - (5 * arg2 / 100 * t / s) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (5 * arg2 / 100 * t / s)
                                if 5 * arg2 / 100 * t / s > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 5 * arg2 / 100 * t / s:
                                    revert with 0, 17
                                stor6 += -5 * arg2 / 100 * t / s
                    if totalFees > !(5 * arg2 / 100):
                        revert with 0, 17
                    if totalFees + (5 * arg2 / 100) < totalFees:
                        revert with 0, 'SafeMath: addition overflow'
                    totalFees += 5 * arg2 / 100
                    emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
            else:
                mem[0] = msg.sender
                mem[32] = 4
                if stor4[address(msg.sender)]:
                    mem[96] = 26
                    mem[128] = 'SafeMath: division by zero'
                    if not arg2 / 100:
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if 0 > arg2:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg2 < 0:
                            revert with 0, 17
                        idx = 0
                        s = 1000 * 10^18
                        t = stor6
                        while idx < stor5.length:
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            if stor1[stor5[idx]] > t:
                                _12307 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12307] = 26
                                mem[_12307 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    _13012 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13012] = 30
                                    mem[_13012 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _13710 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13710] = 30
                                    mem[_13710 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _14011 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _14011 + 68] = mem[idx + _13710 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14011 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14011 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > -1:
                                        revert with 0, 17
                                    if stor1[arg1] < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1]
                                    _17312 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17312] = 30
                                    mem[_17312 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > -1:
                                            revert with 0, 17
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _17740 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _17740 + 68] = mem[idx + _17312 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_17740 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _17740 + -mem[64] + 100
                                if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _13307 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13307] = 30
                                mem[_13307 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor6 / 1000 * 10^18:
                                    _13537 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13537 + 68] = mem[idx + _13307 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13537 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13537 + -mem[64] + 100
                                if arg2 * stor6 / 1000 * 10^18 < 0:
                                    revert with 0, 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _14840 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14840] = 30
                                mem[_14840 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                    _15353 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _15353 + 68] = mem[idx + _14840 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15353 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _15353 + -mem[64] + 100
                                if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                if stor1[arg1] > !(arg2 * stor6 / 1000 * 10^18):
                                    revert with 0, 17
                                if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18)
                                _18947 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18947] = 30
                                mem[_18947 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > -1:
                                        revert with 0, 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _19300 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _19300 + 68] = mem[idx + _18947 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19300 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _19300 + -mem[64] + 100
                            if idx >= stor5.length:
                                revert with 0, 50
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            if stor2[stor5[idx]] <= s:
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                _12404 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12404] = 30
                                mem[_12404 + 32] = 'SafeMath: subtraction overflow'
                                if stor1[stor5[idx]] > t:
                                    _12457 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _12457 + 68] = mem[idx + _12404 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12457 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12457 + -mem[64] + 100
                                if t < stor1[stor5[idx]]:
                                    revert with 0, 17
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                _12795 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12795] = 30
                                mem[_12795 + 32] = 'SafeMath: subtraction overflow'
                                if stor2[stor5[idx]] <= s:
                                    if s < stor2[stor5[idx]]:
                                        revert with 0, 17
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s - stor2[stor5[idx]]
                                    t = t - stor1[stor5[idx]]
                                    continue 
                                _12855 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _12855 + 68] = mem[idx + _12795 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12855 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12855 + -mem[64] + 100
                            _12405 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12405] = 26
                            mem[_12405 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                _13155 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13155] = 30
                                mem[_13155 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = msg.sender
                                mem[32] = 1
                                _14012 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14012] = 30
                                mem[_14012 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _14331 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _14331 + 68] = mem[idx + _14012 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14331 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14331 + -mem[64] + 100
                                if stor1[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor1[arg1] > -1:
                                    revert with 0, 17
                                if stor1[arg1] < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[arg1]
                                _17741 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17741] = 30
                                mem[_17741 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > -1:
                                        revert with 0, 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _18209 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _18209 + 68] = mem[idx + _17741 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_18209 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _18209 + -mem[64] + 100
                            if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                                revert with 0, 17
                            if not arg2:
                                revert with 0, 18
                            if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _13538 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13538] = 30
                            mem[_13538 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg2 * stor6 / 1000 * 10^18:
                                _13711 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13711 + 68] = mem[idx + _13538 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13711 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13711 + -mem[64] + 100
                            if arg2 * stor6 / 1000 * 10^18 < 0:
                                revert with 0, 17
                            mem[0] = msg.sender
                            mem[32] = 1
                            _15355 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15355] = 30
                            mem[_15355 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                _15881 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15881 + 68] = mem[idx + _15355 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15881 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15881 + -mem[64] + 100
                            if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                revert with 0, 17
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                            if stor1[arg1] > !(arg2 * stor6 / 1000 * 10^18):
                                revert with 0, 17
                            if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18)
                            _19302 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19302] = 30
                            mem[_19302 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor6:
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > -1:
                                    revert with 0, 17
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg2, msg.sender, arg1);
                                return 1
                            _19777 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _19777 + 68] = mem[idx + _19302 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19777 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19777 + -mem[64] + 100
                        if t < stor6 / 1000 * 10^18:
                            if not arg2:
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor1[arg1] > -1:
                                    revert with 0, 17
                                if stor1[arg1] < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] = stor1[arg1]
                            else:
                                if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > arg2 * stor6 / 1000 * 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg2 * stor6 / 1000 * 10^18 < 0:
                                    revert with 0, 17
                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                if stor1[arg1] > !(arg2 * stor6 / 1000 * 10^18):
                                    revert with 0, 17
                                if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18)
                        else:
                            if not s:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not arg2:
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor1[arg1] > -1:
                                    revert with 0, 17
                                if stor1[arg1] < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] = stor1[arg1]
                            else:
                                if arg2 and t / s > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * t / s / arg2 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > arg2 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg2 * t / s < 0:
                                    revert with 0, 17
                                if arg2 * t / s > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < arg2 * t / s:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * t / s
                                if stor1[arg1] > !(arg2 * t / s):
                                    revert with 0, 17
                                if stor1[arg1] + (arg2 * t / s) < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] = stor1[arg1] + (arg2 * t / s)
                        if 0 > stor6:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor6 < 0:
                            revert with 0, 17
                        if totalFees > -1:
                            revert with 0, 17
                        if totalFees < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        emit Transfer(arg2, msg.sender, arg1);
                    else:
                        if arg2 / 100 and 5 > -1 / arg2 / 100:
                            revert with 0, 17
                        if not arg2 / 100:
                            revert with 0, 18
                        if 5 * arg2 / 100 / arg2 / 100 != 5:
                            revert with 0, 'SafeMath: multiplication overflow'
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if 5 * arg2 / 100 > arg2:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg2 < 5 * arg2 / 100:
                            revert with 0, 17
                        idx = 0
                        s = 1000 * 10^18
                        t = stor6
                        while idx < stor5.length:
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            if stor1[stor5[idx]] > t:
                                _12306 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12306] = 26
                                mem[_12306 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not 5 * arg2 / 100:
                                        _13009 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13009] = 30
                                        mem[_13009 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _13707 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13707] = 30
                                        mem[_13707 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _14006 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _14006 + 68] = mem[idx + _13707 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_14006 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _14006 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > -1:
                                            revert with 0, 17
                                        if stor1[arg1] < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[arg1]
                                        _17301 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17301] = 30
                                        mem[_17301 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > !(5 * arg2 / 100):
                                                revert with 0, 17
                                            if totalFees + (5 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 5 * arg2 / 100
                                            emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _17735 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _17735 + 68] = mem[idx + _17301 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17735 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _17735 + -mem[64] + 100
                                    if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                        revert with 0, 17
                                    if not 5 * arg2 / 100:
                                        revert with 0, 18
                                    if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _13301 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13301] = 30
                                    mem[_13301 + 32] = 'SafeMath: subtraction overflow'
                                    if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > 0:
                                        _13534 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13534 + 68] = mem[idx + _13301 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13534 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13534 + -mem[64] + 100
                                    if 0 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _14834 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14834] = 30
                                    mem[_14834 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _15347 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _15347 + 68] = mem[idx + _14834 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_15347 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _15347 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > !(-5 * arg2 / 100 * stor6 / 1000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg1] - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1] - (5 * arg2 / 100 * stor6 / 1000 * 10^18)
                                    _18937 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18937] = 30
                                    mem[_18937 + 32] = 'SafeMath: subtraction overflow'
                                    if 5 * arg2 / 100 * stor6 / 1000 * 10^18 <= stor6:
                                        if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                            revert with 0, 17
                                        stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                                        if totalFees > !(5 * arg2 / 100):
                                            revert with 0, 17
                                        if totalFees + (5 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 5 * arg2 / 100
                                        emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _19294 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19294 + 68] = mem[idx + _18937 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19294 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19294 + -mem[64] + 100
                                if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 5 * arg2 / 100:
                                    _13300 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13300] = 30
                                    mem[_13300 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 1000 * 10^18:
                                        _13533 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13533 + 68] = mem[idx + _13300 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13533 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13533 + -mem[64] + 100
                                    if arg2 * stor6 / 1000 * 10^18 < 0:
                                        revert with 0, 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _14833 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14833] = 30
                                    mem[_14833 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        _15346 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _15346 + 68] = mem[idx + _14833 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_15346 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _15346 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor1[arg1] > !(arg2 * stor6 / 1000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18)
                                    _18936 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18936] = 30
                                    mem[_18936 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > !(5 * arg2 / 100):
                                            revert with 0, 17
                                        if totalFees + (5 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 5 * arg2 / 100
                                        emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _19293 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19293 + 68] = mem[idx + _18936 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19293 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19293 + -mem[64] + 100
                                if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                    revert with 0, 17
                                if not 5 * arg2 / 100:
                                    revert with 0, 18
                                if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _14005 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14005] = 30
                                mem[_14005 + 32] = 'SafeMath: subtraction overflow'
                                if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                    _14323 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _14323 + 68] = mem[idx + _14005 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14323 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14323 + -mem[64] + 100
                                if arg2 * stor6 / 1000 * 10^18 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                    revert with 0, 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _16377 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16377] = 30
                                mem[_16377 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                    _17019 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _17019 + 68] = mem[idx + _16377 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_17019 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _17019 + -mem[64] + 100
                                if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                if stor1[arg1] > !((arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)):
                                    revert with 0, 17
                                if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)
                                _20309 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20309] = 30
                                mem[_20309 + 32] = 'SafeMath: subtraction overflow'
                                if 5 * arg2 / 100 * stor6 / 1000 * 10^18 <= stor6:
                                    if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                                    if totalFees > !(5 * arg2 / 100):
                                        revert with 0, 17
                                    if totalFees + (5 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 5 * arg2 / 100
                                    emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _20705 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20705 + 68] = mem[idx + _20309 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20705 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20705 + -mem[64] + 100
                            if idx >= stor5.length:
                                revert with 0, 50
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            if stor2[stor5[idx]] <= s:
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                _12402 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12402] = 30
                                mem[_12402 + 32] = 'SafeMath: subtraction overflow'
                                if stor1[stor5[idx]] > t:
                                    _12456 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _12456 + 68] = mem[idx + _12402 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12456 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12456 + -mem[64] + 100
                                if t < stor1[stor5[idx]]:
                                    revert with 0, 17
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                _12793 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12793] = 30
                                mem[_12793 + 32] = 'SafeMath: subtraction overflow'
                                if stor2[stor5[idx]] <= s:
                                    if s < stor2[stor5[idx]]:
                                        revert with 0, 17
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s - stor2[stor5[idx]]
                                    t = t - stor1[stor5[idx]]
                                    continue 
                                _12853 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _12853 + 68] = mem[idx + _12793 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12853 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12853 + -mem[64] + 100
                            _12403 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12403] = 26
                            mem[_12403 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                if not 5 * arg2 / 100:
                                    _13153 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13153] = 30
                                    mem[_13153 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _14008 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14008] = 30
                                    mem[_14008 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _14327 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _14327 + 68] = mem[idx + _14008 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14327 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14327 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > -1:
                                        revert with 0, 17
                                    if stor1[arg1] < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1]
                                    _17737 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17737] = 30
                                    mem[_17737 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > !(5 * arg2 / 100):
                                            revert with 0, 17
                                        if totalFees + (5 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 5 * arg2 / 100
                                        emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _18196 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _18196 + 68] = mem[idx + _17737 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18196 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _18196 + -mem[64] + 100
                                if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                    revert with 0, 17
                                if not 5 * arg2 / 100:
                                    revert with 0, 18
                                if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _13536 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13536] = 30
                                mem[_13536 + 32] = 'SafeMath: subtraction overflow'
                                if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > 0:
                                    _13709 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13709 + 68] = mem[idx + _13536 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13709 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13709 + -mem[64] + 100
                                if 0 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                    revert with 0, 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _15350 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15350] = 30
                                mem[_15350 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _15877 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _15877 + 68] = mem[idx + _15350 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15877 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _15877 + -mem[64] + 100
                                if stor1[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor1[arg1] > !(-5 * arg2 / 100 * stor6 / 1000 * 10^18):
                                    revert with 0, 17
                                if stor1[arg1] - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[arg1] - (5 * arg2 / 100 * stor6 / 1000 * 10^18)
                                _19297 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19297] = 30
                                mem[_19297 + 32] = 'SafeMath: subtraction overflow'
                                if 5 * arg2 / 100 * stor6 / 1000 * 10^18 <= stor6:
                                    if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                                    if totalFees > !(5 * arg2 / 100):
                                        revert with 0, 17
                                    if totalFees + (5 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 5 * arg2 / 100
                                    emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _19771 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _19771 + 68] = mem[idx + _19297 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19771 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _19771 + -mem[64] + 100
                            if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                                revert with 0, 17
                            if not arg2:
                                revert with 0, 18
                            if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 5 * arg2 / 100:
                                _13535 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13535] = 30
                                mem[_13535 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor6 / 1000 * 10^18:
                                    _13708 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13708 + 68] = mem[idx + _13535 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13708 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13708 + -mem[64] + 100
                                if arg2 * stor6 / 1000 * 10^18 < 0:
                                    revert with 0, 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _15349 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15349] = 30
                                mem[_15349 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                    _15876 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _15876 + 68] = mem[idx + _15349 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15876 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _15876 + -mem[64] + 100
                                if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                if stor1[arg1] > !(arg2 * stor6 / 1000 * 10^18):
                                    revert with 0, 17
                                if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18)
                                _19296 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19296] = 30
                                mem[_19296 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > !(5 * arg2 / 100):
                                        revert with 0, 17
                                    if totalFees + (5 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 5 * arg2 / 100
                                    emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _19770 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _19770 + 68] = mem[idx + _19296 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19770 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _19770 + -mem[64] + 100
                            if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                revert with 0, 17
                            if not 5 * arg2 / 100:
                                revert with 0, 18
                            if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _14326 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14326] = 30
                            mem[_14326 + 32] = 'SafeMath: subtraction overflow'
                            if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                _14835 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14835 + 68] = mem[idx + _14326 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14835 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14835 + -mem[64] + 100
                            if arg2 * stor6 / 1000 * 10^18 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                revert with 0, 17
                            mem[0] = msg.sender
                            mem[32] = 1
                            _17022 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_17022] = 30
                            mem[_17022 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                _17604 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _17604 + 68] = mem[idx + _17022 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_17604 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _17604 + -mem[64] + 100
                            if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                revert with 0, 17
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                            if stor1[arg1] > !((arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)):
                                revert with 0, 17
                            if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)
                            _20709 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20709] = 30
                            mem[_20709 + 32] = 'SafeMath: subtraction overflow'
                            if 5 * arg2 / 100 * stor6 / 1000 * 10^18 <= stor6:
                                if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                    revert with 0, 17
                                stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                                if totalFees > !(5 * arg2 / 100):
                                    revert with 0, 17
                                if totalFees + (5 * arg2 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 5 * arg2 / 100
                                emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                return 1
                            _21179 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _21179 + 68] = mem[idx + _20709 + 32]
                                idx = idx + 32
                                continue 
                            mem[_21179 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _21179 + -mem[64] + 100
                        if t < stor6 / 1000 * 10^18:
                            if not arg2:
                                if not 5 * arg2 / 100:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > -1:
                                        revert with 0, 17
                                    if stor1[arg1] < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1]
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 0, 17
                                else:
                                    if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                        revert with 0, 17
                                    if not 5 * arg2 / 100:
                                        revert with 0, 18
                                    if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > !(-5 * arg2 / 100 * stor6 / 1000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg1] - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1] - (5 * arg2 / 100 * stor6 / 1000 * 10^18)
                                    if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                            else:
                                if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 5 * arg2 / 100:
                                    if 0 > arg2 * stor6 / 1000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * stor6 / 1000 * 10^18 < 0:
                                        revert with 0, 17
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor1[arg1] > !(arg2 * stor6 / 1000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18)
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 0, 17
                                else:
                                    if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                        revert with 0, 17
                                    if not 5 * arg2 / 100:
                                        revert with 0, 18
                                    if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * stor6 / 1000 * 10^18 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor1[arg1] > !((arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)
                                    if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                        else:
                            if not s:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not arg2:
                                if not 5 * arg2 / 100:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > -1:
                                        revert with 0, 17
                                    if stor1[arg1] < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1]
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 0, 17
                                else:
                                    if 5 * arg2 / 100 and t / s > -1 / 5 * arg2 / 100:
                                        revert with 0, 17
                                    if not 5 * arg2 / 100:
                                        revert with 0, 18
                                    if 5 * arg2 / 100 * t / s / 5 * arg2 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 5 * arg2 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 5 * arg2 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > !(-5 * arg2 / 100 * t / s):
                                        revert with 0, 17
                                    if stor1[arg1] - (5 * arg2 / 100 * t / s) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1] - (5 * arg2 / 100 * t / s)
                                    if 5 * arg2 / 100 * t / s > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 5 * arg2 / 100 * t / s:
                                        revert with 0, 17
                                    stor6 += -5 * arg2 / 100 * t / s
                            else:
                                if arg2 and t / s > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * t / s / arg2 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 5 * arg2 / 100:
                                    if 0 > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * t / s < 0:
                                        revert with 0, 17
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * t / s:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor1[arg1] > !(arg2 * t / s):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * t / s) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * t / s)
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 0, 17
                                else:
                                    if 5 * arg2 / 100 and t / s > -1 / 5 * arg2 / 100:
                                        revert with 0, 17
                                    if not 5 * arg2 / 100:
                                        revert with 0, 18
                                    if 5 * arg2 / 100 * t / s / 5 * arg2 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 5 * arg2 / 100 * t / s > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * t / s < 5 * arg2 / 100 * t / s:
                                        revert with 0, 17
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * t / s:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor1[arg1] > !((arg2 * t / s) - (5 * arg2 / 100 * t / s)):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * t / s) - (5 * arg2 / 100 * t / s) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * t / s) - (5 * arg2 / 100 * t / s)
                                    if 5 * arg2 / 100 * t / s > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 5 * arg2 / 100 * t / s:
                                        revert with 0, 17
                                    stor6 += -5 * arg2 / 100 * t / s
                        if totalFees > !(5 * arg2 / 100):
                            revert with 0, 17
                        if totalFees + (5 * arg2 / 100) < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        totalFees += 5 * arg2 / 100
                        emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                else:
                    mem[0] = arg1
                    mem[32] = 4
                    mem[96] = 26
                    mem[128] = 'SafeMath: division by zero'
                    if stor4[address(arg1)]:
                        if not arg2 / 100:
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if 0 > arg2:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg2 < 0:
                                revert with 0, 17
                            idx = 0
                            s = 1000 * 10^18
                            t = stor6
                            while idx < stor5.length:
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                if stor1[stor5[idx]] > t:
                                    _12309 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12309] = 26
                                    mem[_12309 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        _13018 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13018] = 30
                                        mem[_13018 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _13718 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13718] = 30
                                        mem[_13718 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _14023 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _14023 + 68] = mem[idx + _13718 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_14023 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _14023 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > -1:
                                            revert with 0, 17
                                        if stor1[arg1] < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[arg1]
                                        _17336 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17336] = 30
                                        mem[_17336 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > -1:
                                                revert with 0, 17
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _17754 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _17754 + 68] = mem[idx + _17336 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17754 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _17754 + -mem[64] + 100
                                    if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                                        revert with 0, 17
                                    if not arg2:
                                        revert with 0, 18
                                    if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _13319 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13319] = 30
                                    mem[_13319 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 1000 * 10^18:
                                        _13543 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13543 + 68] = mem[idx + _13319 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13543 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13543 + -mem[64] + 100
                                    if arg2 * stor6 / 1000 * 10^18 < 0:
                                        revert with 0, 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _14853 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14853] = 30
                                    mem[_14853 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        _15367 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _15367 + 68] = mem[idx + _14853 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_15367 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _15367 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor1[arg1] > !(arg2 * stor6 / 1000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18)
                                    _18965 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18965] = 30
                                    mem[_18965 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > -1:
                                            revert with 0, 17
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _19314 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19314 + 68] = mem[idx + _18965 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19314 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19314 + -mem[64] + 100
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                if stor2[stor5[idx]] <= s:
                                    if idx >= stor5.length:
                                        revert with 0, 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    _12408 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12408] = 30
                                    mem[_12408 + 32] = 'SafeMath: subtraction overflow'
                                    if stor1[stor5[idx]] > t:
                                        _12459 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _12459 + 68] = mem[idx + _12408 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_12459 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _12459 + -mem[64] + 100
                                    if t < stor1[stor5[idx]]:
                                        revert with 0, 17
                                    if idx >= stor5.length:
                                        revert with 0, 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    _12799 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12799] = 30
                                    mem[_12799 + 32] = 'SafeMath: subtraction overflow'
                                    if stor2[stor5[idx]] <= s:
                                        if s < stor2[stor5[idx]]:
                                            revert with 0, 17
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s - stor2[stor5[idx]]
                                        t = t - stor1[stor5[idx]]
                                        continue 
                                    _12859 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _12859 + 68] = mem[idx + _12799 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12859 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12859 + -mem[64] + 100
                                _12409 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12409] = 26
                                mem[_12409 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    _13159 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13159] = 30
                                    mem[_13159 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _14024 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14024] = 30
                                    mem[_14024 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _14344 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _14344 + 68] = mem[idx + _14024 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14344 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14344 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > -1:
                                        revert with 0, 17
                                    if stor1[arg1] < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1]
                                    _17755 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17755] = 30
                                    mem[_17755 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > -1:
                                            revert with 0, 17
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _18247 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _18247 + 68] = mem[idx + _17755 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18247 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _18247 + -mem[64] + 100
                                if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _13544 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13544] = 30
                                mem[_13544 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor6 / 1000 * 10^18:
                                    _13719 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13719 + 68] = mem[idx + _13544 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13719 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13719 + -mem[64] + 100
                                if arg2 * stor6 / 1000 * 10^18 < 0:
                                    revert with 0, 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _15369 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15369] = 30
                                mem[_15369 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                    _15895 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _15895 + 68] = mem[idx + _15369 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15895 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _15895 + -mem[64] + 100
                                if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                if stor1[arg1] > !(arg2 * stor6 / 1000 * 10^18):
                                    revert with 0, 17
                                if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18)
                                _19316 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19316] = 30
                                mem[_19316 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > -1:
                                        revert with 0, 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _19802 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _19802 + 68] = mem[idx + _19316 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19802 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _19802 + -mem[64] + 100
                            if t < stor6 / 1000 * 10^18:
                                if not arg2:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > -1:
                                        revert with 0, 17
                                    if stor1[arg1] < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1]
                                else:
                                    if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                                        revert with 0, 17
                                    if not arg2:
                                        revert with 0, 18
                                    if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 0 > arg2 * stor6 / 1000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * stor6 / 1000 * 10^18 < 0:
                                        revert with 0, 17
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor1[arg1] > !(arg2 * stor6 / 1000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18)
                            else:
                                if not s:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not arg2:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > -1:
                                        revert with 0, 17
                                    if stor1[arg1] < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1]
                                else:
                                    if arg2 and t / s > -1 / arg2:
                                        revert with 0, 17
                                    if not arg2:
                                        revert with 0, 18
                                    if arg2 * t / s / arg2 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 0 > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * t / s < 0:
                                        revert with 0, 17
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * t / s:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor1[arg1] > !(arg2 * t / s):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * t / s) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * t / s)
                            if 0 > stor6:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor6 < 0:
                                revert with 0, 17
                            if totalFees > -1:
                                revert with 0, 17
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(arg2, msg.sender, arg1);
                        else:
                            if arg2 / 100 and 5 > -1 / arg2 / 100:
                                revert with 0, 17
                            if not arg2 / 100:
                                revert with 0, 18
                            if 5 * arg2 / 100 / arg2 / 100 != 5:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if 5 * arg2 / 100 > arg2:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg2 < 5 * arg2 / 100:
                                revert with 0, 17
                            idx = 0
                            s = 1000 * 10^18
                            t = stor6
                            while idx < stor5.length:
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                if stor1[stor5[idx]] > t:
                                    _12308 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12308] = 26
                                    mem[_12308 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if not 5 * arg2 / 100:
                                            _13015 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_13015] = 30
                                            mem[_13015 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _13715 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_13715] = 30
                                            mem[_13715 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _14018 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _14018 + 68] = mem[idx + _13715 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_14018 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _14018 + -mem[64] + 100
                                            if stor1[address(msg.sender)] < 0:
                                                revert with 0, 17
                                            if stor1[arg1] > -1:
                                                revert with 0, 17
                                            if stor1[arg1] < stor1[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] = stor1[arg1]
                                            _17325 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_17325] = 30
                                            mem[_17325 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if stor6 < 0:
                                                    revert with 0, 17
                                                if totalFees > !(5 * arg2 / 100):
                                                    revert with 0, 17
                                                if totalFees + (5 * arg2 / 100) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += 5 * arg2 / 100
                                                emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                                return 1
                                            _17749 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _17749 + 68] = mem[idx + _17325 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_17749 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _17749 + -mem[64] + 100
                                        if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                            revert with 0, 17
                                        if not 5 * arg2 / 100:
                                            revert with 0, 18
                                        if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _13313 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13313] = 30
                                        mem[_13313 + 32] = 'SafeMath: subtraction overflow'
                                        if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > 0:
                                            _13540 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _13540 + 68] = mem[idx + _13313 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_13540 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _13540 + -mem[64] + 100
                                        if 0 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                            revert with 0, 17
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _14847 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_14847] = 30
                                        mem[_14847 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _15361 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _15361 + 68] = mem[idx + _14847 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_15361 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _15361 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > !(-5 * arg2 / 100 * stor6 / 1000 * 10^18):
                                            revert with 0, 17
                                        if stor1[arg1] - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[arg1] - (5 * arg2 / 100 * stor6 / 1000 * 10^18)
                                        _18955 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18955] = 30
                                        mem[_18955 + 32] = 'SafeMath: subtraction overflow'
                                        if 5 * arg2 / 100 * stor6 / 1000 * 10^18 <= stor6:
                                            if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                                revert with 0, 17
                                            stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                                            if totalFees > !(5 * arg2 / 100):
                                                revert with 0, 17
                                            if totalFees + (5 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 5 * arg2 / 100
                                            emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _19308 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19308 + 68] = mem[idx + _18955 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19308 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19308 + -mem[64] + 100
                                    if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                                        revert with 0, 17
                                    if not arg2:
                                        revert with 0, 18
                                    if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 5 * arg2 / 100:
                                        _13312 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13312] = 30
                                        mem[_13312 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor6 / 1000 * 10^18:
                                            _13539 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _13539 + 68] = mem[idx + _13312 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_13539 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _13539 + -mem[64] + 100
                                        if arg2 * stor6 / 1000 * 10^18 < 0:
                                            revert with 0, 17
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _14846 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_14846] = 30
                                        mem[_14846 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            _15360 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _15360 + 68] = mem[idx + _14846 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_15360 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _15360 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                            revert with 0, 17
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor1[arg1] > !(arg2 * stor6 / 1000 * 10^18):
                                            revert with 0, 17
                                        if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18)
                                        _18954 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18954] = 30
                                        mem[_18954 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > !(5 * arg2 / 100):
                                                revert with 0, 17
                                            if totalFees + (5 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 5 * arg2 / 100
                                            emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _19307 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19307 + 68] = mem[idx + _18954 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19307 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19307 + -mem[64] + 100
                                    if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                        revert with 0, 17
                                    if not 5 * arg2 / 100:
                                        revert with 0, 18
                                    if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _14017 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14017] = 30
                                    mem[_14017 + 32] = 'SafeMath: subtraction overflow'
                                    if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                        _14336 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _14336 + 68] = mem[idx + _14017 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14336 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14336 + -mem[64] + 100
                                    if arg2 * stor6 / 1000 * 10^18 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _16387 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16387] = 30
                                    mem[_16387 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        _17036 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _17036 + 68] = mem[idx + _16387 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17036 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _17036 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor1[arg1] > !((arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)
                                    _20320 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20320] = 30
                                    mem[_20320 + 32] = 'SafeMath: subtraction overflow'
                                    if 5 * arg2 / 100 * stor6 / 1000 * 10^18 <= stor6:
                                        if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                            revert with 0, 17
                                        stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                                        if totalFees > !(5 * arg2 / 100):
                                            revert with 0, 17
                                        if totalFees + (5 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 5 * arg2 / 100
                                        emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _20724 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20724 + 68] = mem[idx + _20320 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20724 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20724 + -mem[64] + 100
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                if stor2[stor5[idx]] <= s:
                                    if idx >= stor5.length:
                                        revert with 0, 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    _12406 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12406] = 30
                                    mem[_12406 + 32] = 'SafeMath: subtraction overflow'
                                    if stor1[stor5[idx]] > t:
                                        _12458 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _12458 + 68] = mem[idx + _12406 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_12458 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _12458 + -mem[64] + 100
                                    if t < stor1[stor5[idx]]:
                                        revert with 0, 17
                                    if idx >= stor5.length:
                                        revert with 0, 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    _12797 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12797] = 30
                                    mem[_12797 + 32] = 'SafeMath: subtraction overflow'
                                    if stor2[stor5[idx]] <= s:
                                        if s < stor2[stor5[idx]]:
                                            revert with 0, 17
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s - stor2[stor5[idx]]
                                        t = t - stor1[stor5[idx]]
                                        continue 
                                    _12857 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _12857 + 68] = mem[idx + _12797 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12857 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12857 + -mem[64] + 100
                                _12407 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12407] = 26
                                mem[_12407 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not 5 * arg2 / 100:
                                        _13157 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13157] = 30
                                        mem[_13157 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _14020 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_14020] = 30
                                        mem[_14020 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _14340 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _14340 + 68] = mem[idx + _14020 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_14340 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _14340 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > -1:
                                            revert with 0, 17
                                        if stor1[arg1] < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[arg1]
                                        _17751 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17751] = 30
                                        mem[_17751 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > !(5 * arg2 / 100):
                                                revert with 0, 17
                                            if totalFees + (5 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 5 * arg2 / 100
                                            emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _18234 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _18234 + 68] = mem[idx + _17751 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18234 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _18234 + -mem[64] + 100
                                    if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                        revert with 0, 17
                                    if not 5 * arg2 / 100:
                                        revert with 0, 18
                                    if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _13542 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13542] = 30
                                    mem[_13542 + 32] = 'SafeMath: subtraction overflow'
                                    if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > 0:
                                        _13717 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13717 + 68] = mem[idx + _13542 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13717 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13717 + -mem[64] + 100
                                    if 0 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _15364 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15364] = 30
                                    mem[_15364 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _15891 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _15891 + 68] = mem[idx + _15364 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_15891 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _15891 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > !(-5 * arg2 / 100 * stor6 / 1000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg1] - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1] - (5 * arg2 / 100 * stor6 / 1000 * 10^18)
                                    _19311 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19311] = 30
                                    mem[_19311 + 32] = 'SafeMath: subtraction overflow'
                                    if 5 * arg2 / 100 * stor6 / 1000 * 10^18 <= stor6:
                                        if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                            revert with 0, 17
                                        stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                                        if totalFees > !(5 * arg2 / 100):
                                            revert with 0, 17
                                        if totalFees + (5 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 5 * arg2 / 100
                                        emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _19796 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19796 + 68] = mem[idx + _19311 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19796 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19796 + -mem[64] + 100
                                if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 5 * arg2 / 100:
                                    _13541 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13541] = 30
                                    mem[_13541 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 1000 * 10^18:
                                        _13716 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13716 + 68] = mem[idx + _13541 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13716 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13716 + -mem[64] + 100
                                    if arg2 * stor6 / 1000 * 10^18 < 0:
                                        revert with 0, 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _15363 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15363] = 30
                                    mem[_15363 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        _15890 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _15890 + 68] = mem[idx + _15363 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_15890 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _15890 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor1[arg1] > !(arg2 * stor6 / 1000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18)
                                    _19310 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19310] = 30
                                    mem[_19310 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > !(5 * arg2 / 100):
                                            revert with 0, 17
                                        if totalFees + (5 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 5 * arg2 / 100
                                        emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _19795 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19795 + 68] = mem[idx + _19310 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19795 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19795 + -mem[64] + 100
                                if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                    revert with 0, 17
                                if not 5 * arg2 / 100:
                                    revert with 0, 18
                                if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _14339 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14339] = 30
                                mem[_14339 + 32] = 'SafeMath: subtraction overflow'
                                if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                    _14848 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _14848 + 68] = mem[idx + _14339 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14848 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14848 + -mem[64] + 100
                                if arg2 * stor6 / 1000 * 10^18 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                    revert with 0, 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _17039 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17039] = 30
                                mem[_17039 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                    _17610 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _17610 + 68] = mem[idx + _17039 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_17610 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _17610 + -mem[64] + 100
                                if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                if stor1[arg1] > !((arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)):
                                    revert with 0, 17
                                if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)
                                _20728 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20728] = 30
                                mem[_20728 + 32] = 'SafeMath: subtraction overflow'
                                if 5 * arg2 / 100 * stor6 / 1000 * 10^18 <= stor6:
                                    if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                                    if totalFees > !(5 * arg2 / 100):
                                        revert with 0, 17
                                    if totalFees + (5 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 5 * arg2 / 100
                                    emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _21189 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21189 + 68] = mem[idx + _20728 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21189 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21189 + -mem[64] + 100
                            if t < stor6 / 1000 * 10^18:
                                if not arg2:
                                    if not 5 * arg2 / 100:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > -1:
                                            revert with 0, 17
                                        if stor1[arg1] < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1]
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 0, 17
                                    else:
                                        if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                            revert with 0, 17
                                        if not 5 * arg2 / 100:
                                            revert with 0, 18
                                        if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if 0 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                            revert with 0, 17
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > !(-5 * arg2 / 100 * stor6 / 1000 * 10^18):
                                            revert with 0, 17
                                        if stor1[arg1] - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1] - (5 * arg2 / 100 * stor6 / 1000 * 10^18)
                                        if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                            revert with 0, 17
                                        stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                                else:
                                    if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                                        revert with 0, 17
                                    if not arg2:
                                        revert with 0, 18
                                    if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 5 * arg2 / 100:
                                        if 0 > arg2 * stor6 / 1000 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg2 * stor6 / 1000 * 10^18 < 0:
                                            revert with 0, 17
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                            revert with 0, 17
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor1[arg1] > !(arg2 * stor6 / 1000 * 10^18):
                                            revert with 0, 17
                                        if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18)
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 0, 17
                                    else:
                                        if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                            revert with 0, 17
                                        if not 5 * arg2 / 100:
                                            revert with 0, 18
                                        if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg2 * stor6 / 1000 * 10^18 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                            revert with 0, 17
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                            revert with 0, 17
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor1[arg1] > !((arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)):
                                            revert with 0, 17
                                        if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)
                                        if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                            revert with 0, 17
                                        stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                            else:
                                if not s:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not arg2:
                                    if not 5 * arg2 / 100:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > -1:
                                            revert with 0, 17
                                        if stor1[arg1] < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1]
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 0, 17
                                    else:
                                        if 5 * arg2 / 100 and t / s > -1 / 5 * arg2 / 100:
                                            revert with 0, 17
                                        if not 5 * arg2 / 100:
                                            revert with 0, 18
                                        if 5 * arg2 / 100 * t / s / 5 * arg2 / 100 != t / s:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if 5 * arg2 / 100 * t / s > 0:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if 0 < 5 * arg2 / 100 * t / s:
                                            revert with 0, 17
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > !(-5 * arg2 / 100 * t / s):
                                            revert with 0, 17
                                        if stor1[arg1] - (5 * arg2 / 100 * t / s) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1] - (5 * arg2 / 100 * t / s)
                                        if 5 * arg2 / 100 * t / s > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 5 * arg2 / 100 * t / s:
                                            revert with 0, 17
                                        stor6 += -5 * arg2 / 100 * t / s
                                else:
                                    if arg2 and t / s > -1 / arg2:
                                        revert with 0, 17
                                    if not arg2:
                                        revert with 0, 18
                                    if arg2 * t / s / arg2 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 5 * arg2 / 100:
                                        if 0 > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg2 * t / s < 0:
                                            revert with 0, 17
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < arg2 * t / s:
                                            revert with 0, 17
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor1[arg1] > !(arg2 * t / s):
                                            revert with 0, 17
                                        if stor1[arg1] + (arg2 * t / s) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1] + (arg2 * t / s)
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 0, 17
                                    else:
                                        if 5 * arg2 / 100 and t / s > -1 / 5 * arg2 / 100:
                                            revert with 0, 17
                                        if not 5 * arg2 / 100:
                                            revert with 0, 18
                                        if 5 * arg2 / 100 * t / s / 5 * arg2 / 100 != t / s:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if 5 * arg2 / 100 * t / s > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg2 * t / s < 5 * arg2 / 100 * t / s:
                                            revert with 0, 17
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < arg2 * t / s:
                                            revert with 0, 17
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor1[arg1] > !((arg2 * t / s) - (5 * arg2 / 100 * t / s)):
                                            revert with 0, 17
                                        if stor1[arg1] + (arg2 * t / s) - (5 * arg2 / 100 * t / s) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1] + (arg2 * t / s) - (5 * arg2 / 100 * t / s)
                                        if 5 * arg2 / 100 * t / s > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 5 * arg2 / 100 * t / s:
                                            revert with 0, 17
                                        stor6 += -5 * arg2 / 100 * t / s
                            if totalFees > !(5 * arg2 / 100):
                                revert with 0, 17
                            if totalFees + (5 * arg2 / 100) < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += 5 * arg2 / 100
                            emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                    else:
                        if not arg2 / 100:
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if 0 > arg2:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg2 < 0:
                                revert with 0, 17
                            idx = 0
                            s = 1000 * 10^18
                            t = stor6
                            while idx < stor5.length:
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                if stor1[stor5[idx]] > t:
                                    _12311 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12311] = 26
                                    mem[_12311 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        _13024 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13024] = 30
                                        mem[_13024 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _13726 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13726] = 30
                                        mem[_13726 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _14035 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _14035 + 68] = mem[idx + _13726 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_14035 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _14035 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > -1:
                                            revert with 0, 17
                                        if stor1[arg1] < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[arg1]
                                        _17360 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17360] = 30
                                        mem[_17360 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > -1:
                                                revert with 0, 17
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _17768 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _17768 + 68] = mem[idx + _17360 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17768 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _17768 + -mem[64] + 100
                                    if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                                        revert with 0, 17
                                    if not arg2:
                                        revert with 0, 18
                                    if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _13331 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13331] = 30
                                    mem[_13331 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 1000 * 10^18:
                                        _13549 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13549 + 68] = mem[idx + _13331 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13549 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13549 + -mem[64] + 100
                                    if arg2 * stor6 / 1000 * 10^18 < 0:
                                        revert with 0, 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _14866 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14866] = 30
                                    mem[_14866 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        _15381 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _15381 + 68] = mem[idx + _14866 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_15381 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _15381 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor1[arg1] > !(arg2 * stor6 / 1000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18)
                                    _18983 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18983] = 30
                                    mem[_18983 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > -1:
                                            revert with 0, 17
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _19328 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19328 + 68] = mem[idx + _18983 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19328 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19328 + -mem[64] + 100
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                if stor2[stor5[idx]] <= s:
                                    if idx >= stor5.length:
                                        revert with 0, 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    _12412 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12412] = 30
                                    mem[_12412 + 32] = 'SafeMath: subtraction overflow'
                                    if stor1[stor5[idx]] > t:
                                        _12461 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _12461 + 68] = mem[idx + _12412 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_12461 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _12461 + -mem[64] + 100
                                    if t < stor1[stor5[idx]]:
                                        revert with 0, 17
                                    if idx >= stor5.length:
                                        revert with 0, 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    _12803 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12803] = 30
                                    mem[_12803 + 32] = 'SafeMath: subtraction overflow'
                                    if stor2[stor5[idx]] <= s:
                                        if s < stor2[stor5[idx]]:
                                            revert with 0, 17
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s - stor2[stor5[idx]]
                                        t = t - stor1[stor5[idx]]
                                        continue 
                                    _12863 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _12863 + 68] = mem[idx + _12803 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12863 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12863 + -mem[64] + 100
                                _12413 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12413] = 26
                                mem[_12413 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    _13163 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13163] = 30
                                    mem[_13163 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _14036 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14036] = 30
                                    mem[_14036 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _14357 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _14357 + 68] = mem[idx + _14036 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14357 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14357 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > -1:
                                        revert with 0, 17
                                    if stor1[arg1] < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1]
                                    _17769 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17769] = 30
                                    mem[_17769 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > -1:
                                            revert with 0, 17
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _18285 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _18285 + 68] = mem[idx + _17769 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18285 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _18285 + -mem[64] + 100
                                if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _13550 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13550] = 30
                                mem[_13550 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor6 / 1000 * 10^18:
                                    _13727 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13727 + 68] = mem[idx + _13550 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13727 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13727 + -mem[64] + 100
                                if arg2 * stor6 / 1000 * 10^18 < 0:
                                    revert with 0, 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _15383 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15383] = 30
                                mem[_15383 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                    _15909 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _15909 + 68] = mem[idx + _15383 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15909 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _15909 + -mem[64] + 100
                                if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                if stor1[arg1] > !(arg2 * stor6 / 1000 * 10^18):
                                    revert with 0, 17
                                if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18)
                                _19330 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19330] = 30
                                mem[_19330 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > -1:
                                        revert with 0, 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _19827 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _19827 + 68] = mem[idx + _19330 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19827 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _19827 + -mem[64] + 100
                            if t < stor6 / 1000 * 10^18:
                                if not arg2:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > -1:
                                        revert with 0, 17
                                    if stor1[arg1] < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1]
                                else:
                                    if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                                        revert with 0, 17
                                    if not arg2:
                                        revert with 0, 18
                                    if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 0 > arg2 * stor6 / 1000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * stor6 / 1000 * 10^18 < 0:
                                        revert with 0, 17
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor1[arg1] > !(arg2 * stor6 / 1000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18)
                            else:
                                if not s:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not arg2:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > -1:
                                        revert with 0, 17
                                    if stor1[arg1] < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1]
                                else:
                                    if arg2 and t / s > -1 / arg2:
                                        revert with 0, 17
                                    if not arg2:
                                        revert with 0, 18
                                    if arg2 * t / s / arg2 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 0 > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * t / s < 0:
                                        revert with 0, 17
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * t / s:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor1[arg1] > !(arg2 * t / s):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * t / s) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * t / s)
                            if 0 > stor6:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor6 < 0:
                                revert with 0, 17
                            if totalFees > -1:
                                revert with 0, 17
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(arg2, msg.sender, arg1);
                        else:
                            if arg2 / 100 and 5 > -1 / arg2 / 100:
                                revert with 0, 17
                            if not arg2 / 100:
                                revert with 0, 18
                            if 5 * arg2 / 100 / arg2 / 100 != 5:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if 5 * arg2 / 100 > arg2:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg2 < 5 * arg2 / 100:
                                revert with 0, 17
                            idx = 0
                            s = 1000 * 10^18
                            t = stor6
                            while idx < stor5.length:
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                if stor1[stor5[idx]] > t:
                                    _12310 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12310] = 26
                                    mem[_12310 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if not 5 * arg2 / 100:
                                            _13021 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_13021] = 30
                                            mem[_13021 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _13723 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_13723] = 30
                                            mem[_13723 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _14030 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _14030 + 68] = mem[idx + _13723 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_14030 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _14030 + -mem[64] + 100
                                            if stor1[address(msg.sender)] < 0:
                                                revert with 0, 17
                                            if stor1[arg1] > -1:
                                                revert with 0, 17
                                            if stor1[arg1] < stor1[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] = stor1[arg1]
                                            _17349 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_17349] = 30
                                            mem[_17349 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if stor6 < 0:
                                                    revert with 0, 17
                                                if totalFees > !(5 * arg2 / 100):
                                                    revert with 0, 17
                                                if totalFees + (5 * arg2 / 100) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += 5 * arg2 / 100
                                                emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                                return 1
                                            _17763 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _17763 + 68] = mem[idx + _17349 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_17763 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _17763 + -mem[64] + 100
                                        if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                            revert with 0, 17
                                        if not 5 * arg2 / 100:
                                            revert with 0, 18
                                        if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _13325 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13325] = 30
                                        mem[_13325 + 32] = 'SafeMath: subtraction overflow'
                                        if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > 0:
                                            _13546 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _13546 + 68] = mem[idx + _13325 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_13546 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _13546 + -mem[64] + 100
                                        if 0 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                            revert with 0, 17
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _14860 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_14860] = 30
                                        mem[_14860 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _15375 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _15375 + 68] = mem[idx + _14860 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_15375 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _15375 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > !(-5 * arg2 / 100 * stor6 / 1000 * 10^18):
                                            revert with 0, 17
                                        if stor1[arg1] - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[arg1] - (5 * arg2 / 100 * stor6 / 1000 * 10^18)
                                        _18973 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18973] = 30
                                        mem[_18973 + 32] = 'SafeMath: subtraction overflow'
                                        if 5 * arg2 / 100 * stor6 / 1000 * 10^18 <= stor6:
                                            if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                                revert with 0, 17
                                            stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                                            if totalFees > !(5 * arg2 / 100):
                                                revert with 0, 17
                                            if totalFees + (5 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 5 * arg2 / 100
                                            emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _19322 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19322 + 68] = mem[idx + _18973 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19322 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19322 + -mem[64] + 100
                                    if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                                        revert with 0, 17
                                    if not arg2:
                                        revert with 0, 18
                                    if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 5 * arg2 / 100:
                                        _13324 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13324] = 30
                                        mem[_13324 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor6 / 1000 * 10^18:
                                            _13545 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _13545 + 68] = mem[idx + _13324 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_13545 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _13545 + -mem[64] + 100
                                        if arg2 * stor6 / 1000 * 10^18 < 0:
                                            revert with 0, 17
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _14859 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_14859] = 30
                                        mem[_14859 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            _15374 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _15374 + 68] = mem[idx + _14859 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_15374 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _15374 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                            revert with 0, 17
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor1[arg1] > !(arg2 * stor6 / 1000 * 10^18):
                                            revert with 0, 17
                                        if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18)
                                        _18972 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18972] = 30
                                        mem[_18972 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > !(5 * arg2 / 100):
                                                revert with 0, 17
                                            if totalFees + (5 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 5 * arg2 / 100
                                            emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _19321 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19321 + 68] = mem[idx + _18972 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19321 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19321 + -mem[64] + 100
                                    if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                        revert with 0, 17
                                    if not 5 * arg2 / 100:
                                        revert with 0, 18
                                    if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _14029 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14029] = 30
                                    mem[_14029 + 32] = 'SafeMath: subtraction overflow'
                                    if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                        _14349 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _14349 + 68] = mem[idx + _14029 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14349 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14349 + -mem[64] + 100
                                    if arg2 * stor6 / 1000 * 10^18 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _16397 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16397] = 30
                                    mem[_16397 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        _17053 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _17053 + 68] = mem[idx + _16397 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17053 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _17053 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor1[arg1] > !((arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)
                                    _20331 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20331] = 30
                                    mem[_20331 + 32] = 'SafeMath: subtraction overflow'
                                    if 5 * arg2 / 100 * stor6 / 1000 * 10^18 <= stor6:
                                        if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                            revert with 0, 17
                                        stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                                        if totalFees > !(5 * arg2 / 100):
                                            revert with 0, 17
                                        if totalFees + (5 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 5 * arg2 / 100
                                        emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _20743 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20743 + 68] = mem[idx + _20331 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20743 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20743 + -mem[64] + 100
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                if stor2[stor5[idx]] <= s:
                                    if idx >= stor5.length:
                                        revert with 0, 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    _12410 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12410] = 30
                                    mem[_12410 + 32] = 'SafeMath: subtraction overflow'
                                    if stor1[stor5[idx]] > t:
                                        _12460 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _12460 + 68] = mem[idx + _12410 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_12460 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _12460 + -mem[64] + 100
                                    if t < stor1[stor5[idx]]:
                                        revert with 0, 17
                                    if idx >= stor5.length:
                                        revert with 0, 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    _12801 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12801] = 30
                                    mem[_12801 + 32] = 'SafeMath: subtraction overflow'
                                    if stor2[stor5[idx]] <= s:
                                        if s < stor2[stor5[idx]]:
                                            revert with 0, 17
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s - stor2[stor5[idx]]
                                        t = t - stor1[stor5[idx]]
                                        continue 
                                    _12861 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _12861 + 68] = mem[idx + _12801 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12861 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12861 + -mem[64] + 100
                                _12411 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12411] = 26
                                mem[_12411 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not 5 * arg2 / 100:
                                        _13161 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13161] = 30
                                        mem[_13161 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _14032 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_14032] = 30
                                        mem[_14032 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _14353 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _14353 + 68] = mem[idx + _14032 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_14353 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _14353 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > -1:
                                            revert with 0, 17
                                        if stor1[arg1] < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[arg1]
                                        _17765 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17765] = 30
                                        mem[_17765 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > !(5 * arg2 / 100):
                                                revert with 0, 17
                                            if totalFees + (5 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 5 * arg2 / 100
                                            emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _18272 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _18272 + 68] = mem[idx + _17765 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18272 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _18272 + -mem[64] + 100
                                    if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                        revert with 0, 17
                                    if not 5 * arg2 / 100:
                                        revert with 0, 18
                                    if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _13548 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13548] = 30
                                    mem[_13548 + 32] = 'SafeMath: subtraction overflow'
                                    if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > 0:
                                        _13725 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13725 + 68] = mem[idx + _13548 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13725 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13725 + -mem[64] + 100
                                    if 0 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _15378 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15378] = 30
                                    mem[_15378 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _15905 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _15905 + 68] = mem[idx + _15378 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_15905 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _15905 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > !(-5 * arg2 / 100 * stor6 / 1000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg1] - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1] - (5 * arg2 / 100 * stor6 / 1000 * 10^18)
                                    _19325 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19325] = 30
                                    mem[_19325 + 32] = 'SafeMath: subtraction overflow'
                                    if 5 * arg2 / 100 * stor6 / 1000 * 10^18 <= stor6:
                                        if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                            revert with 0, 17
                                        stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                                        if totalFees > !(5 * arg2 / 100):
                                            revert with 0, 17
                                        if totalFees + (5 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 5 * arg2 / 100
                                        emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _19821 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19821 + 68] = mem[idx + _19325 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19821 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19821 + -mem[64] + 100
                                if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 5 * arg2 / 100:
                                    _13547 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13547] = 30
                                    mem[_13547 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 1000 * 10^18:
                                        _13724 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13724 + 68] = mem[idx + _13547 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13724 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13724 + -mem[64] + 100
                                    if arg2 * stor6 / 1000 * 10^18 < 0:
                                        revert with 0, 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _15377 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15377] = 30
                                    mem[_15377 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        _15904 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _15904 + 68] = mem[idx + _15377 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_15904 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _15904 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor1[arg1] > !(arg2 * stor6 / 1000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18)
                                    _19324 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19324] = 30
                                    mem[_19324 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > !(5 * arg2 / 100):
                                            revert with 0, 17
                                        if totalFees + (5 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 5 * arg2 / 100
                                        emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _19820 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19820 + 68] = mem[idx + _19324 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19820 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19820 + -mem[64] + 100
                                if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                    revert with 0, 17
                                if not 5 * arg2 / 100:
                                    revert with 0, 18
                                if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _14352 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14352] = 30
                                mem[_14352 + 32] = 'SafeMath: subtraction overflow'
                                if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                    _14861 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _14861 + 68] = mem[idx + _14352 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14861 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14861 + -mem[64] + 100
                                if arg2 * stor6 / 1000 * 10^18 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                    revert with 0, 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _17056 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17056] = 30
                                mem[_17056 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                    _17616 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _17616 + 68] = mem[idx + _17056 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_17616 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _17616 + -mem[64] + 100
                                if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                if stor1[arg1] > !((arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)):
                                    revert with 0, 17
                                if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)
                                _20747 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20747] = 30
                                mem[_20747 + 32] = 'SafeMath: subtraction overflow'
                                if 5 * arg2 / 100 * stor6 / 1000 * 10^18 <= stor6:
                                    if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                                    if totalFees > !(5 * arg2 / 100):
                                        revert with 0, 17
                                    if totalFees + (5 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 5 * arg2 / 100
                                    emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _21199 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21199 + 68] = mem[idx + _20747 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21199 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21199 + -mem[64] + 100
                            if t < stor6 / 1000 * 10^18:
                                if not arg2:
                                    if not 5 * arg2 / 100:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > -1:
                                            revert with 0, 17
                                        if stor1[arg1] < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1]
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 0, 17
                                    else:
                                        if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                            revert with 0, 17
                                        if not 5 * arg2 / 100:
                                            revert with 0, 18
                                        if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if 0 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                            revert with 0, 17
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > !(-5 * arg2 / 100 * stor6 / 1000 * 10^18):
                                            revert with 0, 17
                                        if stor1[arg1] - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1] - (5 * arg2 / 100 * stor6 / 1000 * 10^18)
                                        if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                            revert with 0, 17
                                        stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                                else:
                                    if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                                        revert with 0, 17
                                    if not arg2:
                                        revert with 0, 18
                                    if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 5 * arg2 / 100:
                                        if 0 > arg2 * stor6 / 1000 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg2 * stor6 / 1000 * 10^18 < 0:
                                            revert with 0, 17
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                            revert with 0, 17
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor1[arg1] > !(arg2 * stor6 / 1000 * 10^18):
                                            revert with 0, 17
                                        if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18)
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 0, 17
                                    else:
                                        if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                            revert with 0, 17
                                        if not 5 * arg2 / 100:
                                            revert with 0, 18
                                        if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg2 * stor6 / 1000 * 10^18 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                            revert with 0, 17
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                            revert with 0, 17
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor1[arg1] > !((arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)):
                                            revert with 0, 17
                                        if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)
                                        if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                            revert with 0, 17
                                        stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                            else:
                                if not s:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not arg2:
                                    if not 5 * arg2 / 100:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > -1:
                                            revert with 0, 17
                                        if stor1[arg1] < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1]
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 0, 17
                                    else:
                                        if 5 * arg2 / 100 and t / s > -1 / 5 * arg2 / 100:
                                            revert with 0, 17
                                        if not 5 * arg2 / 100:
                                            revert with 0, 18
                                        if 5 * arg2 / 100 * t / s / 5 * arg2 / 100 != t / s:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if 5 * arg2 / 100 * t / s > 0:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if 0 < 5 * arg2 / 100 * t / s:
                                            revert with 0, 17
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > !(-5 * arg2 / 100 * t / s):
                                            revert with 0, 17
                                        if stor1[arg1] - (5 * arg2 / 100 * t / s) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1] - (5 * arg2 / 100 * t / s)
                                        if 5 * arg2 / 100 * t / s > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 5 * arg2 / 100 * t / s:
                                            revert with 0, 17
                                        stor6 += -5 * arg2 / 100 * t / s
                                else:
                                    if arg2 and t / s > -1 / arg2:
                                        revert with 0, 17
                                    if not arg2:
                                        revert with 0, 18
                                    if arg2 * t / s / arg2 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 5 * arg2 / 100:
                                        if 0 > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg2 * t / s < 0:
                                            revert with 0, 17
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < arg2 * t / s:
                                            revert with 0, 17
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor1[arg1] > !(arg2 * t / s):
                                            revert with 0, 17
                                        if stor1[arg1] + (arg2 * t / s) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1] + (arg2 * t / s)
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 0, 17
                                    else:
                                        if 5 * arg2 / 100 and t / s > -1 / 5 * arg2 / 100:
                                            revert with 0, 17
                                        if not 5 * arg2 / 100:
                                            revert with 0, 18
                                        if 5 * arg2 / 100 * t / s / 5 * arg2 / 100 != t / s:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if 5 * arg2 / 100 * t / s > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg2 * t / s < 5 * arg2 / 100 * t / s:
                                            revert with 0, 17
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < arg2 * t / s:
                                            revert with 0, 17
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor1[arg1] > !((arg2 * t / s) - (5 * arg2 / 100 * t / s)):
                                            revert with 0, 17
                                        if stor1[arg1] + (arg2 * t / s) - (5 * arg2 / 100 * t / s) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1] + (arg2 * t / s) - (5 * arg2 / 100 * t / s)
                                        if 5 * arg2 / 100 * t / s > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 5 * arg2 / 100 * t / s:
                                            revert with 0, 17
                                        stor6 += -5 * arg2 / 100 * t / s
                            if totalFees > !(5 * arg2 / 100):
                                revert with 0, 17
                            if totalFees + (5 * arg2 / 100) < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += 5 * arg2 / 100
                            emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
    else:
        mem[0] = arg1
        mem[32] = 4
        if not stor4[address(arg1)]:
            mem[96] = 26
            mem[128] = 'SafeMath: division by zero'
            if not arg2 / 100:
                mem[64] = 224
                mem[160] = 30
                mem[192] = 'SafeMath: subtraction overflow'
                if 0 > arg2:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg2 < 0:
                    revert with 0, 17
                idx = 0
                s = 1000 * 10^18
                t = stor6
                while idx < stor5.length:
                    mem[0] = stor5[idx]
                    mem[32] = 1
                    if stor1[stor5[idx]] > t:
                        _12329 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12329] = 26
                        mem[_12329 + 32] = 'SafeMath: division by zero'
                        if not arg2:
                            _13078 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13078] = 30
                            mem[_13078 + 32] = 'SafeMath: subtraction overflow'
                            mem[0] = msg.sender
                            mem[32] = 2
                            _13798 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13798] = 30
                            mem[_13798 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 > stor2[address(msg.sender)]:
                                _14143 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14143 + 68] = mem[idx + _13798 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14143 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14143 + -mem[64] + 100
                            if stor2[address(msg.sender)] < arg2:
                                revert with 0, 17
                            mem[0] = msg.sender
                            stor2[address(msg.sender)] -= arg2
                            mem[32] = 1
                            _15509 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15509] = 30
                            mem[_15509 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor1[address(msg.sender)]:
                                _16037 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _16037 + 68] = mem[idx + _15509 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_16037 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _16037 + -mem[64] + 100
                            if stor1[address(msg.sender)] < 0:
                                revert with 0, 17
                            if stor1[arg1] > -1:
                                revert with 0, 17
                            if stor1[arg1] < stor1[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] = stor1[arg1]
                            _19445 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19445] = 30
                            mem[_19445 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor6:
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > -1:
                                    revert with 0, 17
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg2, msg.sender, arg1);
                                return 1
                            _20081 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _20081 + 68] = mem[idx + _19445 + 32]
                                idx = idx + 32
                                continue 
                            mem[_20081 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _20081 + -mem[64] + 100
                        if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                            revert with 0, 17
                        if not arg2:
                            revert with 0, 18
                        if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _13439 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13439] = 30
                        mem[_13439 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg2 * stor6 / 1000 * 10^18:
                            _13603 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13603 + 68] = mem[idx + _13439 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13603 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13603 + -mem[64] + 100
                        if arg2 * stor6 / 1000 * 10^18 < 0:
                            revert with 0, 17
                        mem[0] = msg.sender
                        mem[32] = 2
                        _14983 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14983] = 30
                        mem[_14983 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 > stor2[address(msg.sender)]:
                            _15508 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _15508 + 68] = mem[idx + _14983 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15508 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _15508 + -mem[64] + 100
                        if stor2[address(msg.sender)] < arg2:
                            revert with 0, 17
                        mem[0] = msg.sender
                        stor2[address(msg.sender)] -= arg2
                        mem[32] = 1
                        _17220 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_17220] = 30
                        mem[_17220 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                            _17682 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _17682 + 68] = mem[idx + _17220 + 32]
                                idx = idx + 32
                                continue 
                            mem[_17682 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _17682 + -mem[64] + 100
                        if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                            revert with 0, 17
                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                        if stor1[arg1] > !(arg2 * stor6 / 1000 * 10^18):
                            revert with 0, 17
                        if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) < stor1[arg1]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg1
                        mem[32] = 1
                        stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18)
                        _20909 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_20909] = 30
                        mem[_20909 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= stor6:
                            if stor6 < 0:
                                revert with 0, 17
                            if totalFees > -1:
                                revert with 0, 17
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(arg2, msg.sender, arg1);
                            return 1
                        _21326 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _21326 + 68] = mem[idx + _20909 + 32]
                            idx = idx + 32
                            continue 
                        mem[_21326 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _21326 + -mem[64] + 100
                    if idx >= stor5.length:
                        revert with 0, 50
                    mem[0] = stor5[idx]
                    mem[32] = 2
                    if stor2[stor5[idx]] <= s:
                        if idx >= stor5.length:
                            revert with 0, 50
                        mem[0] = stor5[idx]
                        mem[32] = 1
                        _12448 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12448] = 30
                        mem[_12448 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor5[idx]] > t:
                            _12479 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12479 + 68] = mem[idx + _12448 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12479 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12479 + -mem[64] + 100
                        if t < stor1[stor5[idx]]:
                            revert with 0, 17
                        if idx >= stor5.length:
                            revert with 0, 50
                        mem[0] = stor5[idx]
                        mem[32] = 2
                        _12839 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12839] = 30
                        mem[_12839 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor5[idx]] <= s:
                            if s < stor2[stor5[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor2[stor5[idx]]
                            t = t - stor1[stor5[idx]]
                            continue 
                        _12899 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _12899 + 68] = mem[idx + _12839 + 32]
                            idx = idx + 32
                            continue 
                        mem[_12899 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12899 + -mem[64] + 100
                    _12449 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12449] = 26
                    mem[_12449 + 32] = 'SafeMath: division by zero'
                    if not arg2:
                        _13199 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13199] = 30
                        mem[_13199 + 32] = 'SafeMath: subtraction overflow'
                        mem[0] = msg.sender
                        mem[32] = 2
                        _14144 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14144] = 30
                        mem[_14144 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 > stor2[address(msg.sender)]:
                            _14474 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _14474 + 68] = mem[idx + _14144 + 32]
                                idx = idx + 32
                                continue 
                            mem[_14474 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14474 + -mem[64] + 100
                        if stor2[address(msg.sender)] < arg2:
                            revert with 0, 17
                        mem[0] = msg.sender
                        stor2[address(msg.sender)] -= arg2
                        mem[32] = 1
                        _16039 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16039] = 30
                        mem[_16039 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor1[address(msg.sender)]:
                            _16492 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _16492 + 68] = mem[idx + _16039 + 32]
                                idx = idx + 32
                                continue 
                            mem[_16492 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _16492 + -mem[64] + 100
                        if stor1[address(msg.sender)] < 0:
                            revert with 0, 17
                        if stor1[arg1] > -1:
                            revert with 0, 17
                        if stor1[arg1] < stor1[arg1]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg1
                        mem[32] = 1
                        stor1[address(arg1)] = stor1[arg1]
                        _20082 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_20082] = 30
                        mem[_20082 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= stor6:
                            if stor6 < 0:
                                revert with 0, 17
                            if totalFees > -1:
                                revert with 0, 17
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(arg2, msg.sender, arg1);
                            return 1
                        _20473 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _20473 + 68] = mem[idx + _20082 + 32]
                            idx = idx + 32
                            continue 
                        mem[_20473 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _20473 + -mem[64] + 100
                    if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                        revert with 0, 17
                    if not arg2:
                        revert with 0, 18
                    if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _13604 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_13604] = 30
                    mem[_13604 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg2 * stor6 / 1000 * 10^18:
                        _13799 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13799 + 68] = mem[idx + _13604 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13799 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13799 + -mem[64] + 100
                    if arg2 * stor6 / 1000 * 10^18 < 0:
                        revert with 0, 17
                    mem[0] = msg.sender
                    mem[32] = 2
                    _15511 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15511] = 30
                    mem[_15511 + 32] = 'SafeMath: subtraction overflow'
                    if arg2 > stor2[address(msg.sender)]:
                        _16038 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _16038 + 68] = mem[idx + _15511 + 32]
                            idx = idx + 32
                            continue 
                        mem[_16038 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _16038 + -mem[64] + 100
                    if stor2[address(msg.sender)] < arg2:
                        revert with 0, 17
                    mem[0] = msg.sender
                    stor2[address(msg.sender)] -= arg2
                    mem[32] = 1
                    _17684 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_17684] = 30
                    mem[_17684 + 32] = 'SafeMath: subtraction overflow'
                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                        _18056 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _18056 + 68] = mem[idx + _17684 + 32]
                            idx = idx + 32
                            continue 
                        mem[_18056 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _18056 + -mem[64] + 100
                    if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                        revert with 0, 17
                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                    if stor1[arg1] > !(arg2 * stor6 / 1000 * 10^18):
                        revert with 0, 17
                    if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) < stor1[arg1]:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[0] = arg1
                    mem[32] = 1
                    stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18)
                    _21328 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_21328] = 30
                    mem[_21328 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= stor6:
                        if stor6 < 0:
                            revert with 0, 17
                        if totalFees > -1:
                            revert with 0, 17
                        if totalFees < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        emit Transfer(arg2, msg.sender, arg1);
                        return 1
                    _21640 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _21640 + 68] = mem[idx + _21328 + 32]
                        idx = idx + 32
                        continue 
                    mem[_21640 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _21640 + -mem[64] + 100
                if t < stor6 / 1000 * 10^18:
                    if not arg2:
                        if arg2 > stor2[address(msg.sender)]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor2[address(msg.sender)] < arg2:
                            revert with 0, 17
                        stor2[address(msg.sender)] -= arg2
                        if 0 > stor1[address(msg.sender)]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor1[address(msg.sender)] < 0:
                            revert with 0, 17
                        if stor1[arg1] > -1:
                            revert with 0, 17
                        if stor1[arg1] < stor1[arg1]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor1[address(arg1)] = stor1[arg1]
                    else:
                        if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                            revert with 0, 17
                        if not arg2:
                            revert with 0, 18
                        if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 > arg2 * stor6 / 1000 * 10^18:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg2 * stor6 / 1000 * 10^18 < 0:
                            revert with 0, 17
                        if arg2 > stor2[address(msg.sender)]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor2[address(msg.sender)] < arg2:
                            revert with 0, 17
                        stor2[address(msg.sender)] -= arg2
                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                            revert with 0, 17
                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                        if stor1[arg1] > !(arg2 * stor6 / 1000 * 10^18):
                            revert with 0, 17
                        if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) < stor1[arg1]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18)
                else:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg2:
                        if arg2 > stor2[address(msg.sender)]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor2[address(msg.sender)] < arg2:
                            revert with 0, 17
                        stor2[address(msg.sender)] -= arg2
                        if 0 > stor1[address(msg.sender)]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor1[address(msg.sender)] < 0:
                            revert with 0, 17
                        if stor1[arg1] > -1:
                            revert with 0, 17
                        if stor1[arg1] < stor1[arg1]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor1[address(arg1)] = stor1[arg1]
                    else:
                        if arg2 and t / s > -1 / arg2:
                            revert with 0, 17
                        if not arg2:
                            revert with 0, 18
                        if arg2 * t / s / arg2 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 > arg2 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg2 * t / s < 0:
                            revert with 0, 17
                        if arg2 > stor2[address(msg.sender)]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor2[address(msg.sender)] < arg2:
                            revert with 0, 17
                        stor2[address(msg.sender)] -= arg2
                        if arg2 * t / s > stor1[address(msg.sender)]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor1[address(msg.sender)] < arg2 * t / s:
                            revert with 0, 17
                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                        if stor1[arg1] > !(arg2 * t / s):
                            revert with 0, 17
                        if stor1[arg1] + (arg2 * t / s) < stor1[arg1]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor1[address(arg1)] = stor1[arg1] + (arg2 * t / s)
                if 0 > stor6:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if stor6 < 0:
                    revert with 0, 17
                if totalFees > -1:
                    revert with 0, 17
                if totalFees < totalFees:
                    revert with 0, 'SafeMath: addition overflow'
                emit Transfer(arg2, msg.sender, arg1);
            else:
                if arg2 / 100 and 5 > -1 / arg2 / 100:
                    revert with 0, 17
                if not arg2 / 100:
                    revert with 0, 18
                if 5 * arg2 / 100 / arg2 / 100 != 5:
                    revert with 0, 'SafeMath: multiplication overflow'
                mem[64] = 224
                mem[160] = 30
                mem[192] = 'SafeMath: subtraction overflow'
                if 5 * arg2 / 100 > arg2:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg2 < 5 * arg2 / 100:
                    revert with 0, 17
                idx = 0
                s = 1000 * 10^18
                t = stor6
                while idx < stor5.length:
                    mem[0] = stor5[idx]
                    mem[32] = 1
                    if stor1[stor5[idx]] > t:
                        _12328 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12328] = 26
                        mem[_12328 + 32] = 'SafeMath: division by zero'
                        if not arg2:
                            if not 5 * arg2 / 100:
                                _13075 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13075] = 30
                                mem[_13075 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = msg.sender
                                mem[32] = 2
                                _13795 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13795] = 30
                                mem[_13795 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 > stor2[address(msg.sender)]:
                                    _14138 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _14138 + 68] = mem[idx + _13795 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14138 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14138 + -mem[64] + 100
                                if stor2[address(msg.sender)] < arg2:
                                    revert with 0, 17
                                mem[0] = msg.sender
                                stor2[address(msg.sender)] -= arg2
                                mem[32] = 1
                                _15502 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15502] = 30
                                mem[_15502 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _16030 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _16030 + 68] = mem[idx + _15502 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_16030 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _16030 + -mem[64] + 100
                                if stor1[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor1[arg1] > -1:
                                    revert with 0, 17
                                if stor1[arg1] < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[arg1]
                                _19434 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19434] = 30
                                mem[_19434 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > !(5 * arg2 / 100):
                                        revert with 0, 17
                                    if totalFees + (5 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 5 * arg2 / 100
                                    emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _20076 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20076 + 68] = mem[idx + _19434 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20076 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20076 + -mem[64] + 100
                            if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                revert with 0, 17
                            if not 5 * arg2 / 100:
                                revert with 0, 18
                            if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _13433 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13433] = 30
                            mem[_13433 + 32] = 'SafeMath: subtraction overflow'
                            if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > 0:
                                _13600 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13600 + 68] = mem[idx + _13433 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13600 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13600 + -mem[64] + 100
                            if 0 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                revert with 0, 17
                            mem[0] = msg.sender
                            mem[32] = 2
                            _14977 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14977] = 30
                            mem[_14977 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 > stor2[address(msg.sender)]:
                                _15501 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15501 + 68] = mem[idx + _14977 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15501 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15501 + -mem[64] + 100
                            if stor2[address(msg.sender)] < arg2:
                                revert with 0, 17
                            mem[0] = msg.sender
                            stor2[address(msg.sender)] -= arg2
                            mem[32] = 1
                            _17211 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_17211] = 30
                            mem[_17211 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor1[address(msg.sender)]:
                                _17673 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _17673 + 68] = mem[idx + _17211 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_17673 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _17673 + -mem[64] + 100
                            if stor1[address(msg.sender)] < 0:
                                revert with 0, 17
                            if stor1[arg1] > !(-5 * arg2 / 100 * stor6 / 1000 * 10^18):
                                revert with 0, 17
                            if stor1[arg1] - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] = stor1[arg1] - (5 * arg2 / 100 * stor6 / 1000 * 10^18)
                            _20899 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20899] = 30
                            mem[_20899 + 32] = 'SafeMath: subtraction overflow'
                            if 5 * arg2 / 100 * stor6 / 1000 * 10^18 <= stor6:
                                if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                    revert with 0, 17
                                stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                                if totalFees > !(5 * arg2 / 100):
                                    revert with 0, 17
                                if totalFees + (5 * arg2 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 5 * arg2 / 100
                                emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                return 1
                            _21320 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _21320 + 68] = mem[idx + _20899 + 32]
                                idx = idx + 32
                                continue 
                            mem[_21320 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _21320 + -mem[64] + 100
                        if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                            revert with 0, 17
                        if not arg2:
                            revert with 0, 18
                        if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 5 * arg2 / 100:
                            _13432 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13432] = 30
                            mem[_13432 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg2 * stor6 / 1000 * 10^18:
                                _13599 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13599 + 68] = mem[idx + _13432 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13599 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13599 + -mem[64] + 100
                            if arg2 * stor6 / 1000 * 10^18 < 0:
                                revert with 0, 17
                            mem[0] = msg.sender
                            mem[32] = 2
                            _14976 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14976] = 30
                            mem[_14976 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 > stor2[address(msg.sender)]:
                                _15500 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15500 + 68] = mem[idx + _14976 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15500 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15500 + -mem[64] + 100
                            if stor2[address(msg.sender)] < arg2:
                                revert with 0, 17
                            mem[0] = msg.sender
                            stor2[address(msg.sender)] -= arg2
                            mem[32] = 1
                            _17209 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_17209] = 30
                            mem[_17209 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                _17672 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _17672 + 68] = mem[idx + _17209 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_17672 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _17672 + -mem[64] + 100
                            if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                revert with 0, 17
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                            if stor1[arg1] > !(arg2 * stor6 / 1000 * 10^18):
                                revert with 0, 17
                            if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18)
                            _20898 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20898] = 30
                            mem[_20898 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor6:
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > !(5 * arg2 / 100):
                                    revert with 0, 17
                                if totalFees + (5 * arg2 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 5 * arg2 / 100
                                emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                return 1
                            _21319 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _21319 + 68] = mem[idx + _20898 + 32]
                                idx = idx + 32
                                continue 
                            mem[_21319 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _21319 + -mem[64] + 100
                        if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                            revert with 0, 17
                        if not 5 * arg2 / 100:
                            revert with 0, 18
                        if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _14137 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14137] = 30
                        mem[_14137 + 32] = 'SafeMath: subtraction overflow'
                        if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                            _14466 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _14466 + 68] = mem[idx + _14137 + 32]
                                idx = idx + 32
                                continue 
                            mem[_14466 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14466 + -mem[64] + 100
                        if arg2 * stor6 / 1000 * 10^18 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                            revert with 0, 17
                        mem[0] = msg.sender
                        mem[32] = 2
                        _16487 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16487] = 30
                        mem[_16487 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 > stor2[address(msg.sender)]:
                            _17208 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _17208 + 68] = mem[idx + _16487 + 32]
                                idx = idx + 32
                                continue 
                            mem[_17208 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _17208 + -mem[64] + 100
                        if stor2[address(msg.sender)] < arg2:
                            revert with 0, 17
                        mem[0] = msg.sender
                        stor2[address(msg.sender)] -= arg2
                        mem[32] = 1
                        _18870 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_18870] = 30
                        mem[_18870 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                            _19235 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _19235 + 68] = mem[idx + _18870 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19235 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19235 + -mem[64] + 100
                        if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                            revert with 0, 17
                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                        if stor1[arg1] > !((arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)):
                            revert with 0, 17
                        if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[arg1]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg1
                        mem[32] = 1
                        stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)
                        _22177 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_22177] = 30
                        mem[_22177 + 32] = 'SafeMath: subtraction overflow'
                        if 5 * arg2 / 100 * stor6 / 1000 * 10^18 <= stor6:
                            if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                revert with 0, 17
                            stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                            if totalFees > !(5 * arg2 / 100):
                                revert with 0, 17
                            if totalFees + (5 * arg2 / 100) < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += 5 * arg2 / 100
                            emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                            return 1
                        _22506 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _22506 + 68] = mem[idx + _22177 + 32]
                            idx = idx + 32
                            continue 
                        mem[_22506 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _22506 + -mem[64] + 100
                    if idx >= stor5.length:
                        revert with 0, 50
                    mem[0] = stor5[idx]
                    mem[32] = 2
                    if stor2[stor5[idx]] <= s:
                        if idx >= stor5.length:
                            revert with 0, 50
                        mem[0] = stor5[idx]
                        mem[32] = 1
                        _12446 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12446] = 30
                        mem[_12446 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor5[idx]] > t:
                            _12478 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12478 + 68] = mem[idx + _12446 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12478 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12478 + -mem[64] + 100
                        if t < stor1[stor5[idx]]:
                            revert with 0, 17
                        if idx >= stor5.length:
                            revert with 0, 50
                        mem[0] = stor5[idx]
                        mem[32] = 2
                        _12837 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12837] = 30
                        mem[_12837 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor5[idx]] <= s:
                            if s < stor2[stor5[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor2[stor5[idx]]
                            t = t - stor1[stor5[idx]]
                            continue 
                        _12897 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _12897 + 68] = mem[idx + _12837 + 32]
                            idx = idx + 32
                            continue 
                        mem[_12897 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12897 + -mem[64] + 100
                    _12447 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12447] = 26
                    mem[_12447 + 32] = 'SafeMath: division by zero'
                    if not arg2:
                        if not 5 * arg2 / 100:
                            _13197 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13197] = 30
                            mem[_13197 + 32] = 'SafeMath: subtraction overflow'
                            mem[0] = msg.sender
                            mem[32] = 2
                            _14140 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14140] = 30
                            mem[_14140 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 > stor2[address(msg.sender)]:
                                _14470 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14470 + 68] = mem[idx + _14140 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14470 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14470 + -mem[64] + 100
                            if stor2[address(msg.sender)] < arg2:
                                revert with 0, 17
                            mem[0] = msg.sender
                            stor2[address(msg.sender)] -= arg2
                            mem[32] = 1
                            _16033 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16033] = 30
                            mem[_16033 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor1[address(msg.sender)]:
                                _16489 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _16489 + 68] = mem[idx + _16033 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_16489 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _16489 + -mem[64] + 100
                            if stor1[address(msg.sender)] < 0:
                                revert with 0, 17
                            if stor1[arg1] > -1:
                                revert with 0, 17
                            if stor1[arg1] < stor1[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] = stor1[arg1]
                            _20078 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20078] = 30
                            mem[_20078 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor6:
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > !(5 * arg2 / 100):
                                    revert with 0, 17
                                if totalFees + (5 * arg2 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 5 * arg2 / 100
                                emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                return 1
                            _20460 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _20460 + 68] = mem[idx + _20078 + 32]
                                idx = idx + 32
                                continue 
                            mem[_20460 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _20460 + -mem[64] + 100
                        if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                            revert with 0, 17
                        if not 5 * arg2 / 100:
                            revert with 0, 18
                        if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _13602 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13602] = 30
                        mem[_13602 + 32] = 'SafeMath: subtraction overflow'
                        if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > 0:
                            _13797 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13797 + 68] = mem[idx + _13602 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13797 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13797 + -mem[64] + 100
                        if 0 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                            revert with 0, 17
                        mem[0] = msg.sender
                        mem[32] = 2
                        _15505 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15505] = 30
                        mem[_15505 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 > stor2[address(msg.sender)]:
                            _16032 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _16032 + 68] = mem[idx + _15505 + 32]
                                idx = idx + 32
                                continue 
                            mem[_16032 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _16032 + -mem[64] + 100
                        if stor2[address(msg.sender)] < arg2:
                            revert with 0, 17
                        mem[0] = msg.sender
                        stor2[address(msg.sender)] -= arg2
                        mem[32] = 1
                        _17678 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_17678] = 30
                        mem[_17678 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor1[address(msg.sender)]:
                            _18054 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _18054 + 68] = mem[idx + _17678 + 32]
                                idx = idx + 32
                                continue 
                            mem[_18054 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _18054 + -mem[64] + 100
                        if stor1[address(msg.sender)] < 0:
                            revert with 0, 17
                        if stor1[arg1] > !(-5 * arg2 / 100 * stor6 / 1000 * 10^18):
                            revert with 0, 17
                        if stor1[arg1] - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[arg1]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg1
                        mem[32] = 1
                        stor1[address(arg1)] = stor1[arg1] - (5 * arg2 / 100 * stor6 / 1000 * 10^18)
                        _21323 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21323] = 30
                        mem[_21323 + 32] = 'SafeMath: subtraction overflow'
                        if 5 * arg2 / 100 * stor6 / 1000 * 10^18 <= stor6:
                            if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                revert with 0, 17
                            stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                            if totalFees > !(5 * arg2 / 100):
                                revert with 0, 17
                            if totalFees + (5 * arg2 / 100) < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += 5 * arg2 / 100
                            emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                            return 1
                        _21634 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _21634 + 68] = mem[idx + _21323 + 32]
                            idx = idx + 32
                            continue 
                        mem[_21634 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _21634 + -mem[64] + 100
                    if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                        revert with 0, 17
                    if not arg2:
                        revert with 0, 18
                    if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 5 * arg2 / 100:
                        _13601 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13601] = 30
                        mem[_13601 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg2 * stor6 / 1000 * 10^18:
                            _13796 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13796 + 68] = mem[idx + _13601 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13796 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13796 + -mem[64] + 100
                        if arg2 * stor6 / 1000 * 10^18 < 0:
                            revert with 0, 17
                        mem[0] = msg.sender
                        mem[32] = 2
                        _15504 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15504] = 30
                        mem[_15504 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 > stor2[address(msg.sender)]:
                            _16031 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _16031 + 68] = mem[idx + _15504 + 32]
                                idx = idx + 32
                                continue 
                            mem[_16031 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _16031 + -mem[64] + 100
                        if stor2[address(msg.sender)] < arg2:
                            revert with 0, 17
                        mem[0] = msg.sender
                        stor2[address(msg.sender)] -= arg2
                        mem[32] = 1
                        _17676 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_17676] = 30
                        mem[_17676 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                            _18053 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _18053 + 68] = mem[idx + _17676 + 32]
                                idx = idx + 32
                                continue 
                            mem[_18053 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _18053 + -mem[64] + 100
                        if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                            revert with 0, 17
                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                        if stor1[arg1] > !(arg2 * stor6 / 1000 * 10^18):
                            revert with 0, 17
                        if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) < stor1[arg1]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg1
                        mem[32] = 1
                        stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18)
                        _21322 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21322] = 30
                        mem[_21322 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= stor6:
                            if stor6 < 0:
                                revert with 0, 17
                            if totalFees > !(5 * arg2 / 100):
                                revert with 0, 17
                            if totalFees + (5 * arg2 / 100) < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += 5 * arg2 / 100
                            emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                            return 1
                        _21633 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _21633 + 68] = mem[idx + _21322 + 32]
                            idx = idx + 32
                            continue 
                        mem[_21633 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _21633 + -mem[64] + 100
                    if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                        revert with 0, 17
                    if not 5 * arg2 / 100:
                        revert with 0, 18
                    if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _14469 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14469] = 30
                    mem[_14469 + 32] = 'SafeMath: subtraction overflow'
                    if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                        _14978 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14978 + 68] = mem[idx + _14469 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14978 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14978 + -mem[64] + 100
                    if arg2 * stor6 / 1000 * 10^18 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                        revert with 0, 17
                    mem[0] = msg.sender
                    mem[32] = 2
                    _17213 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_17213] = 30
                    mem[_17213 + 32] = 'SafeMath: subtraction overflow'
                    if arg2 > stor2[address(msg.sender)]:
                        _17675 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _17675 + 68] = mem[idx + _17213 + 32]
                            idx = idx + 32
                            continue 
                        mem[_17675 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _17675 + -mem[64] + 100
                    if stor2[address(msg.sender)] < arg2:
                        revert with 0, 17
                    mem[0] = msg.sender
                    stor2[address(msg.sender)] -= arg2
                    mem[32] = 1
                    _19238 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19238] = 30
                    mem[_19238 + 32] = 'SafeMath: subtraction overflow'
                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                        _19675 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _19675 + 68] = mem[idx + _19238 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19675 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _19675 + -mem[64] + 100
                    if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                        revert with 0, 17
                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                    if stor1[arg1] > !((arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)):
                        revert with 0, 17
                    if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[arg1]:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[0] = arg1
                    mem[32] = 1
                    stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)
                    _22510 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_22510] = 30
                    mem[_22510 + 32] = 'SafeMath: subtraction overflow'
                    if 5 * arg2 / 100 * stor6 / 1000 * 10^18 <= stor6:
                        if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                            revert with 0, 17
                        stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                        if totalFees > !(5 * arg2 / 100):
                            revert with 0, 17
                        if totalFees + (5 * arg2 / 100) < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        totalFees += 5 * arg2 / 100
                        emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                        return 1
                    _22721 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _22721 + 68] = mem[idx + _22510 + 32]
                        idx = idx + 32
                        continue 
                    mem[_22721 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _22721 + -mem[64] + 100
                if t < stor6 / 1000 * 10^18:
                    if not arg2:
                        if not 5 * arg2 / 100:
                            if arg2 > stor2[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor2[address(msg.sender)] < arg2:
                                revert with 0, 17
                            stor2[address(msg.sender)] -= arg2
                            if 0 > stor1[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor1[address(msg.sender)] < 0:
                                revert with 0, 17
                            if stor1[arg1] > -1:
                                revert with 0, 17
                            if stor1[arg1] < stor1[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor1[address(arg1)] = stor1[arg1]
                            if 0 > stor6:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor6 < 0:
                                revert with 0, 17
                        else:
                            if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                revert with 0, 17
                            if not 5 * arg2 / 100:
                                revert with 0, 18
                            if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                revert with 0, 17
                            if arg2 > stor2[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor2[address(msg.sender)] < arg2:
                                revert with 0, 17
                            stor2[address(msg.sender)] -= arg2
                            if 0 > stor1[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor1[address(msg.sender)] < 0:
                                revert with 0, 17
                            if stor1[arg1] > !(-5 * arg2 / 100 * stor6 / 1000 * 10^18):
                                revert with 0, 17
                            if stor1[arg1] - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor1[address(arg1)] = stor1[arg1] - (5 * arg2 / 100 * stor6 / 1000 * 10^18)
                            if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > stor6:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                revert with 0, 17
                            stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                    else:
                        if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                            revert with 0, 17
                        if not arg2:
                            revert with 0, 18
                        if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 5 * arg2 / 100:
                            if 0 > arg2 * stor6 / 1000 * 10^18:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg2 * stor6 / 1000 * 10^18 < 0:
                                revert with 0, 17
                            if arg2 > stor2[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor2[address(msg.sender)] < arg2:
                                revert with 0, 17
                            stor2[address(msg.sender)] -= arg2
                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                revert with 0, 17
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                            if stor1[arg1] > !(arg2 * stor6 / 1000 * 10^18):
                                revert with 0, 17
                            if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18)
                            if 0 > stor6:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor6 < 0:
                                revert with 0, 17
                        else:
                            if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                revert with 0, 17
                            if not 5 * arg2 / 100:
                                revert with 0, 18
                            if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg2 * stor6 / 1000 * 10^18 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                revert with 0, 17
                            if arg2 > stor2[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor2[address(msg.sender)] < arg2:
                                revert with 0, 17
                            stor2[address(msg.sender)] -= arg2
                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                revert with 0, 17
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                            if stor1[arg1] > !((arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)):
                                revert with 0, 17
                            if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)
                            if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > stor6:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                revert with 0, 17
                            stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                else:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg2:
                        if not 5 * arg2 / 100:
                            if arg2 > stor2[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor2[address(msg.sender)] < arg2:
                                revert with 0, 17
                            stor2[address(msg.sender)] -= arg2
                            if 0 > stor1[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor1[address(msg.sender)] < 0:
                                revert with 0, 17
                            if stor1[arg1] > -1:
                                revert with 0, 17
                            if stor1[arg1] < stor1[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor1[address(arg1)] = stor1[arg1]
                            if 0 > stor6:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor6 < 0:
                                revert with 0, 17
                        else:
                            if 5 * arg2 / 100 and t / s > -1 / 5 * arg2 / 100:
                                revert with 0, 17
                            if not 5 * arg2 / 100:
                                revert with 0, 18
                            if 5 * arg2 / 100 * t / s / 5 * arg2 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 5 * arg2 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < 5 * arg2 / 100 * t / s:
                                revert with 0, 17
                            if arg2 > stor2[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor2[address(msg.sender)] < arg2:
                                revert with 0, 17
                            stor2[address(msg.sender)] -= arg2
                            if 0 > stor1[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor1[address(msg.sender)] < 0:
                                revert with 0, 17
                            if stor1[arg1] > !(-5 * arg2 / 100 * t / s):
                                revert with 0, 17
                            if stor1[arg1] - (5 * arg2 / 100 * t / s) < stor1[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor1[address(arg1)] = stor1[arg1] - (5 * arg2 / 100 * t / s)
                            if 5 * arg2 / 100 * t / s > stor6:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor6 < 5 * arg2 / 100 * t / s:
                                revert with 0, 17
                            stor6 += -5 * arg2 / 100 * t / s
                    else:
                        if arg2 and t / s > -1 / arg2:
                            revert with 0, 17
                        if not arg2:
                            revert with 0, 18
                        if arg2 * t / s / arg2 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 5 * arg2 / 100:
                            if 0 > arg2 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg2 * t / s < 0:
                                revert with 0, 17
                            if arg2 > stor2[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor2[address(msg.sender)] < arg2:
                                revert with 0, 17
                            stor2[address(msg.sender)] -= arg2
                            if arg2 * t / s > stor1[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor1[address(msg.sender)] < arg2 * t / s:
                                revert with 0, 17
                            stor1[address(msg.sender)] += -1 * arg2 * t / s
                            if stor1[arg1] > !(arg2 * t / s):
                                revert with 0, 17
                            if stor1[arg1] + (arg2 * t / s) < stor1[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor1[address(arg1)] = stor1[arg1] + (arg2 * t / s)
                            if 0 > stor6:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor6 < 0:
                                revert with 0, 17
                        else:
                            if 5 * arg2 / 100 and t / s > -1 / 5 * arg2 / 100:
                                revert with 0, 17
                            if not 5 * arg2 / 100:
                                revert with 0, 18
                            if 5 * arg2 / 100 * t / s / 5 * arg2 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 5 * arg2 / 100 * t / s > arg2 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg2 * t / s < 5 * arg2 / 100 * t / s:
                                revert with 0, 17
                            if arg2 > stor2[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor2[address(msg.sender)] < arg2:
                                revert with 0, 17
                            stor2[address(msg.sender)] -= arg2
                            if arg2 * t / s > stor1[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor1[address(msg.sender)] < arg2 * t / s:
                                revert with 0, 17
                            stor1[address(msg.sender)] += -1 * arg2 * t / s
                            if stor1[arg1] > !((arg2 * t / s) - (5 * arg2 / 100 * t / s)):
                                revert with 0, 17
                            if stor1[arg1] + (arg2 * t / s) - (5 * arg2 / 100 * t / s) < stor1[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor1[address(arg1)] = stor1[arg1] + (arg2 * t / s) - (5 * arg2 / 100 * t / s)
                            if 5 * arg2 / 100 * t / s > stor6:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor6 < 5 * arg2 / 100 * t / s:
                                revert with 0, 17
                            stor6 += -5 * arg2 / 100 * t / s
                if totalFees > !(5 * arg2 / 100):
                    revert with 0, 17
                if totalFees + (5 * arg2 / 100) < totalFees:
                    revert with 0, 'SafeMath: addition overflow'
                totalFees += 5 * arg2 / 100
                emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
        else:
            if stor4[address(msg.sender)]:
                mem[0] = msg.sender
                mem[32] = 4
                if stor4[address(msg.sender)]:
                    mem[96] = 26
                    mem[128] = 'SafeMath: division by zero'
                    if not arg2 / 100:
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if 0 > arg2:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg2 < 0:
                            revert with 0, 17
                        idx = 0
                        s = 1000 * 10^18
                        t = stor6
                        while idx < stor5.length:
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            if stor1[stor5[idx]] > t:
                                _12315 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12315] = 26
                                mem[_12315 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    _13036 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13036] = 30
                                    mem[_13036 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _13742 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13742] = 30
                                    mem[_13742 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _14059 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _14059 + 68] = mem[idx + _13742 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14059 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14059 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > -1:
                                        revert with 0, 17
                                    if stor1[arg1] < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1]
                                    _17408 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17408] = 30
                                    mem[_17408 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > -1:
                                            revert with 0, 17
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _17792 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _17792 + 68] = mem[idx + _17408 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_17792 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _17792 + -mem[64] + 100
                                if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _13355 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13355] = 30
                                mem[_13355 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor6 / 1000 * 10^18:
                                    _13561 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13561 + 68] = mem[idx + _13355 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13561 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13561 + -mem[64] + 100
                                if arg2 * stor6 / 1000 * 10^18 < 0:
                                    revert with 0, 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _14892 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14892] = 30
                                mem[_14892 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                    _15409 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _15409 + 68] = mem[idx + _14892 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15409 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _15409 + -mem[64] + 100
                                if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                if stor1[arg1] > !(arg2 * stor6 / 1000 * 10^18):
                                    revert with 0, 17
                                if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18)
                                _19021 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19021] = 30
                                mem[_19021 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > -1:
                                        revert with 0, 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _19348 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _19348 + 68] = mem[idx + _19021 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19348 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _19348 + -mem[64] + 100
                            if idx >= stor5.length:
                                revert with 0, 50
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            if stor2[stor5[idx]] <= s:
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                _12420 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12420] = 30
                                mem[_12420 + 32] = 'SafeMath: subtraction overflow'
                                if stor1[stor5[idx]] > t:
                                    _12465 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _12465 + 68] = mem[idx + _12420 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12465 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12465 + -mem[64] + 100
                                if t < stor1[stor5[idx]]:
                                    revert with 0, 17
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                _12811 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12811] = 30
                                mem[_12811 + 32] = 'SafeMath: subtraction overflow'
                                if stor2[stor5[idx]] <= s:
                                    if s < stor2[stor5[idx]]:
                                        revert with 0, 17
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s - stor2[stor5[idx]]
                                    t = t - stor1[stor5[idx]]
                                    continue 
                                _12871 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _12871 + 68] = mem[idx + _12811 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12871 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12871 + -mem[64] + 100
                            _12421 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12421] = 26
                            mem[_12421 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                _13171 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13171] = 30
                                mem[_13171 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = msg.sender
                                mem[32] = 1
                                _14060 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14060] = 30
                                mem[_14060 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _14383 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _14383 + 68] = mem[idx + _14060 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14383 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14383 + -mem[64] + 100
                                if stor1[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor1[arg1] > -1:
                                    revert with 0, 17
                                if stor1[arg1] < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[arg1]
                                _17793 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17793] = 30
                                mem[_17793 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > -1:
                                        revert with 0, 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _18370 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _18370 + 68] = mem[idx + _17793 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_18370 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _18370 + -mem[64] + 100
                            if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                                revert with 0, 17
                            if not arg2:
                                revert with 0, 18
                            if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _13562 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13562] = 30
                            mem[_13562 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg2 * stor6 / 1000 * 10^18:
                                _13743 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13743 + 68] = mem[idx + _13562 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13743 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13743 + -mem[64] + 100
                            if arg2 * stor6 / 1000 * 10^18 < 0:
                                revert with 0, 17
                            mem[0] = msg.sender
                            mem[32] = 1
                            _15411 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15411] = 30
                            mem[_15411 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                _15937 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15937 + 68] = mem[idx + _15411 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15937 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15937 + -mem[64] + 100
                            if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                revert with 0, 17
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                            if stor1[arg1] > !(arg2 * stor6 / 1000 * 10^18):
                                revert with 0, 17
                            if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18)
                            _19350 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19350] = 30
                            mem[_19350 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor6:
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > -1:
                                    revert with 0, 17
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg2, msg.sender, arg1);
                                return 1
                            _19895 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _19895 + 68] = mem[idx + _19350 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19895 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19895 + -mem[64] + 100
                        if t < stor6 / 1000 * 10^18:
                            if not arg2:
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor1[arg1] > -1:
                                    revert with 0, 17
                                if stor1[arg1] < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] = stor1[arg1]
                            else:
                                if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > arg2 * stor6 / 1000 * 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg2 * stor6 / 1000 * 10^18 < 0:
                                    revert with 0, 17
                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                if stor1[arg1] > !(arg2 * stor6 / 1000 * 10^18):
                                    revert with 0, 17
                                if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18)
                        else:
                            if not s:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not arg2:
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor1[arg1] > -1:
                                    revert with 0, 17
                                if stor1[arg1] < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] = stor1[arg1]
                            else:
                                if arg2 and t / s > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * t / s / arg2 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > arg2 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg2 * t / s < 0:
                                    revert with 0, 17
                                if arg2 * t / s > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < arg2 * t / s:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * t / s
                                if stor1[arg1] > !(arg2 * t / s):
                                    revert with 0, 17
                                if stor1[arg1] + (arg2 * t / s) < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] = stor1[arg1] + (arg2 * t / s)
                        if 0 > stor6:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor6 < 0:
                            revert with 0, 17
                        if totalFees > -1:
                            revert with 0, 17
                        if totalFees < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        emit Transfer(arg2, msg.sender, arg1);
                    else:
                        if arg2 / 100 and 5 > -1 / arg2 / 100:
                            revert with 0, 17
                        if not arg2 / 100:
                            revert with 0, 18
                        if 5 * arg2 / 100 / arg2 / 100 != 5:
                            revert with 0, 'SafeMath: multiplication overflow'
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if 5 * arg2 / 100 > arg2:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg2 < 5 * arg2 / 100:
                            revert with 0, 17
                        idx = 0
                        s = 1000 * 10^18
                        t = stor6
                        while idx < stor5.length:
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            if stor1[stor5[idx]] > t:
                                _12314 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12314] = 26
                                mem[_12314 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not 5 * arg2 / 100:
                                        _13033 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13033] = 30
                                        mem[_13033 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _13739 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13739] = 30
                                        mem[_13739 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _14054 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _14054 + 68] = mem[idx + _13739 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_14054 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _14054 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > -1:
                                            revert with 0, 17
                                        if stor1[arg1] < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[arg1]
                                        _17397 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17397] = 30
                                        mem[_17397 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > !(5 * arg2 / 100):
                                                revert with 0, 17
                                            if totalFees + (5 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 5 * arg2 / 100
                                            emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _17787 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _17787 + 68] = mem[idx + _17397 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17787 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _17787 + -mem[64] + 100
                                    if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                        revert with 0, 17
                                    if not 5 * arg2 / 100:
                                        revert with 0, 18
                                    if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _13349 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13349] = 30
                                    mem[_13349 + 32] = 'SafeMath: subtraction overflow'
                                    if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > 0:
                                        _13558 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13558 + 68] = mem[idx + _13349 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13558 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13558 + -mem[64] + 100
                                    if 0 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _14886 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14886] = 30
                                    mem[_14886 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _15403 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _15403 + 68] = mem[idx + _14886 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_15403 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _15403 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > !(-5 * arg2 / 100 * stor6 / 1000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg1] - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1] - (5 * arg2 / 100 * stor6 / 1000 * 10^18)
                                    _19011 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19011] = 30
                                    mem[_19011 + 32] = 'SafeMath: subtraction overflow'
                                    if 5 * arg2 / 100 * stor6 / 1000 * 10^18 <= stor6:
                                        if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                            revert with 0, 17
                                        stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                                        if totalFees > !(5 * arg2 / 100):
                                            revert with 0, 17
                                        if totalFees + (5 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 5 * arg2 / 100
                                        emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _19342 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19342 + 68] = mem[idx + _19011 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19342 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19342 + -mem[64] + 100
                                if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 5 * arg2 / 100:
                                    _13348 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13348] = 30
                                    mem[_13348 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 1000 * 10^18:
                                        _13557 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13557 + 68] = mem[idx + _13348 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13557 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13557 + -mem[64] + 100
                                    if arg2 * stor6 / 1000 * 10^18 < 0:
                                        revert with 0, 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _14885 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14885] = 30
                                    mem[_14885 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        _15402 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _15402 + 68] = mem[idx + _14885 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_15402 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _15402 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor1[arg1] > !(arg2 * stor6 / 1000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18)
                                    _19010 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19010] = 30
                                    mem[_19010 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > !(5 * arg2 / 100):
                                            revert with 0, 17
                                        if totalFees + (5 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 5 * arg2 / 100
                                        emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _19341 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19341 + 68] = mem[idx + _19010 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19341 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19341 + -mem[64] + 100
                                if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                    revert with 0, 17
                                if not 5 * arg2 / 100:
                                    revert with 0, 18
                                if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _14053 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14053] = 30
                                mem[_14053 + 32] = 'SafeMath: subtraction overflow'
                                if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                    _14375 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _14375 + 68] = mem[idx + _14053 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14375 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14375 + -mem[64] + 100
                                if arg2 * stor6 / 1000 * 10^18 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                    revert with 0, 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _16417 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16417] = 30
                                mem[_16417 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                    _17087 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _17087 + 68] = mem[idx + _16417 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_17087 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _17087 + -mem[64] + 100
                                if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                if stor1[arg1] > !((arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)):
                                    revert with 0, 17
                                if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)
                                _20358 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20358] = 30
                                mem[_20358 + 32] = 'SafeMath: subtraction overflow'
                                if 5 * arg2 / 100 * stor6 / 1000 * 10^18 <= stor6:
                                    if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                                    if totalFees > !(5 * arg2 / 100):
                                        revert with 0, 17
                                    if totalFees + (5 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 5 * arg2 / 100
                                    emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _20774 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20774 + 68] = mem[idx + _20358 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20774 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20774 + -mem[64] + 100
                            if idx >= stor5.length:
                                revert with 0, 50
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            if stor2[stor5[idx]] <= s:
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                _12418 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12418] = 30
                                mem[_12418 + 32] = 'SafeMath: subtraction overflow'
                                if stor1[stor5[idx]] > t:
                                    _12464 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _12464 + 68] = mem[idx + _12418 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12464 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12464 + -mem[64] + 100
                                if t < stor1[stor5[idx]]:
                                    revert with 0, 17
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                _12809 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12809] = 30
                                mem[_12809 + 32] = 'SafeMath: subtraction overflow'
                                if stor2[stor5[idx]] <= s:
                                    if s < stor2[stor5[idx]]:
                                        revert with 0, 17
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s - stor2[stor5[idx]]
                                    t = t - stor1[stor5[idx]]
                                    continue 
                                _12869 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _12869 + 68] = mem[idx + _12809 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12869 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12869 + -mem[64] + 100
                            _12419 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12419] = 26
                            mem[_12419 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                if not 5 * arg2 / 100:
                                    _13169 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13169] = 30
                                    mem[_13169 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _14056 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14056] = 30
                                    mem[_14056 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _14379 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _14379 + 68] = mem[idx + _14056 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14379 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14379 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > -1:
                                        revert with 0, 17
                                    if stor1[arg1] < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1]
                                    _17789 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17789] = 30
                                    mem[_17789 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > !(5 * arg2 / 100):
                                            revert with 0, 17
                                        if totalFees + (5 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 5 * arg2 / 100
                                        emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _18357 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _18357 + 68] = mem[idx + _17789 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18357 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _18357 + -mem[64] + 100
                                if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                    revert with 0, 17
                                if not 5 * arg2 / 100:
                                    revert with 0, 18
                                if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _13560 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13560] = 30
                                mem[_13560 + 32] = 'SafeMath: subtraction overflow'
                                if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > 0:
                                    _13741 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13741 + 68] = mem[idx + _13560 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13741 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13741 + -mem[64] + 100
                                if 0 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                    revert with 0, 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _15406 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15406] = 30
                                mem[_15406 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _15933 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _15933 + 68] = mem[idx + _15406 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15933 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _15933 + -mem[64] + 100
                                if stor1[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor1[arg1] > !(-5 * arg2 / 100 * stor6 / 1000 * 10^18):
                                    revert with 0, 17
                                if stor1[arg1] - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[arg1] - (5 * arg2 / 100 * stor6 / 1000 * 10^18)
                                _19345 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19345] = 30
                                mem[_19345 + 32] = 'SafeMath: subtraction overflow'
                                if 5 * arg2 / 100 * stor6 / 1000 * 10^18 <= stor6:
                                    if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                                    if totalFees > !(5 * arg2 / 100):
                                        revert with 0, 17
                                    if totalFees + (5 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 5 * arg2 / 100
                                    emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _19889 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _19889 + 68] = mem[idx + _19345 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19889 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _19889 + -mem[64] + 100
                            if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                                revert with 0, 17
                            if not arg2:
                                revert with 0, 18
                            if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 5 * arg2 / 100:
                                _13559 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13559] = 30
                                mem[_13559 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor6 / 1000 * 10^18:
                                    _13740 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13740 + 68] = mem[idx + _13559 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13740 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13740 + -mem[64] + 100
                                if arg2 * stor6 / 1000 * 10^18 < 0:
                                    revert with 0, 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _15405 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15405] = 30
                                mem[_15405 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                    _15932 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _15932 + 68] = mem[idx + _15405 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15932 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _15932 + -mem[64] + 100
                                if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                if stor1[arg1] > !(arg2 * stor6 / 1000 * 10^18):
                                    revert with 0, 17
                                if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18)
                                _19344 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19344] = 30
                                mem[_19344 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > !(5 * arg2 / 100):
                                        revert with 0, 17
                                    if totalFees + (5 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 5 * arg2 / 100
                                    emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _19888 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _19888 + 68] = mem[idx + _19344 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19888 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _19888 + -mem[64] + 100
                            if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                revert with 0, 17
                            if not 5 * arg2 / 100:
                                revert with 0, 18
                            if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _14378 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14378] = 30
                            mem[_14378 + 32] = 'SafeMath: subtraction overflow'
                            if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                _14887 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14887 + 68] = mem[idx + _14378 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14887 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14887 + -mem[64] + 100
                            if arg2 * stor6 / 1000 * 10^18 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                revert with 0, 17
                            mem[0] = msg.sender
                            mem[32] = 1
                            _17090 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_17090] = 30
                            mem[_17090 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                _17628 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _17628 + 68] = mem[idx + _17090 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_17628 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _17628 + -mem[64] + 100
                            if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                revert with 0, 17
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                            if stor1[arg1] > !((arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)):
                                revert with 0, 17
                            if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)
                            _20778 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20778] = 30
                            mem[_20778 + 32] = 'SafeMath: subtraction overflow'
                            if 5 * arg2 / 100 * stor6 / 1000 * 10^18 <= stor6:
                                if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                    revert with 0, 17
                                stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                                if totalFees > !(5 * arg2 / 100):
                                    revert with 0, 17
                                if totalFees + (5 * arg2 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 5 * arg2 / 100
                                emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                return 1
                            _21234 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _21234 + 68] = mem[idx + _20778 + 32]
                                idx = idx + 32
                                continue 
                            mem[_21234 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _21234 + -mem[64] + 100
                        if t < stor6 / 1000 * 10^18:
                            if not arg2:
                                if not 5 * arg2 / 100:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > -1:
                                        revert with 0, 17
                                    if stor1[arg1] < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1]
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 0, 17
                                else:
                                    if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                        revert with 0, 17
                                    if not 5 * arg2 / 100:
                                        revert with 0, 18
                                    if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > !(-5 * arg2 / 100 * stor6 / 1000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg1] - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1] - (5 * arg2 / 100 * stor6 / 1000 * 10^18)
                                    if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                            else:
                                if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 5 * arg2 / 100:
                                    if 0 > arg2 * stor6 / 1000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * stor6 / 1000 * 10^18 < 0:
                                        revert with 0, 17
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor1[arg1] > !(arg2 * stor6 / 1000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18)
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 0, 17
                                else:
                                    if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                        revert with 0, 17
                                    if not 5 * arg2 / 100:
                                        revert with 0, 18
                                    if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * stor6 / 1000 * 10^18 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor1[arg1] > !((arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)
                                    if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                        else:
                            if not s:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not arg2:
                                if not 5 * arg2 / 100:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > -1:
                                        revert with 0, 17
                                    if stor1[arg1] < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1]
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 0, 17
                                else:
                                    if 5 * arg2 / 100 and t / s > -1 / 5 * arg2 / 100:
                                        revert with 0, 17
                                    if not 5 * arg2 / 100:
                                        revert with 0, 18
                                    if 5 * arg2 / 100 * t / s / 5 * arg2 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 5 * arg2 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 5 * arg2 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > !(-5 * arg2 / 100 * t / s):
                                        revert with 0, 17
                                    if stor1[arg1] - (5 * arg2 / 100 * t / s) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1] - (5 * arg2 / 100 * t / s)
                                    if 5 * arg2 / 100 * t / s > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 5 * arg2 / 100 * t / s:
                                        revert with 0, 17
                                    stor6 += -5 * arg2 / 100 * t / s
                            else:
                                if arg2 and t / s > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * t / s / arg2 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 5 * arg2 / 100:
                                    if 0 > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * t / s < 0:
                                        revert with 0, 17
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * t / s:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor1[arg1] > !(arg2 * t / s):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * t / s) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * t / s)
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 0, 17
                                else:
                                    if 5 * arg2 / 100 and t / s > -1 / 5 * arg2 / 100:
                                        revert with 0, 17
                                    if not 5 * arg2 / 100:
                                        revert with 0, 18
                                    if 5 * arg2 / 100 * t / s / 5 * arg2 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 5 * arg2 / 100 * t / s > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * t / s < 5 * arg2 / 100 * t / s:
                                        revert with 0, 17
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * t / s:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor1[arg1] > !((arg2 * t / s) - (5 * arg2 / 100 * t / s)):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * t / s) - (5 * arg2 / 100 * t / s) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * t / s) - (5 * arg2 / 100 * t / s)
                                    if 5 * arg2 / 100 * t / s > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 5 * arg2 / 100 * t / s:
                                        revert with 0, 17
                                    stor6 += -5 * arg2 / 100 * t / s
                        if totalFees > !(5 * arg2 / 100):
                            revert with 0, 17
                        if totalFees + (5 * arg2 / 100) < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        totalFees += 5 * arg2 / 100
                        emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                else:
                    mem[0] = arg1
                    mem[32] = 4
                    mem[96] = 26
                    mem[128] = 'SafeMath: division by zero'
                    if stor4[address(arg1)]:
                        if not arg2 / 100:
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if 0 > arg2:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg2 < 0:
                                revert with 0, 17
                            idx = 0
                            s = 1000 * 10^18
                            t = stor6
                            while idx < stor5.length:
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                if stor1[stor5[idx]] > t:
                                    _12317 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12317] = 26
                                    mem[_12317 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        _13042 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13042] = 30
                                        mem[_13042 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _13750 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13750] = 30
                                        mem[_13750 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _14071 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _14071 + 68] = mem[idx + _13750 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_14071 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _14071 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > -1:
                                            revert with 0, 17
                                        if stor1[arg1] < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[arg1]
                                        _17432 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17432] = 30
                                        mem[_17432 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > -1:
                                                revert with 0, 17
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _17806 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _17806 + 68] = mem[idx + _17432 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17806 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _17806 + -mem[64] + 100
                                    if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                                        revert with 0, 17
                                    if not arg2:
                                        revert with 0, 18
                                    if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _13367 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13367] = 30
                                    mem[_13367 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 1000 * 10^18:
                                        _13567 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13567 + 68] = mem[idx + _13367 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13567 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13567 + -mem[64] + 100
                                    if arg2 * stor6 / 1000 * 10^18 < 0:
                                        revert with 0, 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _14905 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14905] = 30
                                    mem[_14905 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        _15423 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _15423 + 68] = mem[idx + _14905 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_15423 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _15423 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor1[arg1] > !(arg2 * stor6 / 1000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18)
                                    _19039 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19039] = 30
                                    mem[_19039 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > -1:
                                            revert with 0, 17
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _19362 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19362 + 68] = mem[idx + _19039 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19362 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19362 + -mem[64] + 100
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                if stor2[stor5[idx]] <= s:
                                    if idx >= stor5.length:
                                        revert with 0, 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    _12424 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12424] = 30
                                    mem[_12424 + 32] = 'SafeMath: subtraction overflow'
                                    if stor1[stor5[idx]] > t:
                                        _12467 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _12467 + 68] = mem[idx + _12424 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_12467 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _12467 + -mem[64] + 100
                                    if t < stor1[stor5[idx]]:
                                        revert with 0, 17
                                    if idx >= stor5.length:
                                        revert with 0, 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    _12815 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12815] = 30
                                    mem[_12815 + 32] = 'SafeMath: subtraction overflow'
                                    if stor2[stor5[idx]] <= s:
                                        if s < stor2[stor5[idx]]:
                                            revert with 0, 17
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s - stor2[stor5[idx]]
                                        t = t - stor1[stor5[idx]]
                                        continue 
                                    _12875 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _12875 + 68] = mem[idx + _12815 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12875 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12875 + -mem[64] + 100
                                _12425 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12425] = 26
                                mem[_12425 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    _13175 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13175] = 30
                                    mem[_13175 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _14072 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14072] = 30
                                    mem[_14072 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _14396 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _14396 + 68] = mem[idx + _14072 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14396 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14396 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > -1:
                                        revert with 0, 17
                                    if stor1[arg1] < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1]
                                    _17807 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17807] = 30
                                    mem[_17807 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > -1:
                                            revert with 0, 17
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _18408 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _18408 + 68] = mem[idx + _17807 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18408 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _18408 + -mem[64] + 100
                                if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _13568 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13568] = 30
                                mem[_13568 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor6 / 1000 * 10^18:
                                    _13751 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13751 + 68] = mem[idx + _13568 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13751 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13751 + -mem[64] + 100
                                if arg2 * stor6 / 1000 * 10^18 < 0:
                                    revert with 0, 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _15425 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15425] = 30
                                mem[_15425 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                    _15951 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _15951 + 68] = mem[idx + _15425 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15951 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _15951 + -mem[64] + 100
                                if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                if stor1[arg1] > !(arg2 * stor6 / 1000 * 10^18):
                                    revert with 0, 17
                                if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18)
                                _19364 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19364] = 30
                                mem[_19364 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > -1:
                                        revert with 0, 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _19920 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _19920 + 68] = mem[idx + _19364 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19920 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _19920 + -mem[64] + 100
                            if t < stor6 / 1000 * 10^18:
                                if not arg2:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > -1:
                                        revert with 0, 17
                                    if stor1[arg1] < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1]
                                else:
                                    if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                                        revert with 0, 17
                                    if not arg2:
                                        revert with 0, 18
                                    if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 0 > arg2 * stor6 / 1000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * stor6 / 1000 * 10^18 < 0:
                                        revert with 0, 17
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor1[arg1] > !(arg2 * stor6 / 1000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18)
                            else:
                                if not s:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not arg2:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > -1:
                                        revert with 0, 17
                                    if stor1[arg1] < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1]
                                else:
                                    if arg2 and t / s > -1 / arg2:
                                        revert with 0, 17
                                    if not arg2:
                                        revert with 0, 18
                                    if arg2 * t / s / arg2 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 0 > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * t / s < 0:
                                        revert with 0, 17
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * t / s:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor1[arg1] > !(arg2 * t / s):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * t / s) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * t / s)
                            if 0 > stor6:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor6 < 0:
                                revert with 0, 17
                            if totalFees > -1:
                                revert with 0, 17
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(arg2, msg.sender, arg1);
                        else:
                            if arg2 / 100 and 5 > -1 / arg2 / 100:
                                revert with 0, 17
                            if not arg2 / 100:
                                revert with 0, 18
                            if 5 * arg2 / 100 / arg2 / 100 != 5:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if 5 * arg2 / 100 > arg2:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg2 < 5 * arg2 / 100:
                                revert with 0, 17
                            idx = 0
                            s = 1000 * 10^18
                            t = stor6
                            while idx < stor5.length:
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                if stor1[stor5[idx]] > t:
                                    _12316 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12316] = 26
                                    mem[_12316 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if not 5 * arg2 / 100:
                                            _13039 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_13039] = 30
                                            mem[_13039 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _13747 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_13747] = 30
                                            mem[_13747 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _14066 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _14066 + 68] = mem[idx + _13747 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_14066 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _14066 + -mem[64] + 100
                                            if stor1[address(msg.sender)] < 0:
                                                revert with 0, 17
                                            if stor1[arg1] > -1:
                                                revert with 0, 17
                                            if stor1[arg1] < stor1[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] = stor1[arg1]
                                            _17421 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_17421] = 30
                                            mem[_17421 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if stor6 < 0:
                                                    revert with 0, 17
                                                if totalFees > !(5 * arg2 / 100):
                                                    revert with 0, 17
                                                if totalFees + (5 * arg2 / 100) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += 5 * arg2 / 100
                                                emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                                return 1
                                            _17801 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _17801 + 68] = mem[idx + _17421 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_17801 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _17801 + -mem[64] + 100
                                        if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                            revert with 0, 17
                                        if not 5 * arg2 / 100:
                                            revert with 0, 18
                                        if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _13361 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13361] = 30
                                        mem[_13361 + 32] = 'SafeMath: subtraction overflow'
                                        if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > 0:
                                            _13564 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _13564 + 68] = mem[idx + _13361 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_13564 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _13564 + -mem[64] + 100
                                        if 0 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                            revert with 0, 17
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _14899 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_14899] = 30
                                        mem[_14899 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _15417 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _15417 + 68] = mem[idx + _14899 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_15417 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _15417 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > !(-5 * arg2 / 100 * stor6 / 1000 * 10^18):
                                            revert with 0, 17
                                        if stor1[arg1] - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[arg1] - (5 * arg2 / 100 * stor6 / 1000 * 10^18)
                                        _19029 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19029] = 30
                                        mem[_19029 + 32] = 'SafeMath: subtraction overflow'
                                        if 5 * arg2 / 100 * stor6 / 1000 * 10^18 <= stor6:
                                            if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                                revert with 0, 17
                                            stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                                            if totalFees > !(5 * arg2 / 100):
                                                revert with 0, 17
                                            if totalFees + (5 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 5 * arg2 / 100
                                            emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _19356 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19356 + 68] = mem[idx + _19029 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19356 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19356 + -mem[64] + 100
                                    if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                                        revert with 0, 17
                                    if not arg2:
                                        revert with 0, 18
                                    if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 5 * arg2 / 100:
                                        _13360 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13360] = 30
                                        mem[_13360 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor6 / 1000 * 10^18:
                                            _13563 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _13563 + 68] = mem[idx + _13360 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_13563 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _13563 + -mem[64] + 100
                                        if arg2 * stor6 / 1000 * 10^18 < 0:
                                            revert with 0, 17
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _14898 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_14898] = 30
                                        mem[_14898 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            _15416 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _15416 + 68] = mem[idx + _14898 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_15416 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _15416 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                            revert with 0, 17
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor1[arg1] > !(arg2 * stor6 / 1000 * 10^18):
                                            revert with 0, 17
                                        if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18)
                                        _19028 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19028] = 30
                                        mem[_19028 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > !(5 * arg2 / 100):
                                                revert with 0, 17
                                            if totalFees + (5 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 5 * arg2 / 100
                                            emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _19355 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19355 + 68] = mem[idx + _19028 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19355 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19355 + -mem[64] + 100
                                    if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                        revert with 0, 17
                                    if not 5 * arg2 / 100:
                                        revert with 0, 18
                                    if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _14065 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14065] = 30
                                    mem[_14065 + 32] = 'SafeMath: subtraction overflow'
                                    if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                        _14388 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _14388 + 68] = mem[idx + _14065 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14388 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14388 + -mem[64] + 100
                                    if arg2 * stor6 / 1000 * 10^18 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _16427 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16427] = 30
                                    mem[_16427 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        _17104 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _17104 + 68] = mem[idx + _16427 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17104 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _17104 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor1[arg1] > !((arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)
                                    _20369 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20369] = 30
                                    mem[_20369 + 32] = 'SafeMath: subtraction overflow'
                                    if 5 * arg2 / 100 * stor6 / 1000 * 10^18 <= stor6:
                                        if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                            revert with 0, 17
                                        stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                                        if totalFees > !(5 * arg2 / 100):
                                            revert with 0, 17
                                        if totalFees + (5 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 5 * arg2 / 100
                                        emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _20793 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20793 + 68] = mem[idx + _20369 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20793 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20793 + -mem[64] + 100
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                if stor2[stor5[idx]] <= s:
                                    if idx >= stor5.length:
                                        revert with 0, 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    _12422 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12422] = 30
                                    mem[_12422 + 32] = 'SafeMath: subtraction overflow'
                                    if stor1[stor5[idx]] > t:
                                        _12466 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _12466 + 68] = mem[idx + _12422 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_12466 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _12466 + -mem[64] + 100
                                    if t < stor1[stor5[idx]]:
                                        revert with 0, 17
                                    if idx >= stor5.length:
                                        revert with 0, 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    _12813 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12813] = 30
                                    mem[_12813 + 32] = 'SafeMath: subtraction overflow'
                                    if stor2[stor5[idx]] <= s:
                                        if s < stor2[stor5[idx]]:
                                            revert with 0, 17
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s - stor2[stor5[idx]]
                                        t = t - stor1[stor5[idx]]
                                        continue 
                                    _12873 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _12873 + 68] = mem[idx + _12813 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12873 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12873 + -mem[64] + 100
                                _12423 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12423] = 26
                                mem[_12423 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not 5 * arg2 / 100:
                                        _13173 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13173] = 30
                                        mem[_13173 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _14068 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_14068] = 30
                                        mem[_14068 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _14392 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _14392 + 68] = mem[idx + _14068 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_14392 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _14392 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > -1:
                                            revert with 0, 17
                                        if stor1[arg1] < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[arg1]
                                        _17803 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17803] = 30
                                        mem[_17803 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > !(5 * arg2 / 100):
                                                revert with 0, 17
                                            if totalFees + (5 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 5 * arg2 / 100
                                            emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _18395 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _18395 + 68] = mem[idx + _17803 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18395 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _18395 + -mem[64] + 100
                                    if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                        revert with 0, 17
                                    if not 5 * arg2 / 100:
                                        revert with 0, 18
                                    if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _13566 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13566] = 30
                                    mem[_13566 + 32] = 'SafeMath: subtraction overflow'
                                    if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > 0:
                                        _13749 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13749 + 68] = mem[idx + _13566 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13749 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13749 + -mem[64] + 100
                                    if 0 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _15420 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15420] = 30
                                    mem[_15420 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _15947 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _15947 + 68] = mem[idx + _15420 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_15947 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _15947 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > !(-5 * arg2 / 100 * stor6 / 1000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg1] - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1] - (5 * arg2 / 100 * stor6 / 1000 * 10^18)
                                    _19359 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19359] = 30
                                    mem[_19359 + 32] = 'SafeMath: subtraction overflow'
                                    if 5 * arg2 / 100 * stor6 / 1000 * 10^18 <= stor6:
                                        if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                            revert with 0, 17
                                        stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                                        if totalFees > !(5 * arg2 / 100):
                                            revert with 0, 17
                                        if totalFees + (5 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 5 * arg2 / 100
                                        emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _19914 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19914 + 68] = mem[idx + _19359 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19914 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19914 + -mem[64] + 100
                                if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 5 * arg2 / 100:
                                    _13565 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13565] = 30
                                    mem[_13565 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 1000 * 10^18:
                                        _13748 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13748 + 68] = mem[idx + _13565 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13748 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13748 + -mem[64] + 100
                                    if arg2 * stor6 / 1000 * 10^18 < 0:
                                        revert with 0, 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _15419 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15419] = 30
                                    mem[_15419 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        _15946 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _15946 + 68] = mem[idx + _15419 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_15946 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _15946 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor1[arg1] > !(arg2 * stor6 / 1000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18)
                                    _19358 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19358] = 30
                                    mem[_19358 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > !(5 * arg2 / 100):
                                            revert with 0, 17
                                        if totalFees + (5 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 5 * arg2 / 100
                                        emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _19913 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19913 + 68] = mem[idx + _19358 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19913 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19913 + -mem[64] + 100
                                if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                    revert with 0, 17
                                if not 5 * arg2 / 100:
                                    revert with 0, 18
                                if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _14391 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14391] = 30
                                mem[_14391 + 32] = 'SafeMath: subtraction overflow'
                                if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                    _14900 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _14900 + 68] = mem[idx + _14391 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14900 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14900 + -mem[64] + 100
                                if arg2 * stor6 / 1000 * 10^18 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                    revert with 0, 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _17107 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17107] = 30
                                mem[_17107 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                    _17634 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _17634 + 68] = mem[idx + _17107 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_17634 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _17634 + -mem[64] + 100
                                if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                if stor1[arg1] > !((arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)):
                                    revert with 0, 17
                                if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)
                                _20797 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20797] = 30
                                mem[_20797 + 32] = 'SafeMath: subtraction overflow'
                                if 5 * arg2 / 100 * stor6 / 1000 * 10^18 <= stor6:
                                    if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                                    if totalFees > !(5 * arg2 / 100):
                                        revert with 0, 17
                                    if totalFees + (5 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 5 * arg2 / 100
                                    emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _21244 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21244 + 68] = mem[idx + _20797 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21244 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21244 + -mem[64] + 100
                            if t < stor6 / 1000 * 10^18:
                                if not arg2:
                                    if not 5 * arg2 / 100:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > -1:
                                            revert with 0, 17
                                        if stor1[arg1] < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1]
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 0, 17
                                    else:
                                        if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                            revert with 0, 17
                                        if not 5 * arg2 / 100:
                                            revert with 0, 18
                                        if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if 0 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                            revert with 0, 17
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > !(-5 * arg2 / 100 * stor6 / 1000 * 10^18):
                                            revert with 0, 17
                                        if stor1[arg1] - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1] - (5 * arg2 / 100 * stor6 / 1000 * 10^18)
                                        if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                            revert with 0, 17
                                        stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                                else:
                                    if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                                        revert with 0, 17
                                    if not arg2:
                                        revert with 0, 18
                                    if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 5 * arg2 / 100:
                                        if 0 > arg2 * stor6 / 1000 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg2 * stor6 / 1000 * 10^18 < 0:
                                            revert with 0, 17
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                            revert with 0, 17
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor1[arg1] > !(arg2 * stor6 / 1000 * 10^18):
                                            revert with 0, 17
                                        if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18)
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 0, 17
                                    else:
                                        if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                            revert with 0, 17
                                        if not 5 * arg2 / 100:
                                            revert with 0, 18
                                        if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg2 * stor6 / 1000 * 10^18 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                            revert with 0, 17
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                            revert with 0, 17
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor1[arg1] > !((arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)):
                                            revert with 0, 17
                                        if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)
                                        if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                            revert with 0, 17
                                        stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                            else:
                                if not s:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not arg2:
                                    if not 5 * arg2 / 100:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > -1:
                                            revert with 0, 17
                                        if stor1[arg1] < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1]
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 0, 17
                                    else:
                                        if 5 * arg2 / 100 and t / s > -1 / 5 * arg2 / 100:
                                            revert with 0, 17
                                        if not 5 * arg2 / 100:
                                            revert with 0, 18
                                        if 5 * arg2 / 100 * t / s / 5 * arg2 / 100 != t / s:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if 5 * arg2 / 100 * t / s > 0:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if 0 < 5 * arg2 / 100 * t / s:
                                            revert with 0, 17
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > !(-5 * arg2 / 100 * t / s):
                                            revert with 0, 17
                                        if stor1[arg1] - (5 * arg2 / 100 * t / s) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1] - (5 * arg2 / 100 * t / s)
                                        if 5 * arg2 / 100 * t / s > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 5 * arg2 / 100 * t / s:
                                            revert with 0, 17
                                        stor6 += -5 * arg2 / 100 * t / s
                                else:
                                    if arg2 and t / s > -1 / arg2:
                                        revert with 0, 17
                                    if not arg2:
                                        revert with 0, 18
                                    if arg2 * t / s / arg2 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 5 * arg2 / 100:
                                        if 0 > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg2 * t / s < 0:
                                            revert with 0, 17
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < arg2 * t / s:
                                            revert with 0, 17
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor1[arg1] > !(arg2 * t / s):
                                            revert with 0, 17
                                        if stor1[arg1] + (arg2 * t / s) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1] + (arg2 * t / s)
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 0, 17
                                    else:
                                        if 5 * arg2 / 100 and t / s > -1 / 5 * arg2 / 100:
                                            revert with 0, 17
                                        if not 5 * arg2 / 100:
                                            revert with 0, 18
                                        if 5 * arg2 / 100 * t / s / 5 * arg2 / 100 != t / s:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if 5 * arg2 / 100 * t / s > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg2 * t / s < 5 * arg2 / 100 * t / s:
                                            revert with 0, 17
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < arg2 * t / s:
                                            revert with 0, 17
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor1[arg1] > !((arg2 * t / s) - (5 * arg2 / 100 * t / s)):
                                            revert with 0, 17
                                        if stor1[arg1] + (arg2 * t / s) - (5 * arg2 / 100 * t / s) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1] + (arg2 * t / s) - (5 * arg2 / 100 * t / s)
                                        if 5 * arg2 / 100 * t / s > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 5 * arg2 / 100 * t / s:
                                            revert with 0, 17
                                        stor6 += -5 * arg2 / 100 * t / s
                            if totalFees > !(5 * arg2 / 100):
                                revert with 0, 17
                            if totalFees + (5 * arg2 / 100) < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += 5 * arg2 / 100
                            emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                    else:
                        if not arg2 / 100:
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if 0 > arg2:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg2 < 0:
                                revert with 0, 17
                            idx = 0
                            s = 1000 * 10^18
                            t = stor6
                            while idx < stor5.length:
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                if stor1[stor5[idx]] > t:
                                    _12319 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12319] = 26
                                    mem[_12319 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        _13048 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13048] = 30
                                        mem[_13048 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _13758 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13758] = 30
                                        mem[_13758 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _14083 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _14083 + 68] = mem[idx + _13758 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_14083 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _14083 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > -1:
                                            revert with 0, 17
                                        if stor1[arg1] < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[arg1]
                                        _17456 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17456] = 30
                                        mem[_17456 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > -1:
                                                revert with 0, 17
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _17820 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _17820 + 68] = mem[idx + _17456 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17820 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _17820 + -mem[64] + 100
                                    if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                                        revert with 0, 17
                                    if not arg2:
                                        revert with 0, 18
                                    if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _13379 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13379] = 30
                                    mem[_13379 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 1000 * 10^18:
                                        _13573 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13573 + 68] = mem[idx + _13379 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13573 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13573 + -mem[64] + 100
                                    if arg2 * stor6 / 1000 * 10^18 < 0:
                                        revert with 0, 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _14918 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14918] = 30
                                    mem[_14918 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        _15437 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _15437 + 68] = mem[idx + _14918 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_15437 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _15437 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor1[arg1] > !(arg2 * stor6 / 1000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18)
                                    _19057 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19057] = 30
                                    mem[_19057 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > -1:
                                            revert with 0, 17
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _19376 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19376 + 68] = mem[idx + _19057 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19376 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19376 + -mem[64] + 100
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                if stor2[stor5[idx]] <= s:
                                    if idx >= stor5.length:
                                        revert with 0, 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    _12428 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12428] = 30
                                    mem[_12428 + 32] = 'SafeMath: subtraction overflow'
                                    if stor1[stor5[idx]] > t:
                                        _12469 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _12469 + 68] = mem[idx + _12428 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_12469 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _12469 + -mem[64] + 100
                                    if t < stor1[stor5[idx]]:
                                        revert with 0, 17
                                    if idx >= stor5.length:
                                        revert with 0, 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    _12819 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12819] = 30
                                    mem[_12819 + 32] = 'SafeMath: subtraction overflow'
                                    if stor2[stor5[idx]] <= s:
                                        if s < stor2[stor5[idx]]:
                                            revert with 0, 17
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s - stor2[stor5[idx]]
                                        t = t - stor1[stor5[idx]]
                                        continue 
                                    _12879 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _12879 + 68] = mem[idx + _12819 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12879 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12879 + -mem[64] + 100
                                _12429 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12429] = 26
                                mem[_12429 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    _13179 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13179] = 30
                                    mem[_13179 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _14084 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14084] = 30
                                    mem[_14084 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _14409 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _14409 + 68] = mem[idx + _14084 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14409 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14409 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > -1:
                                        revert with 0, 17
                                    if stor1[arg1] < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1]
                                    _17821 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17821] = 30
                                    mem[_17821 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > -1:
                                            revert with 0, 17
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _18446 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _18446 + 68] = mem[idx + _17821 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18446 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _18446 + -mem[64] + 100
                                if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _13574 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13574] = 30
                                mem[_13574 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor6 / 1000 * 10^18:
                                    _13759 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13759 + 68] = mem[idx + _13574 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13759 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13759 + -mem[64] + 100
                                if arg2 * stor6 / 1000 * 10^18 < 0:
                                    revert with 0, 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _15439 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15439] = 30
                                mem[_15439 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                    _15965 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _15965 + 68] = mem[idx + _15439 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15965 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _15965 + -mem[64] + 100
                                if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                if stor1[arg1] > !(arg2 * stor6 / 1000 * 10^18):
                                    revert with 0, 17
                                if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18)
                                _19378 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19378] = 30
                                mem[_19378 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > -1:
                                        revert with 0, 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _19945 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _19945 + 68] = mem[idx + _19378 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19945 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _19945 + -mem[64] + 100
                            if t < stor6 / 1000 * 10^18:
                                if not arg2:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > -1:
                                        revert with 0, 17
                                    if stor1[arg1] < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1]
                                else:
                                    if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                                        revert with 0, 17
                                    if not arg2:
                                        revert with 0, 18
                                    if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 0 > arg2 * stor6 / 1000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * stor6 / 1000 * 10^18 < 0:
                                        revert with 0, 17
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor1[arg1] > !(arg2 * stor6 / 1000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18)
                            else:
                                if not s:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not arg2:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > -1:
                                        revert with 0, 17
                                    if stor1[arg1] < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1]
                                else:
                                    if arg2 and t / s > -1 / arg2:
                                        revert with 0, 17
                                    if not arg2:
                                        revert with 0, 18
                                    if arg2 * t / s / arg2 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 0 > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * t / s < 0:
                                        revert with 0, 17
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * t / s:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor1[arg1] > !(arg2 * t / s):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * t / s) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * t / s)
                            if 0 > stor6:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor6 < 0:
                                revert with 0, 17
                            if totalFees > -1:
                                revert with 0, 17
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(arg2, msg.sender, arg1);
                        else:
                            if arg2 / 100 and 5 > -1 / arg2 / 100:
                                revert with 0, 17
                            if not arg2 / 100:
                                revert with 0, 18
                            if 5 * arg2 / 100 / arg2 / 100 != 5:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if 5 * arg2 / 100 > arg2:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg2 < 5 * arg2 / 100:
                                revert with 0, 17
                            idx = 0
                            s = 1000 * 10^18
                            t = stor6
                            while idx < stor5.length:
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                if stor1[stor5[idx]] > t:
                                    _12318 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12318] = 26
                                    mem[_12318 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if not 5 * arg2 / 100:
                                            _13045 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_13045] = 30
                                            mem[_13045 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _13755 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_13755] = 30
                                            mem[_13755 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _14078 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _14078 + 68] = mem[idx + _13755 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_14078 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _14078 + -mem[64] + 100
                                            if stor1[address(msg.sender)] < 0:
                                                revert with 0, 17
                                            if stor1[arg1] > -1:
                                                revert with 0, 17
                                            if stor1[arg1] < stor1[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] = stor1[arg1]
                                            _17445 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_17445] = 30
                                            mem[_17445 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if stor6 < 0:
                                                    revert with 0, 17
                                                if totalFees > !(5 * arg2 / 100):
                                                    revert with 0, 17
                                                if totalFees + (5 * arg2 / 100) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += 5 * arg2 / 100
                                                emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                                return 1
                                            _17815 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _17815 + 68] = mem[idx + _17445 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_17815 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _17815 + -mem[64] + 100
                                        if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                            revert with 0, 17
                                        if not 5 * arg2 / 100:
                                            revert with 0, 18
                                        if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _13373 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13373] = 30
                                        mem[_13373 + 32] = 'SafeMath: subtraction overflow'
                                        if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > 0:
                                            _13570 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _13570 + 68] = mem[idx + _13373 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_13570 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _13570 + -mem[64] + 100
                                        if 0 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                            revert with 0, 17
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _14912 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_14912] = 30
                                        mem[_14912 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _15431 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _15431 + 68] = mem[idx + _14912 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_15431 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _15431 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > !(-5 * arg2 / 100 * stor6 / 1000 * 10^18):
                                            revert with 0, 17
                                        if stor1[arg1] - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[arg1] - (5 * arg2 / 100 * stor6 / 1000 * 10^18)
                                        _19047 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19047] = 30
                                        mem[_19047 + 32] = 'SafeMath: subtraction overflow'
                                        if 5 * arg2 / 100 * stor6 / 1000 * 10^18 <= stor6:
                                            if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                                revert with 0, 17
                                            stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                                            if totalFees > !(5 * arg2 / 100):
                                                revert with 0, 17
                                            if totalFees + (5 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 5 * arg2 / 100
                                            emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _19370 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19370 + 68] = mem[idx + _19047 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19370 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19370 + -mem[64] + 100
                                    if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                                        revert with 0, 17
                                    if not arg2:
                                        revert with 0, 18
                                    if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 5 * arg2 / 100:
                                        _13372 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13372] = 30
                                        mem[_13372 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor6 / 1000 * 10^18:
                                            _13569 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _13569 + 68] = mem[idx + _13372 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_13569 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _13569 + -mem[64] + 100
                                        if arg2 * stor6 / 1000 * 10^18 < 0:
                                            revert with 0, 17
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _14911 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_14911] = 30
                                        mem[_14911 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            _15430 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _15430 + 68] = mem[idx + _14911 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_15430 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _15430 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                            revert with 0, 17
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor1[arg1] > !(arg2 * stor6 / 1000 * 10^18):
                                            revert with 0, 17
                                        if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18)
                                        _19046 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19046] = 30
                                        mem[_19046 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > !(5 * arg2 / 100):
                                                revert with 0, 17
                                            if totalFees + (5 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 5 * arg2 / 100
                                            emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _19369 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19369 + 68] = mem[idx + _19046 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19369 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19369 + -mem[64] + 100
                                    if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                        revert with 0, 17
                                    if not 5 * arg2 / 100:
                                        revert with 0, 18
                                    if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _14077 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14077] = 30
                                    mem[_14077 + 32] = 'SafeMath: subtraction overflow'
                                    if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                        _14401 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _14401 + 68] = mem[idx + _14077 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14401 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14401 + -mem[64] + 100
                                    if arg2 * stor6 / 1000 * 10^18 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _16437 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16437] = 30
                                    mem[_16437 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        _17121 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _17121 + 68] = mem[idx + _16437 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17121 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _17121 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor1[arg1] > !((arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)
                                    _20380 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20380] = 30
                                    mem[_20380 + 32] = 'SafeMath: subtraction overflow'
                                    if 5 * arg2 / 100 * stor6 / 1000 * 10^18 <= stor6:
                                        if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                            revert with 0, 17
                                        stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                                        if totalFees > !(5 * arg2 / 100):
                                            revert with 0, 17
                                        if totalFees + (5 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 5 * arg2 / 100
                                        emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _20812 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20812 + 68] = mem[idx + _20380 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20812 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20812 + -mem[64] + 100
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                if stor2[stor5[idx]] <= s:
                                    if idx >= stor5.length:
                                        revert with 0, 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    _12426 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12426] = 30
                                    mem[_12426 + 32] = 'SafeMath: subtraction overflow'
                                    if stor1[stor5[idx]] > t:
                                        _12468 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _12468 + 68] = mem[idx + _12426 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_12468 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _12468 + -mem[64] + 100
                                    if t < stor1[stor5[idx]]:
                                        revert with 0, 17
                                    if idx >= stor5.length:
                                        revert with 0, 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    _12817 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12817] = 30
                                    mem[_12817 + 32] = 'SafeMath: subtraction overflow'
                                    if stor2[stor5[idx]] <= s:
                                        if s < stor2[stor5[idx]]:
                                            revert with 0, 17
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s - stor2[stor5[idx]]
                                        t = t - stor1[stor5[idx]]
                                        continue 
                                    _12877 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _12877 + 68] = mem[idx + _12817 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12877 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12877 + -mem[64] + 100
                                _12427 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12427] = 26
                                mem[_12427 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not 5 * arg2 / 100:
                                        _13177 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13177] = 30
                                        mem[_13177 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _14080 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_14080] = 30
                                        mem[_14080 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _14405 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _14405 + 68] = mem[idx + _14080 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_14405 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _14405 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > -1:
                                            revert with 0, 17
                                        if stor1[arg1] < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[arg1]
                                        _17817 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17817] = 30
                                        mem[_17817 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > !(5 * arg2 / 100):
                                                revert with 0, 17
                                            if totalFees + (5 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 5 * arg2 / 100
                                            emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _18433 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _18433 + 68] = mem[idx + _17817 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18433 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _18433 + -mem[64] + 100
                                    if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                        revert with 0, 17
                                    if not 5 * arg2 / 100:
                                        revert with 0, 18
                                    if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _13572 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13572] = 30
                                    mem[_13572 + 32] = 'SafeMath: subtraction overflow'
                                    if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > 0:
                                        _13757 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13757 + 68] = mem[idx + _13572 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13757 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13757 + -mem[64] + 100
                                    if 0 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _15434 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15434] = 30
                                    mem[_15434 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _15961 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _15961 + 68] = mem[idx + _15434 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_15961 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _15961 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > !(-5 * arg2 / 100 * stor6 / 1000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg1] - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1] - (5 * arg2 / 100 * stor6 / 1000 * 10^18)
                                    _19373 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19373] = 30
                                    mem[_19373 + 32] = 'SafeMath: subtraction overflow'
                                    if 5 * arg2 / 100 * stor6 / 1000 * 10^18 <= stor6:
                                        if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                            revert with 0, 17
                                        stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                                        if totalFees > !(5 * arg2 / 100):
                                            revert with 0, 17
                                        if totalFees + (5 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 5 * arg2 / 100
                                        emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _19939 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19939 + 68] = mem[idx + _19373 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19939 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19939 + -mem[64] + 100
                                if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 5 * arg2 / 100:
                                    _13571 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13571] = 30
                                    mem[_13571 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 1000 * 10^18:
                                        _13756 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13756 + 68] = mem[idx + _13571 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13756 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13756 + -mem[64] + 100
                                    if arg2 * stor6 / 1000 * 10^18 < 0:
                                        revert with 0, 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _15433 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15433] = 30
                                    mem[_15433 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        _15960 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _15960 + 68] = mem[idx + _15433 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_15960 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _15960 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor1[arg1] > !(arg2 * stor6 / 1000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18)
                                    _19372 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19372] = 30
                                    mem[_19372 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > !(5 * arg2 / 100):
                                            revert with 0, 17
                                        if totalFees + (5 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 5 * arg2 / 100
                                        emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _19938 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19938 + 68] = mem[idx + _19372 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19938 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19938 + -mem[64] + 100
                                if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                    revert with 0, 17
                                if not 5 * arg2 / 100:
                                    revert with 0, 18
                                if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _14404 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14404] = 30
                                mem[_14404 + 32] = 'SafeMath: subtraction overflow'
                                if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                    _14913 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _14913 + 68] = mem[idx + _14404 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14913 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14913 + -mem[64] + 100
                                if arg2 * stor6 / 1000 * 10^18 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                    revert with 0, 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _17124 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17124] = 30
                                mem[_17124 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                    _17640 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _17640 + 68] = mem[idx + _17124 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_17640 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _17640 + -mem[64] + 100
                                if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                if stor1[arg1] > !((arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)):
                                    revert with 0, 17
                                if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)
                                _20816 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20816] = 30
                                mem[_20816 + 32] = 'SafeMath: subtraction overflow'
                                if 5 * arg2 / 100 * stor6 / 1000 * 10^18 <= stor6:
                                    if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                                    if totalFees > !(5 * arg2 / 100):
                                        revert with 0, 17
                                    if totalFees + (5 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 5 * arg2 / 100
                                    emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _21254 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21254 + 68] = mem[idx + _20816 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21254 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21254 + -mem[64] + 100
                            if t < stor6 / 1000 * 10^18:
                                if not arg2:
                                    if not 5 * arg2 / 100:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > -1:
                                            revert with 0, 17
                                        if stor1[arg1] < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1]
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 0, 17
                                    else:
                                        if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                            revert with 0, 17
                                        if not 5 * arg2 / 100:
                                            revert with 0, 18
                                        if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if 0 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                            revert with 0, 17
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > !(-5 * arg2 / 100 * stor6 / 1000 * 10^18):
                                            revert with 0, 17
                                        if stor1[arg1] - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1] - (5 * arg2 / 100 * stor6 / 1000 * 10^18)
                                        if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                            revert with 0, 17
                                        stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                                else:
                                    if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                                        revert with 0, 17
                                    if not arg2:
                                        revert with 0, 18
                                    if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 5 * arg2 / 100:
                                        if 0 > arg2 * stor6 / 1000 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg2 * stor6 / 1000 * 10^18 < 0:
                                            revert with 0, 17
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                            revert with 0, 17
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor1[arg1] > !(arg2 * stor6 / 1000 * 10^18):
                                            revert with 0, 17
                                        if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18)
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 0, 17
                                    else:
                                        if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                            revert with 0, 17
                                        if not 5 * arg2 / 100:
                                            revert with 0, 18
                                        if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg2 * stor6 / 1000 * 10^18 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                            revert with 0, 17
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                            revert with 0, 17
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor1[arg1] > !((arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)):
                                            revert with 0, 17
                                        if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)
                                        if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                            revert with 0, 17
                                        stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                            else:
                                if not s:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not arg2:
                                    if not 5 * arg2 / 100:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > -1:
                                            revert with 0, 17
                                        if stor1[arg1] < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1]
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 0, 17
                                    else:
                                        if 5 * arg2 / 100 and t / s > -1 / 5 * arg2 / 100:
                                            revert with 0, 17
                                        if not 5 * arg2 / 100:
                                            revert with 0, 18
                                        if 5 * arg2 / 100 * t / s / 5 * arg2 / 100 != t / s:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if 5 * arg2 / 100 * t / s > 0:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if 0 < 5 * arg2 / 100 * t / s:
                                            revert with 0, 17
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > !(-5 * arg2 / 100 * t / s):
                                            revert with 0, 17
                                        if stor1[arg1] - (5 * arg2 / 100 * t / s) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1] - (5 * arg2 / 100 * t / s)
                                        if 5 * arg2 / 100 * t / s > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 5 * arg2 / 100 * t / s:
                                            revert with 0, 17
                                        stor6 += -5 * arg2 / 100 * t / s
                                else:
                                    if arg2 and t / s > -1 / arg2:
                                        revert with 0, 17
                                    if not arg2:
                                        revert with 0, 18
                                    if arg2 * t / s / arg2 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 5 * arg2 / 100:
                                        if 0 > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg2 * t / s < 0:
                                            revert with 0, 17
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < arg2 * t / s:
                                            revert with 0, 17
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor1[arg1] > !(arg2 * t / s):
                                            revert with 0, 17
                                        if stor1[arg1] + (arg2 * t / s) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1] + (arg2 * t / s)
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 0, 17
                                    else:
                                        if 5 * arg2 / 100 and t / s > -1 / 5 * arg2 / 100:
                                            revert with 0, 17
                                        if not 5 * arg2 / 100:
                                            revert with 0, 18
                                        if 5 * arg2 / 100 * t / s / 5 * arg2 / 100 != t / s:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if 5 * arg2 / 100 * t / s > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg2 * t / s < 5 * arg2 / 100 * t / s:
                                            revert with 0, 17
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < arg2 * t / s:
                                            revert with 0, 17
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor1[arg1] > !((arg2 * t / s) - (5 * arg2 / 100 * t / s)):
                                            revert with 0, 17
                                        if stor1[arg1] + (arg2 * t / s) - (5 * arg2 / 100 * t / s) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1] + (arg2 * t / s) - (5 * arg2 / 100 * t / s)
                                        if 5 * arg2 / 100 * t / s > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 5 * arg2 / 100 * t / s:
                                            revert with 0, 17
                                        stor6 += -5 * arg2 / 100 * t / s
                            if totalFees > !(5 * arg2 / 100):
                                revert with 0, 17
                            if totalFees + (5 * arg2 / 100) < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += 5 * arg2 / 100
                            emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
            else:
                mem[0] = arg1
                mem[32] = 4
                if stor4[address(arg1)]:
                    mem[96] = 26
                    mem[128] = 'SafeMath: division by zero'
                    if not arg2 / 100:
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if 0 > arg2:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg2 < 0:
                            revert with 0, 17
                        idx = 0
                        s = 1000 * 10^18
                        t = stor6
                        while idx < stor5.length:
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            if stor1[stor5[idx]] > t:
                                _12327 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12327] = 26
                                mem[_12327 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    _13072 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13072] = 30
                                    mem[_13072 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _13790 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13790] = 30
                                    mem[_13790 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _14131 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _14131 + 68] = mem[idx + _13790 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14131 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14131 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor2[address(arg1)] > !arg2:
                                        revert with 0, 17
                                    if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] += arg2
                                    if stor1[address(arg1)] > -1:
                                        revert with 0, 17
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _19128 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19128] = 30
                                    mem[_19128 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > -1:
                                            revert with 0, 17
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _19425 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19425 + 68] = mem[idx + _19128 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19425 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19425 + -mem[64] + 100
                                if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _13427 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13427] = 30
                                mem[_13427 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor6 / 1000 * 10^18:
                                    _13597 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13597 + 68] = mem[idx + _13427 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13597 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13597 + -mem[64] + 100
                                if arg2 * stor6 / 1000 * 10^18 < 0:
                                    revert with 0, 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _14970 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14970] = 30
                                mem[_14970 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                    _15493 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _15493 + 68] = mem[idx + _14970 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15493 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _15493 + -mem[64] + 100
                                if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                if stor2[address(arg1)] > !arg2:
                                    revert with 0, 17
                                if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] += arg2
                                if stor1[address(arg1)] > !(arg2 * stor6 / 1000 * 10^18):
                                    revert with 0, 17
                                if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                _20433 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20433] = 30
                                mem[_20433 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > -1:
                                        revert with 0, 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _20891 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20891 + 68] = mem[idx + _20433 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20891 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20891 + -mem[64] + 100
                            if idx >= stor5.length:
                                revert with 0, 50
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            if stor2[stor5[idx]] <= s:
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                _12444 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12444] = 30
                                mem[_12444 + 32] = 'SafeMath: subtraction overflow'
                                if stor1[stor5[idx]] > t:
                                    _12477 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _12477 + 68] = mem[idx + _12444 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12477 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12477 + -mem[64] + 100
                                if t < stor1[stor5[idx]]:
                                    revert with 0, 17
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                _12835 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12835] = 30
                                mem[_12835 + 32] = 'SafeMath: subtraction overflow'
                                if stor2[stor5[idx]] <= s:
                                    if s < stor2[stor5[idx]]:
                                        revert with 0, 17
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s - stor2[stor5[idx]]
                                    t = t - stor1[stor5[idx]]
                                    continue 
                                _12895 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _12895 + 68] = mem[idx + _12835 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12895 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12895 + -mem[64] + 100
                            _12445 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12445] = 26
                            mem[_12445 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                _13195 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13195] = 30
                                mem[_13195 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = msg.sender
                                mem[32] = 1
                                _14132 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14132] = 30
                                mem[_14132 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _14461 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _14461 + 68] = mem[idx + _14132 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14461 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14461 + -mem[64] + 100
                                if stor1[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor2[address(arg1)] > !arg2:
                                    revert with 0, 17
                                if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] += arg2
                                if stor1[address(arg1)] > -1:
                                    revert with 0, 17
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                _19426 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19426] = 30
                                mem[_19426 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > -1:
                                        revert with 0, 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _20064 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20064 + 68] = mem[idx + _19426 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20064 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20064 + -mem[64] + 100
                            if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                                revert with 0, 17
                            if not arg2:
                                revert with 0, 18
                            if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _13598 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13598] = 30
                            mem[_13598 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg2 * stor6 / 1000 * 10^18:
                                _13791 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13791 + 68] = mem[idx + _13598 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13791 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13791 + -mem[64] + 100
                            if arg2 * stor6 / 1000 * 10^18 < 0:
                                revert with 0, 17
                            mem[0] = msg.sender
                            mem[32] = 1
                            _15495 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15495] = 30
                            mem[_15495 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                _16021 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _16021 + 68] = mem[idx + _15495 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_16021 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _16021 + -mem[64] + 100
                            if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                revert with 0, 17
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                            if stor2[address(arg1)] > !arg2:
                                revert with 0, 17
                            if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(arg1)] += arg2
                            if stor1[address(arg1)] > !(arg2 * stor6 / 1000 * 10^18):
                                revert with 0, 17
                            if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                            _20893 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20893] = 30
                            mem[_20893 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor6:
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > -1:
                                    revert with 0, 17
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg2, msg.sender, arg1);
                                return 1
                            _21313 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _21313 + 68] = mem[idx + _20893 + 32]
                                idx = idx + 32
                                continue 
                            mem[_21313 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _21313 + -mem[64] + 100
                        if t < stor6 / 1000 * 10^18:
                            if not arg2:
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor2[address(arg1)] > !arg2:
                                    revert with 0, 17
                                if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] += arg2
                                if stor1[address(arg1)] > -1:
                                    revert with 0, 17
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                            else:
                                if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > arg2 * stor6 / 1000 * 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg2 * stor6 / 1000 * 10^18 < 0:
                                    revert with 0, 17
                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                if stor2[address(arg1)] > !arg2:
                                    revert with 0, 17
                                if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] += arg2
                                if stor1[address(arg1)] > !(arg2 * stor6 / 1000 * 10^18):
                                    revert with 0, 17
                                if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                        else:
                            if not s:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not arg2:
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor2[address(arg1)] > !arg2:
                                    revert with 0, 17
                                if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] += arg2
                                if stor1[address(arg1)] > -1:
                                    revert with 0, 17
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                            else:
                                if arg2 and t / s > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * t / s / arg2 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > arg2 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg2 * t / s < 0:
                                    revert with 0, 17
                                if arg2 * t / s > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < arg2 * t / s:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * t / s
                                if stor2[address(arg1)] > !arg2:
                                    revert with 0, 17
                                if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] += arg2
                                if stor1[address(arg1)] > !(arg2 * t / s):
                                    revert with 0, 17
                                if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] += arg2 * t / s
                        if 0 > stor6:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor6 < 0:
                            revert with 0, 17
                        if totalFees > -1:
                            revert with 0, 17
                        if totalFees < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        emit Transfer(arg2, msg.sender, arg1);
                    else:
                        if arg2 / 100 and 5 > -1 / arg2 / 100:
                            revert with 0, 17
                        if not arg2 / 100:
                            revert with 0, 18
                        if 5 * arg2 / 100 / arg2 / 100 != 5:
                            revert with 0, 'SafeMath: multiplication overflow'
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if 5 * arg2 / 100 > arg2:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg2 < 5 * arg2 / 100:
                            revert with 0, 17
                        idx = 0
                        s = 1000 * 10^18
                        t = stor6
                        while idx < stor5.length:
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            if stor1[stor5[idx]] > t:
                                _12326 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12326] = 26
                                mem[_12326 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not 5 * arg2 / 100:
                                        _13069 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13069] = 30
                                        mem[_13069 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _13787 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13787] = 30
                                        mem[_13787 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _14126 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _14126 + 68] = mem[idx + _13787 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_14126 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _14126 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor2[address(arg1)] > !(arg2 - (5 * arg2 / 100)):
                                            revert with 0, 17
                                        if stor2[address(arg1)] + arg2 - (5 * arg2 / 100) < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (5 * arg2 / 100)
                                        if stor1[address(arg1)] > -1:
                                            revert with 0, 17
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _19116 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19116] = 30
                                        mem[_19116 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > !(5 * arg2 / 100):
                                                revert with 0, 17
                                            if totalFees + (5 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 5 * arg2 / 100
                                            emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _19423 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19423 + 68] = mem[idx + _19116 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19423 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19423 + -mem[64] + 100
                                    if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                        revert with 0, 17
                                    if not 5 * arg2 / 100:
                                        revert with 0, 18
                                    if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _13421 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13421] = 30
                                    mem[_13421 + 32] = 'SafeMath: subtraction overflow'
                                    if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > 0:
                                        _13594 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13594 + 68] = mem[idx + _13421 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13594 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13594 + -mem[64] + 100
                                    if 0 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _14964 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14964] = 30
                                    mem[_14964 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _15487 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _15487 + 68] = mem[idx + _14964 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_15487 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _15487 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor2[address(arg1)] > !(arg2 - (5 * arg2 / 100)):
                                        revert with 0, 17
                                    if stor2[address(arg1)] + arg2 - (5 * arg2 / 100) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (5 * arg2 / 100)
                                    if stor1[address(arg1)] > !(-5 * arg2 / 100 * stor6 / 1000 * 10^18):
                                        revert with 0, 17
                                    if stor1[address(arg1)] - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                                    _20423 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20423] = 30
                                    mem[_20423 + 32] = 'SafeMath: subtraction overflow'
                                    if 5 * arg2 / 100 * stor6 / 1000 * 10^18 <= stor6:
                                        if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                            revert with 0, 17
                                        stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                                        if totalFees > !(5 * arg2 / 100):
                                            revert with 0, 17
                                        if totalFees + (5 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 5 * arg2 / 100
                                        emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _20885 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20885 + 68] = mem[idx + _20423 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20885 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20885 + -mem[64] + 100
                                if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 5 * arg2 / 100:
                                    _13420 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13420] = 30
                                    mem[_13420 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 1000 * 10^18:
                                        _13593 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13593 + 68] = mem[idx + _13420 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13593 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13593 + -mem[64] + 100
                                    if arg2 * stor6 / 1000 * 10^18 < 0:
                                        revert with 0, 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _14963 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14963] = 30
                                    mem[_14963 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        _15486 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _15486 + 68] = mem[idx + _14963 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_15486 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _15486 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor2[address(arg1)] > !(arg2 - (5 * arg2 / 100)):
                                        revert with 0, 17
                                    if stor2[address(arg1)] + arg2 - (5 * arg2 / 100) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (5 * arg2 / 100)
                                    if stor1[address(arg1)] > !(arg2 * stor6 / 1000 * 10^18):
                                        revert with 0, 17
                                    if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                    _20422 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20422] = 30
                                    mem[_20422 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > !(5 * arg2 / 100):
                                            revert with 0, 17
                                        if totalFees + (5 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 5 * arg2 / 100
                                        emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _20884 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20884 + 68] = mem[idx + _20422 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20884 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20884 + -mem[64] + 100
                                if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                    revert with 0, 17
                                if not 5 * arg2 / 100:
                                    revert with 0, 18
                                if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _14125 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14125] = 30
                                mem[_14125 + 32] = 'SafeMath: subtraction overflow'
                                if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                    _14453 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _14453 + 68] = mem[idx + _14125 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14453 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14453 + -mem[64] + 100
                                if arg2 * stor6 / 1000 * 10^18 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                    revert with 0, 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _16477 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16477] = 30
                                mem[_16477 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                    _17189 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _17189 + 68] = mem[idx + _16477 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_17189 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _17189 + -mem[64] + 100
                                if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                if stor2[address(arg1)] > !(arg2 - (5 * arg2 / 100)):
                                    revert with 0, 17
                                if stor2[address(arg1)] + arg2 - (5 * arg2 / 100) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (5 * arg2 / 100)
                                if stor1[address(arg1)] > !((arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)):
                                    revert with 0, 17
                                if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)
                                _21610 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21610] = 30
                                mem[_21610 + 32] = 'SafeMath: subtraction overflow'
                                if 5 * arg2 / 100 * stor6 / 1000 * 10^18 <= stor6:
                                    if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                                    if totalFees > !(5 * arg2 / 100):
                                        revert with 0, 17
                                    if totalFees + (5 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 5 * arg2 / 100
                                    emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _22160 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22160 + 68] = mem[idx + _21610 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22160 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22160 + -mem[64] + 100
                            if idx >= stor5.length:
                                revert with 0, 50
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            if stor2[stor5[idx]] <= s:
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                _12442 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12442] = 30
                                mem[_12442 + 32] = 'SafeMath: subtraction overflow'
                                if stor1[stor5[idx]] > t:
                                    _12476 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _12476 + 68] = mem[idx + _12442 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12476 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12476 + -mem[64] + 100
                                if t < stor1[stor5[idx]]:
                                    revert with 0, 17
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                _12833 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12833] = 30
                                mem[_12833 + 32] = 'SafeMath: subtraction overflow'
                                if stor2[stor5[idx]] <= s:
                                    if s < stor2[stor5[idx]]:
                                        revert with 0, 17
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s - stor2[stor5[idx]]
                                    t = t - stor1[stor5[idx]]
                                    continue 
                                _12893 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _12893 + 68] = mem[idx + _12833 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12893 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12893 + -mem[64] + 100
                            _12443 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12443] = 26
                            mem[_12443 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                if not 5 * arg2 / 100:
                                    _13193 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13193] = 30
                                    mem[_13193 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _14128 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14128] = 30
                                    mem[_14128 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _14457 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _14457 + 68] = mem[idx + _14128 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14457 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14457 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor2[address(arg1)] > !(arg2 - (5 * arg2 / 100)):
                                        revert with 0, 17
                                    if stor2[address(arg1)] + arg2 - (5 * arg2 / 100) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (5 * arg2 / 100)
                                    if stor1[address(arg1)] > -1:
                                        revert with 0, 17
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _19424 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19424] = 30
                                    mem[_19424 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > !(5 * arg2 / 100):
                                            revert with 0, 17
                                        if totalFees + (5 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 5 * arg2 / 100
                                        emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _20051 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20051 + 68] = mem[idx + _19424 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20051 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20051 + -mem[64] + 100
                                if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                    revert with 0, 17
                                if not 5 * arg2 / 100:
                                    revert with 0, 18
                                if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _13596 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13596] = 30
                                mem[_13596 + 32] = 'SafeMath: subtraction overflow'
                                if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > 0:
                                    _13789 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13789 + 68] = mem[idx + _13596 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13789 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13789 + -mem[64] + 100
                                if 0 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                    revert with 0, 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _15490 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15490] = 30
                                mem[_15490 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _16017 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _16017 + 68] = mem[idx + _15490 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_16017 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _16017 + -mem[64] + 100
                                if stor1[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor2[address(arg1)] > !(arg2 - (5 * arg2 / 100)):
                                    revert with 0, 17
                                if stor2[address(arg1)] + arg2 - (5 * arg2 / 100) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (5 * arg2 / 100)
                                if stor1[address(arg1)] > !(-5 * arg2 / 100 * stor6 / 1000 * 10^18):
                                    revert with 0, 17
                                if stor1[address(arg1)] - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                                _20888 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20888] = 30
                                mem[_20888 + 32] = 'SafeMath: subtraction overflow'
                                if 5 * arg2 / 100 * stor6 / 1000 * 10^18 <= stor6:
                                    if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                                    if totalFees > !(5 * arg2 / 100):
                                        revert with 0, 17
                                    if totalFees + (5 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 5 * arg2 / 100
                                    emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _21307 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21307 + 68] = mem[idx + _20888 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21307 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21307 + -mem[64] + 100
                            if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                                revert with 0, 17
                            if not arg2:
                                revert with 0, 18
                            if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 5 * arg2 / 100:
                                _13595 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13595] = 30
                                mem[_13595 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor6 / 1000 * 10^18:
                                    _13788 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13788 + 68] = mem[idx + _13595 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13788 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13788 + -mem[64] + 100
                                if arg2 * stor6 / 1000 * 10^18 < 0:
                                    revert with 0, 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _15489 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15489] = 30
                                mem[_15489 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                    _16016 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _16016 + 68] = mem[idx + _15489 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_16016 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _16016 + -mem[64] + 100
                                if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                if stor2[address(arg1)] > !(arg2 - (5 * arg2 / 100)):
                                    revert with 0, 17
                                if stor2[address(arg1)] + arg2 - (5 * arg2 / 100) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (5 * arg2 / 100)
                                if stor1[address(arg1)] > !(arg2 * stor6 / 1000 * 10^18):
                                    revert with 0, 17
                                if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                _20887 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20887] = 30
                                mem[_20887 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > !(5 * arg2 / 100):
                                        revert with 0, 17
                                    if totalFees + (5 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 5 * arg2 / 100
                                    emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _21306 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21306 + 68] = mem[idx + _20887 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21306 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21306 + -mem[64] + 100
                            if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                revert with 0, 17
                            if not 5 * arg2 / 100:
                                revert with 0, 18
                            if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _14456 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14456] = 30
                            mem[_14456 + 32] = 'SafeMath: subtraction overflow'
                            if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                _14965 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14965 + 68] = mem[idx + _14456 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14965 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14965 + -mem[64] + 100
                            if arg2 * stor6 / 1000 * 10^18 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                revert with 0, 17
                            mem[0] = msg.sender
                            mem[32] = 1
                            _17192 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_17192] = 30
                            mem[_17192 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                _17664 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _17664 + 68] = mem[idx + _17192 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_17664 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _17664 + -mem[64] + 100
                            if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                revert with 0, 17
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                            if stor2[address(arg1)] > !(arg2 - (5 * arg2 / 100)):
                                revert with 0, 17
                            if stor2[address(arg1)] + arg2 - (5 * arg2 / 100) < stor2[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (5 * arg2 / 100)
                            if stor1[address(arg1)] > !((arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)):
                                revert with 0, 17
                            if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)
                            _22164 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22164] = 30
                            mem[_22164 + 32] = 'SafeMath: subtraction overflow'
                            if 5 * arg2 / 100 * stor6 / 1000 * 10^18 <= stor6:
                                if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                    revert with 0, 17
                                stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                                if totalFees > !(5 * arg2 / 100):
                                    revert with 0, 17
                                if totalFees + (5 * arg2 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 5 * arg2 / 100
                                emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                return 1
                            _22494 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _22494 + 68] = mem[idx + _22164 + 32]
                                idx = idx + 32
                                continue 
                            mem[_22494 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _22494 + -mem[64] + 100
                        if t < stor6 / 1000 * 10^18:
                            if not arg2:
                                if not 5 * arg2 / 100:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor2[address(arg1)] > !(arg2 - (5 * arg2 / 100)):
                                        revert with 0, 17
                                    if stor2[address(arg1)] + arg2 - (5 * arg2 / 100) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (5 * arg2 / 100)
                                    if stor1[address(arg1)] > -1:
                                        revert with 0, 17
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 0, 17
                                else:
                                    if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                        revert with 0, 17
                                    if not 5 * arg2 / 100:
                                        revert with 0, 18
                                    if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor2[address(arg1)] > !(arg2 - (5 * arg2 / 100)):
                                        revert with 0, 17
                                    if stor2[address(arg1)] + arg2 - (5 * arg2 / 100) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (5 * arg2 / 100)
                                    if stor1[address(arg1)] > !(-5 * arg2 / 100 * stor6 / 1000 * 10^18):
                                        revert with 0, 17
                                    if stor1[address(arg1)] - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                                    if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                            else:
                                if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 5 * arg2 / 100:
                                    if 0 > arg2 * stor6 / 1000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * stor6 / 1000 * 10^18 < 0:
                                        revert with 0, 17
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor2[address(arg1)] > !(arg2 - (5 * arg2 / 100)):
                                        revert with 0, 17
                                    if stor2[address(arg1)] + arg2 - (5 * arg2 / 100) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (5 * arg2 / 100)
                                    if stor1[address(arg1)] > !(arg2 * stor6 / 1000 * 10^18):
                                        revert with 0, 17
                                    if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += arg2 * stor6 / 1000 * 10^18
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 0, 17
                                else:
                                    if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                        revert with 0, 17
                                    if not 5 * arg2 / 100:
                                        revert with 0, 18
                                    if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * stor6 / 1000 * 10^18 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor2[address(arg1)] > !(arg2 - (5 * arg2 / 100)):
                                        revert with 0, 17
                                    if stor2[address(arg1)] + arg2 - (5 * arg2 / 100) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (5 * arg2 / 100)
                                    if stor1[address(arg1)] > !((arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)):
                                        revert with 0, 17
                                    if stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)
                                    if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                        else:
                            if not s:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not arg2:
                                if not 5 * arg2 / 100:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor2[address(arg1)] > !(arg2 - (5 * arg2 / 100)):
                                        revert with 0, 17
                                    if stor2[address(arg1)] + arg2 - (5 * arg2 / 100) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (5 * arg2 / 100)
                                    if stor1[address(arg1)] > -1:
                                        revert with 0, 17
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 0, 17
                                else:
                                    if 5 * arg2 / 100 and t / s > -1 / 5 * arg2 / 100:
                                        revert with 0, 17
                                    if not 5 * arg2 / 100:
                                        revert with 0, 18
                                    if 5 * arg2 / 100 * t / s / 5 * arg2 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 5 * arg2 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 5 * arg2 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor2[address(arg1)] > !(arg2 - (5 * arg2 / 100)):
                                        revert with 0, 17
                                    if stor2[address(arg1)] + arg2 - (5 * arg2 / 100) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (5 * arg2 / 100)
                                    if stor1[address(arg1)] > !(-5 * arg2 / 100 * t / s):
                                        revert with 0, 17
                                    if stor1[address(arg1)] - (5 * arg2 / 100 * t / s) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += -5 * arg2 / 100 * t / s
                                    if 5 * arg2 / 100 * t / s > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 5 * arg2 / 100 * t / s:
                                        revert with 0, 17
                                    stor6 += -5 * arg2 / 100 * t / s
                            else:
                                if arg2 and t / s > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * t / s / arg2 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 5 * arg2 / 100:
                                    if 0 > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * t / s < 0:
                                        revert with 0, 17
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * t / s:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor2[address(arg1)] > !(arg2 - (5 * arg2 / 100)):
                                        revert with 0, 17
                                    if stor2[address(arg1)] + arg2 - (5 * arg2 / 100) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (5 * arg2 / 100)
                                    if stor1[address(arg1)] > !(arg2 * t / s):
                                        revert with 0, 17
                                    if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += arg2 * t / s
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 0, 17
                                else:
                                    if 5 * arg2 / 100 and t / s > -1 / 5 * arg2 / 100:
                                        revert with 0, 17
                                    if not 5 * arg2 / 100:
                                        revert with 0, 18
                                    if 5 * arg2 / 100 * t / s / 5 * arg2 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 5 * arg2 / 100 * t / s > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * t / s < 5 * arg2 / 100 * t / s:
                                        revert with 0, 17
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * t / s:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor2[address(arg1)] > !(arg2 - (5 * arg2 / 100)):
                                        revert with 0, 17
                                    if stor2[address(arg1)] + arg2 - (5 * arg2 / 100) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (5 * arg2 / 100)
                                    if stor1[address(arg1)] > !((arg2 * t / s) - (5 * arg2 / 100 * t / s)):
                                        revert with 0, 17
                                    if stor1[address(arg1)] + (arg2 * t / s) - (5 * arg2 / 100 * t / s) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (5 * arg2 / 100 * t / s)
                                    if 5 * arg2 / 100 * t / s > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 5 * arg2 / 100 * t / s:
                                        revert with 0, 17
                                    stor6 += -5 * arg2 / 100 * t / s
                        if totalFees > !(5 * arg2 / 100):
                            revert with 0, 17
                        if totalFees + (5 * arg2 / 100) < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        totalFees += 5 * arg2 / 100
                        emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                else:
                    mem[0] = msg.sender
                    mem[32] = 4
                    if stor4[address(msg.sender)]:
                        mem[96] = 26
                        mem[128] = 'SafeMath: division by zero'
                        if not arg2 / 100:
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if 0 > arg2:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg2 < 0:
                                revert with 0, 17
                            idx = 0
                            s = 1000 * 10^18
                            t = stor6
                            while idx < stor5.length:
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                if stor1[stor5[idx]] > t:
                                    _12321 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12321] = 26
                                    mem[_12321 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        _13054 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13054] = 30
                                        mem[_13054 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _13766 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13766] = 30
                                        mem[_13766 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _14095 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _14095 + 68] = mem[idx + _13766 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_14095 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _14095 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > -1:
                                            revert with 0, 17
                                        if stor1[arg1] < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[arg1]
                                        _17480 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17480] = 30
                                        mem[_17480 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > -1:
                                                revert with 0, 17
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _17834 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _17834 + 68] = mem[idx + _17480 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17834 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _17834 + -mem[64] + 100
                                    if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                                        revert with 0, 17
                                    if not arg2:
                                        revert with 0, 18
                                    if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _13391 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13391] = 30
                                    mem[_13391 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 1000 * 10^18:
                                        _13579 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13579 + 68] = mem[idx + _13391 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13579 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13579 + -mem[64] + 100
                                    if arg2 * stor6 / 1000 * 10^18 < 0:
                                        revert with 0, 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _14931 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14931] = 30
                                    mem[_14931 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        _15451 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _15451 + 68] = mem[idx + _14931 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_15451 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _15451 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor1[arg1] > !(arg2 * stor6 / 1000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18)
                                    _19075 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19075] = 30
                                    mem[_19075 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > -1:
                                            revert with 0, 17
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _19390 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19390 + 68] = mem[idx + _19075 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19390 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19390 + -mem[64] + 100
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                if stor2[stor5[idx]] <= s:
                                    if idx >= stor5.length:
                                        revert with 0, 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    _12432 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12432] = 30
                                    mem[_12432 + 32] = 'SafeMath: subtraction overflow'
                                    if stor1[stor5[idx]] > t:
                                        _12471 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _12471 + 68] = mem[idx + _12432 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_12471 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _12471 + -mem[64] + 100
                                    if t < stor1[stor5[idx]]:
                                        revert with 0, 17
                                    if idx >= stor5.length:
                                        revert with 0, 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    _12823 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12823] = 30
                                    mem[_12823 + 32] = 'SafeMath: subtraction overflow'
                                    if stor2[stor5[idx]] <= s:
                                        if s < stor2[stor5[idx]]:
                                            revert with 0, 17
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s - stor2[stor5[idx]]
                                        t = t - stor1[stor5[idx]]
                                        continue 
                                    _12883 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _12883 + 68] = mem[idx + _12823 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12883 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12883 + -mem[64] + 100
                                _12433 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12433] = 26
                                mem[_12433 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    _13183 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13183] = 30
                                    mem[_13183 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _14096 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14096] = 30
                                    mem[_14096 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _14422 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _14422 + 68] = mem[idx + _14096 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14422 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14422 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > -1:
                                        revert with 0, 17
                                    if stor1[arg1] < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1]
                                    _17835 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17835] = 30
                                    mem[_17835 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > -1:
                                            revert with 0, 17
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _18484 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _18484 + 68] = mem[idx + _17835 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18484 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _18484 + -mem[64] + 100
                                if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _13580 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13580] = 30
                                mem[_13580 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor6 / 1000 * 10^18:
                                    _13767 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13767 + 68] = mem[idx + _13580 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13767 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13767 + -mem[64] + 100
                                if arg2 * stor6 / 1000 * 10^18 < 0:
                                    revert with 0, 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _15453 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15453] = 30
                                mem[_15453 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                    _15979 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _15979 + 68] = mem[idx + _15453 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15979 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _15979 + -mem[64] + 100
                                if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                if stor1[arg1] > !(arg2 * stor6 / 1000 * 10^18):
                                    revert with 0, 17
                                if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18)
                                _19392 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19392] = 30
                                mem[_19392 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > -1:
                                        revert with 0, 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _19970 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _19970 + 68] = mem[idx + _19392 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19970 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _19970 + -mem[64] + 100
                            if t < stor6 / 1000 * 10^18:
                                if not arg2:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > -1:
                                        revert with 0, 17
                                    if stor1[arg1] < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1]
                                else:
                                    if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                                        revert with 0, 17
                                    if not arg2:
                                        revert with 0, 18
                                    if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 0 > arg2 * stor6 / 1000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * stor6 / 1000 * 10^18 < 0:
                                        revert with 0, 17
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor1[arg1] > !(arg2 * stor6 / 1000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18)
                            else:
                                if not s:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not arg2:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > -1:
                                        revert with 0, 17
                                    if stor1[arg1] < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1]
                                else:
                                    if arg2 and t / s > -1 / arg2:
                                        revert with 0, 17
                                    if not arg2:
                                        revert with 0, 18
                                    if arg2 * t / s / arg2 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 0 > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * t / s < 0:
                                        revert with 0, 17
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * t / s:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor1[arg1] > !(arg2 * t / s):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * t / s) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * t / s)
                            if 0 > stor6:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor6 < 0:
                                revert with 0, 17
                            if totalFees > -1:
                                revert with 0, 17
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(arg2, msg.sender, arg1);
                        else:
                            if arg2 / 100 and 5 > -1 / arg2 / 100:
                                revert with 0, 17
                            if not arg2 / 100:
                                revert with 0, 18
                            if 5 * arg2 / 100 / arg2 / 100 != 5:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if 5 * arg2 / 100 > arg2:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg2 < 5 * arg2 / 100:
                                revert with 0, 17
                            idx = 0
                            s = 1000 * 10^18
                            t = stor6
                            while idx < stor5.length:
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                if stor1[stor5[idx]] > t:
                                    _12320 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12320] = 26
                                    mem[_12320 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if not 5 * arg2 / 100:
                                            _13051 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_13051] = 30
                                            mem[_13051 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _13763 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_13763] = 30
                                            mem[_13763 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _14090 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _14090 + 68] = mem[idx + _13763 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_14090 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _14090 + -mem[64] + 100
                                            if stor1[address(msg.sender)] < 0:
                                                revert with 0, 17
                                            if stor1[arg1] > -1:
                                                revert with 0, 17
                                            if stor1[arg1] < stor1[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] = stor1[arg1]
                                            _17469 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_17469] = 30
                                            mem[_17469 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if stor6 < 0:
                                                    revert with 0, 17
                                                if totalFees > !(5 * arg2 / 100):
                                                    revert with 0, 17
                                                if totalFees + (5 * arg2 / 100) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += 5 * arg2 / 100
                                                emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                                return 1
                                            _17829 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _17829 + 68] = mem[idx + _17469 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_17829 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _17829 + -mem[64] + 100
                                        if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                            revert with 0, 17
                                        if not 5 * arg2 / 100:
                                            revert with 0, 18
                                        if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _13385 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13385] = 30
                                        mem[_13385 + 32] = 'SafeMath: subtraction overflow'
                                        if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > 0:
                                            _13576 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _13576 + 68] = mem[idx + _13385 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_13576 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _13576 + -mem[64] + 100
                                        if 0 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                            revert with 0, 17
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _14925 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_14925] = 30
                                        mem[_14925 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _15445 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _15445 + 68] = mem[idx + _14925 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_15445 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _15445 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > !(-5 * arg2 / 100 * stor6 / 1000 * 10^18):
                                            revert with 0, 17
                                        if stor1[arg1] - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[arg1] - (5 * arg2 / 100 * stor6 / 1000 * 10^18)
                                        _19065 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19065] = 30
                                        mem[_19065 + 32] = 'SafeMath: subtraction overflow'
                                        if 5 * arg2 / 100 * stor6 / 1000 * 10^18 <= stor6:
                                            if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                                revert with 0, 17
                                            stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                                            if totalFees > !(5 * arg2 / 100):
                                                revert with 0, 17
                                            if totalFees + (5 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 5 * arg2 / 100
                                            emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _19384 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19384 + 68] = mem[idx + _19065 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19384 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19384 + -mem[64] + 100
                                    if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                                        revert with 0, 17
                                    if not arg2:
                                        revert with 0, 18
                                    if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 5 * arg2 / 100:
                                        _13384 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13384] = 30
                                        mem[_13384 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor6 / 1000 * 10^18:
                                            _13575 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _13575 + 68] = mem[idx + _13384 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_13575 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _13575 + -mem[64] + 100
                                        if arg2 * stor6 / 1000 * 10^18 < 0:
                                            revert with 0, 17
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _14924 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_14924] = 30
                                        mem[_14924 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            _15444 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _15444 + 68] = mem[idx + _14924 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_15444 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _15444 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                            revert with 0, 17
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor1[arg1] > !(arg2 * stor6 / 1000 * 10^18):
                                            revert with 0, 17
                                        if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18)
                                        _19064 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19064] = 30
                                        mem[_19064 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > !(5 * arg2 / 100):
                                                revert with 0, 17
                                            if totalFees + (5 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 5 * arg2 / 100
                                            emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _19383 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19383 + 68] = mem[idx + _19064 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19383 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19383 + -mem[64] + 100
                                    if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                        revert with 0, 17
                                    if not 5 * arg2 / 100:
                                        revert with 0, 18
                                    if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _14089 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14089] = 30
                                    mem[_14089 + 32] = 'SafeMath: subtraction overflow'
                                    if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                        _14414 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _14414 + 68] = mem[idx + _14089 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14414 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14414 + -mem[64] + 100
                                    if arg2 * stor6 / 1000 * 10^18 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _16447 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16447] = 30
                                    mem[_16447 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        _17138 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _17138 + 68] = mem[idx + _16447 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17138 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _17138 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor1[arg1] > !((arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)
                                    _20391 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20391] = 30
                                    mem[_20391 + 32] = 'SafeMath: subtraction overflow'
                                    if 5 * arg2 / 100 * stor6 / 1000 * 10^18 <= stor6:
                                        if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                            revert with 0, 17
                                        stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                                        if totalFees > !(5 * arg2 / 100):
                                            revert with 0, 17
                                        if totalFees + (5 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 5 * arg2 / 100
                                        emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _20831 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20831 + 68] = mem[idx + _20391 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20831 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20831 + -mem[64] + 100
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                if stor2[stor5[idx]] <= s:
                                    if idx >= stor5.length:
                                        revert with 0, 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    _12430 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12430] = 30
                                    mem[_12430 + 32] = 'SafeMath: subtraction overflow'
                                    if stor1[stor5[idx]] > t:
                                        _12470 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _12470 + 68] = mem[idx + _12430 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_12470 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _12470 + -mem[64] + 100
                                    if t < stor1[stor5[idx]]:
                                        revert with 0, 17
                                    if idx >= stor5.length:
                                        revert with 0, 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    _12821 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12821] = 30
                                    mem[_12821 + 32] = 'SafeMath: subtraction overflow'
                                    if stor2[stor5[idx]] <= s:
                                        if s < stor2[stor5[idx]]:
                                            revert with 0, 17
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s - stor2[stor5[idx]]
                                        t = t - stor1[stor5[idx]]
                                        continue 
                                    _12881 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _12881 + 68] = mem[idx + _12821 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12881 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12881 + -mem[64] + 100
                                _12431 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12431] = 26
                                mem[_12431 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not 5 * arg2 / 100:
                                        _13181 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13181] = 30
                                        mem[_13181 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _14092 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_14092] = 30
                                        mem[_14092 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _14418 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _14418 + 68] = mem[idx + _14092 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_14418 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _14418 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > -1:
                                            revert with 0, 17
                                        if stor1[arg1] < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[arg1]
                                        _17831 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17831] = 30
                                        mem[_17831 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > !(5 * arg2 / 100):
                                                revert with 0, 17
                                            if totalFees + (5 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 5 * arg2 / 100
                                            emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _18471 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _18471 + 68] = mem[idx + _17831 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18471 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _18471 + -mem[64] + 100
                                    if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                        revert with 0, 17
                                    if not 5 * arg2 / 100:
                                        revert with 0, 18
                                    if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _13578 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13578] = 30
                                    mem[_13578 + 32] = 'SafeMath: subtraction overflow'
                                    if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > 0:
                                        _13765 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13765 + 68] = mem[idx + _13578 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13765 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13765 + -mem[64] + 100
                                    if 0 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _15448 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15448] = 30
                                    mem[_15448 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _15975 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _15975 + 68] = mem[idx + _15448 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_15975 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _15975 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > !(-5 * arg2 / 100 * stor6 / 1000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg1] - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1] - (5 * arg2 / 100 * stor6 / 1000 * 10^18)
                                    _19387 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19387] = 30
                                    mem[_19387 + 32] = 'SafeMath: subtraction overflow'
                                    if 5 * arg2 / 100 * stor6 / 1000 * 10^18 <= stor6:
                                        if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                            revert with 0, 17
                                        stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                                        if totalFees > !(5 * arg2 / 100):
                                            revert with 0, 17
                                        if totalFees + (5 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 5 * arg2 / 100
                                        emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _19964 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19964 + 68] = mem[idx + _19387 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19964 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19964 + -mem[64] + 100
                                if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 5 * arg2 / 100:
                                    _13577 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13577] = 30
                                    mem[_13577 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 1000 * 10^18:
                                        _13764 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13764 + 68] = mem[idx + _13577 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13764 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13764 + -mem[64] + 100
                                    if arg2 * stor6 / 1000 * 10^18 < 0:
                                        revert with 0, 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _15447 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15447] = 30
                                    mem[_15447 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        _15974 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _15974 + 68] = mem[idx + _15447 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_15974 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _15974 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor1[arg1] > !(arg2 * stor6 / 1000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18)
                                    _19386 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19386] = 30
                                    mem[_19386 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > !(5 * arg2 / 100):
                                            revert with 0, 17
                                        if totalFees + (5 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 5 * arg2 / 100
                                        emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _19963 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19963 + 68] = mem[idx + _19386 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19963 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19963 + -mem[64] + 100
                                if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                    revert with 0, 17
                                if not 5 * arg2 / 100:
                                    revert with 0, 18
                                if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _14417 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14417] = 30
                                mem[_14417 + 32] = 'SafeMath: subtraction overflow'
                                if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                    _14926 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _14926 + 68] = mem[idx + _14417 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14926 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14926 + -mem[64] + 100
                                if arg2 * stor6 / 1000 * 10^18 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                    revert with 0, 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _17141 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17141] = 30
                                mem[_17141 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                    _17646 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _17646 + 68] = mem[idx + _17141 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_17646 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _17646 + -mem[64] + 100
                                if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                if stor1[arg1] > !((arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)):
                                    revert with 0, 17
                                if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)
                                _20835 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20835] = 30
                                mem[_20835 + 32] = 'SafeMath: subtraction overflow'
                                if 5 * arg2 / 100 * stor6 / 1000 * 10^18 <= stor6:
                                    if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                                    if totalFees > !(5 * arg2 / 100):
                                        revert with 0, 17
                                    if totalFees + (5 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 5 * arg2 / 100
                                    emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _21264 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21264 + 68] = mem[idx + _20835 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21264 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21264 + -mem[64] + 100
                            if t < stor6 / 1000 * 10^18:
                                if not arg2:
                                    if not 5 * arg2 / 100:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > -1:
                                            revert with 0, 17
                                        if stor1[arg1] < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1]
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 0, 17
                                    else:
                                        if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                            revert with 0, 17
                                        if not 5 * arg2 / 100:
                                            revert with 0, 18
                                        if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if 0 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                            revert with 0, 17
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > !(-5 * arg2 / 100 * stor6 / 1000 * 10^18):
                                            revert with 0, 17
                                        if stor1[arg1] - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1] - (5 * arg2 / 100 * stor6 / 1000 * 10^18)
                                        if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                            revert with 0, 17
                                        stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                                else:
                                    if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                                        revert with 0, 17
                                    if not arg2:
                                        revert with 0, 18
                                    if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 5 * arg2 / 100:
                                        if 0 > arg2 * stor6 / 1000 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg2 * stor6 / 1000 * 10^18 < 0:
                                            revert with 0, 17
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                            revert with 0, 17
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor1[arg1] > !(arg2 * stor6 / 1000 * 10^18):
                                            revert with 0, 17
                                        if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18)
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 0, 17
                                    else:
                                        if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                            revert with 0, 17
                                        if not 5 * arg2 / 100:
                                            revert with 0, 18
                                        if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg2 * stor6 / 1000 * 10^18 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                            revert with 0, 17
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                            revert with 0, 17
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor1[arg1] > !((arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)):
                                            revert with 0, 17
                                        if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)
                                        if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                            revert with 0, 17
                                        stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                            else:
                                if not s:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not arg2:
                                    if not 5 * arg2 / 100:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > -1:
                                            revert with 0, 17
                                        if stor1[arg1] < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1]
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 0, 17
                                    else:
                                        if 5 * arg2 / 100 and t / s > -1 / 5 * arg2 / 100:
                                            revert with 0, 17
                                        if not 5 * arg2 / 100:
                                            revert with 0, 18
                                        if 5 * arg2 / 100 * t / s / 5 * arg2 / 100 != t / s:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if 5 * arg2 / 100 * t / s > 0:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if 0 < 5 * arg2 / 100 * t / s:
                                            revert with 0, 17
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > !(-5 * arg2 / 100 * t / s):
                                            revert with 0, 17
                                        if stor1[arg1] - (5 * arg2 / 100 * t / s) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1] - (5 * arg2 / 100 * t / s)
                                        if 5 * arg2 / 100 * t / s > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 5 * arg2 / 100 * t / s:
                                            revert with 0, 17
                                        stor6 += -5 * arg2 / 100 * t / s
                                else:
                                    if arg2 and t / s > -1 / arg2:
                                        revert with 0, 17
                                    if not arg2:
                                        revert with 0, 18
                                    if arg2 * t / s / arg2 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 5 * arg2 / 100:
                                        if 0 > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg2 * t / s < 0:
                                            revert with 0, 17
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < arg2 * t / s:
                                            revert with 0, 17
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor1[arg1] > !(arg2 * t / s):
                                            revert with 0, 17
                                        if stor1[arg1] + (arg2 * t / s) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1] + (arg2 * t / s)
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 0, 17
                                    else:
                                        if 5 * arg2 / 100 and t / s > -1 / 5 * arg2 / 100:
                                            revert with 0, 17
                                        if not 5 * arg2 / 100:
                                            revert with 0, 18
                                        if 5 * arg2 / 100 * t / s / 5 * arg2 / 100 != t / s:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if 5 * arg2 / 100 * t / s > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg2 * t / s < 5 * arg2 / 100 * t / s:
                                            revert with 0, 17
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < arg2 * t / s:
                                            revert with 0, 17
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor1[arg1] > !((arg2 * t / s) - (5 * arg2 / 100 * t / s)):
                                            revert with 0, 17
                                        if stor1[arg1] + (arg2 * t / s) - (5 * arg2 / 100 * t / s) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1] + (arg2 * t / s) - (5 * arg2 / 100 * t / s)
                                        if 5 * arg2 / 100 * t / s > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 5 * arg2 / 100 * t / s:
                                            revert with 0, 17
                                        stor6 += -5 * arg2 / 100 * t / s
                            if totalFees > !(5 * arg2 / 100):
                                revert with 0, 17
                            if totalFees + (5 * arg2 / 100) < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += 5 * arg2 / 100
                            emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                    else:
                        mem[0] = arg1
                        mem[32] = 4
                        mem[96] = 26
                        mem[128] = 'SafeMath: division by zero'
                        if stor4[address(arg1)]:
                            if not arg2 / 100:
                                mem[64] = 224
                                mem[160] = 30
                                mem[192] = 'SafeMath: subtraction overflow'
                                if 0 > arg2:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg2 < 0:
                                    revert with 0, 17
                                idx = 0
                                s = 1000 * 10^18
                                t = stor6
                                while idx < stor5.length:
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    if stor1[stor5[idx]] > t:
                                        _12323 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12323] = 26
                                        mem[_12323 + 32] = 'SafeMath: division by zero'
                                        if not arg2:
                                            _13060 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_13060] = 30
                                            mem[_13060 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _13774 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_13774] = 30
                                            mem[_13774 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _14107 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _14107 + 68] = mem[idx + _13774 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_14107 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _14107 + -mem[64] + 100
                                            if stor1[address(msg.sender)] < 0:
                                                revert with 0, 17
                                            if stor1[arg1] > -1:
                                                revert with 0, 17
                                            if stor1[arg1] < stor1[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] = stor1[arg1]
                                            _17504 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_17504] = 30
                                            mem[_17504 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if stor6 < 0:
                                                    revert with 0, 17
                                                if totalFees > -1:
                                                    revert with 0, 17
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit Transfer(arg2, msg.sender, arg1);
                                                return 1
                                            _17848 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _17848 + 68] = mem[idx + _17504 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_17848 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _17848 + -mem[64] + 100
                                        if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                                            revert with 0, 17
                                        if not arg2:
                                            revert with 0, 18
                                        if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _13403 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13403] = 30
                                        mem[_13403 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor6 / 1000 * 10^18:
                                            _13585 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _13585 + 68] = mem[idx + _13403 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_13585 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _13585 + -mem[64] + 100
                                        if arg2 * stor6 / 1000 * 10^18 < 0:
                                            revert with 0, 17
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _14944 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_14944] = 30
                                        mem[_14944 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            _15465 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _15465 + 68] = mem[idx + _14944 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_15465 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _15465 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                            revert with 0, 17
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor1[arg1] > !(arg2 * stor6 / 1000 * 10^18):
                                            revert with 0, 17
                                        if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18)
                                        _19093 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19093] = 30
                                        mem[_19093 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > -1:
                                                revert with 0, 17
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _19404 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19404 + 68] = mem[idx + _19093 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19404 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19404 + -mem[64] + 100
                                    if idx >= stor5.length:
                                        revert with 0, 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    if stor2[stor5[idx]] <= s:
                                        if idx >= stor5.length:
                                            revert with 0, 50
                                        mem[0] = stor5[idx]
                                        mem[32] = 1
                                        _12436 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12436] = 30
                                        mem[_12436 + 32] = 'SafeMath: subtraction overflow'
                                        if stor1[stor5[idx]] > t:
                                            _12473 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _12473 + 68] = mem[idx + _12436 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_12473 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _12473 + -mem[64] + 100
                                        if t < stor1[stor5[idx]]:
                                            revert with 0, 17
                                        if idx >= stor5.length:
                                            revert with 0, 50
                                        mem[0] = stor5[idx]
                                        mem[32] = 2
                                        _12827 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12827] = 30
                                        mem[_12827 + 32] = 'SafeMath: subtraction overflow'
                                        if stor2[stor5[idx]] <= s:
                                            if s < stor2[stor5[idx]]:
                                                revert with 0, 17
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            s = s - stor2[stor5[idx]]
                                            t = t - stor1[stor5[idx]]
                                            continue 
                                        _12887 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _12887 + 68] = mem[idx + _12827 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_12887 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _12887 + -mem[64] + 100
                                    _12437 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12437] = 26
                                    mem[_12437 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        _13187 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13187] = 30
                                        mem[_13187 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _14108 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_14108] = 30
                                        mem[_14108 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _14435 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _14435 + 68] = mem[idx + _14108 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_14435 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _14435 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > -1:
                                            revert with 0, 17
                                        if stor1[arg1] < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[arg1]
                                        _17849 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17849] = 30
                                        mem[_17849 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > -1:
                                                revert with 0, 17
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _18522 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _18522 + 68] = mem[idx + _17849 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18522 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _18522 + -mem[64] + 100
                                    if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                                        revert with 0, 17
                                    if not arg2:
                                        revert with 0, 18
                                    if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _13586 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13586] = 30
                                    mem[_13586 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 1000 * 10^18:
                                        _13775 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13775 + 68] = mem[idx + _13586 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13775 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13775 + -mem[64] + 100
                                    if arg2 * stor6 / 1000 * 10^18 < 0:
                                        revert with 0, 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _15467 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15467] = 30
                                    mem[_15467 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        _15993 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _15993 + 68] = mem[idx + _15467 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_15993 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _15993 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor1[arg1] > !(arg2 * stor6 / 1000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18)
                                    _19406 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19406] = 30
                                    mem[_19406 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > -1:
                                            revert with 0, 17
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _19995 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19995 + 68] = mem[idx + _19406 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19995 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19995 + -mem[64] + 100
                                if t < stor6 / 1000 * 10^18:
                                    if not arg2:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > -1:
                                            revert with 0, 17
                                        if stor1[arg1] < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1]
                                    else:
                                        if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                                            revert with 0, 17
                                        if not arg2:
                                            revert with 0, 18
                                        if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if 0 > arg2 * stor6 / 1000 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg2 * stor6 / 1000 * 10^18 < 0:
                                            revert with 0, 17
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                            revert with 0, 17
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor1[arg1] > !(arg2 * stor6 / 1000 * 10^18):
                                            revert with 0, 17
                                        if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18)
                                else:
                                    if not s:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not arg2:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > -1:
                                            revert with 0, 17
                                        if stor1[arg1] < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1]
                                    else:
                                        if arg2 and t / s > -1 / arg2:
                                            revert with 0, 17
                                        if not arg2:
                                            revert with 0, 18
                                        if arg2 * t / s / arg2 != t / s:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if 0 > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg2 * t / s < 0:
                                            revert with 0, 17
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < arg2 * t / s:
                                            revert with 0, 17
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor1[arg1] > !(arg2 * t / s):
                                            revert with 0, 17
                                        if stor1[arg1] + (arg2 * t / s) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1] + (arg2 * t / s)
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > -1:
                                    revert with 0, 17
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg2, msg.sender, arg1);
                            else:
                                if arg2 / 100 and 5 > -1 / arg2 / 100:
                                    revert with 0, 17
                                if not arg2 / 100:
                                    revert with 0, 18
                                if 5 * arg2 / 100 / arg2 / 100 != 5:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[64] = 224
                                mem[160] = 30
                                mem[192] = 'SafeMath: subtraction overflow'
                                if 5 * arg2 / 100 > arg2:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg2 < 5 * arg2 / 100:
                                    revert with 0, 17
                                idx = 0
                                s = 1000 * 10^18
                                t = stor6
                                while idx < stor5.length:
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    if stor1[stor5[idx]] > t:
                                        _12322 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12322] = 26
                                        mem[_12322 + 32] = 'SafeMath: division by zero'
                                        if not arg2:
                                            if not 5 * arg2 / 100:
                                                _13057 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_13057] = 30
                                                mem[_13057 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 1
                                                _13771 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_13771] = 30
                                                mem[_13771 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor1[address(msg.sender)]:
                                                    _14102 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _14102 + 68] = mem[idx + _13771 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_14102 + 98] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _14102 + -mem[64] + 100
                                                if stor1[address(msg.sender)] < 0:
                                                    revert with 0, 17
                                                if stor1[arg1] > -1:
                                                    revert with 0, 17
                                                if stor1[arg1] < stor1[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 1
                                                stor1[address(arg1)] = stor1[arg1]
                                                _17493 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_17493] = 30
                                                mem[_17493 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor6:
                                                    if stor6 < 0:
                                                        revert with 0, 17
                                                    if totalFees > !(5 * arg2 / 100):
                                                        revert with 0, 17
                                                    if totalFees + (5 * arg2 / 100) < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += 5 * arg2 / 100
                                                    emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                                    return 1
                                                _17843 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _17843 + 68] = mem[idx + _17493 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_17843 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _17843 + -mem[64] + 100
                                            if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                                revert with 0, 17
                                            if not 5 * arg2 / 100:
                                                revert with 0, 18
                                            if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _13397 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_13397] = 30
                                            mem[_13397 + 32] = 'SafeMath: subtraction overflow'
                                            if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > 0:
                                                _13582 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _13582 + 68] = mem[idx + _13397 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_13582 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _13582 + -mem[64] + 100
                                            if 0 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                                revert with 0, 17
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _14938 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_14938] = 30
                                            mem[_14938 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _15459 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _15459 + 68] = mem[idx + _14938 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_15459 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _15459 + -mem[64] + 100
                                            if stor1[address(msg.sender)] < 0:
                                                revert with 0, 17
                                            if stor1[arg1] > !(-5 * arg2 / 100 * stor6 / 1000 * 10^18):
                                                revert with 0, 17
                                            if stor1[arg1] - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] = stor1[arg1] - (5 * arg2 / 100 * stor6 / 1000 * 10^18)
                                            _19083 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_19083] = 30
                                            mem[_19083 + 32] = 'SafeMath: subtraction overflow'
                                            if 5 * arg2 / 100 * stor6 / 1000 * 10^18 <= stor6:
                                                if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                                    revert with 0, 17
                                                stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                                                if totalFees > !(5 * arg2 / 100):
                                                    revert with 0, 17
                                                if totalFees + (5 * arg2 / 100) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += 5 * arg2 / 100
                                                emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                                return 1
                                            _19398 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _19398 + 68] = mem[idx + _19083 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_19398 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _19398 + -mem[64] + 100
                                        if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                                            revert with 0, 17
                                        if not arg2:
                                            revert with 0, 18
                                        if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not 5 * arg2 / 100:
                                            _13396 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_13396] = 30
                                            mem[_13396 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > arg2 * stor6 / 1000 * 10^18:
                                                _13581 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _13581 + 68] = mem[idx + _13396 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_13581 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _13581 + -mem[64] + 100
                                            if arg2 * stor6 / 1000 * 10^18 < 0:
                                                revert with 0, 17
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _14937 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_14937] = 30
                                            mem[_14937 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                _15458 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _15458 + 68] = mem[idx + _14937 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_15458 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _15458 + -mem[64] + 100
                                            if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                                revert with 0, 17
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                            if stor1[arg1] > !(arg2 * stor6 / 1000 * 10^18):
                                                revert with 0, 17
                                            if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18)
                                            _19082 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_19082] = 30
                                            mem[_19082 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if stor6 < 0:
                                                    revert with 0, 17
                                                if totalFees > !(5 * arg2 / 100):
                                                    revert with 0, 17
                                                if totalFees + (5 * arg2 / 100) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += 5 * arg2 / 100
                                                emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                                return 1
                                            _19397 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _19397 + 68] = mem[idx + _19082 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_19397 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _19397 + -mem[64] + 100
                                        if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                            revert with 0, 17
                                        if not 5 * arg2 / 100:
                                            revert with 0, 18
                                        if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _14101 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_14101] = 30
                                        mem[_14101 + 32] = 'SafeMath: subtraction overflow'
                                        if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                            _14427 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _14427 + 68] = mem[idx + _14101 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_14427 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _14427 + -mem[64] + 100
                                        if arg2 * stor6 / 1000 * 10^18 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                            revert with 0, 17
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _16457 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16457] = 30
                                        mem[_16457 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            _17155 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _17155 + 68] = mem[idx + _16457 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_17155 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _17155 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                            revert with 0, 17
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor1[arg1] > !((arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)):
                                            revert with 0, 17
                                        if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)
                                        _20402 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_20402] = 30
                                        mem[_20402 + 32] = 'SafeMath: subtraction overflow'
                                        if 5 * arg2 / 100 * stor6 / 1000 * 10^18 <= stor6:
                                            if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                                revert with 0, 17
                                            stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                                            if totalFees > !(5 * arg2 / 100):
                                                revert with 0, 17
                                            if totalFees + (5 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 5 * arg2 / 100
                                            emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _20850 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20850 + 68] = mem[idx + _20402 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20850 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20850 + -mem[64] + 100
                                    if idx >= stor5.length:
                                        revert with 0, 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    if stor2[stor5[idx]] <= s:
                                        if idx >= stor5.length:
                                            revert with 0, 50
                                        mem[0] = stor5[idx]
                                        mem[32] = 1
                                        _12434 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12434] = 30
                                        mem[_12434 + 32] = 'SafeMath: subtraction overflow'
                                        if stor1[stor5[idx]] > t:
                                            _12472 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _12472 + 68] = mem[idx + _12434 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_12472 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _12472 + -mem[64] + 100
                                        if t < stor1[stor5[idx]]:
                                            revert with 0, 17
                                        if idx >= stor5.length:
                                            revert with 0, 50
                                        mem[0] = stor5[idx]
                                        mem[32] = 2
                                        _12825 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12825] = 30
                                        mem[_12825 + 32] = 'SafeMath: subtraction overflow'
                                        if stor2[stor5[idx]] <= s:
                                            if s < stor2[stor5[idx]]:
                                                revert with 0, 17
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            s = s - stor2[stor5[idx]]
                                            t = t - stor1[stor5[idx]]
                                            continue 
                                        _12885 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _12885 + 68] = mem[idx + _12825 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_12885 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _12885 + -mem[64] + 100
                                    _12435 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12435] = 26
                                    mem[_12435 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if not 5 * arg2 / 100:
                                            _13185 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_13185] = 30
                                            mem[_13185 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _14104 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_14104] = 30
                                            mem[_14104 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _14431 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _14431 + 68] = mem[idx + _14104 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_14431 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _14431 + -mem[64] + 100
                                            if stor1[address(msg.sender)] < 0:
                                                revert with 0, 17
                                            if stor1[arg1] > -1:
                                                revert with 0, 17
                                            if stor1[arg1] < stor1[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] = stor1[arg1]
                                            _17845 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_17845] = 30
                                            mem[_17845 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if stor6 < 0:
                                                    revert with 0, 17
                                                if totalFees > !(5 * arg2 / 100):
                                                    revert with 0, 17
                                                if totalFees + (5 * arg2 / 100) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += 5 * arg2 / 100
                                                emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                                return 1
                                            _18509 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _18509 + 68] = mem[idx + _17845 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_18509 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _18509 + -mem[64] + 100
                                        if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                            revert with 0, 17
                                        if not 5 * arg2 / 100:
                                            revert with 0, 18
                                        if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _13584 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13584] = 30
                                        mem[_13584 + 32] = 'SafeMath: subtraction overflow'
                                        if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > 0:
                                            _13773 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _13773 + 68] = mem[idx + _13584 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_13773 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _13773 + -mem[64] + 100
                                        if 0 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                            revert with 0, 17
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _15462 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_15462] = 30
                                        mem[_15462 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _15989 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _15989 + 68] = mem[idx + _15462 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_15989 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _15989 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > !(-5 * arg2 / 100 * stor6 / 1000 * 10^18):
                                            revert with 0, 17
                                        if stor1[arg1] - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[arg1] - (5 * arg2 / 100 * stor6 / 1000 * 10^18)
                                        _19401 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19401] = 30
                                        mem[_19401 + 32] = 'SafeMath: subtraction overflow'
                                        if 5 * arg2 / 100 * stor6 / 1000 * 10^18 <= stor6:
                                            if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                                revert with 0, 17
                                            stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                                            if totalFees > !(5 * arg2 / 100):
                                                revert with 0, 17
                                            if totalFees + (5 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 5 * arg2 / 100
                                            emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _19989 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19989 + 68] = mem[idx + _19401 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19989 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19989 + -mem[64] + 100
                                    if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                                        revert with 0, 17
                                    if not arg2:
                                        revert with 0, 18
                                    if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 5 * arg2 / 100:
                                        _13583 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13583] = 30
                                        mem[_13583 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor6 / 1000 * 10^18:
                                            _13772 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _13772 + 68] = mem[idx + _13583 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_13772 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _13772 + -mem[64] + 100
                                        if arg2 * stor6 / 1000 * 10^18 < 0:
                                            revert with 0, 17
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _15461 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_15461] = 30
                                        mem[_15461 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            _15988 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _15988 + 68] = mem[idx + _15461 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_15988 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _15988 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                            revert with 0, 17
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor1[arg1] > !(arg2 * stor6 / 1000 * 10^18):
                                            revert with 0, 17
                                        if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18)
                                        _19400 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19400] = 30
                                        mem[_19400 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > !(5 * arg2 / 100):
                                                revert with 0, 17
                                            if totalFees + (5 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 5 * arg2 / 100
                                            emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _19988 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19988 + 68] = mem[idx + _19400 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19988 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19988 + -mem[64] + 100
                                    if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                        revert with 0, 17
                                    if not 5 * arg2 / 100:
                                        revert with 0, 18
                                    if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _14430 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14430] = 30
                                    mem[_14430 + 32] = 'SafeMath: subtraction overflow'
                                    if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                        _14939 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _14939 + 68] = mem[idx + _14430 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14939 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14939 + -mem[64] + 100
                                    if arg2 * stor6 / 1000 * 10^18 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _17158 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17158] = 30
                                    mem[_17158 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        _17652 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _17652 + 68] = mem[idx + _17158 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17652 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _17652 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor1[arg1] > !((arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)
                                    _20854 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20854] = 30
                                    mem[_20854 + 32] = 'SafeMath: subtraction overflow'
                                    if 5 * arg2 / 100 * stor6 / 1000 * 10^18 <= stor6:
                                        if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                            revert with 0, 17
                                        stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                                        if totalFees > !(5 * arg2 / 100):
                                            revert with 0, 17
                                        if totalFees + (5 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 5 * arg2 / 100
                                        emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _21274 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21274 + 68] = mem[idx + _20854 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21274 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21274 + -mem[64] + 100
                                if t < stor6 / 1000 * 10^18:
                                    if not arg2:
                                        if not 5 * arg2 / 100:
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor1[address(msg.sender)] < 0:
                                                revert with 0, 17
                                            if stor1[arg1] > -1:
                                                revert with 0, 17
                                            if stor1[arg1] < stor1[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] = stor1[arg1]
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor6 < 0:
                                                revert with 0, 17
                                        else:
                                            if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                                revert with 0, 17
                                            if not 5 * arg2 / 100:
                                                revert with 0, 18
                                            if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > 0:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if 0 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                                revert with 0, 17
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor1[address(msg.sender)] < 0:
                                                revert with 0, 17
                                            if stor1[arg1] > !(-5 * arg2 / 100 * stor6 / 1000 * 10^18):
                                                revert with 0, 17
                                            if stor1[arg1] - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] = stor1[arg1] - (5 * arg2 / 100 * stor6 / 1000 * 10^18)
                                            if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                                revert with 0, 17
                                            stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                                    else:
                                        if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                                            revert with 0, 17
                                        if not arg2:
                                            revert with 0, 18
                                        if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not 5 * arg2 / 100:
                                            if 0 > arg2 * stor6 / 1000 * 10^18:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if arg2 * stor6 / 1000 * 10^18 < 0:
                                                revert with 0, 17
                                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                                revert with 0, 17
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                            if stor1[arg1] > !(arg2 * stor6 / 1000 * 10^18):
                                                revert with 0, 17
                                            if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18)
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor6 < 0:
                                                revert with 0, 17
                                        else:
                                            if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                                revert with 0, 17
                                            if not 5 * arg2 / 100:
                                                revert with 0, 18
                                            if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if arg2 * stor6 / 1000 * 10^18 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                                revert with 0, 17
                                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                                revert with 0, 17
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                            if stor1[arg1] > !((arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)):
                                                revert with 0, 17
                                            if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)
                                            if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                                revert with 0, 17
                                            stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                                else:
                                    if not s:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not arg2:
                                        if not 5 * arg2 / 100:
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor1[address(msg.sender)] < 0:
                                                revert with 0, 17
                                            if stor1[arg1] > -1:
                                                revert with 0, 17
                                            if stor1[arg1] < stor1[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] = stor1[arg1]
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor6 < 0:
                                                revert with 0, 17
                                        else:
                                            if 5 * arg2 / 100 and t / s > -1 / 5 * arg2 / 100:
                                                revert with 0, 17
                                            if not 5 * arg2 / 100:
                                                revert with 0, 18
                                            if 5 * arg2 / 100 * t / s / 5 * arg2 / 100 != t / s:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if 5 * arg2 / 100 * t / s > 0:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if 0 < 5 * arg2 / 100 * t / s:
                                                revert with 0, 17
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor1[address(msg.sender)] < 0:
                                                revert with 0, 17
                                            if stor1[arg1] > !(-5 * arg2 / 100 * t / s):
                                                revert with 0, 17
                                            if stor1[arg1] - (5 * arg2 / 100 * t / s) < stor1[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] = stor1[arg1] - (5 * arg2 / 100 * t / s)
                                            if 5 * arg2 / 100 * t / s > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor6 < 5 * arg2 / 100 * t / s:
                                                revert with 0, 17
                                            stor6 += -5 * arg2 / 100 * t / s
                                    else:
                                        if arg2 and t / s > -1 / arg2:
                                            revert with 0, 17
                                        if not arg2:
                                            revert with 0, 18
                                        if arg2 * t / s / arg2 != t / s:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not 5 * arg2 / 100:
                                            if 0 > arg2 * t / s:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if arg2 * t / s < 0:
                                                revert with 0, 17
                                            if arg2 * t / s > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor1[address(msg.sender)] < arg2 * t / s:
                                                revert with 0, 17
                                            stor1[address(msg.sender)] += -1 * arg2 * t / s
                                            if stor1[arg1] > !(arg2 * t / s):
                                                revert with 0, 17
                                            if stor1[arg1] + (arg2 * t / s) < stor1[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] = stor1[arg1] + (arg2 * t / s)
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor6 < 0:
                                                revert with 0, 17
                                        else:
                                            if 5 * arg2 / 100 and t / s > -1 / 5 * arg2 / 100:
                                                revert with 0, 17
                                            if not 5 * arg2 / 100:
                                                revert with 0, 18
                                            if 5 * arg2 / 100 * t / s / 5 * arg2 / 100 != t / s:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if 5 * arg2 / 100 * t / s > arg2 * t / s:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if arg2 * t / s < 5 * arg2 / 100 * t / s:
                                                revert with 0, 17
                                            if arg2 * t / s > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor1[address(msg.sender)] < arg2 * t / s:
                                                revert with 0, 17
                                            stor1[address(msg.sender)] += -1 * arg2 * t / s
                                            if stor1[arg1] > !((arg2 * t / s) - (5 * arg2 / 100 * t / s)):
                                                revert with 0, 17
                                            if stor1[arg1] + (arg2 * t / s) - (5 * arg2 / 100 * t / s) < stor1[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] = stor1[arg1] + (arg2 * t / s) - (5 * arg2 / 100 * t / s)
                                            if 5 * arg2 / 100 * t / s > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor6 < 5 * arg2 / 100 * t / s:
                                                revert with 0, 17
                                            stor6 += -5 * arg2 / 100 * t / s
                                if totalFees > !(5 * arg2 / 100):
                                    revert with 0, 17
                                if totalFees + (5 * arg2 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 5 * arg2 / 100
                                emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                        else:
                            if not arg2 / 100:
                                mem[64] = 224
                                mem[160] = 30
                                mem[192] = 'SafeMath: subtraction overflow'
                                if 0 > arg2:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg2 < 0:
                                    revert with 0, 17
                                idx = 0
                                s = 1000 * 10^18
                                t = stor6
                                while idx < stor5.length:
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    if stor1[stor5[idx]] > t:
                                        _12325 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12325] = 26
                                        mem[_12325 + 32] = 'SafeMath: division by zero'
                                        if not arg2:
                                            _13066 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_13066] = 30
                                            mem[_13066 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _13782 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_13782] = 30
                                            mem[_13782 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _14119 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _14119 + 68] = mem[idx + _13782 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_14119 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _14119 + -mem[64] + 100
                                            if stor1[address(msg.sender)] < 0:
                                                revert with 0, 17
                                            if stor1[arg1] > -1:
                                                revert with 0, 17
                                            if stor1[arg1] < stor1[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] = stor1[arg1]
                                            _17528 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_17528] = 30
                                            mem[_17528 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if stor6 < 0:
                                                    revert with 0, 17
                                                if totalFees > -1:
                                                    revert with 0, 17
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit Transfer(arg2, msg.sender, arg1);
                                                return 1
                                            _17862 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _17862 + 68] = mem[idx + _17528 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_17862 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _17862 + -mem[64] + 100
                                        if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                                            revert with 0, 17
                                        if not arg2:
                                            revert with 0, 18
                                        if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _13415 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13415] = 30
                                        mem[_13415 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor6 / 1000 * 10^18:
                                            _13591 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _13591 + 68] = mem[idx + _13415 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_13591 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _13591 + -mem[64] + 100
                                        if arg2 * stor6 / 1000 * 10^18 < 0:
                                            revert with 0, 17
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _14957 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_14957] = 30
                                        mem[_14957 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            _15479 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _15479 + 68] = mem[idx + _14957 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_15479 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _15479 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                            revert with 0, 17
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor1[arg1] > !(arg2 * stor6 / 1000 * 10^18):
                                            revert with 0, 17
                                        if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18)
                                        _19111 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19111] = 30
                                        mem[_19111 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > -1:
                                                revert with 0, 17
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _19418 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19418 + 68] = mem[idx + _19111 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19418 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19418 + -mem[64] + 100
                                    if idx >= stor5.length:
                                        revert with 0, 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    if stor2[stor5[idx]] <= s:
                                        if idx >= stor5.length:
                                            revert with 0, 50
                                        mem[0] = stor5[idx]
                                        mem[32] = 1
                                        _12440 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12440] = 30
                                        mem[_12440 + 32] = 'SafeMath: subtraction overflow'
                                        if stor1[stor5[idx]] > t:
                                            _12475 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _12475 + 68] = mem[idx + _12440 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_12475 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _12475 + -mem[64] + 100
                                        if t < stor1[stor5[idx]]:
                                            revert with 0, 17
                                        if idx >= stor5.length:
                                            revert with 0, 50
                                        mem[0] = stor5[idx]
                                        mem[32] = 2
                                        _12831 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12831] = 30
                                        mem[_12831 + 32] = 'SafeMath: subtraction overflow'
                                        if stor2[stor5[idx]] <= s:
                                            if s < stor2[stor5[idx]]:
                                                revert with 0, 17
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            s = s - stor2[stor5[idx]]
                                            t = t - stor1[stor5[idx]]
                                            continue 
                                        _12891 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _12891 + 68] = mem[idx + _12831 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_12891 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _12891 + -mem[64] + 100
                                    _12441 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12441] = 26
                                    mem[_12441 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        _13191 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13191] = 30
                                        mem[_13191 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _14120 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_14120] = 30
                                        mem[_14120 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _14448 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _14448 + 68] = mem[idx + _14120 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_14448 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _14448 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > -1:
                                            revert with 0, 17
                                        if stor1[arg1] < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[arg1]
                                        _17863 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17863] = 30
                                        mem[_17863 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > -1:
                                                revert with 0, 17
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _18560 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _18560 + 68] = mem[idx + _17863 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18560 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _18560 + -mem[64] + 100
                                    if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                                        revert with 0, 17
                                    if not arg2:
                                        revert with 0, 18
                                    if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _13592 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13592] = 30
                                    mem[_13592 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 1000 * 10^18:
                                        _13783 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13783 + 68] = mem[idx + _13592 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13783 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13783 + -mem[64] + 100
                                    if arg2 * stor6 / 1000 * 10^18 < 0:
                                        revert with 0, 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _15481 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15481] = 30
                                    mem[_15481 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        _16007 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _16007 + 68] = mem[idx + _15481 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_16007 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _16007 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor1[arg1] > !(arg2 * stor6 / 1000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18)
                                    _19420 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19420] = 30
                                    mem[_19420 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > -1:
                                            revert with 0, 17
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _20020 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20020 + 68] = mem[idx + _19420 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20020 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20020 + -mem[64] + 100
                                if t < stor6 / 1000 * 10^18:
                                    if not arg2:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > -1:
                                            revert with 0, 17
                                        if stor1[arg1] < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1]
                                    else:
                                        if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                                            revert with 0, 17
                                        if not arg2:
                                            revert with 0, 18
                                        if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if 0 > arg2 * stor6 / 1000 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg2 * stor6 / 1000 * 10^18 < 0:
                                            revert with 0, 17
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                            revert with 0, 17
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor1[arg1] > !(arg2 * stor6 / 1000 * 10^18):
                                            revert with 0, 17
                                        if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18)
                                else:
                                    if not s:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not arg2:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > -1:
                                            revert with 0, 17
                                        if stor1[arg1] < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1]
                                    else:
                                        if arg2 and t / s > -1 / arg2:
                                            revert with 0, 17
                                        if not arg2:
                                            revert with 0, 18
                                        if arg2 * t / s / arg2 != t / s:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if 0 > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg2 * t / s < 0:
                                            revert with 0, 17
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < arg2 * t / s:
                                            revert with 0, 17
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor1[arg1] > !(arg2 * t / s):
                                            revert with 0, 17
                                        if stor1[arg1] + (arg2 * t / s) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1] + (arg2 * t / s)
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > -1:
                                    revert with 0, 17
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg2, msg.sender, arg1);
                            else:
                                if arg2 / 100 and 5 > -1 / arg2 / 100:
                                    revert with 0, 17
                                if not arg2 / 100:
                                    revert with 0, 18
                                if 5 * arg2 / 100 / arg2 / 100 != 5:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[64] = 224
                                mem[160] = 30
                                mem[192] = 'SafeMath: subtraction overflow'
                                if 5 * arg2 / 100 > arg2:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg2 < 5 * arg2 / 100:
                                    revert with 0, 17
                                idx = 0
                                s = 1000 * 10^18
                                t = stor6
                                while idx < stor5.length:
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    if stor1[stor5[idx]] > t:
                                        _12324 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12324] = 26
                                        mem[_12324 + 32] = 'SafeMath: division by zero'
                                        if not arg2:
                                            if not 5 * arg2 / 100:
                                                _13063 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_13063] = 30
                                                mem[_13063 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 1
                                                _13779 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_13779] = 30
                                                mem[_13779 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor1[address(msg.sender)]:
                                                    _14114 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _14114 + 68] = mem[idx + _13779 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_14114 + 98] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _14114 + -mem[64] + 100
                                                if stor1[address(msg.sender)] < 0:
                                                    revert with 0, 17
                                                if stor1[arg1] > -1:
                                                    revert with 0, 17
                                                if stor1[arg1] < stor1[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 1
                                                stor1[address(arg1)] = stor1[arg1]
                                                _17517 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_17517] = 30
                                                mem[_17517 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor6:
                                                    if stor6 < 0:
                                                        revert with 0, 17
                                                    if totalFees > !(5 * arg2 / 100):
                                                        revert with 0, 17
                                                    if totalFees + (5 * arg2 / 100) < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += 5 * arg2 / 100
                                                    emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                                    return 1
                                                _17857 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _17857 + 68] = mem[idx + _17517 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_17857 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _17857 + -mem[64] + 100
                                            if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                                revert with 0, 17
                                            if not 5 * arg2 / 100:
                                                revert with 0, 18
                                            if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _13409 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_13409] = 30
                                            mem[_13409 + 32] = 'SafeMath: subtraction overflow'
                                            if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > 0:
                                                _13588 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _13588 + 68] = mem[idx + _13409 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_13588 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _13588 + -mem[64] + 100
                                            if 0 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                                revert with 0, 17
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _14951 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_14951] = 30
                                            mem[_14951 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _15473 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _15473 + 68] = mem[idx + _14951 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_15473 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _15473 + -mem[64] + 100
                                            if stor1[address(msg.sender)] < 0:
                                                revert with 0, 17
                                            if stor1[arg1] > !(-5 * arg2 / 100 * stor6 / 1000 * 10^18):
                                                revert with 0, 17
                                            if stor1[arg1] - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] = stor1[arg1] - (5 * arg2 / 100 * stor6 / 1000 * 10^18)
                                            _19101 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_19101] = 30
                                            mem[_19101 + 32] = 'SafeMath: subtraction overflow'
                                            if 5 * arg2 / 100 * stor6 / 1000 * 10^18 <= stor6:
                                                if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                                    revert with 0, 17
                                                stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                                                if totalFees > !(5 * arg2 / 100):
                                                    revert with 0, 17
                                                if totalFees + (5 * arg2 / 100) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += 5 * arg2 / 100
                                                emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                                return 1
                                            _19412 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _19412 + 68] = mem[idx + _19101 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_19412 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _19412 + -mem[64] + 100
                                        if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                                            revert with 0, 17
                                        if not arg2:
                                            revert with 0, 18
                                        if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not 5 * arg2 / 100:
                                            _13408 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_13408] = 30
                                            mem[_13408 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > arg2 * stor6 / 1000 * 10^18:
                                                _13587 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _13587 + 68] = mem[idx + _13408 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_13587 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _13587 + -mem[64] + 100
                                            if arg2 * stor6 / 1000 * 10^18 < 0:
                                                revert with 0, 17
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _14950 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_14950] = 30
                                            mem[_14950 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                _15472 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _15472 + 68] = mem[idx + _14950 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_15472 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _15472 + -mem[64] + 100
                                            if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                                revert with 0, 17
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                            if stor1[arg1] > !(arg2 * stor6 / 1000 * 10^18):
                                                revert with 0, 17
                                            if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18)
                                            _19100 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_19100] = 30
                                            mem[_19100 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if stor6 < 0:
                                                    revert with 0, 17
                                                if totalFees > !(5 * arg2 / 100):
                                                    revert with 0, 17
                                                if totalFees + (5 * arg2 / 100) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += 5 * arg2 / 100
                                                emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                                return 1
                                            _19411 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _19411 + 68] = mem[idx + _19100 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_19411 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _19411 + -mem[64] + 100
                                        if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                            revert with 0, 17
                                        if not 5 * arg2 / 100:
                                            revert with 0, 18
                                        if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _14113 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_14113] = 30
                                        mem[_14113 + 32] = 'SafeMath: subtraction overflow'
                                        if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                            _14440 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _14440 + 68] = mem[idx + _14113 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_14440 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _14440 + -mem[64] + 100
                                        if arg2 * stor6 / 1000 * 10^18 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                            revert with 0, 17
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _16467 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16467] = 30
                                        mem[_16467 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            _17172 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _17172 + 68] = mem[idx + _16467 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_17172 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _17172 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                            revert with 0, 17
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor1[arg1] > !((arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)):
                                            revert with 0, 17
                                        if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)
                                        _20413 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_20413] = 30
                                        mem[_20413 + 32] = 'SafeMath: subtraction overflow'
                                        if 5 * arg2 / 100 * stor6 / 1000 * 10^18 <= stor6:
                                            if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                                revert with 0, 17
                                            stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                                            if totalFees > !(5 * arg2 / 100):
                                                revert with 0, 17
                                            if totalFees + (5 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 5 * arg2 / 100
                                            emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _20869 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20869 + 68] = mem[idx + _20413 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20869 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20869 + -mem[64] + 100
                                    if idx >= stor5.length:
                                        revert with 0, 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    if stor2[stor5[idx]] <= s:
                                        if idx >= stor5.length:
                                            revert with 0, 50
                                        mem[0] = stor5[idx]
                                        mem[32] = 1
                                        _12438 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12438] = 30
                                        mem[_12438 + 32] = 'SafeMath: subtraction overflow'
                                        if stor1[stor5[idx]] > t:
                                            _12474 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _12474 + 68] = mem[idx + _12438 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_12474 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _12474 + -mem[64] + 100
                                        if t < stor1[stor5[idx]]:
                                            revert with 0, 17
                                        if idx >= stor5.length:
                                            revert with 0, 50
                                        mem[0] = stor5[idx]
                                        mem[32] = 2
                                        _12829 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12829] = 30
                                        mem[_12829 + 32] = 'SafeMath: subtraction overflow'
                                        if stor2[stor5[idx]] <= s:
                                            if s < stor2[stor5[idx]]:
                                                revert with 0, 17
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            s = s - stor2[stor5[idx]]
                                            t = t - stor1[stor5[idx]]
                                            continue 
                                        _12889 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _12889 + 68] = mem[idx + _12829 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_12889 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _12889 + -mem[64] + 100
                                    _12439 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12439] = 26
                                    mem[_12439 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if not 5 * arg2 / 100:
                                            _13189 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_13189] = 30
                                            mem[_13189 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _14116 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_14116] = 30
                                            mem[_14116 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _14444 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _14444 + 68] = mem[idx + _14116 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_14444 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _14444 + -mem[64] + 100
                                            if stor1[address(msg.sender)] < 0:
                                                revert with 0, 17
                                            if stor1[arg1] > -1:
                                                revert with 0, 17
                                            if stor1[arg1] < stor1[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] = stor1[arg1]
                                            _17859 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_17859] = 30
                                            mem[_17859 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if stor6 < 0:
                                                    revert with 0, 17
                                                if totalFees > !(5 * arg2 / 100):
                                                    revert with 0, 17
                                                if totalFees + (5 * arg2 / 100) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += 5 * arg2 / 100
                                                emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                                return 1
                                            _18547 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _18547 + 68] = mem[idx + _17859 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_18547 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _18547 + -mem[64] + 100
                                        if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                            revert with 0, 17
                                        if not 5 * arg2 / 100:
                                            revert with 0, 18
                                        if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _13590 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13590] = 30
                                        mem[_13590 + 32] = 'SafeMath: subtraction overflow'
                                        if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > 0:
                                            _13781 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _13781 + 68] = mem[idx + _13590 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_13781 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _13781 + -mem[64] + 100
                                        if 0 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                            revert with 0, 17
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _15476 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_15476] = 30
                                        mem[_15476 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _16003 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _16003 + 68] = mem[idx + _15476 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_16003 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _16003 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > !(-5 * arg2 / 100 * stor6 / 1000 * 10^18):
                                            revert with 0, 17
                                        if stor1[arg1] - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[arg1] - (5 * arg2 / 100 * stor6 / 1000 * 10^18)
                                        _19415 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19415] = 30
                                        mem[_19415 + 32] = 'SafeMath: subtraction overflow'
                                        if 5 * arg2 / 100 * stor6 / 1000 * 10^18 <= stor6:
                                            if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                                revert with 0, 17
                                            stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                                            if totalFees > !(5 * arg2 / 100):
                                                revert with 0, 17
                                            if totalFees + (5 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 5 * arg2 / 100
                                            emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _20014 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20014 + 68] = mem[idx + _19415 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20014 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20014 + -mem[64] + 100
                                    if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                                        revert with 0, 17
                                    if not arg2:
                                        revert with 0, 18
                                    if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 5 * arg2 / 100:
                                        _13589 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13589] = 30
                                        mem[_13589 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor6 / 1000 * 10^18:
                                            _13780 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _13780 + 68] = mem[idx + _13589 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_13780 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _13780 + -mem[64] + 100
                                        if arg2 * stor6 / 1000 * 10^18 < 0:
                                            revert with 0, 17
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _15475 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_15475] = 30
                                        mem[_15475 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                            _16002 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _16002 + 68] = mem[idx + _15475 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_16002 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _16002 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                            revert with 0, 17
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                        if stor1[arg1] > !(arg2 * stor6 / 1000 * 10^18):
                                            revert with 0, 17
                                        if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18)
                                        _19414 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19414] = 30
                                        mem[_19414 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > !(5 * arg2 / 100):
                                                revert with 0, 17
                                            if totalFees + (5 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 5 * arg2 / 100
                                            emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _20013 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20013 + 68] = mem[idx + _19414 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20013 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20013 + -mem[64] + 100
                                    if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                        revert with 0, 17
                                    if not 5 * arg2 / 100:
                                        revert with 0, 18
                                    if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _14443 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14443] = 30
                                    mem[_14443 + 32] = 'SafeMath: subtraction overflow'
                                    if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                        _14952 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _14952 + 68] = mem[idx + _14443 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14952 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14952 + -mem[64] + 100
                                    if arg2 * stor6 / 1000 * 10^18 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _17175 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17175] = 30
                                    mem[_17175 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                        _17658 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _17658 + 68] = mem[idx + _17175 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17658 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _17658 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                    if stor1[arg1] > !((arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)
                                    _20873 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20873] = 30
                                    mem[_20873 + 32] = 'SafeMath: subtraction overflow'
                                    if 5 * arg2 / 100 * stor6 / 1000 * 10^18 <= stor6:
                                        if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                            revert with 0, 17
                                        stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                                        if totalFees > !(5 * arg2 / 100):
                                            revert with 0, 17
                                        if totalFees + (5 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 5 * arg2 / 100
                                        emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _21284 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21284 + 68] = mem[idx + _20873 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21284 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21284 + -mem[64] + 100
                                if t < stor6 / 1000 * 10^18:
                                    if not arg2:
                                        if not 5 * arg2 / 100:
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor1[address(msg.sender)] < 0:
                                                revert with 0, 17
                                            if stor1[arg1] > -1:
                                                revert with 0, 17
                                            if stor1[arg1] < stor1[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] = stor1[arg1]
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor6 < 0:
                                                revert with 0, 17
                                        else:
                                            if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                                revert with 0, 17
                                            if not 5 * arg2 / 100:
                                                revert with 0, 18
                                            if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > 0:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if 0 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                                revert with 0, 17
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor1[address(msg.sender)] < 0:
                                                revert with 0, 17
                                            if stor1[arg1] > !(-5 * arg2 / 100 * stor6 / 1000 * 10^18):
                                                revert with 0, 17
                                            if stor1[arg1] - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] = stor1[arg1] - (5 * arg2 / 100 * stor6 / 1000 * 10^18)
                                            if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                                revert with 0, 17
                                            stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                                    else:
                                        if arg2 and stor6 / 1000 * 10^18 > -1 / arg2:
                                            revert with 0, 17
                                        if not arg2:
                                            revert with 0, 18
                                        if arg2 * stor6 / 1000 * 10^18 / arg2 != stor6 / 1000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not 5 * arg2 / 100:
                                            if 0 > arg2 * stor6 / 1000 * 10^18:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if arg2 * stor6 / 1000 * 10^18 < 0:
                                                revert with 0, 17
                                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                                revert with 0, 17
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                            if stor1[arg1] > !(arg2 * stor6 / 1000 * 10^18):
                                                revert with 0, 17
                                            if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18)
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor6 < 0:
                                                revert with 0, 17
                                        else:
                                            if 5 * arg2 / 100 and stor6 / 1000 * 10^18 > -1 / 5 * arg2 / 100:
                                                revert with 0, 17
                                            if not 5 * arg2 / 100:
                                                revert with 0, 18
                                            if 5 * arg2 / 100 * stor6 / 1000 * 10^18 / 5 * arg2 / 100 != stor6 / 1000 * 10^18:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > arg2 * stor6 / 1000 * 10^18:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if arg2 * stor6 / 1000 * 10^18 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                                revert with 0, 17
                                            if arg2 * stor6 / 1000 * 10^18 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor1[address(msg.sender)] < arg2 * stor6 / 1000 * 10^18:
                                                revert with 0, 17
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 1000 * 10^18
                                            if stor1[arg1] > !((arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)):
                                                revert with 0, 17
                                            if stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18) < stor1[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 1000 * 10^18) - (5 * arg2 / 100 * stor6 / 1000 * 10^18)
                                            if 5 * arg2 / 100 * stor6 / 1000 * 10^18 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor6 < 5 * arg2 / 100 * stor6 / 1000 * 10^18:
                                                revert with 0, 17
                                            stor6 += -5 * arg2 / 100 * stor6 / 1000 * 10^18
                                else:
                                    if not s:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not arg2:
                                        if not 5 * arg2 / 100:
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor1[address(msg.sender)] < 0:
                                                revert with 0, 17
                                            if stor1[arg1] > -1:
                                                revert with 0, 17
                                            if stor1[arg1] < stor1[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] = stor1[arg1]
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor6 < 0:
                                                revert with 0, 17
                                        else:
                                            if 5 * arg2 / 100 and t / s > -1 / 5 * arg2 / 100:
                                                revert with 0, 17
                                            if not 5 * arg2 / 100:
                                                revert with 0, 18
                                            if 5 * arg2 / 100 * t / s / 5 * arg2 / 100 != t / s:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if 5 * arg2 / 100 * t / s > 0:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if 0 < 5 * arg2 / 100 * t / s:
                                                revert with 0, 17
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor1[address(msg.sender)] < 0:
                                                revert with 0, 17
                                            if stor1[arg1] > !(-5 * arg2 / 100 * t / s):
                                                revert with 0, 17
                                            if stor1[arg1] - (5 * arg2 / 100 * t / s) < stor1[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] = stor1[arg1] - (5 * arg2 / 100 * t / s)
                                            if 5 * arg2 / 100 * t / s > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor6 < 5 * arg2 / 100 * t / s:
                                                revert with 0, 17
                                            stor6 += -5 * arg2 / 100 * t / s
                                    else:
                                        if arg2 and t / s > -1 / arg2:
                                            revert with 0, 17
                                        if not arg2:
                                            revert with 0, 18
                                        if arg2 * t / s / arg2 != t / s:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not 5 * arg2 / 100:
                                            if 0 > arg2 * t / s:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if arg2 * t / s < 0:
                                                revert with 0, 17
                                            if arg2 * t / s > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor1[address(msg.sender)] < arg2 * t / s:
                                                revert with 0, 17
                                            stor1[address(msg.sender)] += -1 * arg2 * t / s
                                            if stor1[arg1] > !(arg2 * t / s):
                                                revert with 0, 17
                                            if stor1[arg1] + (arg2 * t / s) < stor1[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] = stor1[arg1] + (arg2 * t / s)
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor6 < 0:
                                                revert with 0, 17
                                        else:
                                            if 5 * arg2 / 100 and t / s > -1 / 5 * arg2 / 100:
                                                revert with 0, 17
                                            if not 5 * arg2 / 100:
                                                revert with 0, 18
                                            if 5 * arg2 / 100 * t / s / 5 * arg2 / 100 != t / s:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if 5 * arg2 / 100 * t / s > arg2 * t / s:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if arg2 * t / s < 5 * arg2 / 100 * t / s:
                                                revert with 0, 17
                                            if arg2 * t / s > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor1[address(msg.sender)] < arg2 * t / s:
                                                revert with 0, 17
                                            stor1[address(msg.sender)] += -1 * arg2 * t / s
                                            if stor1[arg1] > !((arg2 * t / s) - (5 * arg2 / 100 * t / s)):
                                                revert with 0, 17
                                            if stor1[arg1] + (arg2 * t / s) - (5 * arg2 / 100 * t / s) < stor1[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] = stor1[arg1] + (arg2 * t / s) - (5 * arg2 / 100 * t / s)
                                            if 5 * arg2 / 100 * t / s > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor6 < 5 * arg2 / 100 * t / s:
                                                revert with 0, 17
                                            stor6 += -5 * arg2 / 100 * t / s
                                if totalFees > !(5 * arg2 / 100):
                                    revert with 0, 17
                                if totalFees + (5 * arg2 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 5 * arg2 / 100
                                emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
    return 1
}



}

contract main {




// =====================  Runtime code  =====================


#
#  - settle()
#  - sub_6d421704(?)
#  - sub_d3661474(?)
#  - sub_dde2eb41(?)
#
const sub_7d2a3803(?) = block.number


address owner;
uint256 stor1;
uint256 stor2;
uint256 sub_cb8cd2ce;
uint256 sub_c577eca1;
uint256 sub_365d99e8;
address lpTokenAddress;
address sub_d8158fd7Address;
address sub_b2fef9b5Address;
address sub_0382016aAddress;
uint256 sub_2434ee80;
uint256 sub_0dff03b8;
uint256 sub_ba3d2e1a;
mapping of uint256 sub_7d0ae073;
mapping of uint256 sub_e96ad276;
mapping of uint256 sub_3173ed27;
mapping of uint256 sub_a9e65351;
mapping of uint256 sub_651145ca;
mapping of uint256 sub_66bfc168;
mapping of uint256 sub_8eaf1ff2;
mapping of uint8 stor21;
array of struct sub_f0ae89d5;
mapping of uint256 sub_e389fcdf;
mapping of uint256 sub_3ddff1d4;
mapping of uint256 sub_fcca3012;
mapping of uint256 sub_7337fd70;
mapping of uint256 sub_c180bead;
mapping of uint256 sub_49d58cab;
mapping of uint256 sub_1b2acd6b;
mapping of uint256 sub_dceb927f;
mapping of uint256 sub_30b8bed2;
array of struct claimList;
mapping of uint256 sub_480a4262;
mapping of uint256 profit;
array of address stor35;
address stor36;
address stor37;
address stor38;
array of uint256 stor96560257906823366609687653797478744522194140651868327126155761560509877273136;

function sub_0382016a(?) payable {
    return sub_0382016aAddress
}

function sub_0dff03b8(?) payable {
    return sub_0dff03b8
}

function sub_1b2acd6b(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    return sub_1b2acd6b[arg1]
}

function sub_2434ee80(?) payable {
    return sub_2434ee80
}

function sub_30b8bed2(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    return sub_30b8bed2[arg1]
}

function sub_3173ed27(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    return sub_3173ed27[arg1]
}

function sub_365d99e8(?) payable {
    return sub_365d99e8
}

function sub_3ddff1d4(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    return sub_3ddff1d4[arg1]
}

function sub_480a4262(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    return sub_480a4262[address(arg1)]
}

function sub_49d58cab(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    return sub_49d58cab[arg1]
}

function sub_4afc9640(?) payable {
    return sub_49d58cab[msg.sender]
}

function lpToken() payable {
    return lpTokenAddress
}

function claimList(address arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 < claimList[arg1].field_0
    return claimList[arg1][arg2].field_0, claimList[arg1][arg2].field_256, claimList[arg1][arg2].field_512
}

function sub_651145ca(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    return sub_651145ca[arg1]
}

function sub_66bfc168(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    return sub_66bfc168[arg1]
}

function sub_68cda032(?) payable {
    return sub_1b2acd6b[msg.sender]
}

function sub_7337fd70(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    return sub_7337fd70[arg1]
}

function sub_7d0ae073(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    return sub_7d0ae073[arg1]
}

function owner() payable {
    return owner
}

function sub_8eaf1ff2(?) payable {
    return sub_8eaf1ff2[msg.sender]
}

function sub_8f91616d(?) payable {
    return sub_3173ed27[msg.sender]
}

function getTotalAddresses() payable {
    return stor35.length
}

function sub_a9e65351(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    return sub_a9e65351[arg1]
}

function sub_b2fef9b5(?) payable {
    return sub_b2fef9b5Address
}

function sub_ba0ac3d4(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    return sub_8eaf1ff2[arg1]
}

function sub_ba3d2e1a(?) payable {
    return sub_ba3d2e1a
}

function sub_c180bead(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    return sub_c180bead[arg1]
}

function sub_c577eca1(?) payable {
    return sub_c577eca1
}

function getProfit(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return profit[address(arg1)]
}

function hasStaked(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return bool(stor21[arg1])
}

function sub_cb8cd2ce(?) payable {
    return sub_cb8cd2ce
}

function sub_d8158fd7(?) payable {
    return sub_d8158fd7Address
}

function sub_dceb927f(?) payable {
    return sub_dceb927f[msg.sender]
}

function sub_e389fcdf(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    return sub_e389fcdf[arg1]
}

function sub_e96ad276(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    return sub_e96ad276[arg1]
}

function sub_e97b4e9f(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    return profit[arg1]
}

function sub_f0ae89d5(?) payable {
    require calldata.size - 4 >= 64
    require arg1 == address(arg1)
    require arg2 < sub_f0ae89d5[arg1].field_0
    return sub_f0ae89d5[arg1][arg2].field_0, 
           sub_f0ae89d5[arg1][arg2].field_256,
           sub_f0ae89d5[arg1][arg2].field_512,
           sub_f0ae89d5[arg1][arg2].field_768,
           sub_f0ae89d5[arg1][arg2].field_1024,
           bool(sub_f0ae89d5[arg1][arg2].field_1280)
}

function sub_f8b0ffca(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    return sub_480a4262[arg1]
}

function sub_fc88afa3(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    return sub_dceb927f[arg1]
}

function sub_fcca3012(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    return sub_fcca3012[arg1]
}

function _fallback() payable {
    revert
}

function sub_b302165a(?) payable {
    if not sub_7d0ae073[msg.sender]:
        revert with 0, 18
    return (sub_e96ad276[msg.sender] / sub_7d0ae073[msg.sender])
}

function renounceOwnership() payable {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    owner = 0
    emit OwnershipTransferred(owner, 0);
}

function sub_dfc23e4f(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    if stor38 != msg.sender:
        revert with 0, 'Unauthorized address'
    if not address(arg1):
        revert with 0, 'Invalid address'
    stor37 = address(arg1)
}

function sub_ef82f3a2(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    if stor38 != msg.sender:
        revert with 0, 'Unauthorized address'
    if not address(arg1):
        revert with 0, 'Invalid address'
    stor36 = address(arg1)
}

function setLpTokenAddress(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not arg1:
        revert with 0, 'Invalid address'
    lpTokenAddress = arg1
}

function sub_b87eef52(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not address(arg1):
        revert with 0, 'Invalid address'
    stor38 = address(arg1)
}

function sub_5be524d9(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not address(arg1):
        revert with 0, 'Invalid address'
    sub_0382016aAddress = address(arg1)
}

function sub_9b756315(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not address(arg1):
        revert with 0, 'Invalid address'
    sub_d8158fd7Address = address(arg1)
}

function sub_f9e1cd0c(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not address(arg1):
        revert with 0, 'Invalid address'
    sub_b2fef9b5Address = address(arg1)
}

function sub_f53fa3b7(?) payable {
    require calldata.size - 4 >= 32
    if not arg1:
        return 0
    if arg1 <= 0:
        if arg1 < 20:
            return 5
    else:
        if arg1 < 20:
            return 1
    ('ge', ('param', 'arg1'), 20)
    if arg1 < 40:
        return 2
    if arg1 < 60:
        return 3
    if arg1 >= 80:
        return 5
    return 4
}

function sub_369ec387(?) payable {
    require calldata.size - 4 >= 32
    if not arg1:
        return 0
    if arg1 <= 0:
        if arg1 < 20:
            return 25
    else:
        if arg1 < 20:
            return 5
    ('ge', ('param', 'arg1'), 20)
    if arg1 < 40:
        return 10
    if arg1 < 60:
        return 15
    if arg1 >= 80:
        return 25
    return 20
}

function transferOwnership(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Ownable: new owner is the zero address'
    owner = arg1
    emit OwnershipTransferred(owner, arg1);
}

function sub_4a7f7771(?) payable {
    require calldata.size - 4 >= 32
    if stor37 != msg.sender:
        revert with 0, 'Unauthorized address'
    if arg1 > 500:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'MaxScore can't be larger than 500'
    if stor1 > arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'MaxScore can't be smaller than minScore'
    stor2 = arg1
}

function setMinScore(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if stor37 != msg.sender:
        revert with 0, 'Unauthorized address'
    if arg1 < 20:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'MinScore can't be smaller than 10'
    if arg1 > stor2:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'MinScore can't be larger than maxScore'
    stor1 = arg1
}

function sub_8452fbfb(?) payable {
    require calldata.size - 4 >= 32
    if stor37 != msg.sender:
        revert with 0, 'Unauthorized address'
    if arg1 > 10 * 10^18:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ClaimPerBlock can't be larger than 10'
    if arg1 < 10^18:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ClaimPerBlock can't be smaller than 1'
    sub_cb8cd2ce = arg1
}

function claim(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if sub_480a4262[msg.sender] < arg1:
        revert with 0, 'Not enough APL'
    require ext_code.size(sub_0382016aAddress)
    call sub_0382016aAddress.0xa9059cbb with:
         gas gas_remaining wei
        args msg.sender, arg1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if profit[msg.sender] > !arg1:
        revert with 0, 17
    profit[msg.sender] += arg1
    if sub_480a4262[msg.sender] < arg1:
        revert with 0, 17
    sub_480a4262[msg.sender] -= arg1
    claimList[msg.sender].field_0++
    claimList[msg.sender][claimList[msg.sender].field_0].field_0 = block.timestamp
    claimList[msg.sender][claimList[msg.sender].field_0].field_256 = block.number
    claimList[msg.sender][claimList[msg.sender].field_0].field_512 = arg1
}

function sub_484db7ef(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    mem[0] = address(arg1)
    mem[32] = 32
    mem[64] = (32 * claimList[address(arg1)].field_0) + 128
    mem[96] = claimList[address(arg1)].field_0
    s = 128
    idx = 0
    while idx < claimList[address(arg1)].field_0:
        mem[0] = sha3(address(arg1), 32)
        _13 = mem[64]
        mem[64] = mem[64] + 96
        mem[_13] = claimList[address(arg1)][idx].field_0
        mem[_13 + 32] = claimList[address(arg1)][idx].field_256
        mem[_13 + 64] = claimList[address(arg1)][idx].field_512
        mem[s] = _13
        s = s + 32
        idx = idx + 1
        continue 
    _14 = mem[64]
    mem[mem[64]] = 32
    _15 = mem[96]
    mem[mem[64] + 32] = mem[96]
    idx = 0
    s = 128
    t = mem[64] + 64
    while idx < _15:
        _21 = mem[s]
        mem[t] = mem[mem[s]]
        mem[t + 32] = mem[_21 + 32]
        mem[t + 64] = mem[_21 + 64]
        idx = idx + 1
        s = s + 32
        t = t + 96
        continue 
    return memory
      from mem[64]
       len _14 + (96 * _15) + -mem[64] + 64
}

function sub_e6e7f762(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    mem[0] = address(arg1)
    mem[32] = 22
    mem[64] = (32 * sub_f0ae89d5[address(arg1)].field_0) + 128
    mem[96] = sub_f0ae89d5[address(arg1)].field_0
    s = 128
    idx = 0
    while idx < sub_f0ae89d5[address(arg1)].field_0:
        mem[0] = sha3(address(arg1), 22)
        _16 = mem[64]
        mem[64] = mem[64] + 192
        mem[_16] = sub_f0ae89d5[address(arg1)][idx].field_0
        mem[_16 + 32] = sub_f0ae89d5[address(arg1)][idx].field_256
        mem[_16 + 64] = sub_f0ae89d5[address(arg1)][idx].field_512
        mem[_16 + 96] = sub_f0ae89d5[address(arg1)][idx].field_768
        mem[_16 + 128] = sub_f0ae89d5[address(arg1)][idx].field_1024
        mem[_16 + 160] = bool(sub_f0ae89d5[address(arg1)][idx].field_1280)
        mem[s] = _16
        s = s + 32
        idx = idx + 1
        continue 
    _17 = mem[64]
    mem[mem[64]] = 32
    _18 = mem[96]
    mem[mem[64] + 32] = mem[96]
    idx = 0
    s = 128
    t = mem[64] + 64
    while idx < _18:
        _27 = mem[s]
        mem[t] = mem[mem[s]]
        mem[t + 32] = mem[_27 + 32]
        mem[t + 64] = mem[_27 + 64]
        mem[t + 96] = mem[_27 + 96]
        mem[t + 128] = mem[_27 + 128]
        mem[t + 160] = bool(mem[_27 + 160])
        idx = idx + 1
        s = s + 32
        t = t + 192
        continue 
    return memory
      from mem[64]
       len _17 + (192 * _18) + -mem[64] + 64
}

function sub_171b1104(?) payable {
    idx = 0
    s = 0
    while idx < stor35.length:
        mem[0] = stor35[idx]
        mem[32] = 25
        if s > !sub_fcca3012[stor35[idx]]:
            revert with 0, 17
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        s = s + sub_fcca3012[stor35[idx]]
        continue 
    return (s * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length)
}

function sub_f6e3430a(?) payable {
    idx = 0
    s = 0
    while idx < stor35.length:
        mem[0] = stor35[idx]
        mem[32] = 19
        if s > !sub_66bfc168[stor35[idx]]:
            revert with 0, 17
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        s = s + sub_66bfc168[stor35[idx]]
        continue 
    return (s * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length)
}

function sub_aff04a33(?) payable {
    idx = 0
    s = 0
    while idx < stor35.length:
        if s > !sub_c180bead[stor35[idx]]:
            revert with 0, 17
        if idx >= stor35.length:
            revert with 0, 50
        mem[0] = stor35[idx]
        mem[32] = 26
        if s + sub_c180bead[stor35[idx]] > !sub_7337fd70[stor35[idx]]:
            revert with 0, 17
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        s = s + sub_c180bead[stor35[idx]] + sub_7337fd70[stor35[idx]]
        continue 
    return (s * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length * stor35.length)
}

function deposit(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if arg1 <= 0:
        revert with 0, 'Invalid staking amount'
    require ext_code.size(lpTokenAddress)
    call lpTokenAddress.0x23b872dd with:
         gas gas_remaining wei
        args msg.sender, this.address, arg1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    require ext_code.size(sub_d8158fd7Address)
    call sub_d8158fd7Address.0xa9059cbb with:
         gas gas_remaining wei
        args msg.sender, arg1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    require ext_code.size(sub_b2fef9b5Address)
    call sub_b2fef9b5Address.0xa9059cbb with:
         gas gas_remaining wei
        args msg.sender, arg1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
    if stor21[msg.sender]:
        if sub_a9e65351[msg.sender] > !arg1:
            revert with 0, 17
        sub_a9e65351[msg.sender] += arg1
        if sub_3173ed27[msg.sender] > !arg1:
            revert with 0, 17
        sub_3173ed27[msg.sender] += arg1
        if sub_651145ca[msg.sender] > !arg1:
            revert with 0, 17
        sub_651145ca[msg.sender] += arg1
    else:
        sub_a9e65351[msg.sender] = arg1
        sub_8eaf1ff2[msg.sender] = 100
        stor21[msg.sender] = 1
        stor35.length++
        storD57B[stor35.length] = msg.sender or Mask(96, 160, storD57B[stor35.length])
        sub_3173ed27[msg.sender] = arg1
        sub_651145ca[msg.sender] = arg1
    sub_f0ae89d5[msg.sender].field_0++
    sub_f0ae89d5[msg.sender][sub_f0ae89d5[msg.sender].field_0].field_0 = block.timestamp
    sub_f0ae89d5[msg.sender][sub_f0ae89d5[msg.sender].field_0].field_256 = block.timestamp
    sub_f0ae89d5[msg.sender][sub_f0ae89d5[msg.sender].field_0].field_512 = block.number
    sub_f0ae89d5[msg.sender][sub_f0ae89d5[msg.sender].field_0].field_768 = block.number
    sub_f0ae89d5[msg.sender][sub_f0ae89d5[msg.sender].field_0].field_1024 = arg1
    sub_f0ae89d5[msg.sender][sub_f0ae89d5[msg.sender].field_0].field_1280 = 1
}

function sub_b9169aa2(?) payable {
    mem[64] = (32 * sub_f0ae89d5[msg.sender].field_0) + 128
    mem[96] = sub_f0ae89d5[msg.sender].field_0
    s = 128
    idx = 0
    while idx < sub_f0ae89d5[msg.sender].field_0:
        mem[0] = sha3(msg.sender, 22)
        _14 = mem[64]
        mem[64] = mem[64] + 192
        mem[_14] = sub_f0ae89d5[msg.sender][idx].field_0
        mem[_14 + 32] = sub_f0ae89d5[msg.sender][idx].field_256
        mem[_14 + 64] = sub_f0ae89d5[msg.sender][idx].field_512
        mem[_14 + 96] = sub_f0ae89d5[msg.sender][idx].field_768
        mem[_14 + 128] = sub_f0ae89d5[msg.sender][idx].field_1024
        mem[_14 + 160] = bool(sub_f0ae89d5[msg.sender][idx].field_1280)
        mem[s] = _14
        s = s + 32
        idx = idx + 1
        continue 
    idx = 0
    s = 0
    while idx < mem[96]:
        if idx >= mem[96]:
            revert with 0, 50
        if block.number < mem[mem[(32 * idx) + 128] + 96]:
            revert with 0, 17
        if s > !(block.number - mem[mem[(32 * idx) + 128] + 96]):
            revert with 0, 17
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        s = s + block.number - mem[mem[(32 * idx) + 128] + 96]
        continue 
    if s * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] and sub_7d0ae073[msg.sender] > -1 / s * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96]:
        revert with 0, 17
    if not sub_e96ad276[msg.sender]:
        revert with 0, 18
    mem[mem[64]] = s * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * mem[96] * sub_7d0ae073[msg.sender] / sub_e96ad276[msg.sender]
    return memory
      from mem[64]
       len 32
}

function withdraw(uint256 arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    if arg1 <= 0:
        revert with 0, 'Invalid unstaking amount'
    if arg2 >= sub_f0ae89d5[msg.sender].field_0:
        revert with 0, 50
    if arg1 > sub_f0ae89d5[msg.sender][arg2].field_1024:
        revert with 0, 'Not enough lp token'
    require ext_code.size(sub_d8158fd7Address)
    staticcall sub_d8158fd7Address.0x70a08231 with:
            gas gas_remaining wei
           args msg.sender
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_code.size(sub_b2fef9b5Address)
    staticcall sub_b2fef9b5Address.0x70a08231 with:
            gas gas_remaining wei
           args msg.sender
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_code.size(lpTokenAddress)
    if arg1 <= ext_call.return_data[0]:
        call lpTokenAddress.0xa9059cbb with:
             gas gas_remaining wei
            args msg.sender, arg1
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == bool(ext_call.return_data[0])
        require ext_code.size(sub_d8158fd7Address)
        call sub_d8158fd7Address.0x23b872dd with:
             gas gas_remaining wei
            args msg.sender, this.address, arg1
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == bool(ext_call.return_data[0])
        require ext_code.size(sub_b2fef9b5Address)
        call sub_b2fef9b5Address.0x23b872dd with:
             gas gas_remaining wei
            args msg.sender, this.address, arg1
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == bool(ext_call.return_data[0])
        if sub_3173ed27[msg.sender] < arg1:
            revert with 0, 17
        sub_3173ed27[msg.sender] -= arg1
        if arg2 >= sub_f0ae89d5[msg.sender].field_0:
            revert with 0, 50
        if arg2 >= sub_f0ae89d5[msg.sender].field_0:
            revert with 0, 50
        if sub_f0ae89d5[msg.sender][arg2].field_1024 != arg1:
            if sub_f0ae89d5[msg.sender][arg2].field_1024 < arg1:
                revert with 0, 17
            if arg2 >= sub_f0ae89d5[msg.sender].field_0:
                revert with 0, 50
            sub_f0ae89d5[msg.sender][arg2].field_1024 -= arg1
        else:
            if block.number < sub_f0ae89d5[msg.sender][arg2].field_768:
                revert with 0, 17
            if sub_e389fcdf[msg.sender] > !(block.number - sub_f0ae89d5[msg.sender][arg2].field_768):
                revert with 0, 17
            sub_e389fcdf[msg.sender] = sub_e389fcdf[msg.sender] + block.number - sub_f0ae89d5[msg.sender][arg2].field_768
            if arg2 >= sub_f0ae89d5[msg.sender].field_0:
                revert with 0, 50
            sub_f0ae89d5[msg.sender][arg2].field_1280 = 0
            if sub_3ddff1d4[msg.sender] > -2:
                revert with 0, 17
            sub_3ddff1d4[msg.sender]++
        if sub_a9e65351[msg.sender] < arg1:
            revert with 0, 17
        sub_a9e65351[msg.sender] -= arg1
    else:
        call lpTokenAddress.0xa9059cbb with:
             gas gas_remaining wei
            args msg.sender, ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == bool(ext_call.return_data[0])
        require ext_code.size(sub_d8158fd7Address)
        call sub_d8158fd7Address.0x23b872dd with:
             gas gas_remaining wei
            args msg.sender, this.address, ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == bool(ext_call.return_data[0])
        require ext_code.size(sub_b2fef9b5Address)
        call sub_b2fef9b5Address.0x23b872dd with:
             gas gas_remaining wei
            args msg.sender, this.address, ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == bool(ext_call.return_data[0])
        if sub_3173ed27[msg.sender] < ext_call.return_data[0]:
            revert with 0, 17
        sub_3173ed27[msg.sender] -= ext_call.return_data[0]
        if arg2 >= sub_f0ae89d5[msg.sender].field_0:
            revert with 0, 50
        if arg2 >= sub_f0ae89d5[msg.sender].field_0:
            revert with 0, 50
        if sub_f0ae89d5[msg.sender][arg2].field_1024 != ext_call.return_data[0]:
            if sub_f0ae89d5[msg.sender][arg2].field_1024 < ext_call.return_data[0]:
                revert with 0, 17
            if arg2 >= sub_f0ae89d5[msg.sender].field_0:
                revert with 0, 50
            sub_f0ae89d5[msg.sender][arg2].field_1024 -= ext_call.return_data[0]
        else:
            if block.number < sub_f0ae89d5[msg.sender][arg2].field_768:
                revert with 0, 17
            if sub_e389fcdf[msg.sender] > !(block.number - sub_f0ae89d5[msg.sender][arg2].field_768):
                revert with 0, 17
            sub_e389fcdf[msg.sender] = sub_e389fcdf[msg.sender] + block.number - sub_f0ae89d5[msg.sender][arg2].field_768
            if arg2 >= sub_f0ae89d5[msg.sender].field_0:
                revert with 0, 50
            sub_f0ae89d5[msg.sender][arg2].field_1280 = 0
            if sub_3ddff1d4[msg.sender] > -2:
                revert with 0, 17
            sub_3ddff1d4[msg.sender]++
        if sub_a9e65351[msg.sender] < ext_call.return_data[0]:
            revert with 0, 17
        sub_a9e65351[msg.sender] -= ext_call.return_data[0]
    if sub_7337fd70[msg.sender] > -2:
        revert with 0, 17
    sub_7337fd70[msg.sender]++
}



}

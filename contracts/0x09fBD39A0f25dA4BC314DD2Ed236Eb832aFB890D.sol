contract main {




// =====================  Runtime code  =====================


#
#  - pendingReward(address arg1)
#
address owner;
array of address stor1;
uint256 unlockTime;
uint256 stor3;
mapping of uint256 balanceOf;
mapping of uint256 allowance;
uint256 totalSupply;
array of uint256 name;
array of uint256 symbol;
uint8 decimals;
uint8 stor9; offset 168
uint8 stor9; offset 176
uint8 stor9; offset 184
uint128 stor9; offset 176
uint128 stor9; offset 168
address sub_197046f4Address; offset 8
mapping of uint256 accTokenPerShare;
uint256 stakingBlock;
uint256 stakingEndBlock;
uint256 unStakingBlock;
uint256 unStakingFee;
uint256 feePeriod;
address feeCollectorAddress;
uint256 bonusEndBlock;
uint256 startBlock;
uint256 lastRewardBlock;
uint256 poolLimitPerUser;
uint256 poolCap;
uint256 totalStaked;
uint8 stor23;
mapping of uint256 rewardPerBlock;
mapping of uint256 pRECISION_FACTOR;
array of struct rewardTokens;
address stakedTokenAddress;
mapping of struct lastStakingBlock;
uint8 sub_c7b01a97;
array of struct sub_ea73c96d;
uint256 sub_cea8c746;
array of address stor2481041784956016742021570618494952475758789857281704946240779902470294861374;

function getLastStakingBlock(address arg1) payable {
    require calldata.size - 4 >= 32
    return uint256(lastStakingBlock[address(arg1)].field_256)
}

function name() payable {
    return name[0 len name.length]
}

function stakingEndBlock() payable {
    return stakingEndBlock
}

function rewardPerBlock(address arg1) payable {
    require calldata.size - 4 >= 32
    return rewardPerBlock[arg1]
}

function getFeeCollector() payable {
    return feeCollectorAddress
}

function totalSupply() payable {
    return totalSupply
}

function PRECISION_FACTOR(address arg1) payable {
    require calldata.size - 4 >= 32
    return pRECISION_FACTOR[arg1]
}

function unStakingBlock() payable {
    return unStakingBlock
}

function userInfo(address arg1) payable {
    require calldata.size - 4 >= 32
    return uint256(lastStakingBlock[arg1].field_0), uint256(lastStakingBlock[arg1].field_256)
}

function sub_197046f4(?) payable {
    return sub_197046f4Address
}

function bonusEndBlock() payable {
    return bonusEndBlock
}

function decimals() payable {
    return decimals
}

function isInitialized() payable {
    return bool(uint8(stor9.field_184))
}

function stakingBlock() payable {
    return stakingBlock
}

function feePeriod() payable {
    return feePeriod
}

function startBlock() payable {
    return startBlock
}

function getUnlockTime() payable {
    return unlockTime
}

function poolLimitPerUser() payable {
    return poolLimitPerUser
}

function accTokenPerShare(address arg1) payable {
    require calldata.size - 4 >= 32
    return accTokenPerShare[arg1]
}

function balanceOf(address arg1) payable {
    require calldata.size - 4 >= 32
    return balanceOf[address(arg1)]
}

function rewardTokens(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 < rewardTokens.length
    return rewardTokens[arg1].field_0
}

function totalStaked() payable {
    return totalStaked
}

function owner() payable {
    return owner
}

function hasUserLimit() payable {
    return bool(uint8(stor9.field_168))
}

function symbol() payable {
    return symbol[0 len symbol.length]
}

function hasPoolLimit() payable {
    return bool(uint8(stor9.field_176))
}

function lastRewardBlock() payable {
    return lastRewardBlock
}

function getStakingEndBlock() payable {
    return stakingEndBlock
}

function poolCap() payable {
    return poolCap
}

function getUnStakingFee() payable {
    return unStakingFee
}

function feeCollector() payable {
    return feeCollectorAddress
}

function sub_c7b01a97(?) payable {
    return bool(sub_c7b01a97)
}

function stakedToken() payable {
    return stakedTokenAddress
}

function sub_cea8c746(?) payable {
    return sub_cea8c746
}

function allowance(address arg1, address arg2) payable {
    require calldata.size - 4 >= 64
    return allowance[address(arg1)][address(arg2)]
}

function getFeePeriod() payable {
    return feePeriod
}

function unStakingFee() payable {
    return unStakingFee
}

function sub_ea73c96d(?) payable {
    require calldata.size - 4 >= 32
    idx = 0
    s = 0
    while idx < uint256(sub_ea73c96d[address(arg1)].field_0):
        mem[0] = arg1
        mem[32] = 30
        idx = idx + 1
        s = s + 1
        continue 
    return uint256(sub_ea73c96d[address(arg1)].field_0)
}

function getUserDebtByToken(address arg1, address arg2) payable {
    require calldata.size - 4 >= 64
    return uint256(lastStakingBlock[address(arg1)][2][address(arg2)].field_0)
}

function sub_fd35f8fe(?) payable {
    require calldata.size - 4 >= 64
    require arg2 < uint256(sub_ea73c96d[arg1].field_0)
    return sub_ea73c96d[arg1][arg2].field_0, 
           uint256(sub_ea73c96d[arg1][arg2].field_256),
           uint256(sub_ea73c96d[arg1][arg2].field_512),
           uint256(sub_ea73c96d[arg1][arg2].field_768)
}

function _fallback() payable {
    revert
}

function stopReward() payable {
    if owner != msg.sender:
        revert with 0, 'eOwnable: caller is not the owne'
    bonusEndBlock = block.number
}

function updateFeePeriod(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'eOwnable: caller is not the owne'
    feePeriod = arg1
}

function setPoolStatus(bool arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'eOwnable: caller is not the owne'
    sub_c7b01a97 = uint8(arg1)
}

function updateUnstakingFee(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'eOwnable: caller is not the owne'
    unStakingFee = arg1
}

function setLockingDuration(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'eOwnable: caller is not the owne'
    sub_cea8c746 = arg1
}

function updateFeeCollector(address arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'eOwnable: caller is not the owne'
    if feeCollectorAddress == arg1:
        revert with 0, 'Already the fee collector'
    feeCollectorAddress = arg1
}

function lock(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'eOwnable: caller is not the owne'
    stor1.length = owner
    owner = 0
    unlockTime = arg1 + block.timestamp
    emit OwnershipTransferred(address arg1, address arg2)
    emit 0x0 
    emit 0x0 
}

function updatePoolCap(bool arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    if owner != msg.sender:
        revert with 0, 'eOwnable: caller is not the owne'
    if not uint8(stor9.field_176):
        revert with 0, 'Must be set'
    if arg1:
        poolCap = arg2
    else:
        Mask(80, 0, stor9.field_176) = Mask(80, 0, arg1)
        poolCap = 0
    emit NewPoolCap(poolCap);
}

function updatePoolLimitPerUser(bool arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    if owner != msg.sender:
        revert with 0, 'eOwnable: caller is not the owne'
    if not uint8(stor9.field_168):
        revert with 0, 'Must be set'
    if arg1:
        poolLimitPerUser = arg2
    else:
        Mask(88, 0, stor9.field_168) = Mask(88, 0, arg1)
        poolLimitPerUser = 0
    emit NewPoolLimit(poolLimitPerUser);
}

function updateRewardPerBlock(uint256 arg1, address arg2) payable {
    require calldata.size - 4 >= 64
    if owner != msg.sender:
        revert with 0, 'eOwnable: caller is not the owne'
    idx = 0
    while idx < rewardTokens.length:
        mem[0] = 26
        if rewardTokens[idx].field_0 != arg2:
            idx = idx + 1
            continue 
        rewardPerBlock[address(arg2)] = arg1
        emit 0x27294c6f: arg1, arg2
    revert with 0, 'Cannot find token'
}

function unlock() payable {
    if stor1.length != msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    35,
                    0x6b596f7520646f6e27742068617665207065726d697373696f6e20746f20756e6c6f63,
                    mem[199 len 29]
    if block.timestamp <= unlockTime:
        revert with 0, 'Contract is locked until 7 days'
    emit OwnershipTransferred(owner, stor1.length);
    owner = stor1.length
}

function transferOwnership(address arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'eOwnable: caller is not the owne'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    38,
                    0x6b4f776e61626c653a206e6577206f776e657220697320746865207a65726f20616464726573,
                    mem[202 len 26]
    emit OwnershipTransferred(owner, arg1);
    owner = arg1
}

function sub_3412a764(?) payable {
    require calldata.size - 4 >= 32
    idx = 0
    s = 0
    while idx < uint256(sub_ea73c96d[address(arg1)].field_0):
        require idx < uint256(sub_ea73c96d[address(arg1)].field_0)
        if uint256(sub_ea73c96d[address(arg1)][idx].field_768) >= block.number:
            mem[0] = arg1
            mem[32] = 30
            idx = idx + 1
            s = s
            continue 
        require idx < uint256(sub_ea73c96d[address(arg1)].field_0)
        mem[0] = arg1
        mem[32] = 30
        idx = idx + 1
        s = s + uint256(sub_ea73c96d[address(arg1)][idx].field_256)
        continue 
    return s
}

function emergencyRewardWithdraw(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'eOwnable: caller is not the owne'
    idx = 0
    while idx < rewardTokens.length:
        mem[0] = 26
        mem[100] = msg.sender
        mem[132] = arg1
        require ext_code.size(rewardTokens[idx].field_0)
        call rewardTokens[idx].field_0.0xa9059cbb with:
             gas gas_remaining wei
            args msg.sender, arg1
        mem[96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        idx = idx + 1
        continue 
}

function approve(address arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    if not msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    36,
                    0x7345524332303a20617070726f76652066726f6d20746865207a65726f20616464726573,
                    mem[200 len 28]
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    34,
                    0x7345524332303a20617070726f766520746f20746865207a65726f20616464726573,
                    mem[198 len 30]
    allowance[address(msg.sender)][address(arg1)] = arg2
    emit Approval(arg2, msg.sender, arg1);
    return 1
}

function recoverWrongTokens(address arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    if owner != msg.sender:
        revert with 0, 'eOwnable: caller is not the owne'
    if stakedTokenAddress == arg1:
        revert with 0, 'Cannot be staked token'
    idx = 0
    while idx < rewardTokens.length:
        mem[0] = 26
        if rewardTokens[idx].field_0 == arg1:
            revert with 0, 'Cannot be reward token'
        idx = idx + 1
        continue 
    require ext_code.size(arg1)
    call arg1.0xa9059cbb with:
         gas gas_remaining wei
        args msg.sender, arg2
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    emit AdminTokenRecovery(address(arg1), arg2);
}

function decreaseAllowance(address arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    if arg2 > allowance[address(msg.sender)][address(arg1)]:
        revert with 0, 
                    32,
                    37,
                    0x6b45524332303a2064656372656173656420616c6c6f77616e63652062656c6f77207a6572,
                    mem[165 len 27],
                    mem[219 len 5]
    if not msg.sender:
        revert with 0, 32, 36, 0x7345524332303a20617070726f76652066726f6d20746865207a65726f20616464726573, mem[296 len 28]
    if not arg1:
        revert with 0, 32, 34, 0x7345524332303a20617070726f766520746f20746865207a65726f20616464726573, mem[294 len 30]
    allowance[address(msg.sender)][address(arg1)] -= arg2
    emit Approval((allowance[address(msg.sender)][address(arg1)] - arg2), msg.sender, arg1);
    return 1
}

function emergencyRemoval(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'eOwnable: caller is not the owne'
    if not stor23:
        revert with 0, 'The pool is not removable'
    require ext_code.size(stakedTokenAddress)
    staticcall stakedTokenAddress.0x70a08231 with:
            gas gas_remaining wei
           args this.address
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[0] < arg1:
        revert with 0, 'Amount exceeds pool balance'
    if arg1:
        require ext_code.size(stakedTokenAddress)
        call stakedTokenAddress.0xa9059cbb with:
             gas gas_remaining wei
            args msg.sender, arg1
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
}

function updateUnStakingBlock(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'eOwnable: caller is not the owne'
    if block.number >= unStakingBlock:
        revert with 0, 'Unstaking has started'
    if stakingBlock > arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    37,
                    0x735374616b696e6720626c6f636b206578636565647320756e7374616b696e6720626c6f63,
                    mem[201 len 27]
    if block.number >= arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    52,
                    0x734e657720556e5374616b696e67426c6f636b206d75737420626520686967686572207468616e2063757272656e7420626c6f63,
                    mem[216 len 12]
    unStakingBlock = arg1
    emit NewUnStakingBlock(arg1);
}

function increaseAllowance(address arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    if arg2 + allowance[address(msg.sender)][address(arg1)] < allowance[address(msg.sender)][address(arg1)]:
        revert with 0, 'SafeMath: addition overflow'
    if not msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    36,
                    0x7345524332303a20617070726f76652066726f6d20746865207a65726f20616464726573,
                    mem[200 len 28]
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    34,
                    0x7345524332303a20617070726f766520746f20746865207a65726f20616464726573,
                    mem[198 len 30]
    allowance[address(msg.sender)][address(arg1)] += arg2
    emit Approval((arg2 + allowance[address(msg.sender)][address(arg1)]), msg.sender, arg1);
    return 1
}

function getAllPreFactor(address[] arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 <= 4294967296
    require arg1 + 36 <= calldata.size
    require arg1.length <= 4294967296 and arg1 + (32 * arg1.length) + 36 <= calldata.size
    mem[128 len 32 * arg1.length] = call.data[arg1 + 36 len 32 * arg1.length]
    require arg1.length <= test266151307()
    mem[(32 * arg1.length) + 128] = arg1.length
    if arg1.length:
        mem[(32 * arg1.length) + 160 len 32 * arg1.length] = call.data[calldata.size len 32 * arg1.length]
    idx = 0
    while idx < arg1.length:
        require idx < arg1.length
        mem[0] = mem[(32 * idx) + 140 len 20]
        mem[32] = 25
        require idx < arg1.length
        mem[(32 * idx) + (32 * arg1.length) + 160] = pRECISION_FACTOR[mem[(32 * idx) + 140 len 20]]
        idx = idx + 1
        continue 
    mem[(64 * arg1.length) + 160] = 32
    mem[(64 * arg1.length) + 192] = arg1.length
    mem[(64 * arg1.length) + 224 len floor32(arg1.length)] = mem[(32 * arg1.length) + 160 len floor32(arg1.length)]
    return memory
      from (64 * arg1.length) + 160
       len (161 * arg1.length) + 64
}

function getAllRewardPerBlock(address[] arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 <= 4294967296
    require arg1 + 36 <= calldata.size
    require arg1.length <= 4294967296 and arg1 + (32 * arg1.length) + 36 <= calldata.size
    mem[128 len 32 * arg1.length] = call.data[arg1 + 36 len 32 * arg1.length]
    require arg1.length <= test266151307()
    mem[(32 * arg1.length) + 128] = arg1.length
    if arg1.length:
        mem[(32 * arg1.length) + 160 len 32 * arg1.length] = call.data[calldata.size len 32 * arg1.length]
    idx = 0
    while idx < arg1.length:
        require idx < arg1.length
        mem[0] = mem[(32 * idx) + 140 len 20]
        mem[32] = 24
        require idx < arg1.length
        mem[(32 * idx) + (32 * arg1.length) + 160] = rewardPerBlock[mem[(32 * idx) + 140 len 20]]
        idx = idx + 1
        continue 
    mem[(64 * arg1.length) + 160] = 32
    mem[(64 * arg1.length) + 192] = arg1.length
    mem[(64 * arg1.length) + 224 len floor32(arg1.length)] = mem[(32 * arg1.length) + 160 len floor32(arg1.length)]
    return memory
      from (64 * arg1.length) + 160
       len (161 * arg1.length) + 64
}

function getAllAccTokenPerShared(address[] arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 <= 4294967296
    require arg1 + 36 <= calldata.size
    require arg1.length <= 4294967296 and arg1 + (32 * arg1.length) + 36 <= calldata.size
    mem[128 len 32 * arg1.length] = call.data[arg1 + 36 len 32 * arg1.length]
    require arg1.length <= test266151307()
    mem[(32 * arg1.length) + 128] = arg1.length
    if arg1.length:
        mem[(32 * arg1.length) + 160 len 32 * arg1.length] = call.data[calldata.size len 32 * arg1.length]
    idx = 0
    while idx < arg1.length:
        require idx < arg1.length
        mem[0] = mem[(32 * idx) + 140 len 20]
        mem[32] = 10
        require idx < arg1.length
        mem[(32 * idx) + (32 * arg1.length) + 160] = accTokenPerShare[mem[(32 * idx) + 140 len 20]]
        idx = idx + 1
        continue 
    mem[(64 * arg1.length) + 160] = 32
    mem[(64 * arg1.length) + 192] = arg1.length
    mem[(64 * arg1.length) + 224 len floor32(arg1.length)] = mem[(32 * arg1.length) + 160 len floor32(arg1.length)]
    return memory
      from (64 * arg1.length) + 160
       len (161 * arg1.length) + 64
}

function transfer(address arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    if not msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    37,
                    0x7345524332303a207472616e736665722066726f6d20746865207a65726f20616464726573,
                    mem[201 len 27]
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    35,
                    0xfe45524332303a207472616e7366657220746f20746865207a65726f20616464726573,
                    mem[199 len 29]
    if arg2 > balanceOf[address(msg.sender)]:
        revert with 0, 
                    32,
                    38,
                    0x6b45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63,
                    mem[166 len 26],
                    mem[218 len 6]
    balanceOf[address(msg.sender)] -= arg2
    if arg2 + balanceOf[arg1] < balanceOf[arg1]:
        revert with 0, 'SafeMath: addition overflow'
    balanceOf[address(arg1)] = arg2 + balanceOf[arg1]
    emit Transfer(arg2, msg.sender, arg1);
    return 1
}

function addRewardToken(address arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    if owner != msg.sender:
        revert with 0, 'eOwnable: caller is not the owne'
    if not arg1:
        revert with 0, 'Must be a real token'
    if this.address == arg1:
        revert with 0, 'Must be a real token'
    idx = 0
    while idx < rewardTokens.length:
        mem[0] = 26
        if rewardTokens[idx].field_0 == arg1:
            revert with 0, 'Token exists'
        idx = idx + 1
        continue 
    rewardTokens.length++
    stor57C3[stor26.length] = arg1
    require ext_code.size(arg1)
    staticcall arg1.0x313ce567 with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[31 len 1] >= 30:
        revert with 0, 'Must be inferior to 30'
    if uint8(ext_call.return_data[0]) > 30:
        revert with 0, 'SafeMath: subtraction overflow'
    pRECISION_FACTOR[address(arg1)] = 10^(-uint8(ext_call.return_data[0]) + 30)
    rewardPerBlock[address(arg1)] = arg2
    accTokenPerShare[address(arg1)] = 0
    emit 0x6503357b: address(arg1), arg2, pRECISION_FACTOR[address(arg1)]
}

function getUserDebt(address arg1) payable {
    require calldata.size - 4 >= 32
    require rewardTokens.length <= test266151307()
    idx = 0
    while idx < rewardTokens.length:
        mem[0] = rewardTokens[idx].field_0
        mem[32] = sha3(address(arg1), 28) + 2
        require idx < rewardTokens.length
        mem[(32 * idx) + 128] = uint256(lastStakingBlock[address(arg1)][2][stor26[idx].field_0].field_0)
        idx = idx + 1
        continue 
    if rewardTokens.length:
        mem[(32 * rewardTokens.length) + 160] = address(rewardTokens.field_0)
        idx = (32 * rewardTokens.length) + 160
        s = 0
        while (64 * rewardTokens.length) + 128 > idx:
            mem[idx + 32] = rewardTokens[s].field_256
            idx = idx + 32
            s = s + 1
            continue 
    mem[(64 * rewardTokens.length) + 160] = 64
    mem[(64 * rewardTokens.length) + 224] = rewardTokens.length
    mem[(64 * rewardTokens.length) + 256 len floor32(rewardTokens.length)] = mem[(32 * rewardTokens.length) + 160 len floor32(rewardTokens.length)]
    mem[(64 * rewardTokens.length) + 192] = (32 * rewardTokens.length) + 96
    mem[(98 * rewardTokens.length) + 256] = rewardTokens.length
    return Array(len=rewardTokens.length, data=mem[(32 * rewardTokens.length) + 160 len floor32(rewardTokens.length)], mem[(64 * rewardTokens.length) + floor32(rewardTokens.length) + 256 len (64 * rewardTokens.length) + -floor32(rewardTokens.length) + 32]), 
           (32 * rewardTokens.length) + 96
}

function updateStartAndEndBlocks(uint256 arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    if owner != msg.sender:
        revert with 0, 'eOwnable: caller is not the owne'
    if block.number >= startBlock:
        revert with 0, 'Pool has started'
    if arg1 >= arg2:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    46,
                    0x654e6577207374617274426c6f636b206d757374206265206c6f776572207468616e206e657720656e64426c6f63,
                    mem[210 len 18]
    if block.number >= arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    48,
                    0x6b4e6577207374617274426c6f636b206d75737420626520686967686572207468616e2063757272656e7420626c6f63,
                    mem[212 len 16]
    if stakingBlock > arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    33,
                    0x735374616b696e6720626c6f636b206578636565647320737461727420626c6f63,
                    mem[197 len 31]
    if stakingEndBlock > arg2:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    41,
                    0x65456e64207374616b696e6720626c6f636b206578636565647320626f6e757320656e6420626c6f63,
                    mem[205 len 23]
    startBlock = arg1
    bonusEndBlock = arg2
    lastRewardBlock = arg1
    emit NewStartAndEndBlocks(arg1, arg2);
}

function updateStakingBlocks(uint256 arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    if owner != msg.sender:
        revert with 0, 'eOwnable: caller is not the owne'
    if arg1 > startBlock:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    33,
                    0x735374616b696e6720626c6f636b206578636565647320737461727420626c6f63,
                    mem[197 len 31]
    if arg1 > unStakingBlock:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    37,
                    0x735374616b696e6720626c6f636b206578636565647320756e7374616b696e6720626c6f63,
                    mem[201 len 27]
    if block.number >= arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    50,
                    0x6b4e6577207374616b696e67426c6f636b206d75737420626520686967686572207468616e2063757272656e7420626c6f63,
                    mem[214 len 14]
    if arg1 >= arg2:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    39,
                    0x6b5374616b696e6720626c6f636b206578636565647320656e64207374616b696e6720626c6f63,
                    mem[203 len 25]
    if arg2 > bonusEndBlock:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    41,
                    0x65456e64207374616b696e6720626c6f636b206578636565647320626f6e757320656e6420626c6f63,
                    mem[205 len 23]
    stakingBlock = arg1
    stakingEndBlock = arg2
    emit NewStakingBlocks(arg1, arg2);
}

function transferFrom(address arg1, address arg2, uint256 arg3) payable {
    require calldata.size - 4 >= 96
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    37,
                    0x7345524332303a207472616e736665722066726f6d20746865207a65726f20616464726573,
                    mem[201 len 27]
    if not arg2:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    35,
                    0xfe45524332303a207472616e7366657220746f20746865207a65726f20616464726573,
                    mem[199 len 29]
    if arg3 > balanceOf[address(arg1)]:
        revert with 0, 
                    32,
                    38,
                    0x6b45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63,
                    mem[166 len 26],
                    mem[218 len 6]
    balanceOf[address(arg1)] -= arg3
    if arg3 + balanceOf[arg2] < balanceOf[arg2]:
        revert with 0, 'SafeMath: addition overflow'
    balanceOf[address(arg2)] = arg3 + balanceOf[arg2]
    emit Transfer(arg3, arg1, arg2);
    if arg3 > allowance[address(arg1)][address(msg.sender)]:
        revert with 0, 
                    32,
                    40,
                    0x7745524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63,
                    mem[264 len 24],
                    mem[312 len 8]
    if not arg1:
        revert with 0, 32, 36, 0x7345524332303a20617070726f76652066726f6d20746865207a65726f20616464726573, mem[392 len 28]
    if not msg.sender:
        revert with 0, 32, 34, 0x7345524332303a20617070726f766520746f20746865207a65726f20616464726573, mem[390 len 30]
    allowance[address(arg1)][address(msg.sender)] -= arg3
    emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
    return 1
}

function removeRewardToken(address arg1) payable {
    mem[64] = 96
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'eOwnable: caller is not the owne'
    if not arg1:
        revert with 0, 'Must be a real token'
    if this.address == arg1:
        revert with 0, 'Must be a real token'
    if not rewardTokens.length:
        revert with 0, 'List of token is empty'
    idx = 0
    while idx < rewardTokens.length:
        mem[0] = 26
        if rewardTokens[idx].field_0 != arg1:
            idx = idx + 1
            continue 
        if idx >= rewardTokens.length:
            if rewardTokens.length:
                mem[128] = address(rewardTokens.field_0)
                idx = 128
                s = sha3(26)
                while (32 * rewardTokens.length) + 96 > idx:
                    mem[idx + 32] = stor1[s]
                    idx = idx + 32
                    s = s + 1
                    continue 
            if not rewardTokens.length:
                idx = sha3(26)
                while sha3(26) + rewardTokens.length > idx:
                    stor[idx] = 0
                    idx = idx + 1
                    continue 
            else:
                s = sha3(26)
                idx = 128
                while (32 * rewardTokens.length) + 128 > idx:
                    stor[s] = mem[idx + 12 len 20]
                    s = s + 1
                    idx = idx + 32
                    continue 
                idx = sha3(26) + (Mask(251, 0, (32 * rewardTokens.length) + 31) >> 5)
                while sha3(26) + rewardTokens.length > idx:
                    stor[idx] = 0
                    idx = idx + 1
                    continue 
            revert with 0, 'Remove token unsuccessfully'
        s = idx
        while s < rewardTokens.length - 1:
            require s + 1 < rewardTokens.length
            require s < rewardTokens.length
            mem[0] = 26
            rewardTokens[s].field_0 = rewardTokens[s].field_256
            s = s + 1
            continue 
        require rewardTokens.length
        rewardTokens[rewardTokens.length].field_0 = 0
        rewardTokens.length--
        mem[128] = address(rewardTokens.field_0)
        idx = 128
        s = sha3(26)
        while (32 * rewardTokens.length) + 96 > idx:
            mem[idx + 32] = stor1[s]
            idx = idx + 32
            s = s + 1
            continue 
        if not rewardTokens.length:
            idx = sha3(26)
            while sha3(26) + rewardTokens.length > idx:
                stor[idx] = 0
                idx = idx + 1
                continue 
        else:
            s = sha3(26)
            idx = 128
            while (32 * rewardTokens.length) + 128 > idx:
                stor[s] = mem[idx + 12 len 20]
                s = s + 1
                idx = idx + 32
                continue 
            idx = sha3(26) + (Mask(251, 0, (32 * rewardTokens.length) + 31) >> 5)
            while sha3(26) + rewardTokens.length > idx:
                stor[idx] = 0
                idx = idx + 1
                continue 
        pRECISION_FACTOR[address(arg1)] = 0
        rewardPerBlock[address(arg1)] = 0
        accTokenPerShare[address(arg1)] = 0
        emit RemoveRewardToken(arg1);
    revert with 0, 'Cannot find token'
}

function sub_06e672e9(?) payable {
    require calldata.size - 4 >= 32
    mem[0] = arg1
    mem[32] = 30
    require uint256(sub_ea73c96d[address(arg1)].field_0) <= test266151307()
    mem[96] = uint256(sub_ea73c96d[address(arg1)].field_0)
    if not uint256(sub_ea73c96d[address(arg1)].field_0):
        require uint256(sub_ea73c96d[address(arg1)].field_0) <= test266151307()
        mem[(32 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 128] = uint256(sub_ea73c96d[address(arg1)].field_0)
        if not uint256(sub_ea73c96d[address(arg1)].field_0):
            require uint256(sub_ea73c96d[address(arg1)].field_0) <= test266151307()
            mem[(64 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 160] = uint256(sub_ea73c96d[address(arg1)].field_0)
            mem[64] = (98 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 192
            if not uint256(sub_ea73c96d[address(arg1)].field_0):
                idx = 0
                while idx < uint256(sub_ea73c96d[address(arg1)].field_0):
                    require idx < uint256(sub_ea73c96d[msg.sender].field_0)
                    require idx < mem[96]
                    mem[(32 * idx) + 128] = uint256(sub_ea73c96d[msg.sender][idx].field_512)
                    require idx < uint256(sub_ea73c96d[msg.sender].field_0)
                    require idx < mem[(32 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 128]
                    mem[(32 * idx) + (32 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 160] = uint256(sub_ea73c96d[msg.sender][idx].field_768)
                    mem[32] = 30
                    require idx < uint256(sub_ea73c96d[msg.sender].field_0)
                    mem[0] = sha3(msg.sender, 30)
                    require idx < mem[(64 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 160]
                    mem[(32 * idx) + (64 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 192] = uint256(sub_ea73c96d[msg.sender][idx].field_256)
                    idx = idx + 1
                    continue 
                _177 = mem[64]
                mem[mem[64]] = 96
                mem[mem[64] + 96] = mem[96]
                _179 = mem[96]
                mem[mem[64] + 128 len floor32(mem[96])] = mem[128 len floor32(mem[96])]
                mem[_177 + 32] = (32 * _179) + 128
                mem[(32 * _179) + _177 + 128] = mem[(32 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 128]
                _330 = mem[(32 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 128]
                mem[(32 * _179) + _177 + 160 len floor32(mem[(32 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 128])] = mem[(32 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 160 len floor32(mem[(32 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 128])]
                mem[_177 + 64] = (32 * _330) + (32 * _179) + 160
                mem[(32 * _330) + (32 * _179) + _177 + 160] = mem[(64 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 160]
                _394 = mem[(64 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 160]
                mem[(32 * _330) + (32 * _179) + _177 + 192 len floor32(mem[(64 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 160])] = mem[(64 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 192 len floor32(mem[(64 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 160])]
                return memory
                  from mem[64]
                   len (32 * _394) + (32 * _330) + (32 * _179) + _177 + -mem[64] + 192
            mem[(64 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 192 len 32 * uint256(sub_ea73c96d[address(arg1)].field_0)] = call.data[calldata.size len 32 * uint256(sub_ea73c96d[address(arg1)].field_0)]
            idx = 0
            while idx < uint256(sub_ea73c96d[address(arg1)].field_0):
                require idx < uint256(sub_ea73c96d[msg.sender].field_0)
                require idx < mem[96]
                mem[(32 * idx) + 128] = uint256(sub_ea73c96d[msg.sender][idx].field_512)
                require idx < uint256(sub_ea73c96d[msg.sender].field_0)
                require idx < mem[(32 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 128]
                mem[(32 * idx) + (32 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 160] = uint256(sub_ea73c96d[msg.sender][idx].field_768)
                mem[32] = 30
                require idx < uint256(sub_ea73c96d[msg.sender].field_0)
                mem[0] = sha3(msg.sender, 30)
                require idx < mem[(64 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 160]
                mem[(32 * idx) + (64 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 192] = uint256(sub_ea73c96d[msg.sender][idx].field_256)
                idx = idx + 1
                continue 
            _182 = mem[64]
            mem[mem[64]] = 96
            mem[mem[64] + 96] = mem[96]
            _184 = mem[96]
            mem[mem[64] + 128 len floor32(mem[96])] = mem[128 len floor32(mem[96])]
            mem[mem[64] + 32] = (32 * _184) + 128
            mem[(32 * _184) + _182 + 128] = mem[(32 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 128]
            _333 = mem[(32 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 128]
            mem[(32 * _184) + _182 + 160 len floor32(mem[(32 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 128])] = mem[(32 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 160 len floor32(mem[(32 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 128])]
            mem[_182 + 64] = (32 * _333) + (32 * _184) + 160
            mem[(32 * _333) + (32 * _184) + _182 + 160] = mem[(64 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 160]
            _397 = mem[(64 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 160]
            mem[(32 * _333) + (32 * _184) + _182 + 192 len floor32(mem[(64 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 160])] = mem[(64 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 192 len floor32(mem[(64 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 160])]
            return memory
              from mem[64]
               len (32 * _397) + (32 * _333) + (32 * _184) + _182 + -mem[64] + 192
        mem[(32 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 160 len 32 * uint256(sub_ea73c96d[address(arg1)].field_0)] = call.data[calldata.size len 32 * uint256(sub_ea73c96d[address(arg1)].field_0)]
        require uint256(sub_ea73c96d[address(arg1)].field_0) <= test266151307()
        mem[(64 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 160] = uint256(sub_ea73c96d[address(arg1)].field_0)
        mem[64] = (98 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 192
        if not uint256(sub_ea73c96d[address(arg1)].field_0):
            idx = 0
            while idx < uint256(sub_ea73c96d[address(arg1)].field_0):
                require idx < uint256(sub_ea73c96d[msg.sender].field_0)
                require idx < mem[96]
                mem[(32 * idx) + 128] = uint256(sub_ea73c96d[msg.sender][idx].field_512)
                require idx < uint256(sub_ea73c96d[msg.sender].field_0)
                require idx < mem[(32 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 128]
                mem[(32 * idx) + (32 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 160] = uint256(sub_ea73c96d[msg.sender][idx].field_768)
                mem[32] = 30
                require idx < uint256(sub_ea73c96d[msg.sender].field_0)
                mem[0] = sha3(msg.sender, 30)
                require idx < mem[(64 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 160]
                mem[(32 * idx) + (64 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 192] = uint256(sub_ea73c96d[msg.sender][idx].field_256)
                idx = idx + 1
                continue 
            _187 = mem[64]
            mem[mem[64]] = 96
            mem[mem[64] + 96] = mem[96]
            _189 = mem[96]
            mem[mem[64] + 128 len floor32(mem[96])] = mem[128 len floor32(mem[96])]
            mem[_187 + 32] = (32 * _189) + 128
            mem[(32 * _189) + _187 + 128] = mem[(32 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 128]
            _336 = mem[(32 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 128]
            mem[(32 * _189) + _187 + 160 len floor32(mem[(32 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 128])] = mem[(32 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 160 len floor32(mem[(32 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 128])]
            mem[_187 + 64] = (32 * _336) + (32 * _189) + 160
            mem[(32 * _336) + (32 * _189) + _187 + 160] = mem[(64 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 160]
            _400 = mem[(64 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 160]
            mem[(32 * _336) + (32 * _189) + _187 + 192 len floor32(mem[(64 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 160])] = mem[(64 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 192 len floor32(mem[(64 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 160])]
            return memory
              from mem[64]
               len (32 * _400) + (32 * _336) + (32 * _189) + _187 + -mem[64] + 192
        mem[(64 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 192 len 32 * uint256(sub_ea73c96d[address(arg1)].field_0)] = call.data[calldata.size len 32 * uint256(sub_ea73c96d[address(arg1)].field_0)]
        idx = 0
        while idx < uint256(sub_ea73c96d[address(arg1)].field_0):
            require idx < uint256(sub_ea73c96d[msg.sender].field_0)
            require idx < mem[96]
            mem[(32 * idx) + 128] = uint256(sub_ea73c96d[msg.sender][idx].field_512)
            require idx < uint256(sub_ea73c96d[msg.sender].field_0)
            require idx < mem[(32 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 128]
            mem[(32 * idx) + (32 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 160] = uint256(sub_ea73c96d[msg.sender][idx].field_768)
            mem[32] = 30
            require idx < uint256(sub_ea73c96d[msg.sender].field_0)
            mem[0] = sha3(msg.sender, 30)
            require idx < mem[(64 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 160]
            mem[(32 * idx) + (64 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 192] = uint256(sub_ea73c96d[msg.sender][idx].field_256)
            idx = idx + 1
            continue 
        _192 = mem[64]
        mem[mem[64]] = 96
        mem[mem[64] + 96] = mem[96]
        _194 = mem[96]
        mem[mem[64] + 128 len floor32(mem[96])] = mem[128 len floor32(mem[96])]
        mem[_192 + 32] = (32 * _194) + 128
        mem[(32 * _194) + _192 + 128] = mem[(32 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 128]
        _339 = mem[(32 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 128]
        mem[(32 * _194) + _192 + 160 len floor32(mem[(32 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 128])] = mem[(32 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 160 len floor32(mem[(32 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 128])]
        mem[_192 + 64] = (32 * _339) + (32 * _194) + 160
        mem[(32 * _339) + (32 * _194) + _192 + 160] = mem[(64 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 160]
        _403 = mem[(64 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 160]
        mem[(32 * _339) + (32 * _194) + _192 + 192 len floor32(mem[(64 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 160])] = mem[(64 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 192 len floor32(mem[(64 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 160])]
        return memory
          from mem[64]
           len (32 * _403) + (32 * _339) + (32 * _194) + _192 + -mem[64] + 192
    mem[128 len 32 * uint256(sub_ea73c96d[address(arg1)].field_0)] = call.data[calldata.size len 32 * uint256(sub_ea73c96d[address(arg1)].field_0)]
    require uint256(sub_ea73c96d[address(arg1)].field_0) <= test266151307()
    mem[(32 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 128] = uint256(sub_ea73c96d[address(arg1)].field_0)
    if not uint256(sub_ea73c96d[address(arg1)].field_0):
        require uint256(sub_ea73c96d[address(arg1)].field_0) <= test266151307()
        mem[(64 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 160] = uint256(sub_ea73c96d[address(arg1)].field_0)
        mem[64] = (98 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 192
        if not uint256(sub_ea73c96d[address(arg1)].field_0):
            idx = 0
            while idx < uint256(sub_ea73c96d[address(arg1)].field_0):
                require idx < uint256(sub_ea73c96d[msg.sender].field_0)
                require idx < mem[96]
                mem[(32 * idx) + 128] = uint256(sub_ea73c96d[msg.sender][idx].field_512)
                require idx < uint256(sub_ea73c96d[msg.sender].field_0)
                require idx < mem[(32 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 128]
                mem[(32 * idx) + (32 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 160] = uint256(sub_ea73c96d[msg.sender][idx].field_768)
                mem[32] = 30
                require idx < uint256(sub_ea73c96d[msg.sender].field_0)
                mem[0] = sha3(msg.sender, 30)
                require idx < mem[(64 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 160]
                mem[(32 * idx) + (64 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 192] = uint256(sub_ea73c96d[msg.sender][idx].field_256)
                idx = idx + 1
                continue 
            _197 = mem[64]
            mem[mem[64]] = 96
            mem[mem[64] + 96] = mem[96]
            _199 = mem[96]
            mem[mem[64] + 128 len floor32(mem[96])] = mem[128 len floor32(mem[96])]
            mem[mem[64] + 32] = (32 * _199) + 128
            mem[(32 * _199) + _197 + 128] = mem[(32 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 128]
            _342 = mem[(32 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 128]
            mem[(32 * _199) + _197 + 160 len floor32(mem[(32 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 128])] = mem[(32 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 160 len floor32(mem[(32 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 128])]
            mem[_197 + 64] = (32 * _342) + (32 * _199) + 160
            mem[(32 * _342) + (32 * _199) + _197 + 160] = mem[(64 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 160]
            _406 = mem[(64 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 160]
            mem[(32 * _342) + (32 * _199) + _197 + 192 len floor32(mem[(64 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 160])] = mem[(64 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 192 len floor32(mem[(64 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 160])]
            return memory
              from mem[64]
               len (32 * _406) + (32 * _342) + (32 * _199) + _197 + -mem[64] + 192
        mem[(64 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 192 len 32 * uint256(sub_ea73c96d[address(arg1)].field_0)] = call.data[calldata.size len 32 * uint256(sub_ea73c96d[address(arg1)].field_0)]
        idx = 0
        while idx < uint256(sub_ea73c96d[address(arg1)].field_0):
            require idx < uint256(sub_ea73c96d[msg.sender].field_0)
            require idx < mem[96]
            mem[(32 * idx) + 128] = uint256(sub_ea73c96d[msg.sender][idx].field_512)
            require idx < uint256(sub_ea73c96d[msg.sender].field_0)
            require idx < mem[(32 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 128]
            mem[(32 * idx) + (32 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 160] = uint256(sub_ea73c96d[msg.sender][idx].field_768)
            mem[32] = 30
            require idx < uint256(sub_ea73c96d[msg.sender].field_0)
            mem[0] = sha3(msg.sender, 30)
            require idx < mem[(64 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 160]
            mem[(32 * idx) + (64 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 192] = uint256(sub_ea73c96d[msg.sender][idx].field_256)
            idx = idx + 1
            continue 
        _202 = mem[64]
        mem[mem[64]] = 96
        mem[mem[64] + 96] = mem[96]
        _204 = mem[96]
        mem[mem[64] + 128 len floor32(mem[96])] = mem[128 len floor32(mem[96])]
        mem[_202 + 32] = (32 * _204) + 128
        mem[(32 * _204) + _202 + 128] = mem[(32 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 128]
        _345 = mem[(32 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 128]
        mem[(32 * _204) + _202 + 160 len floor32(mem[(32 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 128])] = mem[(32 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 160 len floor32(mem[(32 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 128])]
        mem[_202 + 64] = (32 * _345) + (32 * _204) + 160
        mem[(32 * _345) + (32 * _204) + _202 + 160] = mem[(64 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 160]
        _409 = mem[(64 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 160]
        mem[(32 * _345) + (32 * _204) + _202 + 192 len floor32(mem[(64 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 160])] = mem[(64 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 192 len floor32(mem[(64 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 160])]
        return memory
          from mem[64]
           len (32 * _409) + (32 * _345) + (32 * _204) + _202 + -mem[64] + 192
    mem[(32 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 160 len 32 * uint256(sub_ea73c96d[address(arg1)].field_0)] = call.data[calldata.size len 32 * uint256(sub_ea73c96d[address(arg1)].field_0)]
    require uint256(sub_ea73c96d[address(arg1)].field_0) <= test266151307()
    mem[(64 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 160] = uint256(sub_ea73c96d[address(arg1)].field_0)
    mem[64] = (98 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 192
    if not uint256(sub_ea73c96d[address(arg1)].field_0):
        idx = 0
        while idx < uint256(sub_ea73c96d[address(arg1)].field_0):
            require idx < uint256(sub_ea73c96d[msg.sender].field_0)
            require idx < mem[96]
            mem[(32 * idx) + 128] = uint256(sub_ea73c96d[msg.sender][idx].field_512)
            require idx < uint256(sub_ea73c96d[msg.sender].field_0)
            require idx < mem[(32 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 128]
            mem[(32 * idx) + (32 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 160] = uint256(sub_ea73c96d[msg.sender][idx].field_768)
            mem[32] = 30
            require idx < uint256(sub_ea73c96d[msg.sender].field_0)
            mem[0] = sha3(msg.sender, 30)
            require idx < mem[(64 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 160]
            mem[(32 * idx) + (64 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 192] = uint256(sub_ea73c96d[msg.sender][idx].field_256)
            idx = idx + 1
            continue 
        _207 = mem[64]
        mem[mem[64]] = 96
        mem[mem[64] + 96] = mem[96]
        _209 = mem[96]
        mem[mem[64] + 128 len floor32(mem[96])] = mem[128 len floor32(mem[96])]
        mem[_207 + 32] = (32 * _209) + 128
        mem[(32 * _209) + _207 + 128] = mem[(32 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 128]
        _348 = mem[(32 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 128]
        mem[(32 * _209) + _207 + 160 len floor32(mem[(32 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 128])] = mem[(32 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 160 len floor32(mem[(32 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 128])]
        mem[_207 + 64] = (32 * _348) + (32 * _209) + 160
        mem[(32 * _348) + (32 * _209) + _207 + 160] = mem[(64 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 160]
        _412 = mem[(64 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 160]
        mem[(32 * _348) + (32 * _209) + _207 + 192 len floor32(mem[(64 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 160])] = mem[(64 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 192 len floor32(mem[(64 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 160])]
        return memory
          from mem[64]
           len (32 * _412) + (32 * _348) + (32 * _209) + _207 + -mem[64] + 192
    mem[(64 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 192 len 32 * uint256(sub_ea73c96d[address(arg1)].field_0)] = call.data[calldata.size len 32 * uint256(sub_ea73c96d[address(arg1)].field_0)]
    idx = 0
    while idx < uint256(sub_ea73c96d[address(arg1)].field_0):
        require idx < uint256(sub_ea73c96d[msg.sender].field_0)
        require idx < mem[96]
        mem[(32 * idx) + 128] = uint256(sub_ea73c96d[msg.sender][idx].field_512)
        require idx < uint256(sub_ea73c96d[msg.sender].field_0)
        require idx < mem[(32 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 128]
        mem[(32 * idx) + (32 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 160] = uint256(sub_ea73c96d[msg.sender][idx].field_768)
        mem[32] = 30
        require idx < uint256(sub_ea73c96d[msg.sender].field_0)
        mem[0] = sha3(msg.sender, 30)
        require idx < mem[(64 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 160]
        mem[(32 * idx) + (64 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 192] = uint256(sub_ea73c96d[msg.sender][idx].field_256)
        idx = idx + 1
        continue 
    _212 = mem[64]
    mem[mem[64]] = 96
    mem[mem[64] + 96] = mem[96]
    _214 = mem[96]
    mem[mem[64] + 128 len floor32(mem[96])] = mem[128 len floor32(mem[96])]
    mem[_212 + 32] = (32 * _214) + 128
    mem[(32 * _214) + _212 + 128] = mem[(32 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 128]
    _351 = mem[(32 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 128]
    mem[(32 * _214) + _212 + 160 len floor32(mem[(32 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 128])] = mem[(32 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 160 len floor32(mem[(32 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 128])]
    mem[_212 + 64] = (32 * _351) + (32 * _214) + 160
    mem[(32 * _351) + (32 * _214) + _212 + 160] = mem[(64 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 160]
    _415 = mem[(64 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 160]
    mem[(32 * _351) + (32 * _214) + _212 + 192 len floor32(mem[(64 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 160])] = mem[(64 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 192 len floor32(mem[(64 * uint256(sub_ea73c96d[address(arg1)].field_0)) + 160])]
    return memory
      from mem[64]
       len (32 * _415) + (32 * _351) + (32 * _214) + _212 + -mem[64] + 192
}

function initialize(address arg1, address[] arg2, uint256[] arg3, uint256[] arg4, uint256[] arg5, uint256 arg6, uint256[] arg7, address arg8, uint256 arg9, uint256 arg10, bool arg11, address arg12) payable {
    require calldata.size - 4 >= 384
    require arg2 <= 4294967296
    require arg2 + 36 <= calldata.size
    require arg2.length <= 4294967296 and arg2 + (32 * arg2.length) + 36 <= calldata.size
    mem[96] = arg2.length
    mem[128 len 32 * arg2.length] = call.data[arg2 + 36 len 32 * arg2.length]
    require arg3 <= 4294967296
    require arg3 + 36 <= calldata.size
    require arg3.length <= 4294967296 and arg3 + (32 * arg3.length) + 36 <= calldata.size
    mem[(32 * arg2.length) + 128] = arg3.length
    mem[(32 * arg2.length) + 160 len 32 * arg3.length] = call.data[arg3 + 36 len 32 * arg3.length]
    require arg4 <= 4294967296
    require arg4 + 36 <= calldata.size
    require arg4.length <= 4294967296 and arg4 + (32 * arg4.length) + 36 <= calldata.size
    mem[(32 * arg2.length) + (32 * arg3.length) + 160] = arg4.length
    mem[(32 * arg2.length) + (32 * arg3.length) + 192 len 32 * arg4.length] = call.data[arg4 + 36 len 32 * arg4.length]
    require arg5 <= 4294967296
    require arg5 + 36 <= calldata.size
    require arg5.length <= 4294967296 and arg5 + (32 * arg5.length) + 36 <= calldata.size
    mem[(32 * arg2.length) + (32 * arg3.length) + (32 * arg4.length) + 192] = arg5.length
    mem[(32 * arg2.length) + (32 * arg3.length) + (32 * arg4.length) + 224 len 32 * arg5.length] = call.data[arg5 + 36 len 32 * arg5.length]
    require arg7 <= 4294967296
    require arg7 + 36 <= calldata.size
    require arg7.length <= 4294967296 and arg7 + (32 * arg7.length) + 36 <= calldata.size
    mem[64] = (32 * arg2.length) + (32 * arg3.length) + (32 * arg4.length) + (32 * arg5.length) + (32 * arg7.length) + 256
    mem[(32 * arg2.length) + (32 * arg3.length) + (32 * arg4.length) + (32 * arg5.length) + 224] = arg7.length
    mem[(32 * arg2.length) + (32 * arg3.length) + (32 * arg4.length) + (32 * arg5.length) + 256 len 32 * arg7.length] = call.data[arg7 + 36 len 32 * arg7.length]
    mem[(32 * arg2.length) + (32 * arg3.length) + (32 * arg4.length) + (32 * arg5.length) + (32 * arg7.length) + 256] = 0
    if uint8(stor9.field_184):
        revert with 0, 'Already initialized'
    if sub_197046f4Address != msg.sender:
        revert with 0, 'Not factory'
    if arg2.length != arg3.length:
        revert with 0, 'Mismatch length'
    if not arg1:
        revert with 0, 'Invalid address'
    if not arg8:
        revert with 0, 'Invalid address'
    if not arg12:
        revert with 0, 'Invalid address'
    uint8(stor9.field_184) = 1
    stakedTokenAddress = arg1
    rewardTokens.length = arg2.length
    mem[0] = 26
    if not arg2.length:
        idx = 0
        while rewardTokens.length > idx:
            rewardTokens[idx].field_0 = 0
            idx = idx + 1
            continue 
        require 0 < arg4.length
        startBlock = mem[(32 * arg2.length) + (32 * arg3.length) + 192]
        require 1 < arg4.length
        bonusEndBlock = mem[(32 * arg2.length) + (32 * arg3.length) + 224]
        require 1 < arg5.length
        require 0 < arg5.length
        if mem[(32 * arg2.length) + (32 * arg3.length) + (32 * arg4.length) + 224] >= mem[(32 * arg2.length) + (32 * arg3.length) + (32 * arg4.length) + 256]:
            revert with 0, 
                        32,
                        39,
                        0x6b5374616b696e6720626c6f636b206578636565647320656e64207374616b696e6720626c6f63,
                        mem[(32 * arg2.length) + (32 * arg3.length) + (32 * arg4.length) + (32 * arg5.length) + (32 * arg7.length) + 363 len 25]
        require 0 < arg5.length
        stakingBlock = mem[(32 * arg2.length) + (32 * arg3.length) + (32 * arg4.length) + 224]
        require 1 < arg5.length
        stakingEndBlock = mem[(32 * arg2.length) + (32 * arg3.length) + (32 * arg4.length) + 256]
        unStakingBlock = arg6
        require 0 < arg7.length
        unStakingFee = mem[(32 * arg2.length) + (32 * arg3.length) + (32 * arg4.length) + (32 * arg5.length) + 256]
        require 1 < arg7.length
        feePeriod = mem[(32 * arg2.length) + (32 * arg3.length) + (32 * arg4.length) + (32 * arg5.length) + 288]
        feeCollectorAddress = arg8
        stor23 = uint8(arg11)
        if not arg9:
            if not arg10:
                idx = 0
                s = 0
                while idx < arg2.length:
                    require idx < mem[96]
                    require ext_code.size(mem[(32 * idx) + 140 len 20])
                    staticcall mem[(32 * idx) + 140 len 20].0x313ce567 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if uint8(ext_call.return_data[0]) >= 30:
                        revert with 0, 'Must be inferior to 30'
                    _679 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_679] = 30
                    mem[_679 + 32] = 'SafeMath: subtraction overflow'
                    if uint8(ext_call.return_data[0]) > 30:
                        _687 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _687 + 68] = mem[idx + _679 + 32]
                            idx = idx + 32
                            continue 
                        mem[_687 + 68] = mem[_687 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _687 + -mem[64] + 100
                    require idx < mem[96]
                    pRECISION_FACTOR[mem[(32 * idx) + 140 len 20]] = 10^(-uint8(ext_call.return_data[0]) + 30)
                    require idx < mem[(32 * arg2.length) + 128]
                    require idx < mem[96]
                    mem[0] = mem[(32 * idx) + 140 len 20]
                    mem[32] = 24
                    rewardPerBlock[mem[(32 * idx) + 140 len 20]] = mem[(32 * idx) + (32 * arg2.length) + 160]
                    idx = idx + 1
                    s = uint8(ext_call.return_data[0])
                    continue 
            else:
                uint8(stor9.field_176) = 1
                poolCap = arg10
                idx = 0
                s = 0
                while idx < arg2.length:
                    require idx < mem[96]
                    require ext_code.size(mem[(32 * idx) + 140 len 20])
                    staticcall mem[(32 * idx) + 140 len 20].0x313ce567 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if uint8(ext_call.return_data[0]) >= 30:
                        revert with 0, 'Must be inferior to 30'
                    _680 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_680] = 30
                    mem[_680 + 32] = 'SafeMath: subtraction overflow'
                    if uint8(ext_call.return_data[0]) > 30:
                        _690 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _690 + 68] = mem[idx + _680 + 32]
                            idx = idx + 32
                            continue 
                        mem[_690 + 68] = mem[_690 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _690 + -mem[64] + 100
                    require idx < mem[96]
                    pRECISION_FACTOR[mem[(32 * idx) + 140 len 20]] = 10^(-uint8(ext_call.return_data[0]) + 30)
                    require idx < mem[(32 * arg2.length) + 128]
                    require idx < mem[96]
                    mem[0] = mem[(32 * idx) + 140 len 20]
                    mem[32] = 24
                    rewardPerBlock[mem[(32 * idx) + 140 len 20]] = mem[(32 * idx) + (32 * arg2.length) + 160]
                    idx = idx + 1
                    s = uint8(ext_call.return_data[0])
                    continue 
        else:
            uint8(stor9.field_168) = 1
            poolLimitPerUser = arg9
            if not arg10:
                idx = 0
                s = 0
                while idx < arg2.length:
                    require idx < mem[96]
                    require ext_code.size(mem[(32 * idx) + 140 len 20])
                    staticcall mem[(32 * idx) + 140 len 20].0x313ce567 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if uint8(ext_call.return_data[0]) >= 30:
                        revert with 0, 'Must be inferior to 30'
                    _681 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_681] = 30
                    mem[_681 + 32] = 'SafeMath: subtraction overflow'
                    if uint8(ext_call.return_data[0]) > 30:
                        _693 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _693 + 68] = mem[idx + _681 + 32]
                            idx = idx + 32
                            continue 
                        mem[_693 + 68] = mem[_693 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _693 + -mem[64] + 100
                    require idx < mem[96]
                    pRECISION_FACTOR[mem[(32 * idx) + 140 len 20]] = 10^(-uint8(ext_call.return_data[0]) + 30)
                    require idx < mem[(32 * arg2.length) + 128]
                    require idx < mem[96]
                    mem[0] = mem[(32 * idx) + 140 len 20]
                    mem[32] = 24
                    rewardPerBlock[mem[(32 * idx) + 140 len 20]] = mem[(32 * idx) + (32 * arg2.length) + 160]
                    idx = idx + 1
                    s = uint8(ext_call.return_data[0])
                    continue 
            else:
                uint8(stor9.field_176) = 1
                poolCap = arg10
                idx = 0
                s = 0
                while idx < arg2.length:
                    require idx < mem[96]
                    require ext_code.size(mem[(32 * idx) + 140 len 20])
                    staticcall mem[(32 * idx) + 140 len 20].0x313ce567 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if uint8(ext_call.return_data[0]) >= 30:
                        revert with 0, 'Must be inferior to 30'
                    _682 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_682] = 30
                    mem[_682 + 32] = 'SafeMath: subtraction overflow'
                    if uint8(ext_call.return_data[0]) > 30:
                        _696 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _696 + 68] = mem[idx + _682 + 32]
                            idx = idx + 32
                            continue 
                        mem[_696 + 68] = mem[_696 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _696 + -mem[64] + 100
                    require idx < mem[96]
                    pRECISION_FACTOR[mem[(32 * idx) + 140 len 20]] = 10^(-uint8(ext_call.return_data[0]) + 30)
                    require idx < mem[(32 * arg2.length) + 128]
                    require idx < mem[96]
                    mem[0] = mem[(32 * idx) + 140 len 20]
                    mem[32] = 24
                    rewardPerBlock[mem[(32 * idx) + 140 len 20]] = mem[(32 * idx) + (32 * arg2.length) + 160]
                    idx = idx + 1
                    s = uint8(ext_call.return_data[0])
                    continue 
    else:
        s = 0
        idx = 128
        while (32 * arg2.length) + 128 > idx:
            rewardTokens[s].field_0 = mem[idx + 12 len 20]
            s = s + 1
            idx = idx + 32
            continue 
        idx = Mask(251, 0, (32 * arg2.length) + 31) >> 5
        while rewardTokens.length > idx:
            rewardTokens[idx].field_0 = 0
            idx = idx + 1
            continue 
        require 0 < arg4.length
        startBlock = mem[(32 * arg2.length) + (32 * arg3.length) + 192]
        require 1 < arg4.length
        bonusEndBlock = mem[(32 * arg2.length) + (32 * arg3.length) + 224]
        require 1 < arg5.length
        require 0 < arg5.length
        if mem[(32 * arg2.length) + (32 * arg3.length) + (32 * arg4.length) + 224] >= mem[(32 * arg2.length) + (32 * arg3.length) + (32 * arg4.length) + 256]:
            revert with 0, 
                        32,
                        39,
                        0x6b5374616b696e6720626c6f636b206578636565647320656e64207374616b696e6720626c6f63,
                        mem[(32 * arg2.length) + (32 * arg3.length) + (32 * arg4.length) + (32 * arg5.length) + (32 * arg7.length) + 363 len 25]
        require 0 < arg5.length
        stakingBlock = mem[(32 * arg2.length) + (32 * arg3.length) + (32 * arg4.length) + 224]
        require 1 < arg5.length
        stakingEndBlock = mem[(32 * arg2.length) + (32 * arg3.length) + (32 * arg4.length) + 256]
        unStakingBlock = arg6
        require 0 < arg7.length
        unStakingFee = mem[(32 * arg2.length) + (32 * arg3.length) + (32 * arg4.length) + (32 * arg5.length) + 256]
        require 1 < arg7.length
        feePeriod = mem[(32 * arg2.length) + (32 * arg3.length) + (32 * arg4.length) + (32 * arg5.length) + 288]
        feeCollectorAddress = arg8
        stor23 = uint8(arg11)
        if not arg9:
            if not arg10:
                idx = 0
                s = 0
                while idx < arg2.length:
                    require idx < mem[96]
                    require ext_code.size(mem[(32 * idx) + 140 len 20])
                    staticcall mem[(32 * idx) + 140 len 20].0x313ce567 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if uint8(ext_call.return_data[0]) >= 30:
                        revert with 0, 'Must be inferior to 30'
                    _962 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_962] = 30
                    mem[_962 + 32] = 'SafeMath: subtraction overflow'
                    if uint8(ext_call.return_data[0]) > 30:
                        _966 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _966 + 68] = mem[idx + _962 + 32]
                            idx = idx + 32
                            continue 
                        mem[_966 + 68] = mem[_966 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _966 + -mem[64] + 100
                    require idx < mem[96]
                    pRECISION_FACTOR[mem[(32 * idx) + 140 len 20]] = 10^(-uint8(ext_call.return_data[0]) + 30)
                    require idx < mem[(32 * arg2.length) + 128]
                    require idx < mem[96]
                    mem[0] = mem[(32 * idx) + 140 len 20]
                    mem[32] = 24
                    rewardPerBlock[mem[(32 * idx) + 140 len 20]] = mem[(32 * idx) + (32 * arg2.length) + 160]
                    idx = idx + 1
                    s = uint8(ext_call.return_data[0])
                    continue 
            else:
                uint8(stor9.field_176) = 1
                poolCap = arg10
                idx = 0
                s = 0
                while idx < arg2.length:
                    require idx < mem[96]
                    require ext_code.size(mem[(32 * idx) + 140 len 20])
                    staticcall mem[(32 * idx) + 140 len 20].0x313ce567 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if uint8(ext_call.return_data[0]) >= 30:
                        revert with 0, 'Must be inferior to 30'
                    _963 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_963] = 30
                    mem[_963 + 32] = 'SafeMath: subtraction overflow'
                    if uint8(ext_call.return_data[0]) > 30:
                        _969 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _969 + 68] = mem[idx + _963 + 32]
                            idx = idx + 32
                            continue 
                        mem[_969 + 68] = mem[_969 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _969 + -mem[64] + 100
                    require idx < mem[96]
                    pRECISION_FACTOR[mem[(32 * idx) + 140 len 20]] = 10^(-uint8(ext_call.return_data[0]) + 30)
                    require idx < mem[(32 * arg2.length) + 128]
                    require idx < mem[96]
                    mem[0] = mem[(32 * idx) + 140 len 20]
                    mem[32] = 24
                    rewardPerBlock[mem[(32 * idx) + 140 len 20]] = mem[(32 * idx) + (32 * arg2.length) + 160]
                    idx = idx + 1
                    s = uint8(ext_call.return_data[0])
                    continue 
        else:
            uint8(stor9.field_168) = 1
            poolLimitPerUser = arg9
            if not arg10:
                idx = 0
                s = 0
                while idx < arg2.length:
                    require idx < mem[96]
                    require ext_code.size(mem[(32 * idx) + 140 len 20])
                    staticcall mem[(32 * idx) + 140 len 20].0x313ce567 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if uint8(ext_call.return_data[0]) >= 30:
                        revert with 0, 'Must be inferior to 30'
                    _964 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_964] = 30
                    mem[_964 + 32] = 'SafeMath: subtraction overflow'
                    if uint8(ext_call.return_data[0]) > 30:
                        _972 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _972 + 68] = mem[idx + _964 + 32]
                            idx = idx + 32
                            continue 
                        mem[_972 + 68] = mem[_972 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _972 + -mem[64] + 100
                    require idx < mem[96]
                    pRECISION_FACTOR[mem[(32 * idx) + 140 len 20]] = 10^(-uint8(ext_call.return_data[0]) + 30)
                    require idx < mem[(32 * arg2.length) + 128]
                    require idx < mem[96]
                    mem[0] = mem[(32 * idx) + 140 len 20]
                    mem[32] = 24
                    rewardPerBlock[mem[(32 * idx) + 140 len 20]] = mem[(32 * idx) + (32 * arg2.length) + 160]
                    idx = idx + 1
                    s = uint8(ext_call.return_data[0])
                    continue 
            else:
                uint8(stor9.field_176) = 1
                poolCap = arg10
                idx = 0
                s = 0
                while idx < arg2.length:
                    require idx < mem[96]
                    require ext_code.size(mem[(32 * idx) + 140 len 20])
                    staticcall mem[(32 * idx) + 140 len 20].0x313ce567 with:
                            gas gas_remaining wei
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if uint8(ext_call.return_data[0]) >= 30:
                        revert with 0, 'Must be inferior to 30'
                    _965 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_965] = 30
                    mem[_965 + 32] = 'SafeMath: subtraction overflow'
                    if uint8(ext_call.return_data[0]) > 30:
                        _975 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _975 + 68] = mem[idx + _965 + 32]
                            idx = idx + 32
                            continue 
                        mem[_975 + 68] = mem[_975 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _975 + -mem[64] + 100
                    require idx < mem[96]
                    pRECISION_FACTOR[mem[(32 * idx) + 140 len 20]] = 10^(-uint8(ext_call.return_data[0]) + 30)
                    require idx < mem[(32 * arg2.length) + 128]
                    require idx < mem[96]
                    mem[0] = mem[(32 * idx) + 140 len 20]
                    mem[32] = 24
                    rewardPerBlock[mem[(32 * idx) + 140 len 20]] = mem[(32 * idx) + (32 * arg2.length) + 160]
                    idx = idx + 1
                    s = uint8(ext_call.return_data[0])
                    continue 
    lastRewardBlock = startBlock
    if owner != msg.sender:
        revert with 0, 'eOwnable: caller is not the owne'
    if not arg12:
        revert with 0, 32, 38, 0x6b4f776e61626c653a206e6577206f776e657220697320746865207a65726f20616464726573, mem[mem[64] + 106 len 26]
    emit OwnershipTransferred(owner, arg12);
    owner = arg12
}

function pendingRewardByToken(address arg1, address arg2) payable {
    mem[64] = 96
    require calldata.size - 4 >= 64
    idx = 0
    while idx < rewardTokens.length:
        mem[0] = 26
        if rewardTokens[idx].field_0 != arg2:
            idx = idx + 1
            continue 
        require ext_code.size(stakedTokenAddress)
        staticcall stakedTokenAddress.0x70a08231 with:
                gas gas_remaining wei
               args this.address
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if block.number <= lastRewardBlock:
            if not uint256(lastStakingBlock[address(arg1)].field_0):
                if not pRECISION_FACTOR[address(arg2)]:
                    mem[160] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[164] = 32
                    idx = 32
                    while idx < 26:
                        mem[idx + 228] = mem[idx + 128]
                        idx = idx + 32
                        continue 
                    revert with 0, 'SafeMath: division by zero'
                mem[192] = 'SafeMath: subtraction overflow'
                if uint256(lastStakingBlock[address(arg1)][2][address(arg2)].field_0) <= 0 / pRECISION_FACTOR[address(arg2)]:
                    return ((0 / pRECISION_FACTOR[address(arg2)]) - uint256(lastStakingBlock[address(arg1)][2][address(arg2)].field_0))
            else:
                if accTokenPerShare[address(arg2)] * uint256(lastStakingBlock[address(arg1)].field_0) / uint256(lastStakingBlock[address(arg1)].field_0) != accTokenPerShare[address(arg2)]:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if not pRECISION_FACTOR[address(arg2)]:
                    mem[160] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[164] = 32
                    idx = 32
                    while idx < 26:
                        mem[idx + 228] = mem[idx + 128]
                        idx = idx + 32
                        continue 
                    revert with 0, 'SafeMath: division by zero'
                mem[192] = 'SafeMath: subtraction overflow'
                if uint256(lastStakingBlock[address(arg1)][2][address(arg2)].field_0) <= accTokenPerShare[address(arg2)] * uint256(lastStakingBlock[address(arg1)].field_0) / pRECISION_FACTOR[address(arg2)]:
                    return ((accTokenPerShare[address(arg2)] * uint256(lastStakingBlock[address(arg1)].field_0) / pRECISION_FACTOR[address(arg2)]) - uint256(lastStakingBlock[address(arg1)][2][address(arg2)].field_0))
            mem[224] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[228] = 32
            idx = 0
            while idx < 30:
                mem[idx + 292] = mem[idx + 192]
                idx = idx + 32
                continue 
            mem[292] = mem[294 len 30]
            revert with 0, 32, 30, mem[292]
        if not ext_call.return_data[0]:
            if not uint256(lastStakingBlock[address(arg1)].field_0):
                if not pRECISION_FACTOR[address(arg2)]:
                    mem[160] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[164] = 32
                    idx = 32
                    while idx < 26:
                        mem[idx + 228] = mem[idx + 128]
                        idx = idx + 32
                        continue 
                    revert with 0, 'SafeMath: division by zero'
                mem[192] = 'SafeMath: subtraction overflow'
                if uint256(lastStakingBlock[address(arg1)][2][address(arg2)].field_0) <= 0 / pRECISION_FACTOR[address(arg2)]:
                    return ((0 / pRECISION_FACTOR[address(arg2)]) - uint256(lastStakingBlock[address(arg1)][2][address(arg2)].field_0))
            else:
                if accTokenPerShare[address(arg2)] * uint256(lastStakingBlock[address(arg1)].field_0) / uint256(lastStakingBlock[address(arg1)].field_0) != accTokenPerShare[address(arg2)]:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if not pRECISION_FACTOR[address(arg2)]:
                    mem[160] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[164] = 32
                    idx = 32
                    while idx < 26:
                        mem[idx + 228] = mem[idx + 128]
                        idx = idx + 32
                        continue 
                    revert with 0, 'SafeMath: division by zero'
                mem[192] = 'SafeMath: subtraction overflow'
                if uint256(lastStakingBlock[address(arg1)][2][address(arg2)].field_0) <= accTokenPerShare[address(arg2)] * uint256(lastStakingBlock[address(arg1)].field_0) / pRECISION_FACTOR[address(arg2)]:
                    return ((accTokenPerShare[address(arg2)] * uint256(lastStakingBlock[address(arg1)].field_0) / pRECISION_FACTOR[address(arg2)]) - uint256(lastStakingBlock[address(arg1)][2][address(arg2)].field_0))
            mem[224] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[228] = 32
            idx = 0
            while idx < 30:
                mem[idx + 292] = mem[idx + 192]
                idx = idx + 32
                continue 
            mem[292] = mem[294 len 30]
            revert with 0, 32, 30, mem[292]
        if block.number <= bonusEndBlock:
            mem[128] = 'SafeMath: subtraction overflow'
            if lastRewardBlock > block.number:
                mem[160] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[164] = 32
                idx = 0
                while idx < 30:
                    mem[idx + 228] = mem[idx + 128]
                    idx = idx + 32
                    continue 
                mem[228] = mem[230 len 30]
                revert with 0, 32, 30, mem[228]
            if not block.number - lastRewardBlock:
                if not ext_call.return_data[0]:
                    mem[224] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[228] = 32
                    idx = 32
                    while idx < 26:
                        mem[idx + 292] = mem[idx + 192]
                        idx = idx + 32
                        continue 
                    revert with 0, 'SafeMath: division by zero'
                if (0 / ext_call.return_data[0]) + accTokenPerShare[address(arg2)] < accTokenPerShare[address(arg2)]:
                    revert with 0, 'SafeMath: addition overflow'
                if not uint256(lastStakingBlock[address(arg1)].field_0):
                    if not pRECISION_FACTOR[address(arg2)]:
                        mem[288] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[292] = 32
                        idx = 32
                        while idx < 26:
                            mem[idx + 356] = mem[idx + 256]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeMath: division by zero'
                    mem[320] = 'SafeMath: subtraction overflow'
                    if uint256(lastStakingBlock[address(arg1)][2][address(arg2)].field_0) <= 0 / pRECISION_FACTOR[address(arg2)]:
                        return ((0 / pRECISION_FACTOR[address(arg2)]) - uint256(lastStakingBlock[address(arg1)][2][address(arg2)].field_0))
                else:
                    if (0 / ext_call.return_data[0] * uint256(lastStakingBlock[address(arg1)].field_0)) + (accTokenPerShare[address(arg2)] * uint256(lastStakingBlock[address(arg1)].field_0)) / uint256(lastStakingBlock[address(arg1)].field_0) != (0 / ext_call.return_data[0]) + accTokenPerShare[address(arg2)]:
                        revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                    if not pRECISION_FACTOR[address(arg2)]:
                        mem[288] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[292] = 32
                        idx = 32
                        while idx < 26:
                            mem[idx + 356] = mem[idx + 256]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeMath: division by zero'
                    mem[320] = 'SafeMath: subtraction overflow'
                    if uint256(lastStakingBlock[address(arg1)][2][address(arg2)].field_0) <= (0 / ext_call.return_data[0] * uint256(lastStakingBlock[address(arg1)].field_0)) + (accTokenPerShare[address(arg2)] * uint256(lastStakingBlock[address(arg1)].field_0)) / pRECISION_FACTOR[address(arg2)]:
                        return (((0 / ext_call.return_data[0] * uint256(lastStakingBlock[address(arg1)].field_0)) + (accTokenPerShare[address(arg2)] * uint256(lastStakingBlock[address(arg1)].field_0)) / pRECISION_FACTOR[address(arg2)]) - uint256(lastStakingBlock[address(arg1)][2][address(arg2)].field_0))
            else:
                if (block.number * rewardPerBlock[address(arg2)]) - (lastRewardBlock * rewardPerBlock[address(arg2)]) / block.number - lastRewardBlock != rewardPerBlock[address(arg2)]:
                    revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                if not (block.number * rewardPerBlock[address(arg2)]) - (lastRewardBlock * rewardPerBlock[address(arg2)]):
                    if not ext_call.return_data[0]:
                        mem[224] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[228] = 32
                        idx = 32
                        while idx < 26:
                            mem[idx + 292] = mem[idx + 192]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeMath: division by zero'
                    if (0 / ext_call.return_data[0]) + accTokenPerShare[address(arg2)] < accTokenPerShare[address(arg2)]:
                        revert with 0, 'SafeMath: addition overflow'
                    if not uint256(lastStakingBlock[address(arg1)].field_0):
                        if not pRECISION_FACTOR[address(arg2)]:
                            mem[288] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[292] = 32
                            idx = 32
                            while idx < 26:
                                mem[idx + 356] = mem[idx + 256]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        mem[320] = 'SafeMath: subtraction overflow'
                        if uint256(lastStakingBlock[address(arg1)][2][address(arg2)].field_0) <= 0 / pRECISION_FACTOR[address(arg2)]:
                            return ((0 / pRECISION_FACTOR[address(arg2)]) - uint256(lastStakingBlock[address(arg1)][2][address(arg2)].field_0))
                    else:
                        if (0 / ext_call.return_data[0] * uint256(lastStakingBlock[address(arg1)].field_0)) + (accTokenPerShare[address(arg2)] * uint256(lastStakingBlock[address(arg1)].field_0)) / uint256(lastStakingBlock[address(arg1)].field_0) != (0 / ext_call.return_data[0]) + accTokenPerShare[address(arg2)]:
                            revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                        if not pRECISION_FACTOR[address(arg2)]:
                            mem[288] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[292] = 32
                            idx = 32
                            while idx < 26:
                                mem[idx + 356] = mem[idx + 256]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        mem[320] = 'SafeMath: subtraction overflow'
                        if uint256(lastStakingBlock[address(arg1)][2][address(arg2)].field_0) <= (0 / ext_call.return_data[0] * uint256(lastStakingBlock[address(arg1)].field_0)) + (accTokenPerShare[address(arg2)] * uint256(lastStakingBlock[address(arg1)].field_0)) / pRECISION_FACTOR[address(arg2)]:
                            return (((0 / ext_call.return_data[0] * uint256(lastStakingBlock[address(arg1)].field_0)) + (accTokenPerShare[address(arg2)] * uint256(lastStakingBlock[address(arg1)].field_0)) / pRECISION_FACTOR[address(arg2)]) - uint256(lastStakingBlock[address(arg1)][2][address(arg2)].field_0))
                else:
                    if (block.number * rewardPerBlock[address(arg2)] * pRECISION_FACTOR[address(arg2)]) - (lastRewardBlock * rewardPerBlock[address(arg2)] * pRECISION_FACTOR[address(arg2)]) / (block.number * rewardPerBlock[address(arg2)]) - (lastRewardBlock * rewardPerBlock[address(arg2)]) != pRECISION_FACTOR[address(arg2)]:
                        revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                    if not ext_call.return_data[0]:
                        mem[224] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[228] = 32
                        idx = 32
                        while idx < 26:
                            mem[idx + 292] = mem[idx + 192]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeMath: division by zero'
                    if ((block.number * rewardPerBlock[address(arg2)] * pRECISION_FACTOR[address(arg2)]) - (lastRewardBlock * rewardPerBlock[address(arg2)] * pRECISION_FACTOR[address(arg2)]) / ext_call.return_data[0]) + accTokenPerShare[address(arg2)] < accTokenPerShare[address(arg2)]:
                        revert with 0, 'SafeMath: addition overflow'
                    if not uint256(lastStakingBlock[address(arg1)].field_0):
                        if not pRECISION_FACTOR[address(arg2)]:
                            mem[288] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[292] = 32
                            idx = 32
                            while idx < 26:
                                mem[idx + 356] = mem[idx + 256]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        mem[320] = 'SafeMath: subtraction overflow'
                        if uint256(lastStakingBlock[address(arg1)][2][address(arg2)].field_0) <= 0 / pRECISION_FACTOR[address(arg2)]:
                            return ((0 / pRECISION_FACTOR[address(arg2)]) - uint256(lastStakingBlock[address(arg1)][2][address(arg2)].field_0))
                    else:
                        if ((block.number * rewardPerBlock[address(arg2)] * pRECISION_FACTOR[address(arg2)]) - (lastRewardBlock * rewardPerBlock[address(arg2)] * pRECISION_FACTOR[address(arg2)]) / ext_call.return_data[0] * uint256(lastStakingBlock[address(arg1)].field_0)) + (accTokenPerShare[address(arg2)] * uint256(lastStakingBlock[address(arg1)].field_0)) / uint256(lastStakingBlock[address(arg1)].field_0) != ((block.number * rewardPerBlock[address(arg2)] * pRECISION_FACTOR[address(arg2)]) - (lastRewardBlock * rewardPerBlock[address(arg2)] * pRECISION_FACTOR[address(arg2)]) / ext_call.return_data[0]) + accTokenPerShare[address(arg2)]:
                            revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                        if not pRECISION_FACTOR[address(arg2)]:
                            mem[288] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[292] = 32
                            idx = 32
                            while idx < 26:
                                mem[idx + 356] = mem[idx + 256]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        mem[320] = 'SafeMath: subtraction overflow'
                        if uint256(lastStakingBlock[address(arg1)][2][address(arg2)].field_0) <= ((block.number * rewardPerBlock[address(arg2)] * pRECISION_FACTOR[address(arg2)]) - (lastRewardBlock * rewardPerBlock[address(arg2)] * pRECISION_FACTOR[address(arg2)]) / ext_call.return_data[0] * uint256(lastStakingBlock[address(arg1)].field_0)) + (accTokenPerShare[address(arg2)] * uint256(lastStakingBlock[address(arg1)].field_0)) / pRECISION_FACTOR[address(arg2)]:
                            return ((((block.number * rewardPerBlock[address(arg2)] * pRECISION_FACTOR[address(arg2)]) - (lastRewardBlock * rewardPerBlock[address(arg2)] * pRECISION_FACTOR[address(arg2)]) / ext_call.return_data[0] * uint256(lastStakingBlock[address(arg1)].field_0)) + (accTokenPerShare[address(arg2)] * uint256(lastStakingBlock[address(arg1)].field_0)) / pRECISION_FACTOR[address(arg2)]) - uint256(lastStakingBlock[address(arg1)][2][address(arg2)].field_0))
        else:
            if lastRewardBlock >= bonusEndBlock:
                if not ext_call.return_data[0]:
                    mem[160] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[164] = 32
                    idx = 32
                    while idx < 26:
                        mem[idx + 228] = mem[idx + 128]
                        idx = idx + 32
                        continue 
                    revert with 0, 'SafeMath: division by zero'
                if (0 / ext_call.return_data[0]) + accTokenPerShare[address(arg2)] < accTokenPerShare[address(arg2)]:
                    revert with 0, 'SafeMath: addition overflow'
                if not uint256(lastStakingBlock[address(arg1)].field_0):
                    if not pRECISION_FACTOR[address(arg2)]:
                        mem[224] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[228] = 32
                        idx = 32
                        while idx < 26:
                            mem[idx + 292] = mem[idx + 192]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeMath: division by zero'
                    mem[256] = 'SafeMath: subtraction overflow'
                    if uint256(lastStakingBlock[address(arg1)][2][address(arg2)].field_0) <= 0 / pRECISION_FACTOR[address(arg2)]:
                        return ((0 / pRECISION_FACTOR[address(arg2)]) - uint256(lastStakingBlock[address(arg1)][2][address(arg2)].field_0))
                else:
                    if (0 / ext_call.return_data[0] * uint256(lastStakingBlock[address(arg1)].field_0)) + (accTokenPerShare[address(arg2)] * uint256(lastStakingBlock[address(arg1)].field_0)) / uint256(lastStakingBlock[address(arg1)].field_0) != (0 / ext_call.return_data[0]) + accTokenPerShare[address(arg2)]:
                        revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                    if not pRECISION_FACTOR[address(arg2)]:
                        mem[224] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[228] = 32
                        idx = 32
                        while idx < 26:
                            mem[idx + 292] = mem[idx + 192]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeMath: division by zero'
                    mem[256] = 'SafeMath: subtraction overflow'
                    if uint256(lastStakingBlock[address(arg1)][2][address(arg2)].field_0) <= (0 / ext_call.return_data[0] * uint256(lastStakingBlock[address(arg1)].field_0)) + (accTokenPerShare[address(arg2)] * uint256(lastStakingBlock[address(arg1)].field_0)) / pRECISION_FACTOR[address(arg2)]:
                        return (((0 / ext_call.return_data[0] * uint256(lastStakingBlock[address(arg1)].field_0)) + (accTokenPerShare[address(arg2)] * uint256(lastStakingBlock[address(arg1)].field_0)) / pRECISION_FACTOR[address(arg2)]) - uint256(lastStakingBlock[address(arg1)][2][address(arg2)].field_0))
                mem[288] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[292] = 32
                idx = 0
                while idx < 30:
                    mem[idx + 356] = mem[idx + 256]
                    idx = idx + 32
                    continue 
                mem[356] = mem[358 len 30]
                revert with 0, 32, 30, mem[356]
            mem[128] = 'SafeMath: subtraction overflow'
            if lastRewardBlock > bonusEndBlock:
                mem[160] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[164] = 32
                idx = 0
                while idx < 30:
                    mem[idx + 228] = mem[idx + 128]
                    idx = idx + 32
                    continue 
                mem[228] = mem[230 len 30]
                revert with 0, 32, 30, mem[228]
            if not bonusEndBlock - lastRewardBlock:
                if not ext_call.return_data[0]:
                    mem[224] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[228] = 32
                    idx = 32
                    while idx < 26:
                        mem[idx + 292] = mem[idx + 192]
                        idx = idx + 32
                        continue 
                    revert with 0, 'SafeMath: division by zero'
                if (0 / ext_call.return_data[0]) + accTokenPerShare[address(arg2)] < accTokenPerShare[address(arg2)]:
                    revert with 0, 'SafeMath: addition overflow'
                if not uint256(lastStakingBlock[address(arg1)].field_0):
                    if not pRECISION_FACTOR[address(arg2)]:
                        mem[288] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[292] = 32
                        idx = 32
                        while idx < 26:
                            mem[idx + 356] = mem[idx + 256]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeMath: division by zero'
                    mem[320] = 'SafeMath: subtraction overflow'
                    if uint256(lastStakingBlock[address(arg1)][2][address(arg2)].field_0) <= 0 / pRECISION_FACTOR[address(arg2)]:
                        return ((0 / pRECISION_FACTOR[address(arg2)]) - uint256(lastStakingBlock[address(arg1)][2][address(arg2)].field_0))
                else:
                    if (0 / ext_call.return_data[0] * uint256(lastStakingBlock[address(arg1)].field_0)) + (accTokenPerShare[address(arg2)] * uint256(lastStakingBlock[address(arg1)].field_0)) / uint256(lastStakingBlock[address(arg1)].field_0) != (0 / ext_call.return_data[0]) + accTokenPerShare[address(arg2)]:
                        revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                    if not pRECISION_FACTOR[address(arg2)]:
                        mem[288] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[292] = 32
                        idx = 32
                        while idx < 26:
                            mem[idx + 356] = mem[idx + 256]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeMath: division by zero'
                    mem[320] = 'SafeMath: subtraction overflow'
                    if uint256(lastStakingBlock[address(arg1)][2][address(arg2)].field_0) <= (0 / ext_call.return_data[0] * uint256(lastStakingBlock[address(arg1)].field_0)) + (accTokenPerShare[address(arg2)] * uint256(lastStakingBlock[address(arg1)].field_0)) / pRECISION_FACTOR[address(arg2)]:
                        return (((0 / ext_call.return_data[0] * uint256(lastStakingBlock[address(arg1)].field_0)) + (accTokenPerShare[address(arg2)] * uint256(lastStakingBlock[address(arg1)].field_0)) / pRECISION_FACTOR[address(arg2)]) - uint256(lastStakingBlock[address(arg1)][2][address(arg2)].field_0))
            else:
                if (bonusEndBlock * rewardPerBlock[address(arg2)]) - (lastRewardBlock * rewardPerBlock[address(arg2)]) / bonusEndBlock - lastRewardBlock != rewardPerBlock[address(arg2)]:
                    revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                if not (bonusEndBlock * rewardPerBlock[address(arg2)]) - (lastRewardBlock * rewardPerBlock[address(arg2)]):
                    if not ext_call.return_data[0]:
                        mem[224] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[228] = 32
                        idx = 32
                        while idx < 26:
                            mem[idx + 292] = mem[idx + 192]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeMath: division by zero'
                    if (0 / ext_call.return_data[0]) + accTokenPerShare[address(arg2)] < accTokenPerShare[address(arg2)]:
                        revert with 0, 'SafeMath: addition overflow'
                    if not uint256(lastStakingBlock[address(arg1)].field_0):
                        if not pRECISION_FACTOR[address(arg2)]:
                            mem[288] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[292] = 32
                            idx = 32
                            while idx < 26:
                                mem[idx + 356] = mem[idx + 256]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        mem[320] = 'SafeMath: subtraction overflow'
                        if uint256(lastStakingBlock[address(arg1)][2][address(arg2)].field_0) <= 0 / pRECISION_FACTOR[address(arg2)]:
                            return ((0 / pRECISION_FACTOR[address(arg2)]) - uint256(lastStakingBlock[address(arg1)][2][address(arg2)].field_0))
                    else:
                        if (0 / ext_call.return_data[0] * uint256(lastStakingBlock[address(arg1)].field_0)) + (accTokenPerShare[address(arg2)] * uint256(lastStakingBlock[address(arg1)].field_0)) / uint256(lastStakingBlock[address(arg1)].field_0) != (0 / ext_call.return_data[0]) + accTokenPerShare[address(arg2)]:
                            revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                        if not pRECISION_FACTOR[address(arg2)]:
                            mem[288] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[292] = 32
                            idx = 32
                            while idx < 26:
                                mem[idx + 356] = mem[idx + 256]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        mem[320] = 'SafeMath: subtraction overflow'
                        if uint256(lastStakingBlock[address(arg1)][2][address(arg2)].field_0) <= (0 / ext_call.return_data[0] * uint256(lastStakingBlock[address(arg1)].field_0)) + (accTokenPerShare[address(arg2)] * uint256(lastStakingBlock[address(arg1)].field_0)) / pRECISION_FACTOR[address(arg2)]:
                            return (((0 / ext_call.return_data[0] * uint256(lastStakingBlock[address(arg1)].field_0)) + (accTokenPerShare[address(arg2)] * uint256(lastStakingBlock[address(arg1)].field_0)) / pRECISION_FACTOR[address(arg2)]) - uint256(lastStakingBlock[address(arg1)][2][address(arg2)].field_0))
                else:
                    if (bonusEndBlock * rewardPerBlock[address(arg2)] * pRECISION_FACTOR[address(arg2)]) - (lastRewardBlock * rewardPerBlock[address(arg2)] * pRECISION_FACTOR[address(arg2)]) / (bonusEndBlock * rewardPerBlock[address(arg2)]) - (lastRewardBlock * rewardPerBlock[address(arg2)]) != pRECISION_FACTOR[address(arg2)]:
                        revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                    if not ext_call.return_data[0]:
                        mem[224] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[228] = 32
                        idx = 32
                        while idx < 26:
                            mem[idx + 292] = mem[idx + 192]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeMath: division by zero'
                    if ((bonusEndBlock * rewardPerBlock[address(arg2)] * pRECISION_FACTOR[address(arg2)]) - (lastRewardBlock * rewardPerBlock[address(arg2)] * pRECISION_FACTOR[address(arg2)]) / ext_call.return_data[0]) + accTokenPerShare[address(arg2)] < accTokenPerShare[address(arg2)]:
                        revert with 0, 'SafeMath: addition overflow'
                    if not uint256(lastStakingBlock[address(arg1)].field_0):
                        if not pRECISION_FACTOR[address(arg2)]:
                            mem[288] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[292] = 32
                            idx = 32
                            while idx < 26:
                                mem[idx + 356] = mem[idx + 256]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        mem[320] = 'SafeMath: subtraction overflow'
                        if uint256(lastStakingBlock[address(arg1)][2][address(arg2)].field_0) <= 0 / pRECISION_FACTOR[address(arg2)]:
                            return ((0 / pRECISION_FACTOR[address(arg2)]) - uint256(lastStakingBlock[address(arg1)][2][address(arg2)].field_0))
                    else:
                        if ((bonusEndBlock * rewardPerBlock[address(arg2)] * pRECISION_FACTOR[address(arg2)]) - (lastRewardBlock * rewardPerBlock[address(arg2)] * pRECISION_FACTOR[address(arg2)]) / ext_call.return_data[0] * uint256(lastStakingBlock[address(arg1)].field_0)) + (accTokenPerShare[address(arg2)] * uint256(lastStakingBlock[address(arg1)].field_0)) / uint256(lastStakingBlock[address(arg1)].field_0) != ((bonusEndBlock * rewardPerBlock[address(arg2)] * pRECISION_FACTOR[address(arg2)]) - (lastRewardBlock * rewardPerBlock[address(arg2)] * pRECISION_FACTOR[address(arg2)]) / ext_call.return_data[0]) + accTokenPerShare[address(arg2)]:
                            revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                        if not pRECISION_FACTOR[address(arg2)]:
                            mem[288] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[292] = 32
                            idx = 32
                            while idx < 26:
                                mem[idx + 356] = mem[idx + 256]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        mem[320] = 'SafeMath: subtraction overflow'
                        if uint256(lastStakingBlock[address(arg1)][2][address(arg2)].field_0) <= ((bonusEndBlock * rewardPerBlock[address(arg2)] * pRECISION_FACTOR[address(arg2)]) - (lastRewardBlock * rewardPerBlock[address(arg2)] * pRECISION_FACTOR[address(arg2)]) / ext_call.return_data[0] * uint256(lastStakingBlock[address(arg1)].field_0)) + (accTokenPerShare[address(arg2)] * uint256(lastStakingBlock[address(arg1)].field_0)) / pRECISION_FACTOR[address(arg2)]:
                            return ((((bonusEndBlock * rewardPerBlock[address(arg2)] * pRECISION_FACTOR[address(arg2)]) - (lastRewardBlock * rewardPerBlock[address(arg2)] * pRECISION_FACTOR[address(arg2)]) / ext_call.return_data[0] * uint256(lastStakingBlock[address(arg1)].field_0)) + (accTokenPerShare[address(arg2)] * uint256(lastStakingBlock[address(arg1)].field_0)) / pRECISION_FACTOR[address(arg2)]) - uint256(lastStakingBlock[address(arg1)][2][address(arg2)].field_0))
        mem[352] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[356] = 32
        idx = 0
        while idx < 30:
            mem[idx + 420] = mem[idx + 320]
            idx = idx + 32
            continue 
        mem[420] = mem[422 len 30]
        revert with 0, 32, 30, mem[420]
    return 0
}

function withdraw(bool arg1) payable {
    mem[64] = 96
    require calldata.size - 4 >= 32
    if stor3 == 2:
        revert with 0, 'ReentrancyGuard: reentrant call'
    stor3 = 2
    if arg1:
        mem[0] = msg.sender
        mem[32] = 28
        if 0 > uint256(lastStakingBlock[msg.sender].field_0):
            revert with 0, 'Amount to withdraw too high'
        if block.number <= lastRewardBlock:
            idx = 0
            s = 0
            while idx < rewardTokens.length:
                mem[0] = rewardTokens[idx].field_0
                mem[32] = 10
                if not uint256(lastStakingBlock[msg.sender].field_0):
                    _617 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_617] = 26
                    mem[_617 + 32] = 'SafeMath: division by zero'
                    if not pRECISION_FACTOR[stor26[idx].field_0]:
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                        idx = 32
                        while idx < 26:
                            mem[idx + mem[64] + 68] = mem[idx + _617 + 32]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeMath: division by zero'
                    _765 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_765] = 30
                    mem[_765 + 32] = 'SafeMath: subtraction overflow'
                    if uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) > 0 / pRECISION_FACTOR[stor26[idx].field_0]:
                        _874 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _874 + 68] = mem[idx + _765 + 32]
                            idx = idx + 32
                            continue 
                        mem[_874 + 68] = mem[_874 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _874 + -mem[64] + 100
                    if (0 / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0):
                        require idx < rewardTokens.length
                        mem[0] = 26
                        require ext_code.size(rewardTokens[idx].field_0)
                        staticcall rewardTokens[idx].field_0.0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[mem[64] + 4] = msg.sender
                        if (0 / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) <= ext_call.return_data[0]:
                            mem[mem[64] + 36] = (0 / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                            require ext_code.size(rewardTokens[idx].field_0)
                            call rewardTokens[idx].field_0.0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, (0 / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                        else:
                            mem[mem[64] + 36] = ext_call.return_data[0]
                            require ext_code.size(rewardTokens[idx].field_0)
                            call rewardTokens[idx].field_0.0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, ext_call.return_data[0]
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                    idx = idx + 1
                    s = (0 / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                    continue 
                if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                    revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _630 = mem[64]
                mem[64] = mem[64] + 64
                mem[_630] = 26
                mem[_630 + 32] = 'SafeMath: division by zero'
                if not pRECISION_FACTOR[stor26[idx].field_0]:
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                    idx = 32
                    while idx < 26:
                        mem[idx + mem[64] + 68] = mem[idx + _630 + 32]
                        idx = idx + 32
                        continue 
                    revert with 0, 'SafeMath: division by zero'
                _816 = mem[64]
                mem[64] = mem[64] + 64
                mem[_816] = 30
                mem[_816 + 32] = 'SafeMath: subtraction overflow'
                if uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) > accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]:
                    _943 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _943 + 68] = mem[idx + _816 + 32]
                        idx = idx + 32
                        continue 
                    mem[_943 + 68] = mem[_943 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _943 + -mem[64] + 100
                if (accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0):
                    require idx < rewardTokens.length
                    mem[0] = 26
                    require ext_code.size(rewardTokens[idx].field_0)
                    staticcall rewardTokens[idx].field_0.0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[mem[64] + 4] = msg.sender
                    if (accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) <= ext_call.return_data[0]:
                        mem[mem[64] + 36] = (accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                        require ext_code.size(rewardTokens[idx].field_0)
                        call rewardTokens[idx].field_0.0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, (accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                    else:
                        mem[mem[64] + 36] = ext_call.return_data[0]
                        require ext_code.size(rewardTokens[idx].field_0)
                        call rewardTokens[idx].field_0.0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, ext_call.return_data[0]
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                idx = idx + 1
                s = (accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                continue 
            idx = 0
            while idx < rewardTokens.length:
                mem[0] = rewardTokens[idx].field_0
                mem[32] = 10
                if not uint256(lastStakingBlock[msg.sender].field_0):
                    _3527 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3527] = 26
                    mem[_3527 + 32] = 'SafeMath: division by zero'
                    if pRECISION_FACTOR[stor26[idx].field_0]:
                        require idx < rewardTokens.length
                        mem[0] = rewardTokens[idx].field_0
                        mem[32] = sha3(msg.sender, 28) + 2
                        uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                        idx = idx + 1
                        continue 
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                    s = 32
                    while s < 26:
                        mem[s + mem[64] + 68] = mem[s + _3527 + 32]
                        s = s + 32
                        continue 
                else:
                    if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                        revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _3556 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3556] = 26
                    mem[_3556 + 32] = 'SafeMath: division by zero'
                    if pRECISION_FACTOR[stor26[idx].field_0]:
                        require idx < rewardTokens.length
                        mem[0] = rewardTokens[idx].field_0
                        mem[32] = sha3(msg.sender, 28) + 2
                        uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                        idx = idx + 1
                        continue 
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                    idx = 32
                    while idx < 26:
                        mem[idx + mem[64] + 68] = mem[idx + _3556 + 32]
                        idx = idx + 32
                        continue 
                revert with 0, 'SafeMath: division by zero'
        else:
            mem[100] = this.address
            require ext_code.size(stakedTokenAddress)
            staticcall stakedTokenAddress.0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            mem[96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if not ext_call.return_data[0]:
                lastRewardBlock = block.number
                idx = 0
                s = 0
                while idx < rewardTokens.length:
                    mem[0] = rewardTokens[idx].field_0
                    mem[32] = 10
                    if not uint256(lastStakingBlock[msg.sender].field_0):
                        _616 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_616] = 26
                        mem[_616 + 32] = 'SafeMath: division by zero'
                        if not pRECISION_FACTOR[stor26[idx].field_0]:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _616 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        _757 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_757] = 30
                        mem[_757 + 32] = 'SafeMath: subtraction overflow'
                        if uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) > 0 / pRECISION_FACTOR[stor26[idx].field_0]:
                            _864 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _864 + 68] = mem[idx + _757 + 32]
                                idx = idx + 32
                                continue 
                            mem[_864 + 68] = mem[_864 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _864 + -mem[64] + 100
                        if (0 / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0):
                            require idx < rewardTokens.length
                            mem[0] = 26
                            require ext_code.size(rewardTokens[idx].field_0)
                            staticcall rewardTokens[idx].field_0.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[mem[64] + 4] = msg.sender
                            if (0 / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) <= ext_call.return_data[0]:
                                mem[mem[64] + 36] = (0 / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                                require ext_code.size(rewardTokens[idx].field_0)
                                call rewardTokens[idx].field_0.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, (0 / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                            else:
                                mem[mem[64] + 36] = ext_call.return_data[0]
                                require ext_code.size(rewardTokens[idx].field_0)
                                call rewardTokens[idx].field_0.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, ext_call.return_data[0]
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                        idx = idx + 1
                        s = (0 / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                        continue 
                    if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                        revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _627 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_627] = 26
                    mem[_627 + 32] = 'SafeMath: division by zero'
                    if not pRECISION_FACTOR[stor26[idx].field_0]:
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                        idx = 32
                        while idx < 26:
                            mem[idx + mem[64] + 68] = mem[idx + _627 + 32]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeMath: division by zero'
                    _808 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_808] = 30
                    mem[_808 + 32] = 'SafeMath: subtraction overflow'
                    if uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) > accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]:
                        _935 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _935 + 68] = mem[idx + _808 + 32]
                            idx = idx + 32
                            continue 
                        mem[_935 + 68] = mem[_935 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _935 + -mem[64] + 100
                    if (accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0):
                        require idx < rewardTokens.length
                        mem[0] = 26
                        require ext_code.size(rewardTokens[idx].field_0)
                        staticcall rewardTokens[idx].field_0.0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[mem[64] + 4] = msg.sender
                        if (accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) <= ext_call.return_data[0]:
                            mem[mem[64] + 36] = (accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                            require ext_code.size(rewardTokens[idx].field_0)
                            call rewardTokens[idx].field_0.0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, (accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                        else:
                            mem[mem[64] + 36] = ext_call.return_data[0]
                            require ext_code.size(rewardTokens[idx].field_0)
                            call rewardTokens[idx].field_0.0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, ext_call.return_data[0]
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                    idx = idx + 1
                    s = (accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                    continue 
                idx = 0
                while idx < rewardTokens.length:
                    mem[0] = rewardTokens[idx].field_0
                    mem[32] = 10
                    if not uint256(lastStakingBlock[msg.sender].field_0):
                        _3526 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3526] = 26
                        mem[_3526 + 32] = 'SafeMath: division by zero'
                        if pRECISION_FACTOR[stor26[idx].field_0]:
                            require idx < rewardTokens.length
                            mem[0] = rewardTokens[idx].field_0
                            mem[32] = sha3(msg.sender, 28) + 2
                            uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                            idx = idx + 1
                            continue 
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                        s = 32
                        while s < 26:
                            mem[s + mem[64] + 68] = mem[s + _3526 + 32]
                            s = s + 32
                            continue 
                    else:
                        if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                            revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _3555 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3555] = 26
                        mem[_3555 + 32] = 'SafeMath: division by zero'
                        if pRECISION_FACTOR[stor26[idx].field_0]:
                            require idx < rewardTokens.length
                            mem[0] = rewardTokens[idx].field_0
                            mem[32] = sha3(msg.sender, 28) + 2
                            uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                            idx = idx + 1
                            continue 
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                        idx = 32
                        while idx < 26:
                            mem[idx + mem[64] + 68] = mem[idx + _3555 + 32]
                            idx = idx + 32
                            continue 
                    revert with 0, 'SafeMath: division by zero'
            else:
                if block.number <= bonusEndBlock:
                    mem[64] = 160
                    mem[96] = 30
                    mem[128] = 'SafeMath: subtraction overflow'
                    if lastRewardBlock > block.number:
                        revert with 0, 'SafeMath: subtraction overflow'
                    idx = 0
                    while idx < rewardTokens.length:
                        if not block.number - lastRewardBlock:
                            require idx < rewardTokens.length
                            mem[0] = rewardTokens[idx].field_0
                            mem[32] = 25
                            _653 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_653] = 26
                            mem[_653 + 32] = 'SafeMath: division by zero'
                            if not ext_call.return_data[0]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _653 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            require idx < rewardTokens.length
                            if (0 / ext_call.return_data[0]) + accTokenPerShare[stor26[idx].field_0] < accTokenPerShare[stor26[idx].field_0]:
                                revert with 0, 'SafeMath: addition overflow'
                            require idx < rewardTokens.length
                            mem[0] = rewardTokens[idx].field_0
                            mem[32] = 10
                            accTokenPerShare[stor26[idx].field_0] += 0 / ext_call.return_data[0]
                        else:
                            if (block.number * rewardPerBlock[stor26[idx].field_0]) - (lastRewardBlock * rewardPerBlock[stor26[idx].field_0]) / block.number - lastRewardBlock != rewardPerBlock[stor26[idx].field_0]:
                                revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            require idx < rewardTokens.length
                            mem[0] = rewardTokens[idx].field_0
                            mem[32] = 25
                            if not (block.number * rewardPerBlock[stor26[idx].field_0]) - (lastRewardBlock * rewardPerBlock[stor26[idx].field_0]):
                                _671 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_671] = 26
                                mem[_671 + 32] = 'SafeMath: division by zero'
                                if not ext_call.return_data[0]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _671 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                require idx < rewardTokens.length
                                if (0 / ext_call.return_data[0]) + accTokenPerShare[stor26[idx].field_0] < accTokenPerShare[stor26[idx].field_0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require idx < rewardTokens.length
                                mem[0] = rewardTokens[idx].field_0
                                mem[32] = 10
                                accTokenPerShare[stor26[idx].field_0] += 0 / ext_call.return_data[0]
                            else:
                                if (block.number * rewardPerBlock[stor26[idx].field_0] * pRECISION_FACTOR[stor26[idx].field_0]) - (lastRewardBlock * rewardPerBlock[stor26[idx].field_0] * pRECISION_FACTOR[stor26[idx].field_0]) / (block.number * rewardPerBlock[stor26[idx].field_0]) - (lastRewardBlock * rewardPerBlock[stor26[idx].field_0]) != pRECISION_FACTOR[stor26[idx].field_0]:
                                    revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _705 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_705] = 26
                                mem[_705 + 32] = 'SafeMath: division by zero'
                                if not ext_call.return_data[0]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _705 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                require idx < rewardTokens.length
                                if ((block.number * rewardPerBlock[stor26[idx].field_0] * pRECISION_FACTOR[stor26[idx].field_0]) - (lastRewardBlock * rewardPerBlock[stor26[idx].field_0] * pRECISION_FACTOR[stor26[idx].field_0]) / ext_call.return_data[0]) + accTokenPerShare[stor26[idx].field_0] < accTokenPerShare[stor26[idx].field_0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require idx < rewardTokens.length
                                mem[0] = rewardTokens[idx].field_0
                                mem[32] = 10
                                accTokenPerShare[stor26[idx].field_0] += (block.number * rewardPerBlock[stor26[idx].field_0] * pRECISION_FACTOR[stor26[idx].field_0]) - (lastRewardBlock * rewardPerBlock[stor26[idx].field_0] * pRECISION_FACTOR[stor26[idx].field_0]) / ext_call.return_data[0]
                        idx = idx + 1
                        continue 
                    lastRewardBlock = block.number
                    idx = 0
                    s = 0
                    while idx < rewardTokens.length:
                        mem[0] = rewardTokens[idx].field_0
                        mem[32] = 10
                        if not uint256(lastStakingBlock[msg.sender].field_0):
                            _3554 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3554] = 26
                            mem[_3554 + 32] = 'SafeMath: division by zero'
                            if not pRECISION_FACTOR[stor26[idx].field_0]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _3554 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            _3843 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3843] = 30
                            mem[_3843 + 32] = 'SafeMath: subtraction overflow'
                            if uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) > 0 / pRECISION_FACTOR[stor26[idx].field_0]:
                                _4003 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _4003 + 68] = mem[idx + _3843 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4003 + 68] = mem[_4003 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _4003 + -mem[64] + 100
                            if (0 / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0):
                                require idx < rewardTokens.length
                                mem[0] = 26
                                require ext_code.size(rewardTokens[idx].field_0)
                                staticcall rewardTokens[idx].field_0.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[mem[64] + 4] = msg.sender
                                if (0 / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) <= ext_call.return_data[0]:
                                    mem[mem[64] + 36] = (0 / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                                    require ext_code.size(rewardTokens[idx].field_0)
                                    call rewardTokens[idx].field_0.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, (0 / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                                else:
                                    mem[mem[64] + 36] = ext_call.return_data[0]
                                    require ext_code.size(rewardTokens[idx].field_0)
                                    call rewardTokens[idx].field_0.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, ext_call.return_data[0]
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                            idx = idx + 1
                            s = (0 / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                            continue 
                        if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                            revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _3588 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3588] = 26
                        mem[_3588 + 32] = 'SafeMath: division by zero'
                        if not pRECISION_FACTOR[stor26[idx].field_0]:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _3588 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        _3915 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3915] = 30
                        mem[_3915 + 32] = 'SafeMath: subtraction overflow'
                        if uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) > accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]:
                            _4081 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _4081 + 68] = mem[idx + _3915 + 32]
                                idx = idx + 32
                                continue 
                            mem[_4081 + 68] = mem[_4081 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _4081 + -mem[64] + 100
                        if (accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0):
                            require idx < rewardTokens.length
                            mem[0] = 26
                            require ext_code.size(rewardTokens[idx].field_0)
                            staticcall rewardTokens[idx].field_0.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[mem[64] + 4] = msg.sender
                            if (accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) <= ext_call.return_data[0]:
                                mem[mem[64] + 36] = (accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                                require ext_code.size(rewardTokens[idx].field_0)
                                call rewardTokens[idx].field_0.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, (accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                            else:
                                mem[mem[64] + 36] = ext_call.return_data[0]
                                require ext_code.size(rewardTokens[idx].field_0)
                                call rewardTokens[idx].field_0.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, ext_call.return_data[0]
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                        idx = idx + 1
                        s = (accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                        continue 
                    idx = 0
                    while idx < rewardTokens.length:
                        mem[0] = rewardTokens[idx].field_0
                        mem[32] = 10
                        if not uint256(lastStakingBlock[msg.sender].field_0):
                            _6480 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6480] = 26
                            mem[_6480 + 32] = 'SafeMath: division by zero'
                            if pRECISION_FACTOR[stor26[idx].field_0]:
                                require idx < rewardTokens.length
                                mem[0] = rewardTokens[idx].field_0
                                mem[32] = sha3(msg.sender, 28) + 2
                                uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            s = 32
                            while s < 26:
                                mem[s + mem[64] + 68] = mem[s + _6480 + 32]
                                s = s + 32
                                continue 
                        else:
                            if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _6509 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6509] = 26
                            mem[_6509 + 32] = 'SafeMath: division by zero'
                            if pRECISION_FACTOR[stor26[idx].field_0]:
                                require idx < rewardTokens.length
                                mem[0] = rewardTokens[idx].field_0
                                mem[32] = sha3(msg.sender, 28) + 2
                                uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _6509 + 32]
                                idx = idx + 32
                                continue 
                        revert with 0, 'SafeMath: division by zero'
                else:
                    if lastRewardBlock >= bonusEndBlock:
                        idx = 0
                        while idx < rewardTokens.length:
                            require idx < rewardTokens.length
                            mem[0] = rewardTokens[idx].field_0
                            mem[32] = 25
                            _648 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_648] = 26
                            mem[_648 + 32] = 'SafeMath: division by zero'
                            if not ext_call.return_data[0]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _648 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            require idx < rewardTokens.length
                            if (0 / ext_call.return_data[0]) + accTokenPerShare[stor26[idx].field_0] < accTokenPerShare[stor26[idx].field_0]:
                                revert with 0, 'SafeMath: addition overflow'
                            require idx < rewardTokens.length
                            mem[0] = rewardTokens[idx].field_0
                            mem[32] = 10
                            accTokenPerShare[stor26[idx].field_0] += 0 / ext_call.return_data[0]
                            idx = idx + 1
                            continue 
                        lastRewardBlock = block.number
                        idx = 0
                        s = 0
                        while idx < rewardTokens.length:
                            mem[0] = rewardTokens[idx].field_0
                            mem[32] = 10
                            if not uint256(lastStakingBlock[msg.sender].field_0):
                                _3553 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3553] = 26
                                mem[_3553 + 32] = 'SafeMath: division by zero'
                                if not pRECISION_FACTOR[stor26[idx].field_0]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _3553 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                _3835 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3835] = 30
                                mem[_3835 + 32] = 'SafeMath: subtraction overflow'
                                if uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) > 0 / pRECISION_FACTOR[stor26[idx].field_0]:
                                    _3993 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _3993 + 68] = mem[idx + _3835 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_3993 + 68] = mem[_3993 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _3993 + -mem[64] + 100
                                if (0 / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0):
                                    require idx < rewardTokens.length
                                    mem[0] = 26
                                    require ext_code.size(rewardTokens[idx].field_0)
                                    staticcall rewardTokens[idx].field_0.0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[mem[64] + 4] = msg.sender
                                    if (0 / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) <= ext_call.return_data[0]:
                                        mem[mem[64] + 36] = (0 / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                                        require ext_code.size(rewardTokens[idx].field_0)
                                        call rewardTokens[idx].field_0.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, (0 / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                                    else:
                                        mem[mem[64] + 36] = ext_call.return_data[0]
                                        require ext_code.size(rewardTokens[idx].field_0)
                                        call rewardTokens[idx].field_0.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, ext_call.return_data[0]
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                idx = idx + 1
                                s = (0 / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                                continue 
                            if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _3585 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3585] = 26
                            mem[_3585 + 32] = 'SafeMath: division by zero'
                            if not pRECISION_FACTOR[stor26[idx].field_0]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _3585 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            _3907 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3907] = 30
                            mem[_3907 + 32] = 'SafeMath: subtraction overflow'
                            if uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) > accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]:
                                _4073 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _4073 + 68] = mem[idx + _3907 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4073 + 68] = mem[_4073 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _4073 + -mem[64] + 100
                            if (accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0):
                                require idx < rewardTokens.length
                                mem[0] = 26
                                require ext_code.size(rewardTokens[idx].field_0)
                                staticcall rewardTokens[idx].field_0.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[mem[64] + 4] = msg.sender
                                if (accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) <= ext_call.return_data[0]:
                                    mem[mem[64] + 36] = (accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                                    require ext_code.size(rewardTokens[idx].field_0)
                                    call rewardTokens[idx].field_0.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, (accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                                else:
                                    mem[mem[64] + 36] = ext_call.return_data[0]
                                    require ext_code.size(rewardTokens[idx].field_0)
                                    call rewardTokens[idx].field_0.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, ext_call.return_data[0]
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                            idx = idx + 1
                            s = (accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                            continue 
                        idx = 0
                        while idx < rewardTokens.length:
                            mem[0] = rewardTokens[idx].field_0
                            mem[32] = 10
                            if not uint256(lastStakingBlock[msg.sender].field_0):
                                _6479 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6479] = 26
                                mem[_6479 + 32] = 'SafeMath: division by zero'
                                if pRECISION_FACTOR[stor26[idx].field_0]:
                                    require idx < rewardTokens.length
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = sha3(msg.sender, 28) + 2
                                    uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                s = 32
                                while s < 26:
                                    mem[s + mem[64] + 68] = mem[s + _6479 + 32]
                                    s = s + 32
                                    continue 
                            else:
                                if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                    revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _6508 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6508] = 26
                                mem[_6508 + 32] = 'SafeMath: division by zero'
                                if pRECISION_FACTOR[stor26[idx].field_0]:
                                    require idx < rewardTokens.length
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = sha3(msg.sender, 28) + 2
                                    uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _6508 + 32]
                                    idx = idx + 32
                                    continue 
                            revert with 0, 'SafeMath: division by zero'
                    else:
                        mem[64] = 160
                        mem[96] = 30
                        mem[128] = 'SafeMath: subtraction overflow'
                        if lastRewardBlock > bonusEndBlock:
                            revert with 0, 'SafeMath: subtraction overflow'
                        idx = 0
                        while idx < rewardTokens.length:
                            if not bonusEndBlock - lastRewardBlock:
                                require idx < rewardTokens.length
                                mem[0] = rewardTokens[idx].field_0
                                mem[32] = 25
                                _645 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_645] = 26
                                mem[_645 + 32] = 'SafeMath: division by zero'
                                if not ext_call.return_data[0]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _645 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                require idx < rewardTokens.length
                                if (0 / ext_call.return_data[0]) + accTokenPerShare[stor26[idx].field_0] < accTokenPerShare[stor26[idx].field_0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require idx < rewardTokens.length
                                mem[0] = rewardTokens[idx].field_0
                                mem[32] = 10
                                accTokenPerShare[stor26[idx].field_0] += 0 / ext_call.return_data[0]
                            else:
                                if (bonusEndBlock * rewardPerBlock[stor26[idx].field_0]) - (lastRewardBlock * rewardPerBlock[stor26[idx].field_0]) / bonusEndBlock - lastRewardBlock != rewardPerBlock[stor26[idx].field_0]:
                                    revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                require idx < rewardTokens.length
                                mem[0] = rewardTokens[idx].field_0
                                mem[32] = 25
                                if not (bonusEndBlock * rewardPerBlock[stor26[idx].field_0]) - (lastRewardBlock * rewardPerBlock[stor26[idx].field_0]):
                                    _668 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_668] = 26
                                    mem[_668 + 32] = 'SafeMath: division by zero'
                                    if not ext_call.return_data[0]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _668 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    require idx < rewardTokens.length
                                    if (0 / ext_call.return_data[0]) + accTokenPerShare[stor26[idx].field_0] < accTokenPerShare[stor26[idx].field_0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    require idx < rewardTokens.length
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = 10
                                    accTokenPerShare[stor26[idx].field_0] += 0 / ext_call.return_data[0]
                                else:
                                    if (bonusEndBlock * rewardPerBlock[stor26[idx].field_0] * pRECISION_FACTOR[stor26[idx].field_0]) - (lastRewardBlock * rewardPerBlock[stor26[idx].field_0] * pRECISION_FACTOR[stor26[idx].field_0]) / (bonusEndBlock * rewardPerBlock[stor26[idx].field_0]) - (lastRewardBlock * rewardPerBlock[stor26[idx].field_0]) != pRECISION_FACTOR[stor26[idx].field_0]:
                                        revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _692 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_692] = 26
                                    mem[_692 + 32] = 'SafeMath: division by zero'
                                    if not ext_call.return_data[0]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _692 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    require idx < rewardTokens.length
                                    if ((bonusEndBlock * rewardPerBlock[stor26[idx].field_0] * pRECISION_FACTOR[stor26[idx].field_0]) - (lastRewardBlock * rewardPerBlock[stor26[idx].field_0] * pRECISION_FACTOR[stor26[idx].field_0]) / ext_call.return_data[0]) + accTokenPerShare[stor26[idx].field_0] < accTokenPerShare[stor26[idx].field_0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    require idx < rewardTokens.length
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = 10
                                    accTokenPerShare[stor26[idx].field_0] += (bonusEndBlock * rewardPerBlock[stor26[idx].field_0] * pRECISION_FACTOR[stor26[idx].field_0]) - (lastRewardBlock * rewardPerBlock[stor26[idx].field_0] * pRECISION_FACTOR[stor26[idx].field_0]) / ext_call.return_data[0]
                            idx = idx + 1
                            continue 
                        lastRewardBlock = block.number
                        idx = 0
                        s = 0
                        while idx < rewardTokens.length:
                            mem[0] = rewardTokens[idx].field_0
                            mem[32] = 10
                            if not uint256(lastStakingBlock[msg.sender].field_0):
                                _3552 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3552] = 26
                                mem[_3552 + 32] = 'SafeMath: division by zero'
                                if not pRECISION_FACTOR[stor26[idx].field_0]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _3552 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                _3827 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3827] = 30
                                mem[_3827 + 32] = 'SafeMath: subtraction overflow'
                                if uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) > 0 / pRECISION_FACTOR[stor26[idx].field_0]:
                                    _3983 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _3983 + 68] = mem[idx + _3827 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_3983 + 68] = mem[_3983 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _3983 + -mem[64] + 100
                                if (0 / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0):
                                    require idx < rewardTokens.length
                                    mem[0] = 26
                                    require ext_code.size(rewardTokens[idx].field_0)
                                    staticcall rewardTokens[idx].field_0.0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[mem[64] + 4] = msg.sender
                                    if (0 / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) <= ext_call.return_data[0]:
                                        mem[mem[64] + 36] = (0 / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                                        require ext_code.size(rewardTokens[idx].field_0)
                                        call rewardTokens[idx].field_0.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, (0 / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                                    else:
                                        mem[mem[64] + 36] = ext_call.return_data[0]
                                        require ext_code.size(rewardTokens[idx].field_0)
                                        call rewardTokens[idx].field_0.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, ext_call.return_data[0]
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                idx = idx + 1
                                s = (0 / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                                continue 
                            if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _3582 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3582] = 26
                            mem[_3582 + 32] = 'SafeMath: division by zero'
                            if not pRECISION_FACTOR[stor26[idx].field_0]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _3582 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            _3899 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3899] = 30
                            mem[_3899 + 32] = 'SafeMath: subtraction overflow'
                            if uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) > accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]:
                                _4065 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _4065 + 68] = mem[idx + _3899 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4065 + 68] = mem[_4065 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _4065 + -mem[64] + 100
                            if (accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0):
                                require idx < rewardTokens.length
                                mem[0] = 26
                                require ext_code.size(rewardTokens[idx].field_0)
                                staticcall rewardTokens[idx].field_0.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[mem[64] + 4] = msg.sender
                                if (accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) <= ext_call.return_data[0]:
                                    mem[mem[64] + 36] = (accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                                    require ext_code.size(rewardTokens[idx].field_0)
                                    call rewardTokens[idx].field_0.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, (accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                                else:
                                    mem[mem[64] + 36] = ext_call.return_data[0]
                                    require ext_code.size(rewardTokens[idx].field_0)
                                    call rewardTokens[idx].field_0.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, ext_call.return_data[0]
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                            idx = idx + 1
                            s = (accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                            continue 
                        idx = 0
                        while idx < rewardTokens.length:
                            mem[0] = rewardTokens[idx].field_0
                            mem[32] = 10
                            if not uint256(lastStakingBlock[msg.sender].field_0):
                                _6478 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6478] = 26
                                mem[_6478 + 32] = 'SafeMath: division by zero'
                                if pRECISION_FACTOR[stor26[idx].field_0]:
                                    require idx < rewardTokens.length
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = sha3(msg.sender, 28) + 2
                                    uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                s = 32
                                while s < 26:
                                    mem[s + mem[64] + 68] = mem[s + _6478 + 32]
                                    s = s + 32
                                    continue 
                            else:
                                if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                    revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _6507 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6507] = 26
                                mem[_6507 + 32] = 'SafeMath: division by zero'
                                if pRECISION_FACTOR[stor26[idx].field_0]:
                                    require idx < rewardTokens.length
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = sha3(msg.sender, 28) + 2
                                    uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _6507 + 32]
                                    idx = idx + 32
                                    continue 
                            revert with 0, 'SafeMath: division by zero'
        emit Withdraw(0, msg.sender);
    else:
        if not msg.sender:
            revert with 0, 'Invalid address'
        idx = 0
        s = 0
        while idx < uint256(sub_ea73c96d[msg.sender].field_0):
            require idx < uint256(sub_ea73c96d[msg.sender].field_0)
            if uint256(sub_ea73c96d[msg.sender][idx].field_768) >= block.number:
                if bonusEndBlock >= block.number:
                    mem[0] = msg.sender
                    mem[32] = 30
                    idx = idx + 1
                    s = s
                    continue 
            require idx < uint256(sub_ea73c96d[msg.sender].field_0)
            require idx < uint256(sub_ea73c96d[address(msg.sender)].field_0)
            sub_ea73c96d[address(msg.sender)][idx].field_0 = 0
            uint256(sub_ea73c96d[address(msg.sender)][idx].field_256) = 0
            uint256(sub_ea73c96d[address(msg.sender)][idx].field_512) = 0
            uint256(sub_ea73c96d[address(msg.sender)][idx].field_768) = 0
            mem[0] = msg.sender
            mem[32] = 30
            idx = idx + 1
            s = s + uint256(sub_ea73c96d[msg.sender][idx].field_256)
            continue 
        if s <= 0:
            revert with 0, 'Invalid amount'
        mem[0] = msg.sender
        mem[32] = 28
        if s > uint256(lastStakingBlock[msg.sender].field_0):
            revert with 0, 'Amount to withdraw too high'
        if block.number <= lastRewardBlock:
            idx = 0
            t = 0
            while idx < rewardTokens.length:
                mem[0] = rewardTokens[idx].field_0
                mem[32] = 10
                if not uint256(lastStakingBlock[msg.sender].field_0):
                    _3579 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3579] = 26
                    mem[_3579 + 32] = 'SafeMath: division by zero'
                    if not pRECISION_FACTOR[stor26[idx].field_0]:
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                        idx = 32
                        while idx < 26:
                            mem[idx + mem[64] + 68] = mem[idx + _3579 + 32]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeMath: division by zero'
                    _3892 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3892] = 30
                    mem[_3892 + 32] = 'SafeMath: subtraction overflow'
                    if uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) > 0 / pRECISION_FACTOR[stor26[idx].field_0]:
                        _4057 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _4057 + 68] = mem[idx + _3892 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4057 + 68] = mem[_4057 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _4057 + -mem[64] + 100
                    if (0 / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0):
                        require idx < rewardTokens.length
                        mem[0] = 26
                        require ext_code.size(rewardTokens[idx].field_0)
                        staticcall rewardTokens[idx].field_0.0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[mem[64] + 4] = msg.sender
                        if (0 / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) <= ext_call.return_data[0]:
                            mem[mem[64] + 36] = (0 / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                            require ext_code.size(rewardTokens[idx].field_0)
                            call rewardTokens[idx].field_0.0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, (0 / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                        else:
                            mem[mem[64] + 36] = ext_call.return_data[0]
                            require ext_code.size(rewardTokens[idx].field_0)
                            call rewardTokens[idx].field_0.0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, ext_call.return_data[0]
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                    idx = idx + 1
                    t = (0 / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                    continue 
                if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                    revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _3606 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3606] = 26
                mem[_3606 + 32] = 'SafeMath: division by zero'
                if not pRECISION_FACTOR[stor26[idx].field_0]:
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                    idx = 32
                    while idx < 26:
                        mem[idx + mem[64] + 68] = mem[idx + _3606 + 32]
                        idx = idx + 32
                        continue 
                    revert with 0, 'SafeMath: division by zero'
                _3972 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3972] = 30
                mem[_3972 + 32] = 'SafeMath: subtraction overflow'
                if uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) > accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]:
                    _4158 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _4158 + 68] = mem[idx + _3972 + 32]
                        idx = idx + 32
                        continue 
                    mem[_4158 + 68] = mem[_4158 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _4158 + -mem[64] + 100
                if (accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0):
                    require idx < rewardTokens.length
                    mem[0] = 26
                    require ext_code.size(rewardTokens[idx].field_0)
                    staticcall rewardTokens[idx].field_0.0x70a08231 with:
                            gas gas_remaining wei
                           args address(this.address)
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    mem[mem[64] + 4] = msg.sender
                    if (accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) <= ext_call.return_data[0]:
                        mem[mem[64] + 36] = (accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                        require ext_code.size(rewardTokens[idx].field_0)
                        call rewardTokens[idx].field_0.0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, (accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                    else:
                        mem[mem[64] + 36] = ext_call.return_data[0]
                        require ext_code.size(rewardTokens[idx].field_0)
                        call rewardTokens[idx].field_0.0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, ext_call.return_data[0]
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                idx = idx + 1
                t = (accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                continue 
            if not s:
                idx = 0
                while idx < rewardTokens.length:
                    mem[0] = rewardTokens[idx].field_0
                    mem[32] = 10
                    if not uint256(lastStakingBlock[msg.sender].field_0):
                        _6500 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6500] = 26
                        mem[_6500 + 32] = 'SafeMath: division by zero'
                        if pRECISION_FACTOR[stor26[idx].field_0]:
                            require idx < rewardTokens.length
                            mem[0] = rewardTokens[idx].field_0
                            mem[32] = sha3(msg.sender, 28) + 2
                            uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                            idx = idx + 1
                            continue 
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                        s = 32
                        while s < 26:
                            mem[s + mem[64] + 68] = mem[s + _6500 + 32]
                            s = s + 32
                            continue 
                    else:
                        if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                            revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _6529 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6529] = 26
                        mem[_6529 + 32] = 'SafeMath: division by zero'
                        if pRECISION_FACTOR[stor26[idx].field_0]:
                            require idx < rewardTokens.length
                            mem[0] = rewardTokens[idx].field_0
                            mem[32] = sha3(msg.sender, 28) + 2
                            uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                            idx = idx + 1
                            continue 
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                        idx = 32
                        while idx < 26:
                            mem[idx + mem[64] + 68] = mem[idx + _6529 + 32]
                            idx = idx + 32
                            continue 
                    revert with 0, 'SafeMath: division by zero'
                emit Withdraw(s, msg.sender);
            else:
                _3440 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3440] = 30
                mem[_3440 + 32] = 'SafeMath: subtraction overflow'
                if s > uint256(lastStakingBlock[msg.sender].field_0):
                    revert with 0, 'SafeMath: subtraction overflow'
                uint256(lastStakingBlock[msg.sender].field_0) -= s
                if not msg.sender:
                    revert with 0, 32, 33, 0x7245524332303a206275726e2066726f6d20746865207a65726f20616464726573, mem[mem[64] + 101 len 31]
                _3686 = mem[64]
                mem[64] = mem[64] + 96
                mem[_3686] = 34
                mem[_3686 + 32 len 34] = 0x6b45524332303a206275726e20616d6f756e7420657863656564732062616c616e63
                if s > balanceOf[address(msg.sender)]:
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 34
                    mem[mem[64] + 68 len 64] = 0x6b45524332303a206275726e20616d6f756e7420657863656564732062616c616e63, mem[_3686 + 66 len 30]
                    mem[mem[64] + 100] = mem[mem[64] + 130 len 2]
                    revert with 0, 32, 34, mem[mem[64] + 68 len 64]
                mem[0] = msg.sender
                mem[32] = 4
                balanceOf[address(msg.sender)] -= s
                _3970 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3970] = 30
                mem[_3970 + 32] = 'SafeMath: subtraction overflow'
                if s > totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow'
                totalSupply -= s
                emit Transfer(s, msg.sender, 0);
                _4341 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4341] = uint256(lastStakingBlock[msg.sender].field_0)
                mem[_4341 + 32] = uint256(lastStakingBlock[msg.sender].field_256)
                _4437 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4437] = 30
                mem[_4437 + 32] = 'SafeMath: subtraction overflow'
                if uint256(lastStakingBlock[msg.sender].field_256) > block.number:
                    revert with 0, 'SafeMath: subtraction overflow'
                if 0 == feePeriod:
                    if not s:
                        _4689 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4689] = 26
                        mem[_4689 + 32] = 'SafeMath: division by zero'
                        require ext_code.size(stakedTokenAddress)
                        call stakedTokenAddress.0xa9059cbb with:
                             gas gas_remaining wei
                            args feeCollectorAddress, 0
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        _4827 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4827] = 30
                        mem[_4827 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > s:
                            revert with 0, 'SafeMath: subtraction overflow'
                        totalStaked -= s
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = s
                        require ext_code.size(stakedTokenAddress)
                        call stakedTokenAddress.0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, s
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        idx = 0
                        while idx < rewardTokens.length:
                            mem[0] = rewardTokens[idx].field_0
                            mem[32] = 10
                            if not uint256(lastStakingBlock[msg.sender].field_0):
                                _6502 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6502] = 26
                                mem[_6502 + 32] = 'SafeMath: division by zero'
                                if pRECISION_FACTOR[stor26[idx].field_0]:
                                    require idx < rewardTokens.length
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = sha3(msg.sender, 28) + 2
                                    uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                s = 32
                                while s < 26:
                                    mem[s + mem[64] + 68] = mem[s + _6502 + 32]
                                    s = s + 32
                                    continue 
                            else:
                                if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                    revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _6531 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6531] = 26
                                mem[_6531 + 32] = 'SafeMath: division by zero'
                                if pRECISION_FACTOR[stor26[idx].field_0]:
                                    require idx < rewardTokens.length
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = sha3(msg.sender, 28) + 2
                                    uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _6531 + 32]
                                    idx = idx + 32
                                    continue 
                            revert with 0, 'SafeMath: division by zero'
                        emit Withdraw(s, msg.sender);
                    else:
                        if unStakingFee * s / s != unStakingFee:
                            revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _4700 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4700] = 26
                        mem[_4700 + 32] = 'SafeMath: division by zero'
                        require ext_code.size(stakedTokenAddress)
                        call stakedTokenAddress.0xa9059cbb with:
                             gas gas_remaining wei
                            args feeCollectorAddress, unStakingFee * s / 10000
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        _4848 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4848] = 30
                        mem[_4848 + 32] = 'SafeMath: subtraction overflow'
                        if unStakingFee * s / 10000 > s:
                            revert with 0, 'SafeMath: subtraction overflow'
                        totalStaked = totalStaked - s + (unStakingFee * s / 10000)
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = s - (unStakingFee * s / 10000)
                        require ext_code.size(stakedTokenAddress)
                        call stakedTokenAddress.0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, s - (unStakingFee * s / 10000)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        idx = 0
                        while idx < rewardTokens.length:
                            mem[0] = rewardTokens[idx].field_0
                            mem[32] = 10
                            if not uint256(lastStakingBlock[msg.sender].field_0):
                                _6501 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6501] = 26
                                mem[_6501 + 32] = 'SafeMath: division by zero'
                                if pRECISION_FACTOR[stor26[idx].field_0]:
                                    require idx < rewardTokens.length
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = sha3(msg.sender, 28) + 2
                                    uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                s = 32
                                while s < 26:
                                    mem[s + mem[64] + 68] = mem[s + _6501 + 32]
                                    s = s + 32
                                    continue 
                            else:
                                if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                    revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _6530 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6530] = 26
                                mem[_6530 + 32] = 'SafeMath: division by zero'
                                if pRECISION_FACTOR[stor26[idx].field_0]:
                                    require idx < rewardTokens.length
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = sha3(msg.sender, 28) + 2
                                    uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _6530 + 32]
                                    idx = idx + 32
                                    continue 
                            revert with 0, 'SafeMath: division by zero'
                        emit Withdraw((s - (unStakingFee * s / 10000)), msg.sender);
                else:
                    if feePeriod <= 0:
                        totalStaked -= s
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = s
                        require ext_code.size(stakedTokenAddress)
                        call stakedTokenAddress.0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, s
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        idx = 0
                        while idx < rewardTokens.length:
                            mem[0] = rewardTokens[idx].field_0
                            mem[32] = 10
                            if not uint256(lastStakingBlock[msg.sender].field_0):
                                _6503 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6503] = 26
                                mem[_6503 + 32] = 'SafeMath: division by zero'
                                if pRECISION_FACTOR[stor26[idx].field_0]:
                                    require idx < rewardTokens.length
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = sha3(msg.sender, 28) + 2
                                    uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                s = 32
                                while s < 26:
                                    mem[s + mem[64] + 68] = mem[s + _6503 + 32]
                                    s = s + 32
                                    continue 
                            else:
                                if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                    revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _6532 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6532] = 26
                                mem[_6532 + 32] = 'SafeMath: division by zero'
                                if pRECISION_FACTOR[stor26[idx].field_0]:
                                    require idx < rewardTokens.length
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = sha3(msg.sender, 28) + 2
                                    uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _6532 + 32]
                                    idx = idx + 32
                                    continue 
                            revert with 0, 'SafeMath: division by zero'
                        emit Withdraw(s, msg.sender);
                    else:
                        if feePeriod < block.number - uint256(lastStakingBlock[msg.sender].field_256):
                            totalStaked -= s
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = s
                            require ext_code.size(stakedTokenAddress)
                            call stakedTokenAddress.0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, s
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            idx = 0
                            while idx < rewardTokens.length:
                                mem[0] = rewardTokens[idx].field_0
                                mem[32] = 10
                                if not uint256(lastStakingBlock[msg.sender].field_0):
                                    _6504 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6504] = 26
                                    mem[_6504 + 32] = 'SafeMath: division by zero'
                                    if pRECISION_FACTOR[stor26[idx].field_0]:
                                        require idx < rewardTokens.length
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = sha3(msg.sender, 28) + 2
                                        uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    s = 32
                                    while s < 26:
                                        mem[s + mem[64] + 68] = mem[s + _6504 + 32]
                                        s = s + 32
                                        continue 
                                else:
                                    if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                        revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _6533 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6533] = 26
                                    mem[_6533 + 32] = 'SafeMath: division by zero'
                                    if pRECISION_FACTOR[stor26[idx].field_0]:
                                        require idx < rewardTokens.length
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = sha3(msg.sender, 28) + 2
                                        uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _6533 + 32]
                                        idx = idx + 32
                                        continue 
                                revert with 0, 'SafeMath: division by zero'
                            emit Withdraw(s, msg.sender);
                        else:
                            if not s:
                                _4710 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4710] = 26
                                mem[_4710 + 32] = 'SafeMath: division by zero'
                                require ext_code.size(stakedTokenAddress)
                                call stakedTokenAddress.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args feeCollectorAddress, 0
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                _4873 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4873] = 30
                                mem[_4873 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > s:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                totalStaked -= s
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = s
                                require ext_code.size(stakedTokenAddress)
                                call stakedTokenAddress.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, s
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                idx = 0
                                while idx < rewardTokens.length:
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = 10
                                    if not uint256(lastStakingBlock[msg.sender].field_0):
                                        _6506 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6506] = 26
                                        mem[_6506 + 32] = 'SafeMath: division by zero'
                                        if pRECISION_FACTOR[stor26[idx].field_0]:
                                            require idx < rewardTokens.length
                                            mem[0] = rewardTokens[idx].field_0
                                            mem[32] = sha3(msg.sender, 28) + 2
                                            uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                            idx = idx + 1
                                            continue 
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        s = 32
                                        while s < 26:
                                            mem[s + mem[64] + 68] = mem[s + _6506 + 32]
                                            s = s + 32
                                            continue 
                                    else:
                                        if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                            revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _6535 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6535] = 26
                                        mem[_6535 + 32] = 'SafeMath: division by zero'
                                        if pRECISION_FACTOR[stor26[idx].field_0]:
                                            require idx < rewardTokens.length
                                            mem[0] = rewardTokens[idx].field_0
                                            mem[32] = sha3(msg.sender, 28) + 2
                                            uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                            idx = idx + 1
                                            continue 
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _6535 + 32]
                                            idx = idx + 32
                                            continue 
                                    revert with 0, 'SafeMath: division by zero'
                                emit Withdraw(s, msg.sender);
                            else:
                                if unStakingFee * s / s != unStakingFee:
                                    revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _4725 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4725] = 26
                                mem[_4725 + 32] = 'SafeMath: division by zero'
                                require ext_code.size(stakedTokenAddress)
                                call stakedTokenAddress.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args feeCollectorAddress, unStakingFee * s / 10000
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                _4898 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4898] = 30
                                mem[_4898 + 32] = 'SafeMath: subtraction overflow'
                                if unStakingFee * s / 10000 > s:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                totalStaked = totalStaked - s + (unStakingFee * s / 10000)
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = s - (unStakingFee * s / 10000)
                                require ext_code.size(stakedTokenAddress)
                                call stakedTokenAddress.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, s - (unStakingFee * s / 10000)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                idx = 0
                                while idx < rewardTokens.length:
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = 10
                                    if not uint256(lastStakingBlock[msg.sender].field_0):
                                        _6505 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6505] = 26
                                        mem[_6505 + 32] = 'SafeMath: division by zero'
                                        if pRECISION_FACTOR[stor26[idx].field_0]:
                                            require idx < rewardTokens.length
                                            mem[0] = rewardTokens[idx].field_0
                                            mem[32] = sha3(msg.sender, 28) + 2
                                            uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                            idx = idx + 1
                                            continue 
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        s = 32
                                        while s < 26:
                                            mem[s + mem[64] + 68] = mem[s + _6505 + 32]
                                            s = s + 32
                                            continue 
                                    else:
                                        if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                            revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _6534 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6534] = 26
                                        mem[_6534 + 32] = 'SafeMath: division by zero'
                                        if pRECISION_FACTOR[stor26[idx].field_0]:
                                            require idx < rewardTokens.length
                                            mem[0] = rewardTokens[idx].field_0
                                            mem[32] = sha3(msg.sender, 28) + 2
                                            uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                            idx = idx + 1
                                            continue 
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _6534 + 32]
                                            idx = idx + 32
                                            continue 
                                    revert with 0, 'SafeMath: division by zero'
                                emit Withdraw((s - (unStakingFee * s / 10000)), msg.sender);
        else:
            mem[100] = this.address
            require ext_code.size(stakedTokenAddress)
            staticcall stakedTokenAddress.0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            mem[96] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if not ext_call.return_data[0]:
                lastRewardBlock = block.number
                idx = 0
                t = 0
                while idx < rewardTokens.length:
                    mem[0] = rewardTokens[idx].field_0
                    mem[32] = 10
                    if not uint256(lastStakingBlock[msg.sender].field_0):
                        _3575 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3575] = 26
                        mem[_3575 + 32] = 'SafeMath: division by zero'
                        if not pRECISION_FACTOR[stor26[idx].field_0]:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _3575 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        _3883 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3883] = 30
                        mem[_3883 + 32] = 'SafeMath: subtraction overflow'
                        if uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) > 0 / pRECISION_FACTOR[stor26[idx].field_0]:
                            _4045 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _4045 + 68] = mem[idx + _3883 + 32]
                                idx = idx + 32
                                continue 
                            mem[_4045 + 68] = mem[_4045 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _4045 + -mem[64] + 100
                        if (0 / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0):
                            require idx < rewardTokens.length
                            mem[0] = 26
                            require ext_code.size(rewardTokens[idx].field_0)
                            staticcall rewardTokens[idx].field_0.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[mem[64] + 4] = msg.sender
                            if (0 / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) <= ext_call.return_data[0]:
                                mem[mem[64] + 36] = (0 / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                                require ext_code.size(rewardTokens[idx].field_0)
                                call rewardTokens[idx].field_0.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, (0 / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                            else:
                                mem[mem[64] + 36] = ext_call.return_data[0]
                                require ext_code.size(rewardTokens[idx].field_0)
                                call rewardTokens[idx].field_0.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, ext_call.return_data[0]
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                        idx = idx + 1
                        t = (0 / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                        continue 
                    if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                        revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _3603 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3603] = 26
                    mem[_3603 + 32] = 'SafeMath: division by zero'
                    if not pRECISION_FACTOR[stor26[idx].field_0]:
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                        idx = 32
                        while idx < 26:
                            mem[idx + mem[64] + 68] = mem[idx + _3603 + 32]
                            idx = idx + 32
                            continue 
                        revert with 0, 'SafeMath: division by zero'
                    _3962 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3962] = 30
                    mem[_3962 + 32] = 'SafeMath: subtraction overflow'
                    if uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) > accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]:
                        _4146 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _4146 + 68] = mem[idx + _3962 + 32]
                            idx = idx + 32
                            continue 
                        mem[_4146 + 68] = mem[_4146 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _4146 + -mem[64] + 100
                    if (accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0):
                        require idx < rewardTokens.length
                        mem[0] = 26
                        require ext_code.size(rewardTokens[idx].field_0)
                        staticcall rewardTokens[idx].field_0.0x70a08231 with:
                                gas gas_remaining wei
                               args address(this.address)
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        mem[mem[64] + 4] = msg.sender
                        if (accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) <= ext_call.return_data[0]:
                            mem[mem[64] + 36] = (accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                            require ext_code.size(rewardTokens[idx].field_0)
                            call rewardTokens[idx].field_0.0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, (accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                        else:
                            mem[mem[64] + 36] = ext_call.return_data[0]
                            require ext_code.size(rewardTokens[idx].field_0)
                            call rewardTokens[idx].field_0.0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, ext_call.return_data[0]
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                    idx = idx + 1
                    t = (accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                    continue 
                if not s:
                    idx = 0
                    while idx < rewardTokens.length:
                        mem[0] = rewardTokens[idx].field_0
                        mem[32] = 10
                        if not uint256(lastStakingBlock[msg.sender].field_0):
                            _6493 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6493] = 26
                            mem[_6493 + 32] = 'SafeMath: division by zero'
                            if pRECISION_FACTOR[stor26[idx].field_0]:
                                require idx < rewardTokens.length
                                mem[0] = rewardTokens[idx].field_0
                                mem[32] = sha3(msg.sender, 28) + 2
                                uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            s = 32
                            while s < 26:
                                mem[s + mem[64] + 68] = mem[s + _6493 + 32]
                                s = s + 32
                                continue 
                        else:
                            if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _6522 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6522] = 26
                            mem[_6522 + 32] = 'SafeMath: division by zero'
                            if pRECISION_FACTOR[stor26[idx].field_0]:
                                require idx < rewardTokens.length
                                mem[0] = rewardTokens[idx].field_0
                                mem[32] = sha3(msg.sender, 28) + 2
                                uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                idx = idx + 1
                                continue 
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _6522 + 32]
                                idx = idx + 32
                                continue 
                        revert with 0, 'SafeMath: division by zero'
                    emit Withdraw(s, msg.sender);
                else:
                    _3437 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3437] = 30
                    mem[_3437 + 32] = 'SafeMath: subtraction overflow'
                    if s > uint256(lastStakingBlock[msg.sender].field_0):
                        revert with 0, 'SafeMath: subtraction overflow'
                    uint256(lastStakingBlock[msg.sender].field_0) -= s
                    if not msg.sender:
                        revert with 0, 32, 33, 0x7245524332303a206275726e2066726f6d20746865207a65726f20616464726573, mem[mem[64] + 101 len 31]
                    _3679 = mem[64]
                    mem[64] = mem[64] + 96
                    mem[_3679] = 34
                    mem[_3679 + 32 len 34] = 0x6b45524332303a206275726e20616d6f756e7420657863656564732062616c616e63
                    if s > balanceOf[address(msg.sender)]:
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 34
                        mem[mem[64] + 68 len 64] = 0x6b45524332303a206275726e20616d6f756e7420657863656564732062616c616e63, mem[_3679 + 66 len 30]
                        mem[mem[64] + 100] = mem[mem[64] + 130 len 2]
                        revert with 0, 32, 34, mem[mem[64] + 68 len 64]
                    mem[0] = msg.sender
                    mem[32] = 4
                    balanceOf[address(msg.sender)] -= s
                    _3960 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3960] = 30
                    mem[_3960 + 32] = 'SafeMath: subtraction overflow'
                    if s > totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow'
                    totalSupply -= s
                    emit Transfer(s, msg.sender, 0);
                    _4334 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4334] = uint256(lastStakingBlock[msg.sender].field_0)
                    mem[_4334 + 32] = uint256(lastStakingBlock[msg.sender].field_256)
                    _4434 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4434] = 30
                    mem[_4434 + 32] = 'SafeMath: subtraction overflow'
                    if uint256(lastStakingBlock[msg.sender].field_256) > block.number:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if 0 == feePeriod:
                        if not s:
                            _4687 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4687] = 26
                            mem[_4687 + 32] = 'SafeMath: division by zero'
                            require ext_code.size(stakedTokenAddress)
                            call stakedTokenAddress.0xa9059cbb with:
                                 gas gas_remaining wei
                                args feeCollectorAddress, 0
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            _4823 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4823] = 30
                            mem[_4823 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > s:
                                revert with 0, 'SafeMath: subtraction overflow'
                            totalStaked -= s
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = s
                            require ext_code.size(stakedTokenAddress)
                            call stakedTokenAddress.0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, s
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            idx = 0
                            while idx < rewardTokens.length:
                                mem[0] = rewardTokens[idx].field_0
                                mem[32] = 10
                                if not uint256(lastStakingBlock[msg.sender].field_0):
                                    _6495 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6495] = 26
                                    mem[_6495 + 32] = 'SafeMath: division by zero'
                                    if pRECISION_FACTOR[stor26[idx].field_0]:
                                        require idx < rewardTokens.length
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = sha3(msg.sender, 28) + 2
                                        uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    s = 32
                                    while s < 26:
                                        mem[s + mem[64] + 68] = mem[s + _6495 + 32]
                                        s = s + 32
                                        continue 
                                else:
                                    if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                        revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _6524 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6524] = 26
                                    mem[_6524 + 32] = 'SafeMath: division by zero'
                                    if pRECISION_FACTOR[stor26[idx].field_0]:
                                        require idx < rewardTokens.length
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = sha3(msg.sender, 28) + 2
                                        uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _6524 + 32]
                                        idx = idx + 32
                                        continue 
                                revert with 0, 'SafeMath: division by zero'
                            emit Withdraw(s, msg.sender);
                        else:
                            if unStakingFee * s / s != unStakingFee:
                                revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _4697 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4697] = 26
                            mem[_4697 + 32] = 'SafeMath: division by zero'
                            require ext_code.size(stakedTokenAddress)
                            call stakedTokenAddress.0xa9059cbb with:
                                 gas gas_remaining wei
                                args feeCollectorAddress, unStakingFee * s / 10000
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            _4843 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4843] = 30
                            mem[_4843 + 32] = 'SafeMath: subtraction overflow'
                            if unStakingFee * s / 10000 > s:
                                revert with 0, 'SafeMath: subtraction overflow'
                            totalStaked = totalStaked - s + (unStakingFee * s / 10000)
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = s - (unStakingFee * s / 10000)
                            require ext_code.size(stakedTokenAddress)
                            call stakedTokenAddress.0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, s - (unStakingFee * s / 10000)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            idx = 0
                            while idx < rewardTokens.length:
                                mem[0] = rewardTokens[idx].field_0
                                mem[32] = 10
                                if not uint256(lastStakingBlock[msg.sender].field_0):
                                    _6494 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6494] = 26
                                    mem[_6494 + 32] = 'SafeMath: division by zero'
                                    if pRECISION_FACTOR[stor26[idx].field_0]:
                                        require idx < rewardTokens.length
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = sha3(msg.sender, 28) + 2
                                        uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    s = 32
                                    while s < 26:
                                        mem[s + mem[64] + 68] = mem[s + _6494 + 32]
                                        s = s + 32
                                        continue 
                                else:
                                    if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                        revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _6523 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6523] = 26
                                    mem[_6523 + 32] = 'SafeMath: division by zero'
                                    if pRECISION_FACTOR[stor26[idx].field_0]:
                                        require idx < rewardTokens.length
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = sha3(msg.sender, 28) + 2
                                        uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _6523 + 32]
                                        idx = idx + 32
                                        continue 
                                revert with 0, 'SafeMath: division by zero'
                            emit Withdraw((s - (unStakingFee * s / 10000)), msg.sender);
                    else:
                        if feePeriod <= 0:
                            totalStaked -= s
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = s
                            require ext_code.size(stakedTokenAddress)
                            call stakedTokenAddress.0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, s
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            idx = 0
                            while idx < rewardTokens.length:
                                mem[0] = rewardTokens[idx].field_0
                                mem[32] = 10
                                if not uint256(lastStakingBlock[msg.sender].field_0):
                                    _6496 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6496] = 26
                                    mem[_6496 + 32] = 'SafeMath: division by zero'
                                    if pRECISION_FACTOR[stor26[idx].field_0]:
                                        require idx < rewardTokens.length
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = sha3(msg.sender, 28) + 2
                                        uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    s = 32
                                    while s < 26:
                                        mem[s + mem[64] + 68] = mem[s + _6496 + 32]
                                        s = s + 32
                                        continue 
                                else:
                                    if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                        revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _6525 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6525] = 26
                                    mem[_6525 + 32] = 'SafeMath: division by zero'
                                    if pRECISION_FACTOR[stor26[idx].field_0]:
                                        require idx < rewardTokens.length
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = sha3(msg.sender, 28) + 2
                                        uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _6525 + 32]
                                        idx = idx + 32
                                        continue 
                                revert with 0, 'SafeMath: division by zero'
                            emit Withdraw(s, msg.sender);
                        else:
                            if feePeriod < block.number - uint256(lastStakingBlock[msg.sender].field_256):
                                totalStaked -= s
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = s
                                require ext_code.size(stakedTokenAddress)
                                call stakedTokenAddress.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, s
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                idx = 0
                                while idx < rewardTokens.length:
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = 10
                                    if not uint256(lastStakingBlock[msg.sender].field_0):
                                        _6497 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6497] = 26
                                        mem[_6497 + 32] = 'SafeMath: division by zero'
                                        if pRECISION_FACTOR[stor26[idx].field_0]:
                                            require idx < rewardTokens.length
                                            mem[0] = rewardTokens[idx].field_0
                                            mem[32] = sha3(msg.sender, 28) + 2
                                            uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                            idx = idx + 1
                                            continue 
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        s = 32
                                        while s < 26:
                                            mem[s + mem[64] + 68] = mem[s + _6497 + 32]
                                            s = s + 32
                                            continue 
                                    else:
                                        if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                            revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _6526 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6526] = 26
                                        mem[_6526 + 32] = 'SafeMath: division by zero'
                                        if pRECISION_FACTOR[stor26[idx].field_0]:
                                            require idx < rewardTokens.length
                                            mem[0] = rewardTokens[idx].field_0
                                            mem[32] = sha3(msg.sender, 28) + 2
                                            uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                            idx = idx + 1
                                            continue 
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _6526 + 32]
                                            idx = idx + 32
                                            continue 
                                    revert with 0, 'SafeMath: division by zero'
                                emit Withdraw(s, msg.sender);
                            else:
                                if not s:
                                    _4709 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4709] = 26
                                    mem[_4709 + 32] = 'SafeMath: division by zero'
                                    require ext_code.size(stakedTokenAddress)
                                    call stakedTokenAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args feeCollectorAddress, 0
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    _4867 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4867] = 30
                                    mem[_4867 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > s:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    totalStaked -= s
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = s
                                    require ext_code.size(stakedTokenAddress)
                                    call stakedTokenAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, s
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    idx = 0
                                    while idx < rewardTokens.length:
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = 10
                                        if not uint256(lastStakingBlock[msg.sender].field_0):
                                            _6499 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6499] = 26
                                            mem[_6499 + 32] = 'SafeMath: division by zero'
                                            if pRECISION_FACTOR[stor26[idx].field_0]:
                                                require idx < rewardTokens.length
                                                mem[0] = rewardTokens[idx].field_0
                                                mem[32] = sha3(msg.sender, 28) + 2
                                                uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            s = 32
                                            while s < 26:
                                                mem[s + mem[64] + 68] = mem[s + _6499 + 32]
                                                s = s + 32
                                                continue 
                                        else:
                                            if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                                revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _6528 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6528] = 26
                                            mem[_6528 + 32] = 'SafeMath: division by zero'
                                            if pRECISION_FACTOR[stor26[idx].field_0]:
                                                require idx < rewardTokens.length
                                                mem[0] = rewardTokens[idx].field_0
                                                mem[32] = sha3(msg.sender, 28) + 2
                                                uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _6528 + 32]
                                                idx = idx + 32
                                                continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    emit Withdraw(s, msg.sender);
                                else:
                                    if unStakingFee * s / s != unStakingFee:
                                        revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _4722 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4722] = 26
                                    mem[_4722 + 32] = 'SafeMath: division by zero'
                                    require ext_code.size(stakedTokenAddress)
                                    call stakedTokenAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args feeCollectorAddress, unStakingFee * s / 10000
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    _4890 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4890] = 30
                                    mem[_4890 + 32] = 'SafeMath: subtraction overflow'
                                    if unStakingFee * s / 10000 > s:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    totalStaked = totalStaked - s + (unStakingFee * s / 10000)
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = s - (unStakingFee * s / 10000)
                                    require ext_code.size(stakedTokenAddress)
                                    call stakedTokenAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, s - (unStakingFee * s / 10000)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    idx = 0
                                    while idx < rewardTokens.length:
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = 10
                                        if not uint256(lastStakingBlock[msg.sender].field_0):
                                            _6498 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6498] = 26
                                            mem[_6498 + 32] = 'SafeMath: division by zero'
                                            if pRECISION_FACTOR[stor26[idx].field_0]:
                                                require idx < rewardTokens.length
                                                mem[0] = rewardTokens[idx].field_0
                                                mem[32] = sha3(msg.sender, 28) + 2
                                                uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            s = 32
                                            while s < 26:
                                                mem[s + mem[64] + 68] = mem[s + _6498 + 32]
                                                s = s + 32
                                                continue 
                                        else:
                                            if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                                revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _6527 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6527] = 26
                                            mem[_6527 + 32] = 'SafeMath: division by zero'
                                            if pRECISION_FACTOR[stor26[idx].field_0]:
                                                require idx < rewardTokens.length
                                                mem[0] = rewardTokens[idx].field_0
                                                mem[32] = sha3(msg.sender, 28) + 2
                                                uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _6527 + 32]
                                                idx = idx + 32
                                                continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    emit Withdraw((s - (unStakingFee * s / 10000)), msg.sender);
            else:
                if block.number <= bonusEndBlock:
                    mem[64] = 160
                    mem[96] = 30
                    mem[128] = 'SafeMath: subtraction overflow'
                    if lastRewardBlock > block.number:
                        revert with 0, 'SafeMath: subtraction overflow'
                    idx = 0
                    while idx < rewardTokens.length:
                        if not block.number - lastRewardBlock:
                            require idx < rewardTokens.length
                            mem[0] = rewardTokens[idx].field_0
                            mem[32] = 25
                            _3677 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3677] = 26
                            mem[_3677 + 32] = 'SafeMath: division by zero'
                            if not ext_call.return_data[0]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _3677 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            require idx < rewardTokens.length
                            if (0 / ext_call.return_data[0]) + accTokenPerShare[stor26[idx].field_0] < accTokenPerShare[stor26[idx].field_0]:
                                revert with 0, 'SafeMath: addition overflow'
                            require idx < rewardTokens.length
                            mem[0] = rewardTokens[idx].field_0
                            mem[32] = 10
                            accTokenPerShare[stor26[idx].field_0] += 0 / ext_call.return_data[0]
                        else:
                            if (block.number * rewardPerBlock[stor26[idx].field_0]) - (lastRewardBlock * rewardPerBlock[stor26[idx].field_0]) / block.number - lastRewardBlock != rewardPerBlock[stor26[idx].field_0]:
                                revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            require idx < rewardTokens.length
                            mem[0] = rewardTokens[idx].field_0
                            mem[32] = 25
                            if not (block.number * rewardPerBlock[stor26[idx].field_0]) - (lastRewardBlock * rewardPerBlock[stor26[idx].field_0]):
                                _3731 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3731] = 26
                                mem[_3731 + 32] = 'SafeMath: division by zero'
                                if not ext_call.return_data[0]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _3731 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                require idx < rewardTokens.length
                                if (0 / ext_call.return_data[0]) + accTokenPerShare[stor26[idx].field_0] < accTokenPerShare[stor26[idx].field_0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require idx < rewardTokens.length
                                mem[0] = rewardTokens[idx].field_0
                                mem[32] = 10
                                accTokenPerShare[stor26[idx].field_0] += 0 / ext_call.return_data[0]
                            else:
                                if (block.number * rewardPerBlock[stor26[idx].field_0] * pRECISION_FACTOR[stor26[idx].field_0]) - (lastRewardBlock * rewardPerBlock[stor26[idx].field_0] * pRECISION_FACTOR[stor26[idx].field_0]) / (block.number * rewardPerBlock[stor26[idx].field_0]) - (lastRewardBlock * rewardPerBlock[stor26[idx].field_0]) != pRECISION_FACTOR[stor26[idx].field_0]:
                                    revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _3796 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3796] = 26
                                mem[_3796 + 32] = 'SafeMath: division by zero'
                                if not ext_call.return_data[0]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _3796 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                require idx < rewardTokens.length
                                if ((block.number * rewardPerBlock[stor26[idx].field_0] * pRECISION_FACTOR[stor26[idx].field_0]) - (lastRewardBlock * rewardPerBlock[stor26[idx].field_0] * pRECISION_FACTOR[stor26[idx].field_0]) / ext_call.return_data[0]) + accTokenPerShare[stor26[idx].field_0] < accTokenPerShare[stor26[idx].field_0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require idx < rewardTokens.length
                                mem[0] = rewardTokens[idx].field_0
                                mem[32] = 10
                                accTokenPerShare[stor26[idx].field_0] += (block.number * rewardPerBlock[stor26[idx].field_0] * pRECISION_FACTOR[stor26[idx].field_0]) - (lastRewardBlock * rewardPerBlock[stor26[idx].field_0] * pRECISION_FACTOR[stor26[idx].field_0]) / ext_call.return_data[0]
                        idx = idx + 1
                        continue 
                    lastRewardBlock = block.number
                    idx = 0
                    t = 0
                    while idx < rewardTokens.length:
                        mem[0] = rewardTokens[idx].field_0
                        mem[32] = 10
                        if not uint256(lastStakingBlock[msg.sender].field_0):
                            _6521 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6521] = 26
                            mem[_6521 + 32] = 'SafeMath: division by zero'
                            if not pRECISION_FACTOR[stor26[idx].field_0]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _6521 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            _7008 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_7008] = 30
                            mem[_7008 + 32] = 'SafeMath: subtraction overflow'
                            if uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) > 0 / pRECISION_FACTOR[stor26[idx].field_0]:
                                _7161 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _7161 + 68] = mem[idx + _7008 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_7161 + 68] = mem[_7161 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _7161 + -mem[64] + 100
                            if (0 / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0):
                                require idx < rewardTokens.length
                                mem[0] = 26
                                require ext_code.size(rewardTokens[idx].field_0)
                                staticcall rewardTokens[idx].field_0.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[mem[64] + 4] = msg.sender
                                if (0 / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) <= ext_call.return_data[0]:
                                    mem[mem[64] + 36] = (0 / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                                    require ext_code.size(rewardTokens[idx].field_0)
                                    call rewardTokens[idx].field_0.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, (0 / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                                else:
                                    mem[mem[64] + 36] = ext_call.return_data[0]
                                    require ext_code.size(rewardTokens[idx].field_0)
                                    call rewardTokens[idx].field_0.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, ext_call.return_data[0]
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                            idx = idx + 1
                            t = (0 / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                            continue 
                        if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                            revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _6553 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6553] = 26
                        mem[_6553 + 32] = 'SafeMath: division by zero'
                        if not pRECISION_FACTOR[stor26[idx].field_0]:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _6553 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        _7110 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_7110] = 30
                        mem[_7110 + 32] = 'SafeMath: subtraction overflow'
                        if uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) > accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]:
                            _7197 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _7197 + 68] = mem[idx + _7110 + 32]
                                idx = idx + 32
                                continue 
                            mem[_7197 + 68] = mem[_7197 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _7197 + -mem[64] + 100
                        if (accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0):
                            require idx < rewardTokens.length
                            mem[0] = 26
                            require ext_code.size(rewardTokens[idx].field_0)
                            staticcall rewardTokens[idx].field_0.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            mem[mem[64] + 4] = msg.sender
                            if (accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) <= ext_call.return_data[0]:
                                mem[mem[64] + 36] = (accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                                require ext_code.size(rewardTokens[idx].field_0)
                                call rewardTokens[idx].field_0.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, (accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                            else:
                                mem[mem[64] + 36] = ext_call.return_data[0]
                                require ext_code.size(rewardTokens[idx].field_0)
                                call rewardTokens[idx].field_0.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, ext_call.return_data[0]
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                        idx = idx + 1
                        t = (accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                        continue 
                    if not s:
                        idx = 0
                        while idx < rewardTokens.length:
                            mem[0] = rewardTokens[idx].field_0
                            mem[32] = 10
                            if not uint256(lastStakingBlock[msg.sender].field_0):
                                _8661 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_8661] = 26
                                mem[_8661 + 32] = 'SafeMath: division by zero'
                                if pRECISION_FACTOR[stor26[idx].field_0]:
                                    require idx < rewardTokens.length
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = sha3(msg.sender, 28) + 2
                                    uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                s = 32
                                while s < 26:
                                    mem[s + mem[64] + 68] = mem[s + _8661 + 32]
                                    s = s + 32
                                    continue 
                            else:
                                if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                    revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _8682 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_8682] = 26
                                mem[_8682 + 32] = 'SafeMath: division by zero'
                                if pRECISION_FACTOR[stor26[idx].field_0]:
                                    require idx < rewardTokens.length
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = sha3(msg.sender, 28) + 2
                                    uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _8682 + 32]
                                    idx = idx + 32
                                    continue 
                            revert with 0, 'SafeMath: division by zero'
                        emit Withdraw(s, msg.sender);
                    else:
                        _6350 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6350] = 30
                        mem[_6350 + 32] = 'SafeMath: subtraction overflow'
                        if s > uint256(lastStakingBlock[msg.sender].field_0):
                            revert with 0, 'SafeMath: subtraction overflow'
                        uint256(lastStakingBlock[msg.sender].field_0) -= s
                        if not msg.sender:
                            revert with 0, 32, 33, 0x7245524332303a206275726e2066726f6d20746865207a65726f20616464726573, mem[mem[64] + 101 len 31]
                        _6700 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_6700] = 34
                        mem[_6700 + 32 len 34] = 0x6b45524332303a206275726e20616d6f756e7420657863656564732062616c616e63
                        if s > balanceOf[address(msg.sender)]:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 34
                            mem[mem[64] + 68 len 64] = 0x6b45524332303a206275726e20616d6f756e7420657863656564732062616c616e63, mem[_6700 + 66 len 30]
                            mem[mem[64] + 100] = mem[mem[64] + 130 len 2]
                            revert with 0, 32, 34, mem[mem[64] + 68 len 64]
                        mem[0] = msg.sender
                        mem[32] = 4
                        balanceOf[address(msg.sender)] -= s
                        _7108 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_7108] = 30
                        mem[_7108 + 32] = 'SafeMath: subtraction overflow'
                        if s > totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow'
                        totalSupply -= s
                        emit Transfer(s, msg.sender, 0);
                        _7238 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_7238] = uint256(lastStakingBlock[msg.sender].field_0)
                        mem[_7238 + 32] = uint256(lastStakingBlock[msg.sender].field_256)
                        _7269 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_7269] = 30
                        mem[_7269 + 32] = 'SafeMath: subtraction overflow'
                        if uint256(lastStakingBlock[msg.sender].field_256) > block.number:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if 0 == feePeriod:
                            if not s:
                                _7366 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_7366] = 26
                                mem[_7366 + 32] = 'SafeMath: division by zero'
                                require ext_code.size(stakedTokenAddress)
                                call stakedTokenAddress.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args feeCollectorAddress, 0
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                _7457 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_7457] = 30
                                mem[_7457 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > s:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                totalStaked -= s
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = s
                                require ext_code.size(stakedTokenAddress)
                                call stakedTokenAddress.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, s
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                idx = 0
                                while idx < rewardTokens.length:
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = 10
                                    if not uint256(lastStakingBlock[msg.sender].field_0):
                                        _8663 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_8663] = 26
                                        mem[_8663 + 32] = 'SafeMath: division by zero'
                                        if pRECISION_FACTOR[stor26[idx].field_0]:
                                            require idx < rewardTokens.length
                                            mem[0] = rewardTokens[idx].field_0
                                            mem[32] = sha3(msg.sender, 28) + 2
                                            uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                            idx = idx + 1
                                            continue 
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        s = 32
                                        while s < 26:
                                            mem[s + mem[64] + 68] = mem[s + _8663 + 32]
                                            s = s + 32
                                            continue 
                                    else:
                                        if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                            revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _8684 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_8684] = 26
                                        mem[_8684 + 32] = 'SafeMath: division by zero'
                                        if pRECISION_FACTOR[stor26[idx].field_0]:
                                            require idx < rewardTokens.length
                                            mem[0] = rewardTokens[idx].field_0
                                            mem[32] = sha3(msg.sender, 28) + 2
                                            uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                            idx = idx + 1
                                            continue 
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _8684 + 32]
                                            idx = idx + 32
                                            continue 
                                    revert with 0, 'SafeMath: division by zero'
                                emit Withdraw(s, msg.sender);
                            else:
                                if unStakingFee * s / s != unStakingFee:
                                    revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _7374 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_7374] = 26
                                mem[_7374 + 32] = 'SafeMath: division by zero'
                                require ext_code.size(stakedTokenAddress)
                                call stakedTokenAddress.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args feeCollectorAddress, unStakingFee * s / 10000
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                _7471 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_7471] = 30
                                mem[_7471 + 32] = 'SafeMath: subtraction overflow'
                                if unStakingFee * s / 10000 > s:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                totalStaked = totalStaked - s + (unStakingFee * s / 10000)
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = s - (unStakingFee * s / 10000)
                                require ext_code.size(stakedTokenAddress)
                                call stakedTokenAddress.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, s - (unStakingFee * s / 10000)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                idx = 0
                                while idx < rewardTokens.length:
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = 10
                                    if not uint256(lastStakingBlock[msg.sender].field_0):
                                        _8662 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_8662] = 26
                                        mem[_8662 + 32] = 'SafeMath: division by zero'
                                        if pRECISION_FACTOR[stor26[idx].field_0]:
                                            require idx < rewardTokens.length
                                            mem[0] = rewardTokens[idx].field_0
                                            mem[32] = sha3(msg.sender, 28) + 2
                                            uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                            idx = idx + 1
                                            continue 
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        s = 32
                                        while s < 26:
                                            mem[s + mem[64] + 68] = mem[s + _8662 + 32]
                                            s = s + 32
                                            continue 
                                    else:
                                        if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                            revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _8683 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_8683] = 26
                                        mem[_8683 + 32] = 'SafeMath: division by zero'
                                        if pRECISION_FACTOR[stor26[idx].field_0]:
                                            require idx < rewardTokens.length
                                            mem[0] = rewardTokens[idx].field_0
                                            mem[32] = sha3(msg.sender, 28) + 2
                                            uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                            idx = idx + 1
                                            continue 
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _8683 + 32]
                                            idx = idx + 32
                                            continue 
                                    revert with 0, 'SafeMath: division by zero'
                                emit Withdraw((s - (unStakingFee * s / 10000)), msg.sender);
                        else:
                            if feePeriod <= 0:
                                totalStaked -= s
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = s
                                require ext_code.size(stakedTokenAddress)
                                call stakedTokenAddress.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, s
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                idx = 0
                                while idx < rewardTokens.length:
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = 10
                                    if not uint256(lastStakingBlock[msg.sender].field_0):
                                        _8664 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_8664] = 26
                                        mem[_8664 + 32] = 'SafeMath: division by zero'
                                        if pRECISION_FACTOR[stor26[idx].field_0]:
                                            require idx < rewardTokens.length
                                            mem[0] = rewardTokens[idx].field_0
                                            mem[32] = sha3(msg.sender, 28) + 2
                                            uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                            idx = idx + 1
                                            continue 
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        s = 32
                                        while s < 26:
                                            mem[s + mem[64] + 68] = mem[s + _8664 + 32]
                                            s = s + 32
                                            continue 
                                    else:
                                        if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                            revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _8685 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_8685] = 26
                                        mem[_8685 + 32] = 'SafeMath: division by zero'
                                        if pRECISION_FACTOR[stor26[idx].field_0]:
                                            require idx < rewardTokens.length
                                            mem[0] = rewardTokens[idx].field_0
                                            mem[32] = sha3(msg.sender, 28) + 2
                                            uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                            idx = idx + 1
                                            continue 
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _8685 + 32]
                                            idx = idx + 32
                                            continue 
                                    revert with 0, 'SafeMath: division by zero'
                                emit Withdraw(s, msg.sender);
                            else:
                                if feePeriod < block.number - uint256(lastStakingBlock[msg.sender].field_256):
                                    totalStaked -= s
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = s
                                    require ext_code.size(stakedTokenAddress)
                                    call stakedTokenAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, s
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    idx = 0
                                    while idx < rewardTokens.length:
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = 10
                                        if not uint256(lastStakingBlock[msg.sender].field_0):
                                            _8665 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8665] = 26
                                            mem[_8665 + 32] = 'SafeMath: division by zero'
                                            if pRECISION_FACTOR[stor26[idx].field_0]:
                                                require idx < rewardTokens.length
                                                mem[0] = rewardTokens[idx].field_0
                                                mem[32] = sha3(msg.sender, 28) + 2
                                                uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            s = 32
                                            while s < 26:
                                                mem[s + mem[64] + 68] = mem[s + _8665 + 32]
                                                s = s + 32
                                                continue 
                                        else:
                                            if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                                revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _8686 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8686] = 26
                                            mem[_8686 + 32] = 'SafeMath: division by zero'
                                            if pRECISION_FACTOR[stor26[idx].field_0]:
                                                require idx < rewardTokens.length
                                                mem[0] = rewardTokens[idx].field_0
                                                mem[32] = sha3(msg.sender, 28) + 2
                                                uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _8686 + 32]
                                                idx = idx + 32
                                                continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    emit Withdraw(s, msg.sender);
                                else:
                                    if not s:
                                        _7379 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7379] = 26
                                        mem[_7379 + 32] = 'SafeMath: division by zero'
                                        require ext_code.size(stakedTokenAddress)
                                        call stakedTokenAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args feeCollectorAddress, 0
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        _7493 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7493] = 30
                                        mem[_7493 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > s:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        totalStaked -= s
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = s
                                        require ext_code.size(stakedTokenAddress)
                                        call stakedTokenAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, s
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        idx = 0
                                        while idx < rewardTokens.length:
                                            mem[0] = rewardTokens[idx].field_0
                                            mem[32] = 10
                                            if not uint256(lastStakingBlock[msg.sender].field_0):
                                                _8667 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8667] = 26
                                                mem[_8667 + 32] = 'SafeMath: division by zero'
                                                if pRECISION_FACTOR[stor26[idx].field_0]:
                                                    require idx < rewardTokens.length
                                                    mem[0] = rewardTokens[idx].field_0
                                                    mem[32] = sha3(msg.sender, 28) + 2
                                                    uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                                    idx = idx + 1
                                                    continue 
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                                s = 32
                                                while s < 26:
                                                    mem[s + mem[64] + 68] = mem[s + _8667 + 32]
                                                    s = s + 32
                                                    continue 
                                            else:
                                                if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                                    revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                _8688 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8688] = 26
                                                mem[_8688 + 32] = 'SafeMath: division by zero'
                                                if pRECISION_FACTOR[stor26[idx].field_0]:
                                                    require idx < rewardTokens.length
                                                    mem[0] = rewardTokens[idx].field_0
                                                    mem[32] = sha3(msg.sender, 28) + 2
                                                    uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                                    idx = idx + 1
                                                    continue 
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                                idx = 32
                                                while idx < 26:
                                                    mem[idx + mem[64] + 68] = mem[idx + _8688 + 32]
                                                    idx = idx + 32
                                                    continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        emit Withdraw(s, msg.sender);
                                    else:
                                        if unStakingFee * s / s != unStakingFee:
                                            revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _7388 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7388] = 26
                                        mem[_7388 + 32] = 'SafeMath: division by zero'
                                        require ext_code.size(stakedTokenAddress)
                                        call stakedTokenAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args feeCollectorAddress, unStakingFee * s / 10000
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        _7517 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7517] = 30
                                        mem[_7517 + 32] = 'SafeMath: subtraction overflow'
                                        if unStakingFee * s / 10000 > s:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        totalStaked = totalStaked - s + (unStakingFee * s / 10000)
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = s - (unStakingFee * s / 10000)
                                        require ext_code.size(stakedTokenAddress)
                                        call stakedTokenAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, s - (unStakingFee * s / 10000)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        idx = 0
                                        while idx < rewardTokens.length:
                                            mem[0] = rewardTokens[idx].field_0
                                            mem[32] = 10
                                            if not uint256(lastStakingBlock[msg.sender].field_0):
                                                _8666 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8666] = 26
                                                mem[_8666 + 32] = 'SafeMath: division by zero'
                                                if pRECISION_FACTOR[stor26[idx].field_0]:
                                                    require idx < rewardTokens.length
                                                    mem[0] = rewardTokens[idx].field_0
                                                    mem[32] = sha3(msg.sender, 28) + 2
                                                    uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                                    idx = idx + 1
                                                    continue 
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                                s = 32
                                                while s < 26:
                                                    mem[s + mem[64] + 68] = mem[s + _8666 + 32]
                                                    s = s + 32
                                                    continue 
                                            else:
                                                if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                                    revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                _8687 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8687] = 26
                                                mem[_8687 + 32] = 'SafeMath: division by zero'
                                                if pRECISION_FACTOR[stor26[idx].field_0]:
                                                    require idx < rewardTokens.length
                                                    mem[0] = rewardTokens[idx].field_0
                                                    mem[32] = sha3(msg.sender, 28) + 2
                                                    uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                                    idx = idx + 1
                                                    continue 
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                                idx = 32
                                                while idx < 26:
                                                    mem[idx + mem[64] + 68] = mem[idx + _8687 + 32]
                                                    idx = idx + 32
                                                    continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        emit Withdraw((s - (unStakingFee * s / 10000)), msg.sender);
                else:
                    if lastRewardBlock >= bonusEndBlock:
                        idx = 0
                        while idx < rewardTokens.length:
                            require idx < rewardTokens.length
                            mem[0] = rewardTokens[idx].field_0
                            mem[32] = 25
                            _3670 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3670] = 26
                            mem[_3670 + 32] = 'SafeMath: division by zero'
                            if not ext_call.return_data[0]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _3670 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            require idx < rewardTokens.length
                            if (0 / ext_call.return_data[0]) + accTokenPerShare[stor26[idx].field_0] < accTokenPerShare[stor26[idx].field_0]:
                                revert with 0, 'SafeMath: addition overflow'
                            require idx < rewardTokens.length
                            mem[0] = rewardTokens[idx].field_0
                            mem[32] = 10
                            accTokenPerShare[stor26[idx].field_0] += 0 / ext_call.return_data[0]
                            idx = idx + 1
                            continue 
                        lastRewardBlock = block.number
                        idx = 0
                        t = 0
                        while idx < rewardTokens.length:
                            mem[0] = rewardTokens[idx].field_0
                            mem[32] = 10
                            if not uint256(lastStakingBlock[msg.sender].field_0):
                                _6517 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6517] = 26
                                mem[_6517 + 32] = 'SafeMath: division by zero'
                                if not pRECISION_FACTOR[stor26[idx].field_0]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _6517 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                _6999 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6999] = 30
                                mem[_6999 + 32] = 'SafeMath: subtraction overflow'
                                if uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) > 0 / pRECISION_FACTOR[stor26[idx].field_0]:
                                    _7149 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _7149 + 68] = mem[idx + _6999 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_7149 + 68] = mem[_7149 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _7149 + -mem[64] + 100
                                if (0 / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0):
                                    require idx < rewardTokens.length
                                    mem[0] = 26
                                    require ext_code.size(rewardTokens[idx].field_0)
                                    staticcall rewardTokens[idx].field_0.0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[mem[64] + 4] = msg.sender
                                    if (0 / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) <= ext_call.return_data[0]:
                                        mem[mem[64] + 36] = (0 / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                                        require ext_code.size(rewardTokens[idx].field_0)
                                        call rewardTokens[idx].field_0.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, (0 / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                                    else:
                                        mem[mem[64] + 36] = ext_call.return_data[0]
                                        require ext_code.size(rewardTokens[idx].field_0)
                                        call rewardTokens[idx].field_0.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, ext_call.return_data[0]
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                idx = idx + 1
                                t = (0 / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                                continue 
                            if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _6550 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6550] = 26
                            mem[_6550 + 32] = 'SafeMath: division by zero'
                            if not pRECISION_FACTOR[stor26[idx].field_0]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _6550 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            _7100 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_7100] = 30
                            mem[_7100 + 32] = 'SafeMath: subtraction overflow'
                            if uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) > accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]:
                                _7185 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _7185 + 68] = mem[idx + _7100 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_7185 + 68] = mem[_7185 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _7185 + -mem[64] + 100
                            if (accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0):
                                require idx < rewardTokens.length
                                mem[0] = 26
                                require ext_code.size(rewardTokens[idx].field_0)
                                staticcall rewardTokens[idx].field_0.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[mem[64] + 4] = msg.sender
                                if (accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) <= ext_call.return_data[0]:
                                    mem[mem[64] + 36] = (accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                                    require ext_code.size(rewardTokens[idx].field_0)
                                    call rewardTokens[idx].field_0.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, (accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                                else:
                                    mem[mem[64] + 36] = ext_call.return_data[0]
                                    require ext_code.size(rewardTokens[idx].field_0)
                                    call rewardTokens[idx].field_0.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, ext_call.return_data[0]
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                            idx = idx + 1
                            t = (accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                            continue 
                        if not s:
                            idx = 0
                            while idx < rewardTokens.length:
                                mem[0] = rewardTokens[idx].field_0
                                mem[32] = 10
                                if not uint256(lastStakingBlock[msg.sender].field_0):
                                    _8654 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_8654] = 26
                                    mem[_8654 + 32] = 'SafeMath: division by zero'
                                    if pRECISION_FACTOR[stor26[idx].field_0]:
                                        require idx < rewardTokens.length
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = sha3(msg.sender, 28) + 2
                                        uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    s = 32
                                    while s < 26:
                                        mem[s + mem[64] + 68] = mem[s + _8654 + 32]
                                        s = s + 32
                                        continue 
                                else:
                                    if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                        revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _8675 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_8675] = 26
                                    mem[_8675 + 32] = 'SafeMath: division by zero'
                                    if pRECISION_FACTOR[stor26[idx].field_0]:
                                        require idx < rewardTokens.length
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = sha3(msg.sender, 28) + 2
                                        uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _8675 + 32]
                                        idx = idx + 32
                                        continue 
                                revert with 0, 'SafeMath: division by zero'
                            emit Withdraw(s, msg.sender);
                        else:
                            _6346 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6346] = 30
                            mem[_6346 + 32] = 'SafeMath: subtraction overflow'
                            if s > uint256(lastStakingBlock[msg.sender].field_0):
                                revert with 0, 'SafeMath: subtraction overflow'
                            uint256(lastStakingBlock[msg.sender].field_0) -= s
                            if not msg.sender:
                                revert with 0, 32, 33, 0x7245524332303a206275726e2066726f6d20746865207a65726f20616464726573, mem[mem[64] + 101 len 31]
                            _6693 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_6693] = 34
                            mem[_6693 + 32 len 34] = 0x6b45524332303a206275726e20616d6f756e7420657863656564732062616c616e63
                            if s > balanceOf[address(msg.sender)]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 34
                                mem[mem[64] + 68 len 64] = 0x6b45524332303a206275726e20616d6f756e7420657863656564732062616c616e63, mem[_6693 + 66 len 30]
                                mem[mem[64] + 100] = mem[mem[64] + 130 len 2]
                                revert with 0, 32, 34, mem[mem[64] + 68 len 64]
                            mem[0] = msg.sender
                            mem[32] = 4
                            balanceOf[address(msg.sender)] -= s
                            _7098 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_7098] = 30
                            mem[_7098 + 32] = 'SafeMath: subtraction overflow'
                            if s > totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow'
                            totalSupply -= s
                            emit Transfer(s, msg.sender, 0);
                            _7231 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_7231] = uint256(lastStakingBlock[msg.sender].field_0)
                            mem[_7231 + 32] = uint256(lastStakingBlock[msg.sender].field_256)
                            _7266 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_7266] = 30
                            mem[_7266 + 32] = 'SafeMath: subtraction overflow'
                            if uint256(lastStakingBlock[msg.sender].field_256) > block.number:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if 0 == feePeriod:
                                if not s:
                                    _7364 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_7364] = 26
                                    mem[_7364 + 32] = 'SafeMath: division by zero'
                                    require ext_code.size(stakedTokenAddress)
                                    call stakedTokenAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args feeCollectorAddress, 0
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    _7453 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_7453] = 30
                                    mem[_7453 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > s:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    totalStaked -= s
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = s
                                    require ext_code.size(stakedTokenAddress)
                                    call stakedTokenAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, s
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    idx = 0
                                    while idx < rewardTokens.length:
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = 10
                                        if not uint256(lastStakingBlock[msg.sender].field_0):
                                            _8656 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8656] = 26
                                            mem[_8656 + 32] = 'SafeMath: division by zero'
                                            if pRECISION_FACTOR[stor26[idx].field_0]:
                                                require idx < rewardTokens.length
                                                mem[0] = rewardTokens[idx].field_0
                                                mem[32] = sha3(msg.sender, 28) + 2
                                                uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            s = 32
                                            while s < 26:
                                                mem[s + mem[64] + 68] = mem[s + _8656 + 32]
                                                s = s + 32
                                                continue 
                                        else:
                                            if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                                revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _8677 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8677] = 26
                                            mem[_8677 + 32] = 'SafeMath: division by zero'
                                            if pRECISION_FACTOR[stor26[idx].field_0]:
                                                require idx < rewardTokens.length
                                                mem[0] = rewardTokens[idx].field_0
                                                mem[32] = sha3(msg.sender, 28) + 2
                                                uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _8677 + 32]
                                                idx = idx + 32
                                                continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    emit Withdraw(s, msg.sender);
                                else:
                                    if unStakingFee * s / s != unStakingFee:
                                        revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _7371 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_7371] = 26
                                    mem[_7371 + 32] = 'SafeMath: division by zero'
                                    require ext_code.size(stakedTokenAddress)
                                    call stakedTokenAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args feeCollectorAddress, unStakingFee * s / 10000
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    _7466 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_7466] = 30
                                    mem[_7466 + 32] = 'SafeMath: subtraction overflow'
                                    if unStakingFee * s / 10000 > s:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    totalStaked = totalStaked - s + (unStakingFee * s / 10000)
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = s - (unStakingFee * s / 10000)
                                    require ext_code.size(stakedTokenAddress)
                                    call stakedTokenAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, s - (unStakingFee * s / 10000)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    idx = 0
                                    while idx < rewardTokens.length:
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = 10
                                        if not uint256(lastStakingBlock[msg.sender].field_0):
                                            _8655 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8655] = 26
                                            mem[_8655 + 32] = 'SafeMath: division by zero'
                                            if pRECISION_FACTOR[stor26[idx].field_0]:
                                                require idx < rewardTokens.length
                                                mem[0] = rewardTokens[idx].field_0
                                                mem[32] = sha3(msg.sender, 28) + 2
                                                uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            s = 32
                                            while s < 26:
                                                mem[s + mem[64] + 68] = mem[s + _8655 + 32]
                                                s = s + 32
                                                continue 
                                        else:
                                            if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                                revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _8676 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8676] = 26
                                            mem[_8676 + 32] = 'SafeMath: division by zero'
                                            if pRECISION_FACTOR[stor26[idx].field_0]:
                                                require idx < rewardTokens.length
                                                mem[0] = rewardTokens[idx].field_0
                                                mem[32] = sha3(msg.sender, 28) + 2
                                                uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _8676 + 32]
                                                idx = idx + 32
                                                continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    emit Withdraw((s - (unStakingFee * s / 10000)), msg.sender);
                            else:
                                if feePeriod <= 0:
                                    totalStaked -= s
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = s
                                    require ext_code.size(stakedTokenAddress)
                                    call stakedTokenAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, s
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    idx = 0
                                    while idx < rewardTokens.length:
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = 10
                                        if not uint256(lastStakingBlock[msg.sender].field_0):
                                            _8657 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8657] = 26
                                            mem[_8657 + 32] = 'SafeMath: division by zero'
                                            if pRECISION_FACTOR[stor26[idx].field_0]:
                                                require idx < rewardTokens.length
                                                mem[0] = rewardTokens[idx].field_0
                                                mem[32] = sha3(msg.sender, 28) + 2
                                                uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            s = 32
                                            while s < 26:
                                                mem[s + mem[64] + 68] = mem[s + _8657 + 32]
                                                s = s + 32
                                                continue 
                                        else:
                                            if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                                revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _8678 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8678] = 26
                                            mem[_8678 + 32] = 'SafeMath: division by zero'
                                            if pRECISION_FACTOR[stor26[idx].field_0]:
                                                require idx < rewardTokens.length
                                                mem[0] = rewardTokens[idx].field_0
                                                mem[32] = sha3(msg.sender, 28) + 2
                                                uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _8678 + 32]
                                                idx = idx + 32
                                                continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    emit Withdraw(s, msg.sender);
                                else:
                                    if feePeriod < block.number - uint256(lastStakingBlock[msg.sender].field_256):
                                        totalStaked -= s
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = s
                                        require ext_code.size(stakedTokenAddress)
                                        call stakedTokenAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, s
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        idx = 0
                                        while idx < rewardTokens.length:
                                            mem[0] = rewardTokens[idx].field_0
                                            mem[32] = 10
                                            if not uint256(lastStakingBlock[msg.sender].field_0):
                                                _8658 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8658] = 26
                                                mem[_8658 + 32] = 'SafeMath: division by zero'
                                                if pRECISION_FACTOR[stor26[idx].field_0]:
                                                    require idx < rewardTokens.length
                                                    mem[0] = rewardTokens[idx].field_0
                                                    mem[32] = sha3(msg.sender, 28) + 2
                                                    uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                                    idx = idx + 1
                                                    continue 
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                                s = 32
                                                while s < 26:
                                                    mem[s + mem[64] + 68] = mem[s + _8658 + 32]
                                                    s = s + 32
                                                    continue 
                                            else:
                                                if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                                    revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                _8679 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8679] = 26
                                                mem[_8679 + 32] = 'SafeMath: division by zero'
                                                if pRECISION_FACTOR[stor26[idx].field_0]:
                                                    require idx < rewardTokens.length
                                                    mem[0] = rewardTokens[idx].field_0
                                                    mem[32] = sha3(msg.sender, 28) + 2
                                                    uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                                    idx = idx + 1
                                                    continue 
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                                idx = 32
                                                while idx < 26:
                                                    mem[idx + mem[64] + 68] = mem[idx + _8679 + 32]
                                                    idx = idx + 32
                                                    continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        emit Withdraw(s, msg.sender);
                                    else:
                                        if not s:
                                            _7378 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7378] = 26
                                            mem[_7378 + 32] = 'SafeMath: division by zero'
                                            require ext_code.size(stakedTokenAddress)
                                            call stakedTokenAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args feeCollectorAddress, 0
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            _7487 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7487] = 30
                                            mem[_7487 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > s:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            totalStaked -= s
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = s
                                            require ext_code.size(stakedTokenAddress)
                                            call stakedTokenAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, s
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            idx = 0
                                            while idx < rewardTokens.length:
                                                mem[0] = rewardTokens[idx].field_0
                                                mem[32] = 10
                                                if not uint256(lastStakingBlock[msg.sender].field_0):
                                                    _8660 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_8660] = 26
                                                    mem[_8660 + 32] = 'SafeMath: division by zero'
                                                    if pRECISION_FACTOR[stor26[idx].field_0]:
                                                        require idx < rewardTokens.length
                                                        mem[0] = rewardTokens[idx].field_0
                                                        mem[32] = sha3(msg.sender, 28) + 2
                                                        uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                                        idx = idx + 1
                                                        continue 
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                                    s = 32
                                                    while s < 26:
                                                        mem[s + mem[64] + 68] = mem[s + _8660 + 32]
                                                        s = s + 32
                                                        continue 
                                                else:
                                                    if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                                        revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    _8681 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_8681] = 26
                                                    mem[_8681 + 32] = 'SafeMath: division by zero'
                                                    if pRECISION_FACTOR[stor26[idx].field_0]:
                                                        require idx < rewardTokens.length
                                                        mem[0] = rewardTokens[idx].field_0
                                                        mem[32] = sha3(msg.sender, 28) + 2
                                                        uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                                        idx = idx + 1
                                                        continue 
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                                    idx = 32
                                                    while idx < 26:
                                                        mem[idx + mem[64] + 68] = mem[idx + _8681 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                revert with 0, 'SafeMath: division by zero'
                                            emit Withdraw(s, msg.sender);
                                        else:
                                            if unStakingFee * s / s != unStakingFee:
                                                revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _7385 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7385] = 26
                                            mem[_7385 + 32] = 'SafeMath: division by zero'
                                            require ext_code.size(stakedTokenAddress)
                                            call stakedTokenAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args feeCollectorAddress, unStakingFee * s / 10000
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            _7509 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7509] = 30
                                            mem[_7509 + 32] = 'SafeMath: subtraction overflow'
                                            if unStakingFee * s / 10000 > s:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            totalStaked = totalStaked - s + (unStakingFee * s / 10000)
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = s - (unStakingFee * s / 10000)
                                            require ext_code.size(stakedTokenAddress)
                                            call stakedTokenAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, s - (unStakingFee * s / 10000)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            idx = 0
                                            while idx < rewardTokens.length:
                                                mem[0] = rewardTokens[idx].field_0
                                                mem[32] = 10
                                                if not uint256(lastStakingBlock[msg.sender].field_0):
                                                    _8659 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_8659] = 26
                                                    mem[_8659 + 32] = 'SafeMath: division by zero'
                                                    if pRECISION_FACTOR[stor26[idx].field_0]:
                                                        require idx < rewardTokens.length
                                                        mem[0] = rewardTokens[idx].field_0
                                                        mem[32] = sha3(msg.sender, 28) + 2
                                                        uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                                        idx = idx + 1
                                                        continue 
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                                    s = 32
                                                    while s < 26:
                                                        mem[s + mem[64] + 68] = mem[s + _8659 + 32]
                                                        s = s + 32
                                                        continue 
                                                else:
                                                    if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                                        revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    _8680 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_8680] = 26
                                                    mem[_8680 + 32] = 'SafeMath: division by zero'
                                                    if pRECISION_FACTOR[stor26[idx].field_0]:
                                                        require idx < rewardTokens.length
                                                        mem[0] = rewardTokens[idx].field_0
                                                        mem[32] = sha3(msg.sender, 28) + 2
                                                        uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                                        idx = idx + 1
                                                        continue 
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                                    idx = 32
                                                    while idx < 26:
                                                        mem[idx + mem[64] + 68] = mem[idx + _8680 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                revert with 0, 'SafeMath: division by zero'
                                            emit Withdraw((s - (unStakingFee * s / 10000)), msg.sender);
                    else:
                        mem[64] = 160
                        mem[96] = 30
                        mem[128] = 'SafeMath: subtraction overflow'
                        if lastRewardBlock > bonusEndBlock:
                            revert with 0, 'SafeMath: subtraction overflow'
                        idx = 0
                        while idx < rewardTokens.length:
                            if not bonusEndBlock - lastRewardBlock:
                                require idx < rewardTokens.length
                                mem[0] = rewardTokens[idx].field_0
                                mem[32] = 25
                                _3665 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3665] = 26
                                mem[_3665 + 32] = 'SafeMath: division by zero'
                                if not ext_call.return_data[0]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _3665 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                require idx < rewardTokens.length
                                if (0 / ext_call.return_data[0]) + accTokenPerShare[stor26[idx].field_0] < accTokenPerShare[stor26[idx].field_0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require idx < rewardTokens.length
                                mem[0] = rewardTokens[idx].field_0
                                mem[32] = 10
                                accTokenPerShare[stor26[idx].field_0] += 0 / ext_call.return_data[0]
                            else:
                                if (bonusEndBlock * rewardPerBlock[stor26[idx].field_0]) - (lastRewardBlock * rewardPerBlock[stor26[idx].field_0]) / bonusEndBlock - lastRewardBlock != rewardPerBlock[stor26[idx].field_0]:
                                    revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                require idx < rewardTokens.length
                                mem[0] = rewardTokens[idx].field_0
                                mem[32] = 25
                                if not (bonusEndBlock * rewardPerBlock[stor26[idx].field_0]) - (lastRewardBlock * rewardPerBlock[stor26[idx].field_0]):
                                    _3722 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3722] = 26
                                    mem[_3722 + 32] = 'SafeMath: division by zero'
                                    if not ext_call.return_data[0]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _3722 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    require idx < rewardTokens.length
                                    if (0 / ext_call.return_data[0]) + accTokenPerShare[stor26[idx].field_0] < accTokenPerShare[stor26[idx].field_0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    require idx < rewardTokens.length
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = 10
                                    accTokenPerShare[stor26[idx].field_0] += 0 / ext_call.return_data[0]
                                else:
                                    if (bonusEndBlock * rewardPerBlock[stor26[idx].field_0] * pRECISION_FACTOR[stor26[idx].field_0]) - (lastRewardBlock * rewardPerBlock[stor26[idx].field_0] * pRECISION_FACTOR[stor26[idx].field_0]) / (bonusEndBlock * rewardPerBlock[stor26[idx].field_0]) - (lastRewardBlock * rewardPerBlock[stor26[idx].field_0]) != pRECISION_FACTOR[stor26[idx].field_0]:
                                        revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _3783 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_3783] = 26
                                    mem[_3783 + 32] = 'SafeMath: division by zero'
                                    if not ext_call.return_data[0]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _3783 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    require idx < rewardTokens.length
                                    if ((bonusEndBlock * rewardPerBlock[stor26[idx].field_0] * pRECISION_FACTOR[stor26[idx].field_0]) - (lastRewardBlock * rewardPerBlock[stor26[idx].field_0] * pRECISION_FACTOR[stor26[idx].field_0]) / ext_call.return_data[0]) + accTokenPerShare[stor26[idx].field_0] < accTokenPerShare[stor26[idx].field_0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    require idx < rewardTokens.length
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = 10
                                    accTokenPerShare[stor26[idx].field_0] += (bonusEndBlock * rewardPerBlock[stor26[idx].field_0] * pRECISION_FACTOR[stor26[idx].field_0]) - (lastRewardBlock * rewardPerBlock[stor26[idx].field_0] * pRECISION_FACTOR[stor26[idx].field_0]) / ext_call.return_data[0]
                            idx = idx + 1
                            continue 
                        lastRewardBlock = block.number
                        idx = 0
                        t = 0
                        while idx < rewardTokens.length:
                            mem[0] = rewardTokens[idx].field_0
                            mem[32] = 10
                            if not uint256(lastStakingBlock[msg.sender].field_0):
                                _6513 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6513] = 26
                                mem[_6513 + 32] = 'SafeMath: division by zero'
                                if not pRECISION_FACTOR[stor26[idx].field_0]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _6513 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                _6990 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6990] = 30
                                mem[_6990 + 32] = 'SafeMath: subtraction overflow'
                                if uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) > 0 / pRECISION_FACTOR[stor26[idx].field_0]:
                                    _7137 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _7137 + 68] = mem[idx + _6990 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_7137 + 68] = mem[_7137 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _7137 + -mem[64] + 100
                                if (0 / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0):
                                    require idx < rewardTokens.length
                                    mem[0] = 26
                                    require ext_code.size(rewardTokens[idx].field_0)
                                    staticcall rewardTokens[idx].field_0.0x70a08231 with:
                                            gas gas_remaining wei
                                           args address(this.address)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[mem[64] + 4] = msg.sender
                                    if (0 / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) <= ext_call.return_data[0]:
                                        mem[mem[64] + 36] = (0 / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                                        require ext_code.size(rewardTokens[idx].field_0)
                                        call rewardTokens[idx].field_0.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, (0 / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                                    else:
                                        mem[mem[64] + 36] = ext_call.return_data[0]
                                        require ext_code.size(rewardTokens[idx].field_0)
                                        call rewardTokens[idx].field_0.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, ext_call.return_data[0]
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                idx = idx + 1
                                t = (0 / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                                continue 
                            if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _6547 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6547] = 26
                            mem[_6547 + 32] = 'SafeMath: division by zero'
                            if not pRECISION_FACTOR[stor26[idx].field_0]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _6547 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            _7090 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_7090] = 30
                            mem[_7090 + 32] = 'SafeMath: subtraction overflow'
                            if uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) > accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]:
                                _7173 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _7173 + 68] = mem[idx + _7090 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_7173 + 68] = mem[_7173 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _7173 + -mem[64] + 100
                            if (accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0):
                                require idx < rewardTokens.length
                                mem[0] = 26
                                require ext_code.size(rewardTokens[idx].field_0)
                                staticcall rewardTokens[idx].field_0.0x70a08231 with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[mem[64] + 4] = msg.sender
                                if (accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) <= ext_call.return_data[0]:
                                    mem[mem[64] + 36] = (accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                                    require ext_code.size(rewardTokens[idx].field_0)
                                    call rewardTokens[idx].field_0.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, (accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                                else:
                                    mem[mem[64] + 36] = ext_call.return_data[0]
                                    require ext_code.size(rewardTokens[idx].field_0)
                                    call rewardTokens[idx].field_0.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, ext_call.return_data[0]
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                            idx = idx + 1
                            t = (accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                            continue 
                        if not s:
                            idx = 0
                            while idx < rewardTokens.length:
                                mem[0] = rewardTokens[idx].field_0
                                mem[32] = 10
                                if not uint256(lastStakingBlock[msg.sender].field_0):
                                    _8647 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_8647] = 26
                                    mem[_8647 + 32] = 'SafeMath: division by zero'
                                    if pRECISION_FACTOR[stor26[idx].field_0]:
                                        require idx < rewardTokens.length
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = sha3(msg.sender, 28) + 2
                                        uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    s = 32
                                    while s < 26:
                                        mem[s + mem[64] + 68] = mem[s + _8647 + 32]
                                        s = s + 32
                                        continue 
                                else:
                                    if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                        revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _8668 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_8668] = 26
                                    mem[_8668 + 32] = 'SafeMath: division by zero'
                                    if pRECISION_FACTOR[stor26[idx].field_0]:
                                        require idx < rewardTokens.length
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = sha3(msg.sender, 28) + 2
                                        uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _8668 + 32]
                                        idx = idx + 32
                                        continue 
                                revert with 0, 'SafeMath: division by zero'
                            emit Withdraw(s, msg.sender);
                        else:
                            _6340 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6340] = 30
                            mem[_6340 + 32] = 'SafeMath: subtraction overflow'
                            if s > uint256(lastStakingBlock[msg.sender].field_0):
                                revert with 0, 'SafeMath: subtraction overflow'
                            uint256(lastStakingBlock[msg.sender].field_0) -= s
                            if not msg.sender:
                                revert with 0, 32, 33, 0x7245524332303a206275726e2066726f6d20746865207a65726f20616464726573, mem[mem[64] + 101 len 31]
                            _6686 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_6686] = 34
                            mem[_6686 + 32 len 34] = 0x6b45524332303a206275726e20616d6f756e7420657863656564732062616c616e63
                            if s > balanceOf[address(msg.sender)]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 34
                                mem[mem[64] + 68 len 64] = 0x6b45524332303a206275726e20616d6f756e7420657863656564732062616c616e63, mem[_6686 + 66 len 30]
                                mem[mem[64] + 100] = mem[mem[64] + 130 len 2]
                                revert with 0, 32, 34, mem[mem[64] + 68 len 64]
                            mem[0] = msg.sender
                            mem[32] = 4
                            balanceOf[address(msg.sender)] -= s
                            _7088 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_7088] = 30
                            mem[_7088 + 32] = 'SafeMath: subtraction overflow'
                            if s > totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow'
                            totalSupply -= s
                            emit Transfer(s, msg.sender, 0);
                            _7224 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_7224] = uint256(lastStakingBlock[msg.sender].field_0)
                            mem[_7224 + 32] = uint256(lastStakingBlock[msg.sender].field_256)
                            _7263 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_7263] = 30
                            mem[_7263 + 32] = 'SafeMath: subtraction overflow'
                            if uint256(lastStakingBlock[msg.sender].field_256) > block.number:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if 0 == feePeriod:
                                if not s:
                                    _7362 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_7362] = 26
                                    mem[_7362 + 32] = 'SafeMath: division by zero'
                                    require ext_code.size(stakedTokenAddress)
                                    call stakedTokenAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args feeCollectorAddress, 0
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    _7449 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_7449] = 30
                                    mem[_7449 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > s:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    totalStaked -= s
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = s
                                    require ext_code.size(stakedTokenAddress)
                                    call stakedTokenAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, s
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    idx = 0
                                    while idx < rewardTokens.length:
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = 10
                                        if not uint256(lastStakingBlock[msg.sender].field_0):
                                            _8649 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8649] = 26
                                            mem[_8649 + 32] = 'SafeMath: division by zero'
                                            if pRECISION_FACTOR[stor26[idx].field_0]:
                                                require idx < rewardTokens.length
                                                mem[0] = rewardTokens[idx].field_0
                                                mem[32] = sha3(msg.sender, 28) + 2
                                                uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            s = 32
                                            while s < 26:
                                                mem[s + mem[64] + 68] = mem[s + _8649 + 32]
                                                s = s + 32
                                                continue 
                                        else:
                                            if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                                revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _8670 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8670] = 26
                                            mem[_8670 + 32] = 'SafeMath: division by zero'
                                            if pRECISION_FACTOR[stor26[idx].field_0]:
                                                require idx < rewardTokens.length
                                                mem[0] = rewardTokens[idx].field_0
                                                mem[32] = sha3(msg.sender, 28) + 2
                                                uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _8670 + 32]
                                                idx = idx + 32
                                                continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    emit Withdraw(s, msg.sender);
                                else:
                                    if unStakingFee * s / s != unStakingFee:
                                        revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _7368 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_7368] = 26
                                    mem[_7368 + 32] = 'SafeMath: division by zero'
                                    require ext_code.size(stakedTokenAddress)
                                    call stakedTokenAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args feeCollectorAddress, unStakingFee * s / 10000
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    _7461 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_7461] = 30
                                    mem[_7461 + 32] = 'SafeMath: subtraction overflow'
                                    if unStakingFee * s / 10000 > s:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    totalStaked = totalStaked - s + (unStakingFee * s / 10000)
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = s - (unStakingFee * s / 10000)
                                    require ext_code.size(stakedTokenAddress)
                                    call stakedTokenAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, s - (unStakingFee * s / 10000)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    idx = 0
                                    while idx < rewardTokens.length:
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = 10
                                        if not uint256(lastStakingBlock[msg.sender].field_0):
                                            _8648 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8648] = 26
                                            mem[_8648 + 32] = 'SafeMath: division by zero'
                                            if pRECISION_FACTOR[stor26[idx].field_0]:
                                                require idx < rewardTokens.length
                                                mem[0] = rewardTokens[idx].field_0
                                                mem[32] = sha3(msg.sender, 28) + 2
                                                uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            s = 32
                                            while s < 26:
                                                mem[s + mem[64] + 68] = mem[s + _8648 + 32]
                                                s = s + 32
                                                continue 
                                        else:
                                            if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                                revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _8669 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8669] = 26
                                            mem[_8669 + 32] = 'SafeMath: division by zero'
                                            if pRECISION_FACTOR[stor26[idx].field_0]:
                                                require idx < rewardTokens.length
                                                mem[0] = rewardTokens[idx].field_0
                                                mem[32] = sha3(msg.sender, 28) + 2
                                                uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _8669 + 32]
                                                idx = idx + 32
                                                continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    emit Withdraw((s - (unStakingFee * s / 10000)), msg.sender);
                            else:
                                if feePeriod <= 0:
                                    totalStaked -= s
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = s
                                    require ext_code.size(stakedTokenAddress)
                                    call stakedTokenAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, s
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    idx = 0
                                    while idx < rewardTokens.length:
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = 10
                                        if not uint256(lastStakingBlock[msg.sender].field_0):
                                            _8650 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8650] = 26
                                            mem[_8650 + 32] = 'SafeMath: division by zero'
                                            if pRECISION_FACTOR[stor26[idx].field_0]:
                                                require idx < rewardTokens.length
                                                mem[0] = rewardTokens[idx].field_0
                                                mem[32] = sha3(msg.sender, 28) + 2
                                                uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            s = 32
                                            while s < 26:
                                                mem[s + mem[64] + 68] = mem[s + _8650 + 32]
                                                s = s + 32
                                                continue 
                                        else:
                                            if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                                revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _8671 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8671] = 26
                                            mem[_8671 + 32] = 'SafeMath: division by zero'
                                            if pRECISION_FACTOR[stor26[idx].field_0]:
                                                require idx < rewardTokens.length
                                                mem[0] = rewardTokens[idx].field_0
                                                mem[32] = sha3(msg.sender, 28) + 2
                                                uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _8671 + 32]
                                                idx = idx + 32
                                                continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    emit Withdraw(s, msg.sender);
                                else:
                                    if feePeriod < block.number - uint256(lastStakingBlock[msg.sender].field_256):
                                        totalStaked -= s
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = s
                                        require ext_code.size(stakedTokenAddress)
                                        call stakedTokenAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, s
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        idx = 0
                                        while idx < rewardTokens.length:
                                            mem[0] = rewardTokens[idx].field_0
                                            mem[32] = 10
                                            if not uint256(lastStakingBlock[msg.sender].field_0):
                                                _8651 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8651] = 26
                                                mem[_8651 + 32] = 'SafeMath: division by zero'
                                                if pRECISION_FACTOR[stor26[idx].field_0]:
                                                    require idx < rewardTokens.length
                                                    mem[0] = rewardTokens[idx].field_0
                                                    mem[32] = sha3(msg.sender, 28) + 2
                                                    uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                                    idx = idx + 1
                                                    continue 
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                                s = 32
                                                while s < 26:
                                                    mem[s + mem[64] + 68] = mem[s + _8651 + 32]
                                                    s = s + 32
                                                    continue 
                                            else:
                                                if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                                    revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                _8672 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8672] = 26
                                                mem[_8672 + 32] = 'SafeMath: division by zero'
                                                if pRECISION_FACTOR[stor26[idx].field_0]:
                                                    require idx < rewardTokens.length
                                                    mem[0] = rewardTokens[idx].field_0
                                                    mem[32] = sha3(msg.sender, 28) + 2
                                                    uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                                    idx = idx + 1
                                                    continue 
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                                idx = 32
                                                while idx < 26:
                                                    mem[idx + mem[64] + 68] = mem[idx + _8672 + 32]
                                                    idx = idx + 32
                                                    continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        emit Withdraw(s, msg.sender);
                                    else:
                                        if not s:
                                            _7377 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7377] = 26
                                            mem[_7377 + 32] = 'SafeMath: division by zero'
                                            require ext_code.size(stakedTokenAddress)
                                            call stakedTokenAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args feeCollectorAddress, 0
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            _7481 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7481] = 30
                                            mem[_7481 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > s:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            totalStaked -= s
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = s
                                            require ext_code.size(stakedTokenAddress)
                                            call stakedTokenAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, s
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            idx = 0
                                            while idx < rewardTokens.length:
                                                mem[0] = rewardTokens[idx].field_0
                                                mem[32] = 10
                                                if not uint256(lastStakingBlock[msg.sender].field_0):
                                                    _8653 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_8653] = 26
                                                    mem[_8653 + 32] = 'SafeMath: division by zero'
                                                    if pRECISION_FACTOR[stor26[idx].field_0]:
                                                        require idx < rewardTokens.length
                                                        mem[0] = rewardTokens[idx].field_0
                                                        mem[32] = sha3(msg.sender, 28) + 2
                                                        uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                                        idx = idx + 1
                                                        continue 
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                                    s = 32
                                                    while s < 26:
                                                        mem[s + mem[64] + 68] = mem[s + _8653 + 32]
                                                        s = s + 32
                                                        continue 
                                                else:
                                                    if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                                        revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    _8674 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_8674] = 26
                                                    mem[_8674 + 32] = 'SafeMath: division by zero'
                                                    if pRECISION_FACTOR[stor26[idx].field_0]:
                                                        require idx < rewardTokens.length
                                                        mem[0] = rewardTokens[idx].field_0
                                                        mem[32] = sha3(msg.sender, 28) + 2
                                                        uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                                        idx = idx + 1
                                                        continue 
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                                    idx = 32
                                                    while idx < 26:
                                                        mem[idx + mem[64] + 68] = mem[idx + _8674 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                revert with 0, 'SafeMath: division by zero'
                                            emit Withdraw(s, msg.sender);
                                        else:
                                            if unStakingFee * s / s != unStakingFee:
                                                revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _7382 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7382] = 26
                                            mem[_7382 + 32] = 'SafeMath: division by zero'
                                            require ext_code.size(stakedTokenAddress)
                                            call stakedTokenAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args feeCollectorAddress, unStakingFee * s / 10000
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            _7501 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_7501] = 30
                                            mem[_7501 + 32] = 'SafeMath: subtraction overflow'
                                            if unStakingFee * s / 10000 > s:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            totalStaked = totalStaked - s + (unStakingFee * s / 10000)
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = s - (unStakingFee * s / 10000)
                                            require ext_code.size(stakedTokenAddress)
                                            call stakedTokenAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, s - (unStakingFee * s / 10000)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            idx = 0
                                            while idx < rewardTokens.length:
                                                mem[0] = rewardTokens[idx].field_0
                                                mem[32] = 10
                                                if not uint256(lastStakingBlock[msg.sender].field_0):
                                                    _8652 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_8652] = 26
                                                    mem[_8652 + 32] = 'SafeMath: division by zero'
                                                    if pRECISION_FACTOR[stor26[idx].field_0]:
                                                        require idx < rewardTokens.length
                                                        mem[0] = rewardTokens[idx].field_0
                                                        mem[32] = sha3(msg.sender, 28) + 2
                                                        uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                                        idx = idx + 1
                                                        continue 
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                                    s = 32
                                                    while s < 26:
                                                        mem[s + mem[64] + 68] = mem[s + _8652 + 32]
                                                        s = s + 32
                                                        continue 
                                                else:
                                                    if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                                        revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                                    _8673 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_8673] = 26
                                                    mem[_8673 + 32] = 'SafeMath: division by zero'
                                                    if pRECISION_FACTOR[stor26[idx].field_0]:
                                                        require idx < rewardTokens.length
                                                        mem[0] = rewardTokens[idx].field_0
                                                        mem[32] = sha3(msg.sender, 28) + 2
                                                        uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                                        idx = idx + 1
                                                        continue 
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                                    idx = 32
                                                    while idx < 26:
                                                        mem[idx + mem[64] + 68] = mem[idx + _8673 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                revert with 0, 'SafeMath: division by zero'
                                            emit Withdraw((s - (unStakingFee * s / 10000)), msg.sender);
    stor3 = 1
}

function deposit(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if stor3 == 2:
        revert with 0, 'ReentrancyGuard: reentrant call'
    stor3 = 2
    if bool(sub_c7b01a97) != 1:
        revert with 0, 'Pool is not ready'
    if block.number < stakingBlock:
        revert with 0, 'Staking has not started'
    if stakingEndBlock < block.number:
        revert with 0, 'Staking has ended'
    mem[64] = 224
    mem[96] = msg.sender
    mem[128] = arg1
    mem[160] = block.number
    mem[192] = block.number + sub_cea8c746
    mem[32] = 30
    uint256(sub_ea73c96d[msg.sender].field_0)++
    mem[0] = sha3(msg.sender, 30)
    sub_ea73c96d[msg.sender][uint256(sub_ea73c96d[msg.sender].field_0)].field_0 = msg.sender
    uint256(sub_ea73c96d[msg.sender][uint256(sub_ea73c96d[msg.sender].field_0)].field_256) = arg1
    uint256(sub_ea73c96d[msg.sender][uint256(sub_ea73c96d[msg.sender].field_0)].field_512) = block.number
    uint256(sub_ea73c96d[msg.sender][uint256(sub_ea73c96d[msg.sender].field_0)].field_768) = block.number + sub_cea8c746
    if not uint8(stor9.field_176):
        if not uint8(stor9.field_168):
            if block.number <= lastRewardBlock:
                if not uint256(lastStakingBlock[msg.sender].field_0):
                    if not arg1:
                        idx = 0
                        while idx < rewardTokens.length:
                            mem[0] = rewardTokens[idx].field_0
                            mem[32] = 10
                            if not uint256(lastStakingBlock[msg.sender].field_0):
                                _5764 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5764] = 26
                                mem[_5764 + 32] = 'SafeMath: division by zero'
                                if pRECISION_FACTOR[stor26[idx].field_0]:
                                    require idx < rewardTokens.length
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = sha3(msg.sender, 28) + 2
                                    uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                s = 32
                                while s < 26:
                                    mem[s + mem[64] + 68] = mem[s + _5764 + 32]
                                    s = s + 32
                                    continue 
                            else:
                                if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                    revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _5880 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5880] = 26
                                mem[_5880 + 32] = 'SafeMath: division by zero'
                                if pRECISION_FACTOR[stor26[idx].field_0]:
                                    require idx < rewardTokens.length
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = sha3(msg.sender, 28) + 2
                                    uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _5880 + 32]
                                    idx = idx + 32
                                    continue 
                            revert with 0, 'SafeMath: division by zero'
                    else:
                        if arg1 + uint256(lastStakingBlock[msg.sender].field_0) < uint256(lastStakingBlock[msg.sender].field_0):
                            revert with 0, 'SafeMath: addition overflow'
                        uint256(lastStakingBlock[msg.sender].field_0) += arg1
                        mem[228] = msg.sender
                        mem[260] = this.address
                        mem[292] = arg1
                        require ext_code.size(stakedTokenAddress)
                        call stakedTokenAddress.0x23b872dd with:
                             gas gas_remaining wei
                            args msg.sender, this.address, arg1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not msg.sender:
                            revert with 0, 'ERC20: mint to the zero address'
                        if arg1 + totalSupply < totalSupply:
                            revert with 0, 'SafeMath: addition overflow'
                        totalSupply += arg1
                        if arg1 + balanceOf[address(msg.sender)] < balanceOf[address(msg.sender)]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[32] = 4
                        balanceOf[address(msg.sender)] += arg1
                        mem[224] = arg1
                        emit Transfer(arg1, 0, msg.sender);
                        idx = 0
                        while idx < rewardTokens.length:
                            mem[0] = rewardTokens[idx].field_0
                            mem[32] = 10
                            if not uint256(lastStakingBlock[msg.sender].field_0):
                                _5765 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5765] = 26
                                mem[_5765 + 32] = 'SafeMath: division by zero'
                                if pRECISION_FACTOR[stor26[idx].field_0]:
                                    require idx < rewardTokens.length
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = sha3(msg.sender, 28) + 2
                                    uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                s = 32
                                while s < 26:
                                    mem[s + mem[64] + 68] = mem[s + _5765 + 32]
                                    s = s + 32
                                    continue 
                            else:
                                if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                    revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _5881 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5881] = 26
                                mem[_5881 + 32] = 'SafeMath: division by zero'
                                if pRECISION_FACTOR[stor26[idx].field_0]:
                                    require idx < rewardTokens.length
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = sha3(msg.sender, 28) + 2
                                    uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _5881 + 32]
                                    idx = idx + 32
                                    continue 
                            revert with 0, 'SafeMath: division by zero'
                else:
                    idx = 0
                    s = 0
                    while idx < rewardTokens.length:
                        mem[0] = rewardTokens[idx].field_0
                        mem[32] = 10
                        if not uint256(lastStakingBlock[msg.sender].field_0):
                            _5882 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5882] = 26
                            mem[_5882 + 32] = 'SafeMath: division by zero'
                            if not pRECISION_FACTOR[stor26[idx].field_0]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _5882 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            _6819 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6819] = 30
                            mem[_6819 + 32] = 'SafeMath: subtraction overflow'
                            if uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) > 0 / pRECISION_FACTOR[stor26[idx].field_0]:
                                _7299 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _7299 + 68] = mem[idx + _6819 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_7299 + 68] = mem[_7299 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _7299 + -mem[64] + 100
                            if (0 / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0):
                                require idx < rewardTokens.length
                                mem[0] = 26
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = (0 / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                                require ext_code.size(rewardTokens[idx].field_0)
                                call rewardTokens[idx].field_0.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, (0 / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                            idx = idx + 1
                            s = (0 / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                            continue 
                        if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                            revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _5965 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5965] = 26
                        mem[_5965 + 32] = 'SafeMath: division by zero'
                        if not pRECISION_FACTOR[stor26[idx].field_0]:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _5965 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        _7043 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_7043] = 30
                        mem[_7043 + 32] = 'SafeMath: subtraction overflow'
                        if uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) > accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]:
                            _7535 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _7535 + 68] = mem[idx + _7043 + 32]
                                idx = idx + 32
                                continue 
                            mem[_7535 + 68] = mem[_7535 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _7535 + -mem[64] + 100
                        if (accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0):
                            require idx < rewardTokens.length
                            mem[0] = 26
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = (accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                            require ext_code.size(rewardTokens[idx].field_0)
                            call rewardTokens[idx].field_0.0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, (accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                        idx = idx + 1
                        s = (accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                        continue 
                    if not arg1:
                        idx = 0
                        while idx < rewardTokens.length:
                            mem[0] = rewardTokens[idx].field_0
                            mem[32] = 10
                            if not uint256(lastStakingBlock[msg.sender].field_0):
                                _11322 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11322] = 26
                                mem[_11322 + 32] = 'SafeMath: division by zero'
                                if pRECISION_FACTOR[stor26[idx].field_0]:
                                    require idx < rewardTokens.length
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = sha3(msg.sender, 28) + 2
                                    uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                s = 32
                                while s < 26:
                                    mem[s + mem[64] + 68] = mem[s + _11322 + 32]
                                    s = s + 32
                                    continue 
                            else:
                                if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                    revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _11392 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11392] = 26
                                mem[_11392 + 32] = 'SafeMath: division by zero'
                                if pRECISION_FACTOR[stor26[idx].field_0]:
                                    require idx < rewardTokens.length
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = sha3(msg.sender, 28) + 2
                                    uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _11392 + 32]
                                    idx = idx + 32
                                    continue 
                            revert with 0, 'SafeMath: division by zero'
                    else:
                        if arg1 + uint256(lastStakingBlock[msg.sender].field_0) < uint256(lastStakingBlock[msg.sender].field_0):
                            revert with 0, 'SafeMath: addition overflow'
                        uint256(lastStakingBlock[msg.sender].field_0) += arg1
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = this.address
                        mem[mem[64] + 68] = arg1
                        require ext_code.size(stakedTokenAddress)
                        call stakedTokenAddress.0x23b872dd with:
                             gas gas_remaining wei
                            args msg.sender, this.address, arg1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not msg.sender:
                            revert with 0, 'ERC20: mint to the zero address'
                        if arg1 + totalSupply < totalSupply:
                            revert with 0, 'SafeMath: addition overflow'
                        totalSupply += arg1
                        if arg1 + balanceOf[address(msg.sender)] < balanceOf[address(msg.sender)]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[32] = 4
                        balanceOf[address(msg.sender)] += arg1
                        mem[mem[64]] = arg1
                        emit Transfer(arg1, 0, msg.sender);
                        idx = 0
                        while idx < rewardTokens.length:
                            mem[0] = rewardTokens[idx].field_0
                            mem[32] = 10
                            if not uint256(lastStakingBlock[msg.sender].field_0):
                                _11323 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11323] = 26
                                mem[_11323 + 32] = 'SafeMath: division by zero'
                                if pRECISION_FACTOR[stor26[idx].field_0]:
                                    require idx < rewardTokens.length
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = sha3(msg.sender, 28) + 2
                                    uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                s = 32
                                while s < 26:
                                    mem[s + mem[64] + 68] = mem[s + _11323 + 32]
                                    s = s + 32
                                    continue 
                            else:
                                if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                    revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _11393 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11393] = 26
                                mem[_11393 + 32] = 'SafeMath: division by zero'
                                if pRECISION_FACTOR[stor26[idx].field_0]:
                                    require idx < rewardTokens.length
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = sha3(msg.sender, 28) + 2
                                    uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _11393 + 32]
                                    idx = idx + 32
                                    continue 
                            revert with 0, 'SafeMath: division by zero'
            else:
                mem[228] = this.address
                require ext_code.size(stakedTokenAddress)
                staticcall stakedTokenAddress.0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[224] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if not ext_call.return_data[0]:
                    lastRewardBlock = block.number
                    if not uint256(lastStakingBlock[msg.sender].field_0):
                        if not arg1:
                            idx = 0
                            while idx < rewardTokens.length:
                                mem[0] = rewardTokens[idx].field_0
                                mem[32] = 10
                                if not uint256(lastStakingBlock[msg.sender].field_0):
                                    _5759 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5759] = 26
                                    mem[_5759 + 32] = 'SafeMath: division by zero'
                                    if pRECISION_FACTOR[stor26[idx].field_0]:
                                        require idx < rewardTokens.length
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = sha3(msg.sender, 28) + 2
                                        uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    s = 32
                                    while s < 26:
                                        mem[s + mem[64] + 68] = mem[s + _5759 + 32]
                                        s = s + 32
                                        continue 
                                else:
                                    if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                        revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _5877 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5877] = 26
                                    mem[_5877 + 32] = 'SafeMath: division by zero'
                                    if pRECISION_FACTOR[stor26[idx].field_0]:
                                        require idx < rewardTokens.length
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = sha3(msg.sender, 28) + 2
                                        uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _5877 + 32]
                                        idx = idx + 32
                                        continue 
                                revert with 0, 'SafeMath: division by zero'
                        else:
                            if arg1 + uint256(lastStakingBlock[msg.sender].field_0) < uint256(lastStakingBlock[msg.sender].field_0):
                                revert with 0, 'SafeMath: addition overflow'
                            uint256(lastStakingBlock[msg.sender].field_0) += arg1
                            mem[228] = msg.sender
                            mem[260] = this.address
                            mem[292] = arg1
                            require ext_code.size(stakedTokenAddress)
                            call stakedTokenAddress.0x23b872dd with:
                                 gas gas_remaining wei
                                args msg.sender, this.address, arg1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if not msg.sender:
                                revert with 0, 'ERC20: mint to the zero address'
                            if arg1 + totalSupply < totalSupply:
                                revert with 0, 'SafeMath: addition overflow'
                            totalSupply += arg1
                            if arg1 + balanceOf[address(msg.sender)] < balanceOf[address(msg.sender)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[32] = 4
                            balanceOf[address(msg.sender)] += arg1
                            mem[224] = arg1
                            emit Transfer(arg1, 0, msg.sender);
                            idx = 0
                            while idx < rewardTokens.length:
                                mem[0] = rewardTokens[idx].field_0
                                mem[32] = 10
                                if not uint256(lastStakingBlock[msg.sender].field_0):
                                    _5760 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5760] = 26
                                    mem[_5760 + 32] = 'SafeMath: division by zero'
                                    if pRECISION_FACTOR[stor26[idx].field_0]:
                                        require idx < rewardTokens.length
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = sha3(msg.sender, 28) + 2
                                        uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    s = 32
                                    while s < 26:
                                        mem[s + mem[64] + 68] = mem[s + _5760 + 32]
                                        s = s + 32
                                        continue 
                                else:
                                    if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                        revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _5878 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5878] = 26
                                    mem[_5878 + 32] = 'SafeMath: division by zero'
                                    if pRECISION_FACTOR[stor26[idx].field_0]:
                                        require idx < rewardTokens.length
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = sha3(msg.sender, 28) + 2
                                        uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _5878 + 32]
                                        idx = idx + 32
                                        continue 
                                revert with 0, 'SafeMath: division by zero'
                    else:
                        idx = 0
                        s = 0
                        while idx < rewardTokens.length:
                            mem[0] = rewardTokens[idx].field_0
                            mem[32] = 10
                            if not uint256(lastStakingBlock[msg.sender].field_0):
                                _5879 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5879] = 26
                                mem[_5879 + 32] = 'SafeMath: division by zero'
                                if not pRECISION_FACTOR[stor26[idx].field_0]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _5879 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                _6800 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6800] = 30
                                mem[_6800 + 32] = 'SafeMath: subtraction overflow'
                                if uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) > 0 / pRECISION_FACTOR[stor26[idx].field_0]:
                                    _7290 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _7290 + 68] = mem[idx + _6800 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_7290 + 68] = mem[_7290 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _7290 + -mem[64] + 100
                                if (0 / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0):
                                    require idx < rewardTokens.length
                                    mem[0] = 26
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = (0 / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                                    require ext_code.size(rewardTokens[idx].field_0)
                                    call rewardTokens[idx].field_0.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, (0 / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                idx = idx + 1
                                s = (0 / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                                continue 
                            if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _5958 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5958] = 26
                            mem[_5958 + 32] = 'SafeMath: division by zero'
                            if not pRECISION_FACTOR[stor26[idx].field_0]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _5958 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            _7032 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_7032] = 30
                            mem[_7032 + 32] = 'SafeMath: subtraction overflow'
                            if uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) > accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]:
                                _7526 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _7526 + 68] = mem[idx + _7032 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_7526 + 68] = mem[_7526 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _7526 + -mem[64] + 100
                            if (accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0):
                                require idx < rewardTokens.length
                                mem[0] = 26
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = (accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                                require ext_code.size(rewardTokens[idx].field_0)
                                call rewardTokens[idx].field_0.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, (accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                            idx = idx + 1
                            s = (accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                            continue 
                        if not arg1:
                            idx = 0
                            while idx < rewardTokens.length:
                                mem[0] = rewardTokens[idx].field_0
                                mem[32] = 10
                                if not uint256(lastStakingBlock[msg.sender].field_0):
                                    _11320 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11320] = 26
                                    mem[_11320 + 32] = 'SafeMath: division by zero'
                                    if pRECISION_FACTOR[stor26[idx].field_0]:
                                        require idx < rewardTokens.length
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = sha3(msg.sender, 28) + 2
                                        uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    s = 32
                                    while s < 26:
                                        mem[s + mem[64] + 68] = mem[s + _11320 + 32]
                                        s = s + 32
                                        continue 
                                else:
                                    if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                        revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _11390 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11390] = 26
                                    mem[_11390 + 32] = 'SafeMath: division by zero'
                                    if pRECISION_FACTOR[stor26[idx].field_0]:
                                        require idx < rewardTokens.length
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = sha3(msg.sender, 28) + 2
                                        uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _11390 + 32]
                                        idx = idx + 32
                                        continue 
                                revert with 0, 'SafeMath: division by zero'
                        else:
                            if arg1 + uint256(lastStakingBlock[msg.sender].field_0) < uint256(lastStakingBlock[msg.sender].field_0):
                                revert with 0, 'SafeMath: addition overflow'
                            uint256(lastStakingBlock[msg.sender].field_0) += arg1
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = this.address
                            mem[mem[64] + 68] = arg1
                            require ext_code.size(stakedTokenAddress)
                            call stakedTokenAddress.0x23b872dd with:
                                 gas gas_remaining wei
                                args msg.sender, this.address, arg1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if not msg.sender:
                                revert with 0, 'ERC20: mint to the zero address'
                            if arg1 + totalSupply < totalSupply:
                                revert with 0, 'SafeMath: addition overflow'
                            totalSupply += arg1
                            if arg1 + balanceOf[address(msg.sender)] < balanceOf[address(msg.sender)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[32] = 4
                            balanceOf[address(msg.sender)] += arg1
                            mem[mem[64]] = arg1
                            emit Transfer(arg1, 0, msg.sender);
                            idx = 0
                            while idx < rewardTokens.length:
                                mem[0] = rewardTokens[idx].field_0
                                mem[32] = 10
                                if not uint256(lastStakingBlock[msg.sender].field_0):
                                    _11321 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11321] = 26
                                    mem[_11321 + 32] = 'SafeMath: division by zero'
                                    if pRECISION_FACTOR[stor26[idx].field_0]:
                                        require idx < rewardTokens.length
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = sha3(msg.sender, 28) + 2
                                        uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    s = 32
                                    while s < 26:
                                        mem[s + mem[64] + 68] = mem[s + _11321 + 32]
                                        s = s + 32
                                        continue 
                                else:
                                    if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                        revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _11391 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11391] = 26
                                    mem[_11391 + 32] = 'SafeMath: division by zero'
                                    if pRECISION_FACTOR[stor26[idx].field_0]:
                                        require idx < rewardTokens.length
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = sha3(msg.sender, 28) + 2
                                        uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _11391 + 32]
                                        idx = idx + 32
                                        continue 
                                revert with 0, 'SafeMath: division by zero'
                else:
                    if block.number <= bonusEndBlock:
                        mem[64] = 288
                        mem[224] = 30
                        mem[256] = 'SafeMath: subtraction overflow'
                        if lastRewardBlock > block.number:
                            revert with 0, 'SafeMath: subtraction overflow'
                        idx = 0
                        while idx < rewardTokens.length:
                            if not block.number - lastRewardBlock:
                                require idx < rewardTokens.length
                                mem[0] = rewardTokens[idx].field_0
                                mem[32] = 25
                                _6233 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6233] = 26
                                mem[_6233 + 32] = 'SafeMath: division by zero'
                                if not ext_call.return_data[0]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _6233 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                require idx < rewardTokens.length
                                if (0 / ext_call.return_data[0]) + accTokenPerShare[stor26[idx].field_0] < accTokenPerShare[stor26[idx].field_0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require idx < rewardTokens.length
                                mem[0] = rewardTokens[idx].field_0
                                mem[32] = 10
                                accTokenPerShare[stor26[idx].field_0] += 0 / ext_call.return_data[0]
                            else:
                                if (block.number * rewardPerBlock[stor26[idx].field_0]) - (lastRewardBlock * rewardPerBlock[stor26[idx].field_0]) / block.number - lastRewardBlock != rewardPerBlock[stor26[idx].field_0]:
                                    revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                require idx < rewardTokens.length
                                mem[0] = rewardTokens[idx].field_0
                                mem[32] = 25
                                if not (block.number * rewardPerBlock[stor26[idx].field_0]) - (lastRewardBlock * rewardPerBlock[stor26[idx].field_0]):
                                    _6383 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6383] = 26
                                    mem[_6383 + 32] = 'SafeMath: division by zero'
                                    if not ext_call.return_data[0]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _6383 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    require idx < rewardTokens.length
                                    if (0 / ext_call.return_data[0]) + accTokenPerShare[stor26[idx].field_0] < accTokenPerShare[stor26[idx].field_0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    require idx < rewardTokens.length
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = 10
                                    accTokenPerShare[stor26[idx].field_0] += 0 / ext_call.return_data[0]
                                else:
                                    if (block.number * rewardPerBlock[stor26[idx].field_0] * pRECISION_FACTOR[stor26[idx].field_0]) - (lastRewardBlock * rewardPerBlock[stor26[idx].field_0] * pRECISION_FACTOR[stor26[idx].field_0]) / (block.number * rewardPerBlock[stor26[idx].field_0]) - (lastRewardBlock * rewardPerBlock[stor26[idx].field_0]) != pRECISION_FACTOR[stor26[idx].field_0]:
                                        revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _6562 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6562] = 26
                                    mem[_6562 + 32] = 'SafeMath: division by zero'
                                    if not ext_call.return_data[0]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _6562 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    require idx < rewardTokens.length
                                    if ((block.number * rewardPerBlock[stor26[idx].field_0] * pRECISION_FACTOR[stor26[idx].field_0]) - (lastRewardBlock * rewardPerBlock[stor26[idx].field_0] * pRECISION_FACTOR[stor26[idx].field_0]) / ext_call.return_data[0]) + accTokenPerShare[stor26[idx].field_0] < accTokenPerShare[stor26[idx].field_0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    require idx < rewardTokens.length
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = 10
                                    accTokenPerShare[stor26[idx].field_0] += (block.number * rewardPerBlock[stor26[idx].field_0] * pRECISION_FACTOR[stor26[idx].field_0]) - (lastRewardBlock * rewardPerBlock[stor26[idx].field_0] * pRECISION_FACTOR[stor26[idx].field_0]) / ext_call.return_data[0]
                            idx = idx + 1
                            continue 
                        lastRewardBlock = block.number
                        if not uint256(lastStakingBlock[msg.sender].field_0):
                            if not arg1:
                                s = 0
                                while s < rewardTokens.length:
                                    mem[0] = rewardTokens[s].field_0
                                    mem[32] = 10
                                    if not uint256(lastStakingBlock[msg.sender].field_0):
                                        _11315 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11315] = 26
                                        mem[_11315 + 32] = 'SafeMath: division by zero'
                                        if pRECISION_FACTOR[stor26[s].field_0]:
                                            require s < rewardTokens.length
                                            mem[0] = rewardTokens[s].field_0
                                            mem[32] = sha3(msg.sender, 28) + 2
                                            uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[s].field_0]
                                            s = s + 1
                                            continue 
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _11315 + 32]
                                            idx = idx + 32
                                            continue 
                                    else:
                                        if accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[s].field_0]:
                                            revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _11387 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11387] = 26
                                        mem[_11387 + 32] = 'SafeMath: division by zero'
                                        if pRECISION_FACTOR[stor26[s].field_0]:
                                            require s < rewardTokens.length
                                            mem[0] = rewardTokens[s].field_0
                                            mem[32] = sha3(msg.sender, 28) + 2
                                            uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0) = accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[s].field_0]
                                            s = s + 1
                                            continue 
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        s = 32
                                        while s < 26:
                                            mem[s + mem[64] + 68] = mem[s + _11387 + 32]
                                            s = s + 32
                                            continue 
                                    revert with 0, 'SafeMath: division by zero'
                            else:
                                if arg1 + uint256(lastStakingBlock[msg.sender].field_0) < uint256(lastStakingBlock[msg.sender].field_0):
                                    revert with 0, 'SafeMath: addition overflow'
                                uint256(lastStakingBlock[msg.sender].field_0) += arg1
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = this.address
                                mem[mem[64] + 68] = arg1
                                require ext_code.size(stakedTokenAddress)
                                call stakedTokenAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, this.address, arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not msg.sender:
                                    revert with 0, 'ERC20: mint to the zero address'
                                if arg1 + totalSupply < totalSupply:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalSupply += arg1
                                if arg1 + balanceOf[address(msg.sender)] < balanceOf[address(msg.sender)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[32] = 4
                                balanceOf[address(msg.sender)] += arg1
                                mem[mem[64]] = arg1
                                emit Transfer(arg1, 0, msg.sender);
                                idx = 0
                                while idx < rewardTokens.length:
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = 10
                                    if not uint256(lastStakingBlock[msg.sender].field_0):
                                        _11316 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11316] = 26
                                        mem[_11316 + 32] = 'SafeMath: division by zero'
                                        if pRECISION_FACTOR[stor26[idx].field_0]:
                                            require idx < rewardTokens.length
                                            mem[0] = rewardTokens[idx].field_0
                                            mem[32] = sha3(msg.sender, 28) + 2
                                            uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                            idx = idx + 1
                                            continue 
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        s = 32
                                        while s < 26:
                                            mem[s + mem[64] + 68] = mem[s + _11316 + 32]
                                            s = s + 32
                                            continue 
                                    else:
                                        if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                            revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _11388 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11388] = 26
                                        mem[_11388 + 32] = 'SafeMath: division by zero'
                                        if pRECISION_FACTOR[stor26[idx].field_0]:
                                            require idx < rewardTokens.length
                                            mem[0] = rewardTokens[idx].field_0
                                            mem[32] = sha3(msg.sender, 28) + 2
                                            uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                            idx = idx + 1
                                            continue 
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _11388 + 32]
                                            idx = idx + 32
                                            continue 
                                    revert with 0, 'SafeMath: division by zero'
                        else:
                            s = 0
                            t = 0
                            while s < rewardTokens.length:
                                mem[0] = rewardTokens[s].field_0
                                mem[32] = 10
                                if not uint256(lastStakingBlock[msg.sender].field_0):
                                    _11389 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11389] = 26
                                    mem[_11389 + 32] = 'SafeMath: division by zero'
                                    if not pRECISION_FACTOR[stor26[s].field_0]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _11389 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    _12575 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12575] = 30
                                    mem[_12575 + 32] = 'SafeMath: subtraction overflow'
                                    if uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0) > 0 / pRECISION_FACTOR[stor26[s].field_0]:
                                        _13001 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13001 + 68] = mem[idx + _12575 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13001 + 68] = mem[_13001 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _13001 + -mem[64] + 100
                                    if (0 / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0):
                                        require s < rewardTokens.length
                                        mem[0] = 26
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = (0 / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0)
                                        require ext_code.size(rewardTokens[s].field_0)
                                        call rewardTokens[s].field_0.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, (0 / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                    s = s + 1
                                    t = (0 / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0)
                                    continue 
                                if accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[s].field_0]:
                                    revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _11453 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11453] = 26
                                mem[_11453 + 32] = 'SafeMath: division by zero'
                                if not pRECISION_FACTOR[stor26[s].field_0]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    s = 32
                                    while s < 26:
                                        mem[s + mem[64] + 68] = mem[s + _11453 + 32]
                                        s = s + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                _12858 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12858] = 30
                                mem[_12858 + 32] = 'SafeMath: subtraction overflow'
                                if uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0) > accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[s].field_0]:
                                    _13109 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13109 + 68] = mem[idx + _12858 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13109 + 68] = mem[_13109 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _13109 + -mem[64] + 100
                                if (accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0):
                                    require s < rewardTokens.length
                                    mem[0] = 26
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = (accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0)
                                    require ext_code.size(rewardTokens[s].field_0)
                                    call rewardTokens[s].field_0.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, (accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                s = s + 1
                                t = (accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0)
                                continue 
                            if not arg1:
                                idx = 0
                                while idx < rewardTokens.length:
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = 10
                                    if not uint256(lastStakingBlock[msg.sender].field_0):
                                        _14657 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_14657] = 26
                                        mem[_14657 + 32] = 'SafeMath: division by zero'
                                        if pRECISION_FACTOR[stor26[idx].field_0]:
                                            require idx < rewardTokens.length
                                            mem[0] = rewardTokens[idx].field_0
                                            mem[32] = sha3(msg.sender, 28) + 2
                                            uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                            idx = idx + 1
                                            continue 
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        s = 32
                                        while s < 26:
                                            mem[s + mem[64] + 68] = mem[s + _14657 + 32]
                                            s = s + 32
                                            continue 
                                    else:
                                        if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                            revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _14681 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_14681] = 26
                                        mem[_14681 + 32] = 'SafeMath: division by zero'
                                        if pRECISION_FACTOR[stor26[idx].field_0]:
                                            require idx < rewardTokens.length
                                            mem[0] = rewardTokens[idx].field_0
                                            mem[32] = sha3(msg.sender, 28) + 2
                                            uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                            idx = idx + 1
                                            continue 
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _14681 + 32]
                                            idx = idx + 32
                                            continue 
                                    revert with 0, 'SafeMath: division by zero'
                            else:
                                if arg1 + uint256(lastStakingBlock[msg.sender].field_0) < uint256(lastStakingBlock[msg.sender].field_0):
                                    revert with 0, 'SafeMath: addition overflow'
                                uint256(lastStakingBlock[msg.sender].field_0) += arg1
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = this.address
                                mem[mem[64] + 68] = arg1
                                require ext_code.size(stakedTokenAddress)
                                call stakedTokenAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, this.address, arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not msg.sender:
                                    revert with 0, 'ERC20: mint to the zero address'
                                if arg1 + totalSupply < totalSupply:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalSupply += arg1
                                if arg1 + balanceOf[address(msg.sender)] < balanceOf[address(msg.sender)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[32] = 4
                                balanceOf[address(msg.sender)] += arg1
                                mem[mem[64]] = arg1
                                emit Transfer(arg1, 0, msg.sender);
                                idx = 0
                                while idx < rewardTokens.length:
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = 10
                                    if not uint256(lastStakingBlock[msg.sender].field_0):
                                        _14658 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_14658] = 26
                                        mem[_14658 + 32] = 'SafeMath: division by zero'
                                        if pRECISION_FACTOR[stor26[idx].field_0]:
                                            require idx < rewardTokens.length
                                            mem[0] = rewardTokens[idx].field_0
                                            mem[32] = sha3(msg.sender, 28) + 2
                                            uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                            idx = idx + 1
                                            continue 
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        s = 32
                                        while s < 26:
                                            mem[s + mem[64] + 68] = mem[s + _14658 + 32]
                                            s = s + 32
                                            continue 
                                    else:
                                        if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                            revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _14682 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_14682] = 26
                                        mem[_14682 + 32] = 'SafeMath: division by zero'
                                        if pRECISION_FACTOR[stor26[idx].field_0]:
                                            require idx < rewardTokens.length
                                            mem[0] = rewardTokens[idx].field_0
                                            mem[32] = sha3(msg.sender, 28) + 2
                                            uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                            idx = idx + 1
                                            continue 
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _14682 + 32]
                                            idx = idx + 32
                                            continue 
                                    revert with 0, 'SafeMath: division by zero'
                    else:
                        if lastRewardBlock >= bonusEndBlock:
                            idx = 0
                            while idx < rewardTokens.length:
                                require idx < rewardTokens.length
                                mem[0] = rewardTokens[idx].field_0
                                mem[32] = 25
                                _6228 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6228] = 26
                                mem[_6228 + 32] = 'SafeMath: division by zero'
                                if not ext_call.return_data[0]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _6228 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                require idx < rewardTokens.length
                                if (0 / ext_call.return_data[0]) + accTokenPerShare[stor26[idx].field_0] < accTokenPerShare[stor26[idx].field_0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require idx < rewardTokens.length
                                mem[0] = rewardTokens[idx].field_0
                                mem[32] = 10
                                accTokenPerShare[stor26[idx].field_0] += 0 / ext_call.return_data[0]
                                idx = idx + 1
                                continue 
                            lastRewardBlock = block.number
                            if not uint256(lastStakingBlock[msg.sender].field_0):
                                if not arg1:
                                    s = 0
                                    while s < rewardTokens.length:
                                        mem[0] = rewardTokens[s].field_0
                                        mem[32] = 10
                                        if not uint256(lastStakingBlock[msg.sender].field_0):
                                            _11310 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11310] = 26
                                            mem[_11310 + 32] = 'SafeMath: division by zero'
                                            if pRECISION_FACTOR[stor26[s].field_0]:
                                                require s < rewardTokens.length
                                                mem[0] = rewardTokens[s].field_0
                                                mem[32] = sha3(msg.sender, 28) + 2
                                                uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[s].field_0]
                                                s = s + 1
                                                continue 
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _11310 + 32]
                                                idx = idx + 32
                                                continue 
                                        else:
                                            if accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[s].field_0]:
                                                revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _11384 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11384] = 26
                                            mem[_11384 + 32] = 'SafeMath: division by zero'
                                            if pRECISION_FACTOR[stor26[s].field_0]:
                                                require s < rewardTokens.length
                                                mem[0] = rewardTokens[s].field_0
                                                mem[32] = sha3(msg.sender, 28) + 2
                                                uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0) = accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[s].field_0]
                                                s = s + 1
                                                continue 
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            s = 32
                                            while s < 26:
                                                mem[s + mem[64] + 68] = mem[s + _11384 + 32]
                                                s = s + 32
                                                continue 
                                        revert with 0, 'SafeMath: division by zero'
                                else:
                                    if arg1 + uint256(lastStakingBlock[msg.sender].field_0) < uint256(lastStakingBlock[msg.sender].field_0):
                                        revert with 0, 'SafeMath: addition overflow'
                                    uint256(lastStakingBlock[msg.sender].field_0) += arg1
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = this.address
                                    mem[mem[64] + 68] = arg1
                                    require ext_code.size(stakedTokenAddress)
                                    call stakedTokenAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, this.address, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not msg.sender:
                                        revert with 0, 'ERC20: mint to the zero address'
                                    if arg1 + totalSupply < totalSupply:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalSupply += arg1
                                    if arg1 + balanceOf[address(msg.sender)] < balanceOf[address(msg.sender)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[32] = 4
                                    balanceOf[address(msg.sender)] += arg1
                                    mem[mem[64]] = arg1
                                    emit Transfer(arg1, 0, msg.sender);
                                    idx = 0
                                    while idx < rewardTokens.length:
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = 10
                                        if not uint256(lastStakingBlock[msg.sender].field_0):
                                            _11311 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11311] = 26
                                            mem[_11311 + 32] = 'SafeMath: division by zero'
                                            if pRECISION_FACTOR[stor26[idx].field_0]:
                                                require idx < rewardTokens.length
                                                mem[0] = rewardTokens[idx].field_0
                                                mem[32] = sha3(msg.sender, 28) + 2
                                                uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            s = 32
                                            while s < 26:
                                                mem[s + mem[64] + 68] = mem[s + _11311 + 32]
                                                s = s + 32
                                                continue 
                                        else:
                                            if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                                revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _11385 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11385] = 26
                                            mem[_11385 + 32] = 'SafeMath: division by zero'
                                            if pRECISION_FACTOR[stor26[idx].field_0]:
                                                require idx < rewardTokens.length
                                                mem[0] = rewardTokens[idx].field_0
                                                mem[32] = sha3(msg.sender, 28) + 2
                                                uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _11385 + 32]
                                                idx = idx + 32
                                                continue 
                                        revert with 0, 'SafeMath: division by zero'
                            else:
                                s = 0
                                t = 0
                                while s < rewardTokens.length:
                                    mem[0] = rewardTokens[s].field_0
                                    mem[32] = 10
                                    if not uint256(lastStakingBlock[msg.sender].field_0):
                                        _11386 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11386] = 26
                                        mem[_11386 + 32] = 'SafeMath: division by zero'
                                        if not pRECISION_FACTOR[stor26[s].field_0]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _11386 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        _12556 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12556] = 30
                                        mem[_12556 + 32] = 'SafeMath: subtraction overflow'
                                        if uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0) > 0 / pRECISION_FACTOR[stor26[s].field_0]:
                                            _12992 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _12992 + 68] = mem[idx + _12556 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_12992 + 68] = mem[_12992 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _12992 + -mem[64] + 100
                                        if (0 / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0):
                                            require s < rewardTokens.length
                                            mem[0] = 26
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = (0 / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0)
                                            require ext_code.size(rewardTokens[s].field_0)
                                            call rewardTokens[s].field_0.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (0 / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                        s = s + 1
                                        t = (0 / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0)
                                        continue 
                                    if accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[s].field_0]:
                                        revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _11446 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11446] = 26
                                    mem[_11446 + 32] = 'SafeMath: division by zero'
                                    if not pRECISION_FACTOR[stor26[s].field_0]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        s = 32
                                        while s < 26:
                                            mem[s + mem[64] + 68] = mem[s + _11446 + 32]
                                            s = s + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    _12847 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12847] = 30
                                    mem[_12847 + 32] = 'SafeMath: subtraction overflow'
                                    if uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0) > accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[s].field_0]:
                                        _13100 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13100 + 68] = mem[idx + _12847 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13100 + 68] = mem[_13100 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _13100 + -mem[64] + 100
                                    if (accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0):
                                        require s < rewardTokens.length
                                        mem[0] = 26
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = (accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0)
                                        require ext_code.size(rewardTokens[s].field_0)
                                        call rewardTokens[s].field_0.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, (accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                    s = s + 1
                                    t = (accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0)
                                    continue 
                                if not arg1:
                                    idx = 0
                                    while idx < rewardTokens.length:
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = 10
                                        if not uint256(lastStakingBlock[msg.sender].field_0):
                                            _14655 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_14655] = 26
                                            mem[_14655 + 32] = 'SafeMath: division by zero'
                                            if pRECISION_FACTOR[stor26[idx].field_0]:
                                                require idx < rewardTokens.length
                                                mem[0] = rewardTokens[idx].field_0
                                                mem[32] = sha3(msg.sender, 28) + 2
                                                uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            s = 32
                                            while s < 26:
                                                mem[s + mem[64] + 68] = mem[s + _14655 + 32]
                                                s = s + 32
                                                continue 
                                        else:
                                            if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                                revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _14679 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_14679] = 26
                                            mem[_14679 + 32] = 'SafeMath: division by zero'
                                            if pRECISION_FACTOR[stor26[idx].field_0]:
                                                require idx < rewardTokens.length
                                                mem[0] = rewardTokens[idx].field_0
                                                mem[32] = sha3(msg.sender, 28) + 2
                                                uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _14679 + 32]
                                                idx = idx + 32
                                                continue 
                                        revert with 0, 'SafeMath: division by zero'
                                else:
                                    if arg1 + uint256(lastStakingBlock[msg.sender].field_0) < uint256(lastStakingBlock[msg.sender].field_0):
                                        revert with 0, 'SafeMath: addition overflow'
                                    uint256(lastStakingBlock[msg.sender].field_0) += arg1
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = this.address
                                    mem[mem[64] + 68] = arg1
                                    require ext_code.size(stakedTokenAddress)
                                    call stakedTokenAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, this.address, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not msg.sender:
                                        revert with 0, 'ERC20: mint to the zero address'
                                    if arg1 + totalSupply < totalSupply:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalSupply += arg1
                                    if arg1 + balanceOf[address(msg.sender)] < balanceOf[address(msg.sender)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[32] = 4
                                    balanceOf[address(msg.sender)] += arg1
                                    mem[mem[64]] = arg1
                                    emit Transfer(arg1, 0, msg.sender);
                                    idx = 0
                                    while idx < rewardTokens.length:
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = 10
                                        if not uint256(lastStakingBlock[msg.sender].field_0):
                                            _14656 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_14656] = 26
                                            mem[_14656 + 32] = 'SafeMath: division by zero'
                                            if pRECISION_FACTOR[stor26[idx].field_0]:
                                                require idx < rewardTokens.length
                                                mem[0] = rewardTokens[idx].field_0
                                                mem[32] = sha3(msg.sender, 28) + 2
                                                uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            s = 32
                                            while s < 26:
                                                mem[s + mem[64] + 68] = mem[s + _14656 + 32]
                                                s = s + 32
                                                continue 
                                        else:
                                            if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                                revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _14680 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_14680] = 26
                                            mem[_14680 + 32] = 'SafeMath: division by zero'
                                            if pRECISION_FACTOR[stor26[idx].field_0]:
                                                require idx < rewardTokens.length
                                                mem[0] = rewardTokens[idx].field_0
                                                mem[32] = sha3(msg.sender, 28) + 2
                                                uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _14680 + 32]
                                                idx = idx + 32
                                                continue 
                                        revert with 0, 'SafeMath: division by zero'
                        else:
                            mem[64] = 288
                            mem[224] = 30
                            mem[256] = 'SafeMath: subtraction overflow'
                            if lastRewardBlock > bonusEndBlock:
                                revert with 0, 'SafeMath: subtraction overflow'
                            idx = 0
                            while idx < rewardTokens.length:
                                if not bonusEndBlock - lastRewardBlock:
                                    require idx < rewardTokens.length
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = 25
                                    _6225 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6225] = 26
                                    mem[_6225 + 32] = 'SafeMath: division by zero'
                                    if not ext_call.return_data[0]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _6225 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    require idx < rewardTokens.length
                                    if (0 / ext_call.return_data[0]) + accTokenPerShare[stor26[idx].field_0] < accTokenPerShare[stor26[idx].field_0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    require idx < rewardTokens.length
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = 10
                                    accTokenPerShare[stor26[idx].field_0] += 0 / ext_call.return_data[0]
                                else:
                                    if (bonusEndBlock * rewardPerBlock[stor26[idx].field_0]) - (lastRewardBlock * rewardPerBlock[stor26[idx].field_0]) / bonusEndBlock - lastRewardBlock != rewardPerBlock[stor26[idx].field_0]:
                                        revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    require idx < rewardTokens.length
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = 25
                                    if not (bonusEndBlock * rewardPerBlock[stor26[idx].field_0]) - (lastRewardBlock * rewardPerBlock[stor26[idx].field_0]):
                                        _6368 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6368] = 26
                                        mem[_6368 + 32] = 'SafeMath: division by zero'
                                        if not ext_call.return_data[0]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _6368 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        require idx < rewardTokens.length
                                        if (0 / ext_call.return_data[0]) + accTokenPerShare[stor26[idx].field_0] < accTokenPerShare[stor26[idx].field_0]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        require idx < rewardTokens.length
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = 10
                                        accTokenPerShare[stor26[idx].field_0] += 0 / ext_call.return_data[0]
                                    else:
                                        if (bonusEndBlock * rewardPerBlock[stor26[idx].field_0] * pRECISION_FACTOR[stor26[idx].field_0]) - (lastRewardBlock * rewardPerBlock[stor26[idx].field_0] * pRECISION_FACTOR[stor26[idx].field_0]) / (bonusEndBlock * rewardPerBlock[stor26[idx].field_0]) - (lastRewardBlock * rewardPerBlock[stor26[idx].field_0]) != pRECISION_FACTOR[stor26[idx].field_0]:
                                            revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _6551 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6551] = 26
                                        mem[_6551 + 32] = 'SafeMath: division by zero'
                                        if not ext_call.return_data[0]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _6551 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        require idx < rewardTokens.length
                                        if ((bonusEndBlock * rewardPerBlock[stor26[idx].field_0] * pRECISION_FACTOR[stor26[idx].field_0]) - (lastRewardBlock * rewardPerBlock[stor26[idx].field_0] * pRECISION_FACTOR[stor26[idx].field_0]) / ext_call.return_data[0]) + accTokenPerShare[stor26[idx].field_0] < accTokenPerShare[stor26[idx].field_0]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        require idx < rewardTokens.length
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = 10
                                        accTokenPerShare[stor26[idx].field_0] += (bonusEndBlock * rewardPerBlock[stor26[idx].field_0] * pRECISION_FACTOR[stor26[idx].field_0]) - (lastRewardBlock * rewardPerBlock[stor26[idx].field_0] * pRECISION_FACTOR[stor26[idx].field_0]) / ext_call.return_data[0]
                                idx = idx + 1
                                continue 
                            lastRewardBlock = block.number
                            if not uint256(lastStakingBlock[msg.sender].field_0):
                                if not arg1:
                                    s = 0
                                    while s < rewardTokens.length:
                                        mem[0] = rewardTokens[s].field_0
                                        mem[32] = 10
                                        if not uint256(lastStakingBlock[msg.sender].field_0):
                                            _11305 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11305] = 26
                                            mem[_11305 + 32] = 'SafeMath: division by zero'
                                            if pRECISION_FACTOR[stor26[s].field_0]:
                                                require s < rewardTokens.length
                                                mem[0] = rewardTokens[s].field_0
                                                mem[32] = sha3(msg.sender, 28) + 2
                                                uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[s].field_0]
                                                s = s + 1
                                                continue 
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _11305 + 32]
                                                idx = idx + 32
                                                continue 
                                        else:
                                            if accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[s].field_0]:
                                                revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _11381 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11381] = 26
                                            mem[_11381 + 32] = 'SafeMath: division by zero'
                                            if pRECISION_FACTOR[stor26[s].field_0]:
                                                require s < rewardTokens.length
                                                mem[0] = rewardTokens[s].field_0
                                                mem[32] = sha3(msg.sender, 28) + 2
                                                uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0) = accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[s].field_0]
                                                s = s + 1
                                                continue 
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            s = 32
                                            while s < 26:
                                                mem[s + mem[64] + 68] = mem[s + _11381 + 32]
                                                s = s + 32
                                                continue 
                                        revert with 0, 'SafeMath: division by zero'
                                else:
                                    if arg1 + uint256(lastStakingBlock[msg.sender].field_0) < uint256(lastStakingBlock[msg.sender].field_0):
                                        revert with 0, 'SafeMath: addition overflow'
                                    uint256(lastStakingBlock[msg.sender].field_0) += arg1
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = this.address
                                    mem[mem[64] + 68] = arg1
                                    require ext_code.size(stakedTokenAddress)
                                    call stakedTokenAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, this.address, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not msg.sender:
                                        revert with 0, 'ERC20: mint to the zero address'
                                    if arg1 + totalSupply < totalSupply:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalSupply += arg1
                                    if arg1 + balanceOf[address(msg.sender)] < balanceOf[address(msg.sender)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[32] = 4
                                    balanceOf[address(msg.sender)] += arg1
                                    mem[mem[64]] = arg1
                                    emit Transfer(arg1, 0, msg.sender);
                                    idx = 0
                                    while idx < rewardTokens.length:
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = 10
                                        if not uint256(lastStakingBlock[msg.sender].field_0):
                                            _11306 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11306] = 26
                                            mem[_11306 + 32] = 'SafeMath: division by zero'
                                            if pRECISION_FACTOR[stor26[idx].field_0]:
                                                require idx < rewardTokens.length
                                                mem[0] = rewardTokens[idx].field_0
                                                mem[32] = sha3(msg.sender, 28) + 2
                                                uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            s = 32
                                            while s < 26:
                                                mem[s + mem[64] + 68] = mem[s + _11306 + 32]
                                                s = s + 32
                                                continue 
                                        else:
                                            if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                                revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _11382 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11382] = 26
                                            mem[_11382 + 32] = 'SafeMath: division by zero'
                                            if pRECISION_FACTOR[stor26[idx].field_0]:
                                                require idx < rewardTokens.length
                                                mem[0] = rewardTokens[idx].field_0
                                                mem[32] = sha3(msg.sender, 28) + 2
                                                uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _11382 + 32]
                                                idx = idx + 32
                                                continue 
                                        revert with 0, 'SafeMath: division by zero'
                            else:
                                s = 0
                                t = 0
                                while s < rewardTokens.length:
                                    mem[0] = rewardTokens[s].field_0
                                    mem[32] = 10
                                    if not uint256(lastStakingBlock[msg.sender].field_0):
                                        _11383 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11383] = 26
                                        mem[_11383 + 32] = 'SafeMath: division by zero'
                                        if not pRECISION_FACTOR[stor26[s].field_0]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _11383 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        _12537 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12537] = 30
                                        mem[_12537 + 32] = 'SafeMath: subtraction overflow'
                                        if uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0) > 0 / pRECISION_FACTOR[stor26[s].field_0]:
                                            _12983 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _12983 + 68] = mem[idx + _12537 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_12983 + 68] = mem[_12983 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _12983 + -mem[64] + 100
                                        if (0 / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0):
                                            require s < rewardTokens.length
                                            mem[0] = 26
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = (0 / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0)
                                            require ext_code.size(rewardTokens[s].field_0)
                                            call rewardTokens[s].field_0.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (0 / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                        s = s + 1
                                        t = (0 / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0)
                                        continue 
                                    if accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[s].field_0]:
                                        revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _11439 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11439] = 26
                                    mem[_11439 + 32] = 'SafeMath: division by zero'
                                    if not pRECISION_FACTOR[stor26[s].field_0]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        s = 32
                                        while s < 26:
                                            mem[s + mem[64] + 68] = mem[s + _11439 + 32]
                                            s = s + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    _12836 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12836] = 30
                                    mem[_12836 + 32] = 'SafeMath: subtraction overflow'
                                    if uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0) > accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[s].field_0]:
                                        _13091 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13091 + 68] = mem[idx + _12836 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13091 + 68] = mem[_13091 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _13091 + -mem[64] + 100
                                    if (accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0):
                                        require s < rewardTokens.length
                                        mem[0] = 26
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = (accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0)
                                        require ext_code.size(rewardTokens[s].field_0)
                                        call rewardTokens[s].field_0.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, (accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                    s = s + 1
                                    t = (accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0)
                                    continue 
                                if not arg1:
                                    idx = 0
                                    while idx < rewardTokens.length:
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = 10
                                        if not uint256(lastStakingBlock[msg.sender].field_0):
                                            _14653 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_14653] = 26
                                            mem[_14653 + 32] = 'SafeMath: division by zero'
                                            if pRECISION_FACTOR[stor26[idx].field_0]:
                                                require idx < rewardTokens.length
                                                mem[0] = rewardTokens[idx].field_0
                                                mem[32] = sha3(msg.sender, 28) + 2
                                                uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            s = 32
                                            while s < 26:
                                                mem[s + mem[64] + 68] = mem[s + _14653 + 32]
                                                s = s + 32
                                                continue 
                                        else:
                                            if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                                revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _14677 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_14677] = 26
                                            mem[_14677 + 32] = 'SafeMath: division by zero'
                                            if pRECISION_FACTOR[stor26[idx].field_0]:
                                                require idx < rewardTokens.length
                                                mem[0] = rewardTokens[idx].field_0
                                                mem[32] = sha3(msg.sender, 28) + 2
                                                uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _14677 + 32]
                                                idx = idx + 32
                                                continue 
                                        revert with 0, 'SafeMath: division by zero'
                                else:
                                    if arg1 + uint256(lastStakingBlock[msg.sender].field_0) < uint256(lastStakingBlock[msg.sender].field_0):
                                        revert with 0, 'SafeMath: addition overflow'
                                    uint256(lastStakingBlock[msg.sender].field_0) += arg1
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = this.address
                                    mem[mem[64] + 68] = arg1
                                    require ext_code.size(stakedTokenAddress)
                                    call stakedTokenAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, this.address, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not msg.sender:
                                        revert with 0, 'ERC20: mint to the zero address'
                                    if arg1 + totalSupply < totalSupply:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalSupply += arg1
                                    if arg1 + balanceOf[address(msg.sender)] < balanceOf[address(msg.sender)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[32] = 4
                                    balanceOf[address(msg.sender)] += arg1
                                    mem[mem[64]] = arg1
                                    emit Transfer(arg1, 0, msg.sender);
                                    idx = 0
                                    while idx < rewardTokens.length:
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = 10
                                        if not uint256(lastStakingBlock[msg.sender].field_0):
                                            _14654 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_14654] = 26
                                            mem[_14654 + 32] = 'SafeMath: division by zero'
                                            if pRECISION_FACTOR[stor26[idx].field_0]:
                                                require idx < rewardTokens.length
                                                mem[0] = rewardTokens[idx].field_0
                                                mem[32] = sha3(msg.sender, 28) + 2
                                                uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            s = 32
                                            while s < 26:
                                                mem[s + mem[64] + 68] = mem[s + _14654 + 32]
                                                s = s + 32
                                                continue 
                                        else:
                                            if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                                revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _14678 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_14678] = 26
                                            mem[_14678 + 32] = 'SafeMath: division by zero'
                                            if pRECISION_FACTOR[stor26[idx].field_0]:
                                                require idx < rewardTokens.length
                                                mem[0] = rewardTokens[idx].field_0
                                                mem[32] = sha3(msg.sender, 28) + 2
                                                uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _14678 + 32]
                                                idx = idx + 32
                                                continue 
                                        revert with 0, 'SafeMath: division by zero'
        else:
            if uint256(lastStakingBlock[msg.sender].field_0) + arg1 < arg1:
                revert with 0, 'SafeMath: addition overflow'
            if uint256(lastStakingBlock[msg.sender].field_0) + arg1 > poolLimitPerUser:
                revert with 0, 'User amount above limit'
            if block.number <= lastRewardBlock:
                if not uint256(lastStakingBlock[msg.sender].field_0):
                    if not arg1:
                        idx = 0
                        while idx < rewardTokens.length:
                            mem[0] = rewardTokens[idx].field_0
                            mem[32] = 10
                            if not uint256(lastStakingBlock[msg.sender].field_0):
                                _5796 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5796] = 26
                                mem[_5796 + 32] = 'SafeMath: division by zero'
                                if pRECISION_FACTOR[stor26[idx].field_0]:
                                    require idx < rewardTokens.length
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = sha3(msg.sender, 28) + 2
                                    uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                s = 32
                                while s < 26:
                                    mem[s + mem[64] + 68] = mem[s + _5796 + 32]
                                    s = s + 32
                                    continue 
                            else:
                                if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                    revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _5898 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5898] = 26
                                mem[_5898 + 32] = 'SafeMath: division by zero'
                                if pRECISION_FACTOR[stor26[idx].field_0]:
                                    require idx < rewardTokens.length
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = sha3(msg.sender, 28) + 2
                                    uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _5898 + 32]
                                    idx = idx + 32
                                    continue 
                            revert with 0, 'SafeMath: division by zero'
                    else:
                        if arg1 + uint256(lastStakingBlock[msg.sender].field_0) < uint256(lastStakingBlock[msg.sender].field_0):
                            revert with 0, 'SafeMath: addition overflow'
                        uint256(lastStakingBlock[msg.sender].field_0) += arg1
                        mem[228] = msg.sender
                        mem[260] = this.address
                        mem[292] = arg1
                        require ext_code.size(stakedTokenAddress)
                        call stakedTokenAddress.0x23b872dd with:
                             gas gas_remaining wei
                            args msg.sender, this.address, arg1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not msg.sender:
                            revert with 0, 'ERC20: mint to the zero address'
                        if arg1 + totalSupply < totalSupply:
                            revert with 0, 'SafeMath: addition overflow'
                        totalSupply += arg1
                        if arg1 + balanceOf[address(msg.sender)] < balanceOf[address(msg.sender)]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[32] = 4
                        balanceOf[address(msg.sender)] += arg1
                        mem[224] = arg1
                        emit Transfer(arg1, 0, msg.sender);
                        idx = 0
                        while idx < rewardTokens.length:
                            mem[0] = rewardTokens[idx].field_0
                            mem[32] = 10
                            if not uint256(lastStakingBlock[msg.sender].field_0):
                                _5797 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5797] = 26
                                mem[_5797 + 32] = 'SafeMath: division by zero'
                                if pRECISION_FACTOR[stor26[idx].field_0]:
                                    require idx < rewardTokens.length
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = sha3(msg.sender, 28) + 2
                                    uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                s = 32
                                while s < 26:
                                    mem[s + mem[64] + 68] = mem[s + _5797 + 32]
                                    s = s + 32
                                    continue 
                            else:
                                if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                    revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _5899 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5899] = 26
                                mem[_5899 + 32] = 'SafeMath: division by zero'
                                if pRECISION_FACTOR[stor26[idx].field_0]:
                                    require idx < rewardTokens.length
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = sha3(msg.sender, 28) + 2
                                    uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _5899 + 32]
                                    idx = idx + 32
                                    continue 
                            revert with 0, 'SafeMath: division by zero'
                else:
                    idx = 0
                    s = 0
                    while idx < rewardTokens.length:
                        mem[0] = rewardTokens[idx].field_0
                        mem[32] = 10
                        if not uint256(lastStakingBlock[msg.sender].field_0):
                            _5900 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5900] = 26
                            mem[_5900 + 32] = 'SafeMath: division by zero'
                            if not pRECISION_FACTOR[stor26[idx].field_0]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _5900 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            _6872 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6872] = 30
                            mem[_6872 + 32] = 'SafeMath: subtraction overflow'
                            if uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) > 0 / pRECISION_FACTOR[stor26[idx].field_0]:
                                _7356 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _7356 + 68] = mem[idx + _6872 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_7356 + 68] = mem[_7356 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _7356 + -mem[64] + 100
                            if (0 / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0):
                                require idx < rewardTokens.length
                                mem[0] = 26
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = (0 / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                                require ext_code.size(rewardTokens[idx].field_0)
                                call rewardTokens[idx].field_0.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, (0 / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                            idx = idx + 1
                            s = (0 / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                            continue 
                        if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                            revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _5994 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5994] = 26
                        mem[_5994 + 32] = 'SafeMath: division by zero'
                        if not pRECISION_FACTOR[stor26[idx].field_0]:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _5994 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        _7109 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_7109] = 30
                        mem[_7109 + 32] = 'SafeMath: subtraction overflow'
                        if uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) > accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]:
                            _7600 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _7600 + 68] = mem[idx + _7109 + 32]
                                idx = idx + 32
                                continue 
                            mem[_7600 + 68] = mem[_7600 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _7600 + -mem[64] + 100
                        if (accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0):
                            require idx < rewardTokens.length
                            mem[0] = 26
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = (accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                            require ext_code.size(rewardTokens[idx].field_0)
                            call rewardTokens[idx].field_0.0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, (accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                        idx = idx + 1
                        s = (accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                        continue 
                    if not arg1:
                        idx = 0
                        while idx < rewardTokens.length:
                            mem[0] = rewardTokens[idx].field_0
                            mem[32] = 10
                            if not uint256(lastStakingBlock[msg.sender].field_0):
                                _11341 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11341] = 26
                                mem[_11341 + 32] = 'SafeMath: division by zero'
                                if pRECISION_FACTOR[stor26[idx].field_0]:
                                    require idx < rewardTokens.length
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = sha3(msg.sender, 28) + 2
                                    uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                s = 32
                                while s < 26:
                                    mem[s + mem[64] + 68] = mem[s + _11341 + 32]
                                    s = s + 32
                                    continue 
                            else:
                                if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                    revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _11405 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11405] = 26
                                mem[_11405 + 32] = 'SafeMath: division by zero'
                                if pRECISION_FACTOR[stor26[idx].field_0]:
                                    require idx < rewardTokens.length
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = sha3(msg.sender, 28) + 2
                                    uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _11405 + 32]
                                    idx = idx + 32
                                    continue 
                            revert with 0, 'SafeMath: division by zero'
                    else:
                        if arg1 + uint256(lastStakingBlock[msg.sender].field_0) < uint256(lastStakingBlock[msg.sender].field_0):
                            revert with 0, 'SafeMath: addition overflow'
                        uint256(lastStakingBlock[msg.sender].field_0) += arg1
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = this.address
                        mem[mem[64] + 68] = arg1
                        require ext_code.size(stakedTokenAddress)
                        call stakedTokenAddress.0x23b872dd with:
                             gas gas_remaining wei
                            args msg.sender, this.address, arg1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not msg.sender:
                            revert with 0, 'ERC20: mint to the zero address'
                        if arg1 + totalSupply < totalSupply:
                            revert with 0, 'SafeMath: addition overflow'
                        totalSupply += arg1
                        if arg1 + balanceOf[address(msg.sender)] < balanceOf[address(msg.sender)]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[32] = 4
                        balanceOf[address(msg.sender)] += arg1
                        mem[mem[64]] = arg1
                        emit Transfer(arg1, 0, msg.sender);
                        idx = 0
                        while idx < rewardTokens.length:
                            mem[0] = rewardTokens[idx].field_0
                            mem[32] = 10
                            if not uint256(lastStakingBlock[msg.sender].field_0):
                                _11342 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11342] = 26
                                mem[_11342 + 32] = 'SafeMath: division by zero'
                                if pRECISION_FACTOR[stor26[idx].field_0]:
                                    require idx < rewardTokens.length
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = sha3(msg.sender, 28) + 2
                                    uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                s = 32
                                while s < 26:
                                    mem[s + mem[64] + 68] = mem[s + _11342 + 32]
                                    s = s + 32
                                    continue 
                            else:
                                if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                    revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _11406 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11406] = 26
                                mem[_11406 + 32] = 'SafeMath: division by zero'
                                if pRECISION_FACTOR[stor26[idx].field_0]:
                                    require idx < rewardTokens.length
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = sha3(msg.sender, 28) + 2
                                    uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _11406 + 32]
                                    idx = idx + 32
                                    continue 
                            revert with 0, 'SafeMath: division by zero'
            else:
                mem[228] = this.address
                require ext_code.size(stakedTokenAddress)
                staticcall stakedTokenAddress.0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[224] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if not ext_call.return_data[0]:
                    lastRewardBlock = block.number
                    if not uint256(lastStakingBlock[msg.sender].field_0):
                        if not arg1:
                            idx = 0
                            while idx < rewardTokens.length:
                                mem[0] = rewardTokens[idx].field_0
                                mem[32] = 10
                                if not uint256(lastStakingBlock[msg.sender].field_0):
                                    _5791 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5791] = 26
                                    mem[_5791 + 32] = 'SafeMath: division by zero'
                                    if pRECISION_FACTOR[stor26[idx].field_0]:
                                        require idx < rewardTokens.length
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = sha3(msg.sender, 28) + 2
                                        uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    s = 32
                                    while s < 26:
                                        mem[s + mem[64] + 68] = mem[s + _5791 + 32]
                                        s = s + 32
                                        continue 
                                else:
                                    if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                        revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _5895 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5895] = 26
                                    mem[_5895 + 32] = 'SafeMath: division by zero'
                                    if pRECISION_FACTOR[stor26[idx].field_0]:
                                        require idx < rewardTokens.length
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = sha3(msg.sender, 28) + 2
                                        uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _5895 + 32]
                                        idx = idx + 32
                                        continue 
                                revert with 0, 'SafeMath: division by zero'
                        else:
                            if arg1 + uint256(lastStakingBlock[msg.sender].field_0) < uint256(lastStakingBlock[msg.sender].field_0):
                                revert with 0, 'SafeMath: addition overflow'
                            uint256(lastStakingBlock[msg.sender].field_0) += arg1
                            mem[228] = msg.sender
                            mem[260] = this.address
                            mem[292] = arg1
                            require ext_code.size(stakedTokenAddress)
                            call stakedTokenAddress.0x23b872dd with:
                                 gas gas_remaining wei
                                args msg.sender, this.address, arg1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if not msg.sender:
                                revert with 0, 'ERC20: mint to the zero address'
                            if arg1 + totalSupply < totalSupply:
                                revert with 0, 'SafeMath: addition overflow'
                            totalSupply += arg1
                            if arg1 + balanceOf[address(msg.sender)] < balanceOf[address(msg.sender)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[32] = 4
                            balanceOf[address(msg.sender)] += arg1
                            mem[224] = arg1
                            emit Transfer(arg1, 0, msg.sender);
                            idx = 0
                            while idx < rewardTokens.length:
                                mem[0] = rewardTokens[idx].field_0
                                mem[32] = 10
                                if not uint256(lastStakingBlock[msg.sender].field_0):
                                    _5792 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5792] = 26
                                    mem[_5792 + 32] = 'SafeMath: division by zero'
                                    if pRECISION_FACTOR[stor26[idx].field_0]:
                                        require idx < rewardTokens.length
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = sha3(msg.sender, 28) + 2
                                        uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    s = 32
                                    while s < 26:
                                        mem[s + mem[64] + 68] = mem[s + _5792 + 32]
                                        s = s + 32
                                        continue 
                                else:
                                    if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                        revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _5896 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5896] = 26
                                    mem[_5896 + 32] = 'SafeMath: division by zero'
                                    if pRECISION_FACTOR[stor26[idx].field_0]:
                                        require idx < rewardTokens.length
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = sha3(msg.sender, 28) + 2
                                        uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _5896 + 32]
                                        idx = idx + 32
                                        continue 
                                revert with 0, 'SafeMath: division by zero'
                    else:
                        idx = 0
                        s = 0
                        while idx < rewardTokens.length:
                            mem[0] = rewardTokens[idx].field_0
                            mem[32] = 10
                            if not uint256(lastStakingBlock[msg.sender].field_0):
                                _5897 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5897] = 26
                                mem[_5897 + 32] = 'SafeMath: division by zero'
                                if not pRECISION_FACTOR[stor26[idx].field_0]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _5897 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                _6853 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6853] = 30
                                mem[_6853 + 32] = 'SafeMath: subtraction overflow'
                                if uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) > 0 / pRECISION_FACTOR[stor26[idx].field_0]:
                                    _7347 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _7347 + 68] = mem[idx + _6853 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_7347 + 68] = mem[_7347 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _7347 + -mem[64] + 100
                                if (0 / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0):
                                    require idx < rewardTokens.length
                                    mem[0] = 26
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = (0 / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                                    require ext_code.size(rewardTokens[idx].field_0)
                                    call rewardTokens[idx].field_0.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, (0 / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                idx = idx + 1
                                s = (0 / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                                continue 
                            if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _5987 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5987] = 26
                            mem[_5987 + 32] = 'SafeMath: division by zero'
                            if not pRECISION_FACTOR[stor26[idx].field_0]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _5987 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            _7098 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_7098] = 30
                            mem[_7098 + 32] = 'SafeMath: subtraction overflow'
                            if uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) > accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]:
                                _7591 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _7591 + 68] = mem[idx + _7098 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_7591 + 68] = mem[_7591 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _7591 + -mem[64] + 100
                            if (accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0):
                                require idx < rewardTokens.length
                                mem[0] = 26
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = (accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                                require ext_code.size(rewardTokens[idx].field_0)
                                call rewardTokens[idx].field_0.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, (accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                            idx = idx + 1
                            s = (accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                            continue 
                        if not arg1:
                            idx = 0
                            while idx < rewardTokens.length:
                                mem[0] = rewardTokens[idx].field_0
                                mem[32] = 10
                                if not uint256(lastStakingBlock[msg.sender].field_0):
                                    _11339 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11339] = 26
                                    mem[_11339 + 32] = 'SafeMath: division by zero'
                                    if pRECISION_FACTOR[stor26[idx].field_0]:
                                        require idx < rewardTokens.length
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = sha3(msg.sender, 28) + 2
                                        uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    s = 32
                                    while s < 26:
                                        mem[s + mem[64] + 68] = mem[s + _11339 + 32]
                                        s = s + 32
                                        continue 
                                else:
                                    if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                        revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _11403 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11403] = 26
                                    mem[_11403 + 32] = 'SafeMath: division by zero'
                                    if pRECISION_FACTOR[stor26[idx].field_0]:
                                        require idx < rewardTokens.length
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = sha3(msg.sender, 28) + 2
                                        uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _11403 + 32]
                                        idx = idx + 32
                                        continue 
                                revert with 0, 'SafeMath: division by zero'
                        else:
                            if arg1 + uint256(lastStakingBlock[msg.sender].field_0) < uint256(lastStakingBlock[msg.sender].field_0):
                                revert with 0, 'SafeMath: addition overflow'
                            uint256(lastStakingBlock[msg.sender].field_0) += arg1
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = this.address
                            mem[mem[64] + 68] = arg1
                            require ext_code.size(stakedTokenAddress)
                            call stakedTokenAddress.0x23b872dd with:
                                 gas gas_remaining wei
                                args msg.sender, this.address, arg1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if not msg.sender:
                                revert with 0, 'ERC20: mint to the zero address'
                            if arg1 + totalSupply < totalSupply:
                                revert with 0, 'SafeMath: addition overflow'
                            totalSupply += arg1
                            if arg1 + balanceOf[address(msg.sender)] < balanceOf[address(msg.sender)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[32] = 4
                            balanceOf[address(msg.sender)] += arg1
                            mem[mem[64]] = arg1
                            emit Transfer(arg1, 0, msg.sender);
                            idx = 0
                            while idx < rewardTokens.length:
                                mem[0] = rewardTokens[idx].field_0
                                mem[32] = 10
                                if not uint256(lastStakingBlock[msg.sender].field_0):
                                    _11340 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11340] = 26
                                    mem[_11340 + 32] = 'SafeMath: division by zero'
                                    if pRECISION_FACTOR[stor26[idx].field_0]:
                                        require idx < rewardTokens.length
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = sha3(msg.sender, 28) + 2
                                        uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    s = 32
                                    while s < 26:
                                        mem[s + mem[64] + 68] = mem[s + _11340 + 32]
                                        s = s + 32
                                        continue 
                                else:
                                    if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                        revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _11404 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11404] = 26
                                    mem[_11404 + 32] = 'SafeMath: division by zero'
                                    if pRECISION_FACTOR[stor26[idx].field_0]:
                                        require idx < rewardTokens.length
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = sha3(msg.sender, 28) + 2
                                        uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _11404 + 32]
                                        idx = idx + 32
                                        continue 
                                revert with 0, 'SafeMath: division by zero'
                else:
                    if block.number <= bonusEndBlock:
                        mem[64] = 288
                        mem[224] = 30
                        mem[256] = 'SafeMath: subtraction overflow'
                        if lastRewardBlock > block.number:
                            revert with 0, 'SafeMath: subtraction overflow'
                        idx = 0
                        while idx < rewardTokens.length:
                            if not block.number - lastRewardBlock:
                                require idx < rewardTokens.length
                                mem[0] = rewardTokens[idx].field_0
                                mem[32] = 25
                                _6268 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6268] = 26
                                mem[_6268 + 32] = 'SafeMath: division by zero'
                                if not ext_call.return_data[0]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _6268 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                require idx < rewardTokens.length
                                if (0 / ext_call.return_data[0]) + accTokenPerShare[stor26[idx].field_0] < accTokenPerShare[stor26[idx].field_0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require idx < rewardTokens.length
                                mem[0] = rewardTokens[idx].field_0
                                mem[32] = 10
                                accTokenPerShare[stor26[idx].field_0] += 0 / ext_call.return_data[0]
                            else:
                                if (block.number * rewardPerBlock[stor26[idx].field_0]) - (lastRewardBlock * rewardPerBlock[stor26[idx].field_0]) / block.number - lastRewardBlock != rewardPerBlock[stor26[idx].field_0]:
                                    revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                require idx < rewardTokens.length
                                mem[0] = rewardTokens[idx].field_0
                                mem[32] = 25
                                if not (block.number * rewardPerBlock[stor26[idx].field_0]) - (lastRewardBlock * rewardPerBlock[stor26[idx].field_0]):
                                    _6430 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6430] = 26
                                    mem[_6430 + 32] = 'SafeMath: division by zero'
                                    if not ext_call.return_data[0]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _6430 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    require idx < rewardTokens.length
                                    if (0 / ext_call.return_data[0]) + accTokenPerShare[stor26[idx].field_0] < accTokenPerShare[stor26[idx].field_0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    require idx < rewardTokens.length
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = 10
                                    accTokenPerShare[stor26[idx].field_0] += 0 / ext_call.return_data[0]
                                else:
                                    if (block.number * rewardPerBlock[stor26[idx].field_0] * pRECISION_FACTOR[stor26[idx].field_0]) - (lastRewardBlock * rewardPerBlock[stor26[idx].field_0] * pRECISION_FACTOR[stor26[idx].field_0]) / (block.number * rewardPerBlock[stor26[idx].field_0]) - (lastRewardBlock * rewardPerBlock[stor26[idx].field_0]) != pRECISION_FACTOR[stor26[idx].field_0]:
                                        revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _6617 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6617] = 26
                                    mem[_6617 + 32] = 'SafeMath: division by zero'
                                    if not ext_call.return_data[0]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _6617 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    require idx < rewardTokens.length
                                    if ((block.number * rewardPerBlock[stor26[idx].field_0] * pRECISION_FACTOR[stor26[idx].field_0]) - (lastRewardBlock * rewardPerBlock[stor26[idx].field_0] * pRECISION_FACTOR[stor26[idx].field_0]) / ext_call.return_data[0]) + accTokenPerShare[stor26[idx].field_0] < accTokenPerShare[stor26[idx].field_0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    require idx < rewardTokens.length
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = 10
                                    accTokenPerShare[stor26[idx].field_0] += (block.number * rewardPerBlock[stor26[idx].field_0] * pRECISION_FACTOR[stor26[idx].field_0]) - (lastRewardBlock * rewardPerBlock[stor26[idx].field_0] * pRECISION_FACTOR[stor26[idx].field_0]) / ext_call.return_data[0]
                            idx = idx + 1
                            continue 
                        lastRewardBlock = block.number
                        if not uint256(lastStakingBlock[msg.sender].field_0):
                            if not arg1:
                                s = 0
                                while s < rewardTokens.length:
                                    mem[0] = rewardTokens[s].field_0
                                    mem[32] = 10
                                    if not uint256(lastStakingBlock[msg.sender].field_0):
                                        _11334 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11334] = 26
                                        mem[_11334 + 32] = 'SafeMath: division by zero'
                                        if pRECISION_FACTOR[stor26[s].field_0]:
                                            require s < rewardTokens.length
                                            mem[0] = rewardTokens[s].field_0
                                            mem[32] = sha3(msg.sender, 28) + 2
                                            uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[s].field_0]
                                            s = s + 1
                                            continue 
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _11334 + 32]
                                            idx = idx + 32
                                            continue 
                                    else:
                                        if accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[s].field_0]:
                                            revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _11400 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11400] = 26
                                        mem[_11400 + 32] = 'SafeMath: division by zero'
                                        if pRECISION_FACTOR[stor26[s].field_0]:
                                            require s < rewardTokens.length
                                            mem[0] = rewardTokens[s].field_0
                                            mem[32] = sha3(msg.sender, 28) + 2
                                            uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0) = accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[s].field_0]
                                            s = s + 1
                                            continue 
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        s = 32
                                        while s < 26:
                                            mem[s + mem[64] + 68] = mem[s + _11400 + 32]
                                            s = s + 32
                                            continue 
                                    revert with 0, 'SafeMath: division by zero'
                            else:
                                if arg1 + uint256(lastStakingBlock[msg.sender].field_0) < uint256(lastStakingBlock[msg.sender].field_0):
                                    revert with 0, 'SafeMath: addition overflow'
                                uint256(lastStakingBlock[msg.sender].field_0) += arg1
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = this.address
                                mem[mem[64] + 68] = arg1
                                require ext_code.size(stakedTokenAddress)
                                call stakedTokenAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, this.address, arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not msg.sender:
                                    revert with 0, 'ERC20: mint to the zero address'
                                if arg1 + totalSupply < totalSupply:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalSupply += arg1
                                if arg1 + balanceOf[address(msg.sender)] < balanceOf[address(msg.sender)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[32] = 4
                                balanceOf[address(msg.sender)] += arg1
                                mem[mem[64]] = arg1
                                emit Transfer(arg1, 0, msg.sender);
                                idx = 0
                                while idx < rewardTokens.length:
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = 10
                                    if not uint256(lastStakingBlock[msg.sender].field_0):
                                        _11335 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11335] = 26
                                        mem[_11335 + 32] = 'SafeMath: division by zero'
                                        if pRECISION_FACTOR[stor26[idx].field_0]:
                                            require idx < rewardTokens.length
                                            mem[0] = rewardTokens[idx].field_0
                                            mem[32] = sha3(msg.sender, 28) + 2
                                            uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                            idx = idx + 1
                                            continue 
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        s = 32
                                        while s < 26:
                                            mem[s + mem[64] + 68] = mem[s + _11335 + 32]
                                            s = s + 32
                                            continue 
                                    else:
                                        if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                            revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _11401 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11401] = 26
                                        mem[_11401 + 32] = 'SafeMath: division by zero'
                                        if pRECISION_FACTOR[stor26[idx].field_0]:
                                            require idx < rewardTokens.length
                                            mem[0] = rewardTokens[idx].field_0
                                            mem[32] = sha3(msg.sender, 28) + 2
                                            uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                            idx = idx + 1
                                            continue 
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _11401 + 32]
                                            idx = idx + 32
                                            continue 
                                    revert with 0, 'SafeMath: division by zero'
                        else:
                            s = 0
                            t = 0
                            while s < rewardTokens.length:
                                mem[0] = rewardTokens[s].field_0
                                mem[32] = 10
                                if not uint256(lastStakingBlock[msg.sender].field_0):
                                    _11402 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11402] = 26
                                    mem[_11402 + 32] = 'SafeMath: division by zero'
                                    if not pRECISION_FACTOR[stor26[s].field_0]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _11402 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    _12652 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12652] = 30
                                    mem[_12652 + 32] = 'SafeMath: subtraction overflow'
                                    if uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0) > 0 / pRECISION_FACTOR[stor26[s].field_0]:
                                        _13028 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13028 + 68] = mem[idx + _12652 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13028 + 68] = mem[_13028 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _13028 + -mem[64] + 100
                                    if (0 / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0):
                                        require s < rewardTokens.length
                                        mem[0] = 26
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = (0 / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0)
                                        require ext_code.size(rewardTokens[s].field_0)
                                        call rewardTokens[s].field_0.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, (0 / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                    s = s + 1
                                    t = (0 / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0)
                                    continue 
                                if accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[s].field_0]:
                                    revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _11486 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11486] = 26
                                mem[_11486 + 32] = 'SafeMath: division by zero'
                                if not pRECISION_FACTOR[stor26[s].field_0]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    s = 32
                                    while s < 26:
                                        mem[s + mem[64] + 68] = mem[s + _11486 + 32]
                                        s = s + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                _12895 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12895] = 30
                                mem[_12895 + 32] = 'SafeMath: subtraction overflow'
                                if uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0) > accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[s].field_0]:
                                    _13136 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13136 + 68] = mem[idx + _12895 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13136 + 68] = mem[_13136 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _13136 + -mem[64] + 100
                                if (accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0):
                                    require s < rewardTokens.length
                                    mem[0] = 26
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = (accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0)
                                    require ext_code.size(rewardTokens[s].field_0)
                                    call rewardTokens[s].field_0.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, (accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                s = s + 1
                                t = (accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0)
                                continue 
                            if not arg1:
                                idx = 0
                                while idx < rewardTokens.length:
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = 10
                                    if not uint256(lastStakingBlock[msg.sender].field_0):
                                        _14663 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_14663] = 26
                                        mem[_14663 + 32] = 'SafeMath: division by zero'
                                        if pRECISION_FACTOR[stor26[idx].field_0]:
                                            require idx < rewardTokens.length
                                            mem[0] = rewardTokens[idx].field_0
                                            mem[32] = sha3(msg.sender, 28) + 2
                                            uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                            idx = idx + 1
                                            continue 
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        s = 32
                                        while s < 26:
                                            mem[s + mem[64] + 68] = mem[s + _14663 + 32]
                                            s = s + 32
                                            continue 
                                    else:
                                        if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                            revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _14687 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_14687] = 26
                                        mem[_14687 + 32] = 'SafeMath: division by zero'
                                        if pRECISION_FACTOR[stor26[idx].field_0]:
                                            require idx < rewardTokens.length
                                            mem[0] = rewardTokens[idx].field_0
                                            mem[32] = sha3(msg.sender, 28) + 2
                                            uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                            idx = idx + 1
                                            continue 
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _14687 + 32]
                                            idx = idx + 32
                                            continue 
                                    revert with 0, 'SafeMath: division by zero'
                            else:
                                if arg1 + uint256(lastStakingBlock[msg.sender].field_0) < uint256(lastStakingBlock[msg.sender].field_0):
                                    revert with 0, 'SafeMath: addition overflow'
                                uint256(lastStakingBlock[msg.sender].field_0) += arg1
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = this.address
                                mem[mem[64] + 68] = arg1
                                require ext_code.size(stakedTokenAddress)
                                call stakedTokenAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, this.address, arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not msg.sender:
                                    revert with 0, 'ERC20: mint to the zero address'
                                if arg1 + totalSupply < totalSupply:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalSupply += arg1
                                if arg1 + balanceOf[address(msg.sender)] < balanceOf[address(msg.sender)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[32] = 4
                                balanceOf[address(msg.sender)] += arg1
                                mem[mem[64]] = arg1
                                emit Transfer(arg1, 0, msg.sender);
                                idx = 0
                                while idx < rewardTokens.length:
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = 10
                                    if not uint256(lastStakingBlock[msg.sender].field_0):
                                        _14664 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_14664] = 26
                                        mem[_14664 + 32] = 'SafeMath: division by zero'
                                        if pRECISION_FACTOR[stor26[idx].field_0]:
                                            require idx < rewardTokens.length
                                            mem[0] = rewardTokens[idx].field_0
                                            mem[32] = sha3(msg.sender, 28) + 2
                                            uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                            idx = idx + 1
                                            continue 
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        s = 32
                                        while s < 26:
                                            mem[s + mem[64] + 68] = mem[s + _14664 + 32]
                                            s = s + 32
                                            continue 
                                    else:
                                        if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                            revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _14688 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_14688] = 26
                                        mem[_14688 + 32] = 'SafeMath: division by zero'
                                        if pRECISION_FACTOR[stor26[idx].field_0]:
                                            require idx < rewardTokens.length
                                            mem[0] = rewardTokens[idx].field_0
                                            mem[32] = sha3(msg.sender, 28) + 2
                                            uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                            idx = idx + 1
                                            continue 
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _14688 + 32]
                                            idx = idx + 32
                                            continue 
                                    revert with 0, 'SafeMath: division by zero'
                    else:
                        if lastRewardBlock >= bonusEndBlock:
                            idx = 0
                            while idx < rewardTokens.length:
                                require idx < rewardTokens.length
                                mem[0] = rewardTokens[idx].field_0
                                mem[32] = 25
                                _6263 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6263] = 26
                                mem[_6263 + 32] = 'SafeMath: division by zero'
                                if not ext_call.return_data[0]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _6263 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                require idx < rewardTokens.length
                                if (0 / ext_call.return_data[0]) + accTokenPerShare[stor26[idx].field_0] < accTokenPerShare[stor26[idx].field_0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require idx < rewardTokens.length
                                mem[0] = rewardTokens[idx].field_0
                                mem[32] = 10
                                accTokenPerShare[stor26[idx].field_0] += 0 / ext_call.return_data[0]
                                idx = idx + 1
                                continue 
                            lastRewardBlock = block.number
                            if not uint256(lastStakingBlock[msg.sender].field_0):
                                if not arg1:
                                    s = 0
                                    while s < rewardTokens.length:
                                        mem[0] = rewardTokens[s].field_0
                                        mem[32] = 10
                                        if not uint256(lastStakingBlock[msg.sender].field_0):
                                            _11329 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11329] = 26
                                            mem[_11329 + 32] = 'SafeMath: division by zero'
                                            if pRECISION_FACTOR[stor26[s].field_0]:
                                                require s < rewardTokens.length
                                                mem[0] = rewardTokens[s].field_0
                                                mem[32] = sha3(msg.sender, 28) + 2
                                                uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[s].field_0]
                                                s = s + 1
                                                continue 
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _11329 + 32]
                                                idx = idx + 32
                                                continue 
                                        else:
                                            if accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[s].field_0]:
                                                revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _11397 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11397] = 26
                                            mem[_11397 + 32] = 'SafeMath: division by zero'
                                            if pRECISION_FACTOR[stor26[s].field_0]:
                                                require s < rewardTokens.length
                                                mem[0] = rewardTokens[s].field_0
                                                mem[32] = sha3(msg.sender, 28) + 2
                                                uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0) = accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[s].field_0]
                                                s = s + 1
                                                continue 
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            s = 32
                                            while s < 26:
                                                mem[s + mem[64] + 68] = mem[s + _11397 + 32]
                                                s = s + 32
                                                continue 
                                        revert with 0, 'SafeMath: division by zero'
                                else:
                                    if arg1 + uint256(lastStakingBlock[msg.sender].field_0) < uint256(lastStakingBlock[msg.sender].field_0):
                                        revert with 0, 'SafeMath: addition overflow'
                                    uint256(lastStakingBlock[msg.sender].field_0) += arg1
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = this.address
                                    mem[mem[64] + 68] = arg1
                                    require ext_code.size(stakedTokenAddress)
                                    call stakedTokenAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, this.address, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not msg.sender:
                                        revert with 0, 'ERC20: mint to the zero address'
                                    if arg1 + totalSupply < totalSupply:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalSupply += arg1
                                    if arg1 + balanceOf[address(msg.sender)] < balanceOf[address(msg.sender)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[32] = 4
                                    balanceOf[address(msg.sender)] += arg1
                                    mem[mem[64]] = arg1
                                    emit Transfer(arg1, 0, msg.sender);
                                    idx = 0
                                    while idx < rewardTokens.length:
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = 10
                                        if not uint256(lastStakingBlock[msg.sender].field_0):
                                            _11330 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11330] = 26
                                            mem[_11330 + 32] = 'SafeMath: division by zero'
                                            if pRECISION_FACTOR[stor26[idx].field_0]:
                                                require idx < rewardTokens.length
                                                mem[0] = rewardTokens[idx].field_0
                                                mem[32] = sha3(msg.sender, 28) + 2
                                                uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            s = 32
                                            while s < 26:
                                                mem[s + mem[64] + 68] = mem[s + _11330 + 32]
                                                s = s + 32
                                                continue 
                                        else:
                                            if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                                revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _11398 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11398] = 26
                                            mem[_11398 + 32] = 'SafeMath: division by zero'
                                            if pRECISION_FACTOR[stor26[idx].field_0]:
                                                require idx < rewardTokens.length
                                                mem[0] = rewardTokens[idx].field_0
                                                mem[32] = sha3(msg.sender, 28) + 2
                                                uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _11398 + 32]
                                                idx = idx + 32
                                                continue 
                                        revert with 0, 'SafeMath: division by zero'
                            else:
                                s = 0
                                t = 0
                                while s < rewardTokens.length:
                                    mem[0] = rewardTokens[s].field_0
                                    mem[32] = 10
                                    if not uint256(lastStakingBlock[msg.sender].field_0):
                                        _11399 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11399] = 26
                                        mem[_11399 + 32] = 'SafeMath: division by zero'
                                        if not pRECISION_FACTOR[stor26[s].field_0]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _11399 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        _12633 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12633] = 30
                                        mem[_12633 + 32] = 'SafeMath: subtraction overflow'
                                        if uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0) > 0 / pRECISION_FACTOR[stor26[s].field_0]:
                                            _13019 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _13019 + 68] = mem[idx + _12633 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_13019 + 68] = mem[_13019 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _13019 + -mem[64] + 100
                                        if (0 / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0):
                                            require s < rewardTokens.length
                                            mem[0] = 26
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = (0 / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0)
                                            require ext_code.size(rewardTokens[s].field_0)
                                            call rewardTokens[s].field_0.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (0 / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                        s = s + 1
                                        t = (0 / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0)
                                        continue 
                                    if accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[s].field_0]:
                                        revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _11479 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11479] = 26
                                    mem[_11479 + 32] = 'SafeMath: division by zero'
                                    if not pRECISION_FACTOR[stor26[s].field_0]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        s = 32
                                        while s < 26:
                                            mem[s + mem[64] + 68] = mem[s + _11479 + 32]
                                            s = s + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    _12884 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12884] = 30
                                    mem[_12884 + 32] = 'SafeMath: subtraction overflow'
                                    if uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0) > accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[s].field_0]:
                                        _13127 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13127 + 68] = mem[idx + _12884 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13127 + 68] = mem[_13127 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _13127 + -mem[64] + 100
                                    if (accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0):
                                        require s < rewardTokens.length
                                        mem[0] = 26
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = (accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0)
                                        require ext_code.size(rewardTokens[s].field_0)
                                        call rewardTokens[s].field_0.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, (accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                    s = s + 1
                                    t = (accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0)
                                    continue 
                                if not arg1:
                                    idx = 0
                                    while idx < rewardTokens.length:
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = 10
                                        if not uint256(lastStakingBlock[msg.sender].field_0):
                                            _14661 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_14661] = 26
                                            mem[_14661 + 32] = 'SafeMath: division by zero'
                                            if pRECISION_FACTOR[stor26[idx].field_0]:
                                                require idx < rewardTokens.length
                                                mem[0] = rewardTokens[idx].field_0
                                                mem[32] = sha3(msg.sender, 28) + 2
                                                uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            s = 32
                                            while s < 26:
                                                mem[s + mem[64] + 68] = mem[s + _14661 + 32]
                                                s = s + 32
                                                continue 
                                        else:
                                            if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                                revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _14685 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_14685] = 26
                                            mem[_14685 + 32] = 'SafeMath: division by zero'
                                            if pRECISION_FACTOR[stor26[idx].field_0]:
                                                require idx < rewardTokens.length
                                                mem[0] = rewardTokens[idx].field_0
                                                mem[32] = sha3(msg.sender, 28) + 2
                                                uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _14685 + 32]
                                                idx = idx + 32
                                                continue 
                                        revert with 0, 'SafeMath: division by zero'
                                else:
                                    if arg1 + uint256(lastStakingBlock[msg.sender].field_0) < uint256(lastStakingBlock[msg.sender].field_0):
                                        revert with 0, 'SafeMath: addition overflow'
                                    uint256(lastStakingBlock[msg.sender].field_0) += arg1
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = this.address
                                    mem[mem[64] + 68] = arg1
                                    require ext_code.size(stakedTokenAddress)
                                    call stakedTokenAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, this.address, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not msg.sender:
                                        revert with 0, 'ERC20: mint to the zero address'
                                    if arg1 + totalSupply < totalSupply:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalSupply += arg1
                                    if arg1 + balanceOf[address(msg.sender)] < balanceOf[address(msg.sender)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[32] = 4
                                    balanceOf[address(msg.sender)] += arg1
                                    mem[mem[64]] = arg1
                                    emit Transfer(arg1, 0, msg.sender);
                                    idx = 0
                                    while idx < rewardTokens.length:
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = 10
                                        if not uint256(lastStakingBlock[msg.sender].field_0):
                                            _14662 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_14662] = 26
                                            mem[_14662 + 32] = 'SafeMath: division by zero'
                                            if pRECISION_FACTOR[stor26[idx].field_0]:
                                                require idx < rewardTokens.length
                                                mem[0] = rewardTokens[idx].field_0
                                                mem[32] = sha3(msg.sender, 28) + 2
                                                uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            s = 32
                                            while s < 26:
                                                mem[s + mem[64] + 68] = mem[s + _14662 + 32]
                                                s = s + 32
                                                continue 
                                        else:
                                            if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                                revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _14686 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_14686] = 26
                                            mem[_14686 + 32] = 'SafeMath: division by zero'
                                            if pRECISION_FACTOR[stor26[idx].field_0]:
                                                require idx < rewardTokens.length
                                                mem[0] = rewardTokens[idx].field_0
                                                mem[32] = sha3(msg.sender, 28) + 2
                                                uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _14686 + 32]
                                                idx = idx + 32
                                                continue 
                                        revert with 0, 'SafeMath: division by zero'
                        else:
                            mem[64] = 288
                            mem[224] = 30
                            mem[256] = 'SafeMath: subtraction overflow'
                            if lastRewardBlock > bonusEndBlock:
                                revert with 0, 'SafeMath: subtraction overflow'
                            idx = 0
                            while idx < rewardTokens.length:
                                if not bonusEndBlock - lastRewardBlock:
                                    require idx < rewardTokens.length
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = 25
                                    _6260 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6260] = 26
                                    mem[_6260 + 32] = 'SafeMath: division by zero'
                                    if not ext_call.return_data[0]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _6260 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    require idx < rewardTokens.length
                                    if (0 / ext_call.return_data[0]) + accTokenPerShare[stor26[idx].field_0] < accTokenPerShare[stor26[idx].field_0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    require idx < rewardTokens.length
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = 10
                                    accTokenPerShare[stor26[idx].field_0] += 0 / ext_call.return_data[0]
                                else:
                                    if (bonusEndBlock * rewardPerBlock[stor26[idx].field_0]) - (lastRewardBlock * rewardPerBlock[stor26[idx].field_0]) / bonusEndBlock - lastRewardBlock != rewardPerBlock[stor26[idx].field_0]:
                                        revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    require idx < rewardTokens.length
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = 25
                                    if not (bonusEndBlock * rewardPerBlock[stor26[idx].field_0]) - (lastRewardBlock * rewardPerBlock[stor26[idx].field_0]):
                                        _6415 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6415] = 26
                                        mem[_6415 + 32] = 'SafeMath: division by zero'
                                        if not ext_call.return_data[0]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _6415 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        require idx < rewardTokens.length
                                        if (0 / ext_call.return_data[0]) + accTokenPerShare[stor26[idx].field_0] < accTokenPerShare[stor26[idx].field_0]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        require idx < rewardTokens.length
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = 10
                                        accTokenPerShare[stor26[idx].field_0] += 0 / ext_call.return_data[0]
                                    else:
                                        if (bonusEndBlock * rewardPerBlock[stor26[idx].field_0] * pRECISION_FACTOR[stor26[idx].field_0]) - (lastRewardBlock * rewardPerBlock[stor26[idx].field_0] * pRECISION_FACTOR[stor26[idx].field_0]) / (bonusEndBlock * rewardPerBlock[stor26[idx].field_0]) - (lastRewardBlock * rewardPerBlock[stor26[idx].field_0]) != pRECISION_FACTOR[stor26[idx].field_0]:
                                            revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _6606 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6606] = 26
                                        mem[_6606 + 32] = 'SafeMath: division by zero'
                                        if not ext_call.return_data[0]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _6606 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        require idx < rewardTokens.length
                                        if ((bonusEndBlock * rewardPerBlock[stor26[idx].field_0] * pRECISION_FACTOR[stor26[idx].field_0]) - (lastRewardBlock * rewardPerBlock[stor26[idx].field_0] * pRECISION_FACTOR[stor26[idx].field_0]) / ext_call.return_data[0]) + accTokenPerShare[stor26[idx].field_0] < accTokenPerShare[stor26[idx].field_0]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        require idx < rewardTokens.length
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = 10
                                        accTokenPerShare[stor26[idx].field_0] += (bonusEndBlock * rewardPerBlock[stor26[idx].field_0] * pRECISION_FACTOR[stor26[idx].field_0]) - (lastRewardBlock * rewardPerBlock[stor26[idx].field_0] * pRECISION_FACTOR[stor26[idx].field_0]) / ext_call.return_data[0]
                                idx = idx + 1
                                continue 
                            lastRewardBlock = block.number
                            if not uint256(lastStakingBlock[msg.sender].field_0):
                                if not arg1:
                                    s = 0
                                    while s < rewardTokens.length:
                                        mem[0] = rewardTokens[s].field_0
                                        mem[32] = 10
                                        if not uint256(lastStakingBlock[msg.sender].field_0):
                                            _11324 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11324] = 26
                                            mem[_11324 + 32] = 'SafeMath: division by zero'
                                            if pRECISION_FACTOR[stor26[s].field_0]:
                                                require s < rewardTokens.length
                                                mem[0] = rewardTokens[s].field_0
                                                mem[32] = sha3(msg.sender, 28) + 2
                                                uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[s].field_0]
                                                s = s + 1
                                                continue 
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _11324 + 32]
                                                idx = idx + 32
                                                continue 
                                        else:
                                            if accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[s].field_0]:
                                                revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _11394 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11394] = 26
                                            mem[_11394 + 32] = 'SafeMath: division by zero'
                                            if pRECISION_FACTOR[stor26[s].field_0]:
                                                require s < rewardTokens.length
                                                mem[0] = rewardTokens[s].field_0
                                                mem[32] = sha3(msg.sender, 28) + 2
                                                uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0) = accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[s].field_0]
                                                s = s + 1
                                                continue 
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            s = 32
                                            while s < 26:
                                                mem[s + mem[64] + 68] = mem[s + _11394 + 32]
                                                s = s + 32
                                                continue 
                                        revert with 0, 'SafeMath: division by zero'
                                else:
                                    if arg1 + uint256(lastStakingBlock[msg.sender].field_0) < uint256(lastStakingBlock[msg.sender].field_0):
                                        revert with 0, 'SafeMath: addition overflow'
                                    uint256(lastStakingBlock[msg.sender].field_0) += arg1
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = this.address
                                    mem[mem[64] + 68] = arg1
                                    require ext_code.size(stakedTokenAddress)
                                    call stakedTokenAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, this.address, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not msg.sender:
                                        revert with 0, 'ERC20: mint to the zero address'
                                    if arg1 + totalSupply < totalSupply:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalSupply += arg1
                                    if arg1 + balanceOf[address(msg.sender)] < balanceOf[address(msg.sender)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[32] = 4
                                    balanceOf[address(msg.sender)] += arg1
                                    mem[mem[64]] = arg1
                                    emit Transfer(arg1, 0, msg.sender);
                                    idx = 0
                                    while idx < rewardTokens.length:
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = 10
                                        if not uint256(lastStakingBlock[msg.sender].field_0):
                                            _11325 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11325] = 26
                                            mem[_11325 + 32] = 'SafeMath: division by zero'
                                            if pRECISION_FACTOR[stor26[idx].field_0]:
                                                require idx < rewardTokens.length
                                                mem[0] = rewardTokens[idx].field_0
                                                mem[32] = sha3(msg.sender, 28) + 2
                                                uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            s = 32
                                            while s < 26:
                                                mem[s + mem[64] + 68] = mem[s + _11325 + 32]
                                                s = s + 32
                                                continue 
                                        else:
                                            if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                                revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _11395 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11395] = 26
                                            mem[_11395 + 32] = 'SafeMath: division by zero'
                                            if pRECISION_FACTOR[stor26[idx].field_0]:
                                                require idx < rewardTokens.length
                                                mem[0] = rewardTokens[idx].field_0
                                                mem[32] = sha3(msg.sender, 28) + 2
                                                uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _11395 + 32]
                                                idx = idx + 32
                                                continue 
                                        revert with 0, 'SafeMath: division by zero'
                            else:
                                s = 0
                                t = 0
                                while s < rewardTokens.length:
                                    mem[0] = rewardTokens[s].field_0
                                    mem[32] = 10
                                    if not uint256(lastStakingBlock[msg.sender].field_0):
                                        _11396 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11396] = 26
                                        mem[_11396 + 32] = 'SafeMath: division by zero'
                                        if not pRECISION_FACTOR[stor26[s].field_0]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _11396 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        _12614 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12614] = 30
                                        mem[_12614 + 32] = 'SafeMath: subtraction overflow'
                                        if uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0) > 0 / pRECISION_FACTOR[stor26[s].field_0]:
                                            _13010 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _13010 + 68] = mem[idx + _12614 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_13010 + 68] = mem[_13010 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _13010 + -mem[64] + 100
                                        if (0 / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0):
                                            require s < rewardTokens.length
                                            mem[0] = 26
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = (0 / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0)
                                            require ext_code.size(rewardTokens[s].field_0)
                                            call rewardTokens[s].field_0.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (0 / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                        s = s + 1
                                        t = (0 / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0)
                                        continue 
                                    if accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[s].field_0]:
                                        revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _11472 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11472] = 26
                                    mem[_11472 + 32] = 'SafeMath: division by zero'
                                    if not pRECISION_FACTOR[stor26[s].field_0]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        s = 32
                                        while s < 26:
                                            mem[s + mem[64] + 68] = mem[s + _11472 + 32]
                                            s = s + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    _12873 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12873] = 30
                                    mem[_12873 + 32] = 'SafeMath: subtraction overflow'
                                    if uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0) > accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[s].field_0]:
                                        _13118 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13118 + 68] = mem[idx + _12873 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13118 + 68] = mem[_13118 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _13118 + -mem[64] + 100
                                    if (accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0):
                                        require s < rewardTokens.length
                                        mem[0] = 26
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = (accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0)
                                        require ext_code.size(rewardTokens[s].field_0)
                                        call rewardTokens[s].field_0.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, (accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                    s = s + 1
                                    t = (accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0)
                                    continue 
                                if not arg1:
                                    idx = 0
                                    while idx < rewardTokens.length:
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = 10
                                        if not uint256(lastStakingBlock[msg.sender].field_0):
                                            _14659 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_14659] = 26
                                            mem[_14659 + 32] = 'SafeMath: division by zero'
                                            if pRECISION_FACTOR[stor26[idx].field_0]:
                                                require idx < rewardTokens.length
                                                mem[0] = rewardTokens[idx].field_0
                                                mem[32] = sha3(msg.sender, 28) + 2
                                                uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            s = 32
                                            while s < 26:
                                                mem[s + mem[64] + 68] = mem[s + _14659 + 32]
                                                s = s + 32
                                                continue 
                                        else:
                                            if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                                revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _14683 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_14683] = 26
                                            mem[_14683 + 32] = 'SafeMath: division by zero'
                                            if pRECISION_FACTOR[stor26[idx].field_0]:
                                                require idx < rewardTokens.length
                                                mem[0] = rewardTokens[idx].field_0
                                                mem[32] = sha3(msg.sender, 28) + 2
                                                uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _14683 + 32]
                                                idx = idx + 32
                                                continue 
                                        revert with 0, 'SafeMath: division by zero'
                                else:
                                    if arg1 + uint256(lastStakingBlock[msg.sender].field_0) < uint256(lastStakingBlock[msg.sender].field_0):
                                        revert with 0, 'SafeMath: addition overflow'
                                    uint256(lastStakingBlock[msg.sender].field_0) += arg1
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = this.address
                                    mem[mem[64] + 68] = arg1
                                    require ext_code.size(stakedTokenAddress)
                                    call stakedTokenAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, this.address, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not msg.sender:
                                        revert with 0, 'ERC20: mint to the zero address'
                                    if arg1 + totalSupply < totalSupply:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalSupply += arg1
                                    if arg1 + balanceOf[address(msg.sender)] < balanceOf[address(msg.sender)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[32] = 4
                                    balanceOf[address(msg.sender)] += arg1
                                    mem[mem[64]] = arg1
                                    emit Transfer(arg1, 0, msg.sender);
                                    idx = 0
                                    while idx < rewardTokens.length:
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = 10
                                        if not uint256(lastStakingBlock[msg.sender].field_0):
                                            _14660 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_14660] = 26
                                            mem[_14660 + 32] = 'SafeMath: division by zero'
                                            if pRECISION_FACTOR[stor26[idx].field_0]:
                                                require idx < rewardTokens.length
                                                mem[0] = rewardTokens[idx].field_0
                                                mem[32] = sha3(msg.sender, 28) + 2
                                                uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            s = 32
                                            while s < 26:
                                                mem[s + mem[64] + 68] = mem[s + _14660 + 32]
                                                s = s + 32
                                                continue 
                                        else:
                                            if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                                revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _14684 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_14684] = 26
                                            mem[_14684 + 32] = 'SafeMath: division by zero'
                                            if pRECISION_FACTOR[stor26[idx].field_0]:
                                                require idx < rewardTokens.length
                                                mem[0] = rewardTokens[idx].field_0
                                                mem[32] = sha3(msg.sender, 28) + 2
                                                uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _14684 + 32]
                                                idx = idx + 32
                                                continue 
                                        revert with 0, 'SafeMath: division by zero'
    else:
        mem[228] = this.address
        require ext_code.size(stakedTokenAddress)
        staticcall stakedTokenAddress.0x70a08231 with:
                gas gas_remaining wei
               args this.address
        mem[224] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[0] + arg1 < arg1:
            revert with 0, 'SafeMath: addition overflow'
        if ext_call.return_data[0] + arg1 > poolCap:
            revert with 0, 'Pool cap reached'
        if not uint8(stor9.field_168):
            if block.number <= lastRewardBlock:
                if not uint256(lastStakingBlock[msg.sender].field_0):
                    if not arg1:
                        idx = 0
                        while idx < rewardTokens.length:
                            mem[0] = rewardTokens[idx].field_0
                            mem[32] = 10
                            if not uint256(lastStakingBlock[msg.sender].field_0):
                                _5828 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5828] = 26
                                mem[_5828 + 32] = 'SafeMath: division by zero'
                                if pRECISION_FACTOR[stor26[idx].field_0]:
                                    require idx < rewardTokens.length
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = sha3(msg.sender, 28) + 2
                                    uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                s = 32
                                while s < 26:
                                    mem[s + mem[64] + 68] = mem[s + _5828 + 32]
                                    s = s + 32
                                    continue 
                            else:
                                if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                    revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _5916 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5916] = 26
                                mem[_5916 + 32] = 'SafeMath: division by zero'
                                if pRECISION_FACTOR[stor26[idx].field_0]:
                                    require idx < rewardTokens.length
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = sha3(msg.sender, 28) + 2
                                    uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _5916 + 32]
                                    idx = idx + 32
                                    continue 
                            revert with 0, 'SafeMath: division by zero'
                    else:
                        if arg1 + uint256(lastStakingBlock[msg.sender].field_0) < uint256(lastStakingBlock[msg.sender].field_0):
                            revert with 0, 'SafeMath: addition overflow'
                        uint256(lastStakingBlock[msg.sender].field_0) += arg1
                        mem[228] = msg.sender
                        mem[260] = this.address
                        mem[292] = arg1
                        require ext_code.size(stakedTokenAddress)
                        call stakedTokenAddress.0x23b872dd with:
                             gas gas_remaining wei
                            args msg.sender, this.address, arg1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not msg.sender:
                            revert with 0, 'ERC20: mint to the zero address'
                        if arg1 + totalSupply < totalSupply:
                            revert with 0, 'SafeMath: addition overflow'
                        totalSupply += arg1
                        if arg1 + balanceOf[address(msg.sender)] < balanceOf[address(msg.sender)]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[32] = 4
                        balanceOf[address(msg.sender)] += arg1
                        mem[224] = arg1
                        emit Transfer(arg1, 0, msg.sender);
                        idx = 0
                        while idx < rewardTokens.length:
                            mem[0] = rewardTokens[idx].field_0
                            mem[32] = 10
                            if not uint256(lastStakingBlock[msg.sender].field_0):
                                _5829 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5829] = 26
                                mem[_5829 + 32] = 'SafeMath: division by zero'
                                if pRECISION_FACTOR[stor26[idx].field_0]:
                                    require idx < rewardTokens.length
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = sha3(msg.sender, 28) + 2
                                    uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                s = 32
                                while s < 26:
                                    mem[s + mem[64] + 68] = mem[s + _5829 + 32]
                                    s = s + 32
                                    continue 
                            else:
                                if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                    revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _5917 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5917] = 26
                                mem[_5917 + 32] = 'SafeMath: division by zero'
                                if pRECISION_FACTOR[stor26[idx].field_0]:
                                    require idx < rewardTokens.length
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = sha3(msg.sender, 28) + 2
                                    uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _5917 + 32]
                                    idx = idx + 32
                                    continue 
                            revert with 0, 'SafeMath: division by zero'
                else:
                    idx = 0
                    s = 0
                    while idx < rewardTokens.length:
                        mem[0] = rewardTokens[idx].field_0
                        mem[32] = 10
                        if not uint256(lastStakingBlock[msg.sender].field_0):
                            _5918 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5918] = 26
                            mem[_5918 + 32] = 'SafeMath: division by zero'
                            if not pRECISION_FACTOR[stor26[idx].field_0]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _5918 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            _6925 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6925] = 30
                            mem[_6925 + 32] = 'SafeMath: subtraction overflow'
                            if uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) > 0 / pRECISION_FACTOR[stor26[idx].field_0]:
                                _7413 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _7413 + 68] = mem[idx + _6925 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_7413 + 68] = mem[_7413 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _7413 + -mem[64] + 100
                            if (0 / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0):
                                require idx < rewardTokens.length
                                mem[0] = 26
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = (0 / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                                require ext_code.size(rewardTokens[idx].field_0)
                                call rewardTokens[idx].field_0.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, (0 / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                            idx = idx + 1
                            s = (0 / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                            continue 
                        if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                            revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _6023 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6023] = 26
                        mem[_6023 + 32] = 'SafeMath: division by zero'
                        if not pRECISION_FACTOR[stor26[idx].field_0]:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _6023 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        _7175 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_7175] = 30
                        mem[_7175 + 32] = 'SafeMath: subtraction overflow'
                        if uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) > accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]:
                            _7665 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _7665 + 68] = mem[idx + _7175 + 32]
                                idx = idx + 32
                                continue 
                            mem[_7665 + 68] = mem[_7665 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _7665 + -mem[64] + 100
                        if (accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0):
                            require idx < rewardTokens.length
                            mem[0] = 26
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = (accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                            require ext_code.size(rewardTokens[idx].field_0)
                            call rewardTokens[idx].field_0.0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, (accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                        idx = idx + 1
                        s = (accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                        continue 
                    if not arg1:
                        idx = 0
                        while idx < rewardTokens.length:
                            mem[0] = rewardTokens[idx].field_0
                            mem[32] = 10
                            if not uint256(lastStakingBlock[msg.sender].field_0):
                                _11360 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11360] = 26
                                mem[_11360 + 32] = 'SafeMath: division by zero'
                                if pRECISION_FACTOR[stor26[idx].field_0]:
                                    require idx < rewardTokens.length
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = sha3(msg.sender, 28) + 2
                                    uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                s = 32
                                while s < 26:
                                    mem[s + mem[64] + 68] = mem[s + _11360 + 32]
                                    s = s + 32
                                    continue 
                            else:
                                if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                    revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _11418 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11418] = 26
                                mem[_11418 + 32] = 'SafeMath: division by zero'
                                if pRECISION_FACTOR[stor26[idx].field_0]:
                                    require idx < rewardTokens.length
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = sha3(msg.sender, 28) + 2
                                    uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _11418 + 32]
                                    idx = idx + 32
                                    continue 
                            revert with 0, 'SafeMath: division by zero'
                    else:
                        if arg1 + uint256(lastStakingBlock[msg.sender].field_0) < uint256(lastStakingBlock[msg.sender].field_0):
                            revert with 0, 'SafeMath: addition overflow'
                        uint256(lastStakingBlock[msg.sender].field_0) += arg1
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = this.address
                        mem[mem[64] + 68] = arg1
                        require ext_code.size(stakedTokenAddress)
                        call stakedTokenAddress.0x23b872dd with:
                             gas gas_remaining wei
                            args msg.sender, this.address, arg1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not msg.sender:
                            revert with 0, 'ERC20: mint to the zero address'
                        if arg1 + totalSupply < totalSupply:
                            revert with 0, 'SafeMath: addition overflow'
                        totalSupply += arg1
                        if arg1 + balanceOf[address(msg.sender)] < balanceOf[address(msg.sender)]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[32] = 4
                        balanceOf[address(msg.sender)] += arg1
                        mem[mem[64]] = arg1
                        emit Transfer(arg1, 0, msg.sender);
                        idx = 0
                        while idx < rewardTokens.length:
                            mem[0] = rewardTokens[idx].field_0
                            mem[32] = 10
                            if not uint256(lastStakingBlock[msg.sender].field_0):
                                _11361 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11361] = 26
                                mem[_11361 + 32] = 'SafeMath: division by zero'
                                if pRECISION_FACTOR[stor26[idx].field_0]:
                                    require idx < rewardTokens.length
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = sha3(msg.sender, 28) + 2
                                    uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                s = 32
                                while s < 26:
                                    mem[s + mem[64] + 68] = mem[s + _11361 + 32]
                                    s = s + 32
                                    continue 
                            else:
                                if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                    revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _11419 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11419] = 26
                                mem[_11419 + 32] = 'SafeMath: division by zero'
                                if pRECISION_FACTOR[stor26[idx].field_0]:
                                    require idx < rewardTokens.length
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = sha3(msg.sender, 28) + 2
                                    uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _11419 + 32]
                                    idx = idx + 32
                                    continue 
                            revert with 0, 'SafeMath: division by zero'
            else:
                mem[228] = this.address
                require ext_code.size(stakedTokenAddress)
                staticcall stakedTokenAddress.0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[224] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if not ext_call.return_data[0]:
                    lastRewardBlock = block.number
                    if not uint256(lastStakingBlock[msg.sender].field_0):
                        if not arg1:
                            idx = 0
                            while idx < rewardTokens.length:
                                mem[0] = rewardTokens[idx].field_0
                                mem[32] = 10
                                if not uint256(lastStakingBlock[msg.sender].field_0):
                                    _5823 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5823] = 26
                                    mem[_5823 + 32] = 'SafeMath: division by zero'
                                    if pRECISION_FACTOR[stor26[idx].field_0]:
                                        require idx < rewardTokens.length
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = sha3(msg.sender, 28) + 2
                                        uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    s = 32
                                    while s < 26:
                                        mem[s + mem[64] + 68] = mem[s + _5823 + 32]
                                        s = s + 32
                                        continue 
                                else:
                                    if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                        revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _5913 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5913] = 26
                                    mem[_5913 + 32] = 'SafeMath: division by zero'
                                    if pRECISION_FACTOR[stor26[idx].field_0]:
                                        require idx < rewardTokens.length
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = sha3(msg.sender, 28) + 2
                                        uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _5913 + 32]
                                        idx = idx + 32
                                        continue 
                                revert with 0, 'SafeMath: division by zero'
                        else:
                            if arg1 + uint256(lastStakingBlock[msg.sender].field_0) < uint256(lastStakingBlock[msg.sender].field_0):
                                revert with 0, 'SafeMath: addition overflow'
                            uint256(lastStakingBlock[msg.sender].field_0) += arg1
                            mem[228] = msg.sender
                            mem[260] = this.address
                            mem[292] = arg1
                            require ext_code.size(stakedTokenAddress)
                            call stakedTokenAddress.0x23b872dd with:
                                 gas gas_remaining wei
                                args msg.sender, this.address, arg1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if not msg.sender:
                                revert with 0, 'ERC20: mint to the zero address'
                            if arg1 + totalSupply < totalSupply:
                                revert with 0, 'SafeMath: addition overflow'
                            totalSupply += arg1
                            if arg1 + balanceOf[address(msg.sender)] < balanceOf[address(msg.sender)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[32] = 4
                            balanceOf[address(msg.sender)] += arg1
                            mem[224] = arg1
                            emit Transfer(arg1, 0, msg.sender);
                            idx = 0
                            while idx < rewardTokens.length:
                                mem[0] = rewardTokens[idx].field_0
                                mem[32] = 10
                                if not uint256(lastStakingBlock[msg.sender].field_0):
                                    _5824 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5824] = 26
                                    mem[_5824 + 32] = 'SafeMath: division by zero'
                                    if pRECISION_FACTOR[stor26[idx].field_0]:
                                        require idx < rewardTokens.length
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = sha3(msg.sender, 28) + 2
                                        uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    s = 32
                                    while s < 26:
                                        mem[s + mem[64] + 68] = mem[s + _5824 + 32]
                                        s = s + 32
                                        continue 
                                else:
                                    if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                        revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _5914 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5914] = 26
                                    mem[_5914 + 32] = 'SafeMath: division by zero'
                                    if pRECISION_FACTOR[stor26[idx].field_0]:
                                        require idx < rewardTokens.length
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = sha3(msg.sender, 28) + 2
                                        uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _5914 + 32]
                                        idx = idx + 32
                                        continue 
                                revert with 0, 'SafeMath: division by zero'
                    else:
                        idx = 0
                        s = 0
                        while idx < rewardTokens.length:
                            mem[0] = rewardTokens[idx].field_0
                            mem[32] = 10
                            if not uint256(lastStakingBlock[msg.sender].field_0):
                                _5915 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5915] = 26
                                mem[_5915 + 32] = 'SafeMath: division by zero'
                                if not pRECISION_FACTOR[stor26[idx].field_0]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _5915 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                _6906 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6906] = 30
                                mem[_6906 + 32] = 'SafeMath: subtraction overflow'
                                if uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) > 0 / pRECISION_FACTOR[stor26[idx].field_0]:
                                    _7404 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _7404 + 68] = mem[idx + _6906 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_7404 + 68] = mem[_7404 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _7404 + -mem[64] + 100
                                if (0 / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0):
                                    require idx < rewardTokens.length
                                    mem[0] = 26
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = (0 / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                                    require ext_code.size(rewardTokens[idx].field_0)
                                    call rewardTokens[idx].field_0.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, (0 / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                idx = idx + 1
                                s = (0 / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                                continue 
                            if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _6016 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6016] = 26
                            mem[_6016 + 32] = 'SafeMath: division by zero'
                            if not pRECISION_FACTOR[stor26[idx].field_0]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _6016 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            _7164 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_7164] = 30
                            mem[_7164 + 32] = 'SafeMath: subtraction overflow'
                            if uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) > accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]:
                                _7656 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _7656 + 68] = mem[idx + _7164 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_7656 + 68] = mem[_7656 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _7656 + -mem[64] + 100
                            if (accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0):
                                require idx < rewardTokens.length
                                mem[0] = 26
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = (accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                                require ext_code.size(rewardTokens[idx].field_0)
                                call rewardTokens[idx].field_0.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, (accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                            idx = idx + 1
                            s = (accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                            continue 
                        if not arg1:
                            idx = 0
                            while idx < rewardTokens.length:
                                mem[0] = rewardTokens[idx].field_0
                                mem[32] = 10
                                if not uint256(lastStakingBlock[msg.sender].field_0):
                                    _11358 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11358] = 26
                                    mem[_11358 + 32] = 'SafeMath: division by zero'
                                    if pRECISION_FACTOR[stor26[idx].field_0]:
                                        require idx < rewardTokens.length
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = sha3(msg.sender, 28) + 2
                                        uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    s = 32
                                    while s < 26:
                                        mem[s + mem[64] + 68] = mem[s + _11358 + 32]
                                        s = s + 32
                                        continue 
                                else:
                                    if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                        revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _11416 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11416] = 26
                                    mem[_11416 + 32] = 'SafeMath: division by zero'
                                    if pRECISION_FACTOR[stor26[idx].field_0]:
                                        require idx < rewardTokens.length
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = sha3(msg.sender, 28) + 2
                                        uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _11416 + 32]
                                        idx = idx + 32
                                        continue 
                                revert with 0, 'SafeMath: division by zero'
                        else:
                            if arg1 + uint256(lastStakingBlock[msg.sender].field_0) < uint256(lastStakingBlock[msg.sender].field_0):
                                revert with 0, 'SafeMath: addition overflow'
                            uint256(lastStakingBlock[msg.sender].field_0) += arg1
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = this.address
                            mem[mem[64] + 68] = arg1
                            require ext_code.size(stakedTokenAddress)
                            call stakedTokenAddress.0x23b872dd with:
                                 gas gas_remaining wei
                                args msg.sender, this.address, arg1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if not msg.sender:
                                revert with 0, 'ERC20: mint to the zero address'
                            if arg1 + totalSupply < totalSupply:
                                revert with 0, 'SafeMath: addition overflow'
                            totalSupply += arg1
                            if arg1 + balanceOf[address(msg.sender)] < balanceOf[address(msg.sender)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[32] = 4
                            balanceOf[address(msg.sender)] += arg1
                            mem[mem[64]] = arg1
                            emit Transfer(arg1, 0, msg.sender);
                            idx = 0
                            while idx < rewardTokens.length:
                                mem[0] = rewardTokens[idx].field_0
                                mem[32] = 10
                                if not uint256(lastStakingBlock[msg.sender].field_0):
                                    _11359 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11359] = 26
                                    mem[_11359 + 32] = 'SafeMath: division by zero'
                                    if pRECISION_FACTOR[stor26[idx].field_0]:
                                        require idx < rewardTokens.length
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = sha3(msg.sender, 28) + 2
                                        uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    s = 32
                                    while s < 26:
                                        mem[s + mem[64] + 68] = mem[s + _11359 + 32]
                                        s = s + 32
                                        continue 
                                else:
                                    if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                        revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _11417 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11417] = 26
                                    mem[_11417 + 32] = 'SafeMath: division by zero'
                                    if pRECISION_FACTOR[stor26[idx].field_0]:
                                        require idx < rewardTokens.length
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = sha3(msg.sender, 28) + 2
                                        uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _11417 + 32]
                                        idx = idx + 32
                                        continue 
                                revert with 0, 'SafeMath: division by zero'
                else:
                    if block.number <= bonusEndBlock:
                        mem[64] = 288
                        mem[224] = 30
                        mem[256] = 'SafeMath: subtraction overflow'
                        if lastRewardBlock > block.number:
                            revert with 0, 'SafeMath: subtraction overflow'
                        idx = 0
                        while idx < rewardTokens.length:
                            if not block.number - lastRewardBlock:
                                require idx < rewardTokens.length
                                mem[0] = rewardTokens[idx].field_0
                                mem[32] = 25
                                _6303 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6303] = 26
                                mem[_6303 + 32] = 'SafeMath: division by zero'
                                if not ext_call.return_data[0]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _6303 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                require idx < rewardTokens.length
                                if (0 / ext_call.return_data[0]) + accTokenPerShare[stor26[idx].field_0] < accTokenPerShare[stor26[idx].field_0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require idx < rewardTokens.length
                                mem[0] = rewardTokens[idx].field_0
                                mem[32] = 10
                                accTokenPerShare[stor26[idx].field_0] += 0 / ext_call.return_data[0]
                            else:
                                if (block.number * rewardPerBlock[stor26[idx].field_0]) - (lastRewardBlock * rewardPerBlock[stor26[idx].field_0]) / block.number - lastRewardBlock != rewardPerBlock[stor26[idx].field_0]:
                                    revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                require idx < rewardTokens.length
                                mem[0] = rewardTokens[idx].field_0
                                mem[32] = 25
                                if not (block.number * rewardPerBlock[stor26[idx].field_0]) - (lastRewardBlock * rewardPerBlock[stor26[idx].field_0]):
                                    _6477 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6477] = 26
                                    mem[_6477 + 32] = 'SafeMath: division by zero'
                                    if not ext_call.return_data[0]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _6477 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    require idx < rewardTokens.length
                                    if (0 / ext_call.return_data[0]) + accTokenPerShare[stor26[idx].field_0] < accTokenPerShare[stor26[idx].field_0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    require idx < rewardTokens.length
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = 10
                                    accTokenPerShare[stor26[idx].field_0] += 0 / ext_call.return_data[0]
                                else:
                                    if (block.number * rewardPerBlock[stor26[idx].field_0] * pRECISION_FACTOR[stor26[idx].field_0]) - (lastRewardBlock * rewardPerBlock[stor26[idx].field_0] * pRECISION_FACTOR[stor26[idx].field_0]) / (block.number * rewardPerBlock[stor26[idx].field_0]) - (lastRewardBlock * rewardPerBlock[stor26[idx].field_0]) != pRECISION_FACTOR[stor26[idx].field_0]:
                                        revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _6672 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6672] = 26
                                    mem[_6672 + 32] = 'SafeMath: division by zero'
                                    if not ext_call.return_data[0]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _6672 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    require idx < rewardTokens.length
                                    if ((block.number * rewardPerBlock[stor26[idx].field_0] * pRECISION_FACTOR[stor26[idx].field_0]) - (lastRewardBlock * rewardPerBlock[stor26[idx].field_0] * pRECISION_FACTOR[stor26[idx].field_0]) / ext_call.return_data[0]) + accTokenPerShare[stor26[idx].field_0] < accTokenPerShare[stor26[idx].field_0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    require idx < rewardTokens.length
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = 10
                                    accTokenPerShare[stor26[idx].field_0] += (block.number * rewardPerBlock[stor26[idx].field_0] * pRECISION_FACTOR[stor26[idx].field_0]) - (lastRewardBlock * rewardPerBlock[stor26[idx].field_0] * pRECISION_FACTOR[stor26[idx].field_0]) / ext_call.return_data[0]
                            idx = idx + 1
                            continue 
                        lastRewardBlock = block.number
                        if not uint256(lastStakingBlock[msg.sender].field_0):
                            if not arg1:
                                s = 0
                                while s < rewardTokens.length:
                                    mem[0] = rewardTokens[s].field_0
                                    mem[32] = 10
                                    if not uint256(lastStakingBlock[msg.sender].field_0):
                                        _11353 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11353] = 26
                                        mem[_11353 + 32] = 'SafeMath: division by zero'
                                        if pRECISION_FACTOR[stor26[s].field_0]:
                                            require s < rewardTokens.length
                                            mem[0] = rewardTokens[s].field_0
                                            mem[32] = sha3(msg.sender, 28) + 2
                                            uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[s].field_0]
                                            s = s + 1
                                            continue 
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _11353 + 32]
                                            idx = idx + 32
                                            continue 
                                    else:
                                        if accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[s].field_0]:
                                            revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _11413 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11413] = 26
                                        mem[_11413 + 32] = 'SafeMath: division by zero'
                                        if pRECISION_FACTOR[stor26[s].field_0]:
                                            require s < rewardTokens.length
                                            mem[0] = rewardTokens[s].field_0
                                            mem[32] = sha3(msg.sender, 28) + 2
                                            uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0) = accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[s].field_0]
                                            s = s + 1
                                            continue 
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        s = 32
                                        while s < 26:
                                            mem[s + mem[64] + 68] = mem[s + _11413 + 32]
                                            s = s + 32
                                            continue 
                                    revert with 0, 'SafeMath: division by zero'
                            else:
                                if arg1 + uint256(lastStakingBlock[msg.sender].field_0) < uint256(lastStakingBlock[msg.sender].field_0):
                                    revert with 0, 'SafeMath: addition overflow'
                                uint256(lastStakingBlock[msg.sender].field_0) += arg1
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = this.address
                                mem[mem[64] + 68] = arg1
                                require ext_code.size(stakedTokenAddress)
                                call stakedTokenAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, this.address, arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not msg.sender:
                                    revert with 0, 'ERC20: mint to the zero address'
                                if arg1 + totalSupply < totalSupply:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalSupply += arg1
                                if arg1 + balanceOf[address(msg.sender)] < balanceOf[address(msg.sender)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[32] = 4
                                balanceOf[address(msg.sender)] += arg1
                                mem[mem[64]] = arg1
                                emit Transfer(arg1, 0, msg.sender);
                                idx = 0
                                while idx < rewardTokens.length:
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = 10
                                    if not uint256(lastStakingBlock[msg.sender].field_0):
                                        _11354 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11354] = 26
                                        mem[_11354 + 32] = 'SafeMath: division by zero'
                                        if pRECISION_FACTOR[stor26[idx].field_0]:
                                            require idx < rewardTokens.length
                                            mem[0] = rewardTokens[idx].field_0
                                            mem[32] = sha3(msg.sender, 28) + 2
                                            uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                            idx = idx + 1
                                            continue 
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        s = 32
                                        while s < 26:
                                            mem[s + mem[64] + 68] = mem[s + _11354 + 32]
                                            s = s + 32
                                            continue 
                                    else:
                                        if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                            revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _11414 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11414] = 26
                                        mem[_11414 + 32] = 'SafeMath: division by zero'
                                        if pRECISION_FACTOR[stor26[idx].field_0]:
                                            require idx < rewardTokens.length
                                            mem[0] = rewardTokens[idx].field_0
                                            mem[32] = sha3(msg.sender, 28) + 2
                                            uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                            idx = idx + 1
                                            continue 
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _11414 + 32]
                                            idx = idx + 32
                                            continue 
                                    revert with 0, 'SafeMath: division by zero'
                        else:
                            s = 0
                            t = 0
                            while s < rewardTokens.length:
                                mem[0] = rewardTokens[s].field_0
                                mem[32] = 10
                                if not uint256(lastStakingBlock[msg.sender].field_0):
                                    _11415 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11415] = 26
                                    mem[_11415 + 32] = 'SafeMath: division by zero'
                                    if not pRECISION_FACTOR[stor26[s].field_0]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _11415 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    _12729 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12729] = 30
                                    mem[_12729 + 32] = 'SafeMath: subtraction overflow'
                                    if uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0) > 0 / pRECISION_FACTOR[stor26[s].field_0]:
                                        _13055 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13055 + 68] = mem[idx + _12729 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13055 + 68] = mem[_13055 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _13055 + -mem[64] + 100
                                    if (0 / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0):
                                        require s < rewardTokens.length
                                        mem[0] = 26
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = (0 / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0)
                                        require ext_code.size(rewardTokens[s].field_0)
                                        call rewardTokens[s].field_0.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, (0 / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                    s = s + 1
                                    t = (0 / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0)
                                    continue 
                                if accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[s].field_0]:
                                    revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _11519 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11519] = 26
                                mem[_11519 + 32] = 'SafeMath: division by zero'
                                if not pRECISION_FACTOR[stor26[s].field_0]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    s = 32
                                    while s < 26:
                                        mem[s + mem[64] + 68] = mem[s + _11519 + 32]
                                        s = s + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                _12932 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12932] = 30
                                mem[_12932 + 32] = 'SafeMath: subtraction overflow'
                                if uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0) > accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[s].field_0]:
                                    _13163 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13163 + 68] = mem[idx + _12932 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13163 + 68] = mem[_13163 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _13163 + -mem[64] + 100
                                if (accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0):
                                    require s < rewardTokens.length
                                    mem[0] = 26
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = (accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0)
                                    require ext_code.size(rewardTokens[s].field_0)
                                    call rewardTokens[s].field_0.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, (accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                s = s + 1
                                t = (accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0)
                                continue 
                            if not arg1:
                                idx = 0
                                while idx < rewardTokens.length:
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = 10
                                    if not uint256(lastStakingBlock[msg.sender].field_0):
                                        _14669 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_14669] = 26
                                        mem[_14669 + 32] = 'SafeMath: division by zero'
                                        if pRECISION_FACTOR[stor26[idx].field_0]:
                                            require idx < rewardTokens.length
                                            mem[0] = rewardTokens[idx].field_0
                                            mem[32] = sha3(msg.sender, 28) + 2
                                            uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                            idx = idx + 1
                                            continue 
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        s = 32
                                        while s < 26:
                                            mem[s + mem[64] + 68] = mem[s + _14669 + 32]
                                            s = s + 32
                                            continue 
                                    else:
                                        if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                            revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _14693 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_14693] = 26
                                        mem[_14693 + 32] = 'SafeMath: division by zero'
                                        if pRECISION_FACTOR[stor26[idx].field_0]:
                                            require idx < rewardTokens.length
                                            mem[0] = rewardTokens[idx].field_0
                                            mem[32] = sha3(msg.sender, 28) + 2
                                            uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                            idx = idx + 1
                                            continue 
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _14693 + 32]
                                            idx = idx + 32
                                            continue 
                                    revert with 0, 'SafeMath: division by zero'
                            else:
                                if arg1 + uint256(lastStakingBlock[msg.sender].field_0) < uint256(lastStakingBlock[msg.sender].field_0):
                                    revert with 0, 'SafeMath: addition overflow'
                                uint256(lastStakingBlock[msg.sender].field_0) += arg1
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = this.address
                                mem[mem[64] + 68] = arg1
                                require ext_code.size(stakedTokenAddress)
                                call stakedTokenAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, this.address, arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not msg.sender:
                                    revert with 0, 'ERC20: mint to the zero address'
                                if arg1 + totalSupply < totalSupply:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalSupply += arg1
                                if arg1 + balanceOf[address(msg.sender)] < balanceOf[address(msg.sender)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[32] = 4
                                balanceOf[address(msg.sender)] += arg1
                                mem[mem[64]] = arg1
                                emit Transfer(arg1, 0, msg.sender);
                                idx = 0
                                while idx < rewardTokens.length:
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = 10
                                    if not uint256(lastStakingBlock[msg.sender].field_0):
                                        _14670 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_14670] = 26
                                        mem[_14670 + 32] = 'SafeMath: division by zero'
                                        if pRECISION_FACTOR[stor26[idx].field_0]:
                                            require idx < rewardTokens.length
                                            mem[0] = rewardTokens[idx].field_0
                                            mem[32] = sha3(msg.sender, 28) + 2
                                            uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                            idx = idx + 1
                                            continue 
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        s = 32
                                        while s < 26:
                                            mem[s + mem[64] + 68] = mem[s + _14670 + 32]
                                            s = s + 32
                                            continue 
                                    else:
                                        if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                            revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _14694 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_14694] = 26
                                        mem[_14694 + 32] = 'SafeMath: division by zero'
                                        if pRECISION_FACTOR[stor26[idx].field_0]:
                                            require idx < rewardTokens.length
                                            mem[0] = rewardTokens[idx].field_0
                                            mem[32] = sha3(msg.sender, 28) + 2
                                            uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                            idx = idx + 1
                                            continue 
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _14694 + 32]
                                            idx = idx + 32
                                            continue 
                                    revert with 0, 'SafeMath: division by zero'
                    else:
                        if lastRewardBlock >= bonusEndBlock:
                            idx = 0
                            while idx < rewardTokens.length:
                                require idx < rewardTokens.length
                                mem[0] = rewardTokens[idx].field_0
                                mem[32] = 25
                                _6298 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6298] = 26
                                mem[_6298 + 32] = 'SafeMath: division by zero'
                                if not ext_call.return_data[0]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _6298 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                require idx < rewardTokens.length
                                if (0 / ext_call.return_data[0]) + accTokenPerShare[stor26[idx].field_0] < accTokenPerShare[stor26[idx].field_0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require idx < rewardTokens.length
                                mem[0] = rewardTokens[idx].field_0
                                mem[32] = 10
                                accTokenPerShare[stor26[idx].field_0] += 0 / ext_call.return_data[0]
                                idx = idx + 1
                                continue 
                            lastRewardBlock = block.number
                            if not uint256(lastStakingBlock[msg.sender].field_0):
                                if not arg1:
                                    s = 0
                                    while s < rewardTokens.length:
                                        mem[0] = rewardTokens[s].field_0
                                        mem[32] = 10
                                        if not uint256(lastStakingBlock[msg.sender].field_0):
                                            _11348 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11348] = 26
                                            mem[_11348 + 32] = 'SafeMath: division by zero'
                                            if pRECISION_FACTOR[stor26[s].field_0]:
                                                require s < rewardTokens.length
                                                mem[0] = rewardTokens[s].field_0
                                                mem[32] = sha3(msg.sender, 28) + 2
                                                uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[s].field_0]
                                                s = s + 1
                                                continue 
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _11348 + 32]
                                                idx = idx + 32
                                                continue 
                                        else:
                                            if accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[s].field_0]:
                                                revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _11410 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11410] = 26
                                            mem[_11410 + 32] = 'SafeMath: division by zero'
                                            if pRECISION_FACTOR[stor26[s].field_0]:
                                                require s < rewardTokens.length
                                                mem[0] = rewardTokens[s].field_0
                                                mem[32] = sha3(msg.sender, 28) + 2
                                                uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0) = accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[s].field_0]
                                                s = s + 1
                                                continue 
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            s = 32
                                            while s < 26:
                                                mem[s + mem[64] + 68] = mem[s + _11410 + 32]
                                                s = s + 32
                                                continue 
                                        revert with 0, 'SafeMath: division by zero'
                                else:
                                    if arg1 + uint256(lastStakingBlock[msg.sender].field_0) < uint256(lastStakingBlock[msg.sender].field_0):
                                        revert with 0, 'SafeMath: addition overflow'
                                    uint256(lastStakingBlock[msg.sender].field_0) += arg1
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = this.address
                                    mem[mem[64] + 68] = arg1
                                    require ext_code.size(stakedTokenAddress)
                                    call stakedTokenAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, this.address, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not msg.sender:
                                        revert with 0, 'ERC20: mint to the zero address'
                                    if arg1 + totalSupply < totalSupply:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalSupply += arg1
                                    if arg1 + balanceOf[address(msg.sender)] < balanceOf[address(msg.sender)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[32] = 4
                                    balanceOf[address(msg.sender)] += arg1
                                    mem[mem[64]] = arg1
                                    emit Transfer(arg1, 0, msg.sender);
                                    idx = 0
                                    while idx < rewardTokens.length:
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = 10
                                        if not uint256(lastStakingBlock[msg.sender].field_0):
                                            _11349 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11349] = 26
                                            mem[_11349 + 32] = 'SafeMath: division by zero'
                                            if pRECISION_FACTOR[stor26[idx].field_0]:
                                                require idx < rewardTokens.length
                                                mem[0] = rewardTokens[idx].field_0
                                                mem[32] = sha3(msg.sender, 28) + 2
                                                uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            s = 32
                                            while s < 26:
                                                mem[s + mem[64] + 68] = mem[s + _11349 + 32]
                                                s = s + 32
                                                continue 
                                        else:
                                            if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                                revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _11411 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11411] = 26
                                            mem[_11411 + 32] = 'SafeMath: division by zero'
                                            if pRECISION_FACTOR[stor26[idx].field_0]:
                                                require idx < rewardTokens.length
                                                mem[0] = rewardTokens[idx].field_0
                                                mem[32] = sha3(msg.sender, 28) + 2
                                                uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _11411 + 32]
                                                idx = idx + 32
                                                continue 
                                        revert with 0, 'SafeMath: division by zero'
                            else:
                                s = 0
                                t = 0
                                while s < rewardTokens.length:
                                    mem[0] = rewardTokens[s].field_0
                                    mem[32] = 10
                                    if not uint256(lastStakingBlock[msg.sender].field_0):
                                        _11412 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11412] = 26
                                        mem[_11412 + 32] = 'SafeMath: division by zero'
                                        if not pRECISION_FACTOR[stor26[s].field_0]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _11412 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        _12710 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12710] = 30
                                        mem[_12710 + 32] = 'SafeMath: subtraction overflow'
                                        if uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0) > 0 / pRECISION_FACTOR[stor26[s].field_0]:
                                            _13046 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _13046 + 68] = mem[idx + _12710 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_13046 + 68] = mem[_13046 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _13046 + -mem[64] + 100
                                        if (0 / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0):
                                            require s < rewardTokens.length
                                            mem[0] = 26
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = (0 / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0)
                                            require ext_code.size(rewardTokens[s].field_0)
                                            call rewardTokens[s].field_0.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (0 / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                        s = s + 1
                                        t = (0 / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0)
                                        continue 
                                    if accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[s].field_0]:
                                        revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _11512 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11512] = 26
                                    mem[_11512 + 32] = 'SafeMath: division by zero'
                                    if not pRECISION_FACTOR[stor26[s].field_0]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        s = 32
                                        while s < 26:
                                            mem[s + mem[64] + 68] = mem[s + _11512 + 32]
                                            s = s + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    _12921 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12921] = 30
                                    mem[_12921 + 32] = 'SafeMath: subtraction overflow'
                                    if uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0) > accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[s].field_0]:
                                        _13154 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13154 + 68] = mem[idx + _12921 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13154 + 68] = mem[_13154 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _13154 + -mem[64] + 100
                                    if (accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0):
                                        require s < rewardTokens.length
                                        mem[0] = 26
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = (accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0)
                                        require ext_code.size(rewardTokens[s].field_0)
                                        call rewardTokens[s].field_0.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, (accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                    s = s + 1
                                    t = (accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0)
                                    continue 
                                if not arg1:
                                    idx = 0
                                    while idx < rewardTokens.length:
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = 10
                                        if not uint256(lastStakingBlock[msg.sender].field_0):
                                            _14667 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_14667] = 26
                                            mem[_14667 + 32] = 'SafeMath: division by zero'
                                            if pRECISION_FACTOR[stor26[idx].field_0]:
                                                require idx < rewardTokens.length
                                                mem[0] = rewardTokens[idx].field_0
                                                mem[32] = sha3(msg.sender, 28) + 2
                                                uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            s = 32
                                            while s < 26:
                                                mem[s + mem[64] + 68] = mem[s + _14667 + 32]
                                                s = s + 32
                                                continue 
                                        else:
                                            if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                                revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _14691 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_14691] = 26
                                            mem[_14691 + 32] = 'SafeMath: division by zero'
                                            if pRECISION_FACTOR[stor26[idx].field_0]:
                                                require idx < rewardTokens.length
                                                mem[0] = rewardTokens[idx].field_0
                                                mem[32] = sha3(msg.sender, 28) + 2
                                                uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _14691 + 32]
                                                idx = idx + 32
                                                continue 
                                        revert with 0, 'SafeMath: division by zero'
                                else:
                                    if arg1 + uint256(lastStakingBlock[msg.sender].field_0) < uint256(lastStakingBlock[msg.sender].field_0):
                                        revert with 0, 'SafeMath: addition overflow'
                                    uint256(lastStakingBlock[msg.sender].field_0) += arg1
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = this.address
                                    mem[mem[64] + 68] = arg1
                                    require ext_code.size(stakedTokenAddress)
                                    call stakedTokenAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, this.address, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not msg.sender:
                                        revert with 0, 'ERC20: mint to the zero address'
                                    if arg1 + totalSupply < totalSupply:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalSupply += arg1
                                    if arg1 + balanceOf[address(msg.sender)] < balanceOf[address(msg.sender)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[32] = 4
                                    balanceOf[address(msg.sender)] += arg1
                                    mem[mem[64]] = arg1
                                    emit Transfer(arg1, 0, msg.sender);
                                    idx = 0
                                    while idx < rewardTokens.length:
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = 10
                                        if not uint256(lastStakingBlock[msg.sender].field_0):
                                            _14668 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_14668] = 26
                                            mem[_14668 + 32] = 'SafeMath: division by zero'
                                            if pRECISION_FACTOR[stor26[idx].field_0]:
                                                require idx < rewardTokens.length
                                                mem[0] = rewardTokens[idx].field_0
                                                mem[32] = sha3(msg.sender, 28) + 2
                                                uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            s = 32
                                            while s < 26:
                                                mem[s + mem[64] + 68] = mem[s + _14668 + 32]
                                                s = s + 32
                                                continue 
                                        else:
                                            if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                                revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _14692 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_14692] = 26
                                            mem[_14692 + 32] = 'SafeMath: division by zero'
                                            if pRECISION_FACTOR[stor26[idx].field_0]:
                                                require idx < rewardTokens.length
                                                mem[0] = rewardTokens[idx].field_0
                                                mem[32] = sha3(msg.sender, 28) + 2
                                                uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _14692 + 32]
                                                idx = idx + 32
                                                continue 
                                        revert with 0, 'SafeMath: division by zero'
                        else:
                            mem[64] = 288
                            mem[224] = 30
                            mem[256] = 'SafeMath: subtraction overflow'
                            if lastRewardBlock > bonusEndBlock:
                                revert with 0, 'SafeMath: subtraction overflow'
                            idx = 0
                            while idx < rewardTokens.length:
                                if not bonusEndBlock - lastRewardBlock:
                                    require idx < rewardTokens.length
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = 25
                                    _6295 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6295] = 26
                                    mem[_6295 + 32] = 'SafeMath: division by zero'
                                    if not ext_call.return_data[0]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _6295 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    require idx < rewardTokens.length
                                    if (0 / ext_call.return_data[0]) + accTokenPerShare[stor26[idx].field_0] < accTokenPerShare[stor26[idx].field_0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    require idx < rewardTokens.length
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = 10
                                    accTokenPerShare[stor26[idx].field_0] += 0 / ext_call.return_data[0]
                                else:
                                    if (bonusEndBlock * rewardPerBlock[stor26[idx].field_0]) - (lastRewardBlock * rewardPerBlock[stor26[idx].field_0]) / bonusEndBlock - lastRewardBlock != rewardPerBlock[stor26[idx].field_0]:
                                        revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    require idx < rewardTokens.length
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = 25
                                    if not (bonusEndBlock * rewardPerBlock[stor26[idx].field_0]) - (lastRewardBlock * rewardPerBlock[stor26[idx].field_0]):
                                        _6462 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6462] = 26
                                        mem[_6462 + 32] = 'SafeMath: division by zero'
                                        if not ext_call.return_data[0]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _6462 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        require idx < rewardTokens.length
                                        if (0 / ext_call.return_data[0]) + accTokenPerShare[stor26[idx].field_0] < accTokenPerShare[stor26[idx].field_0]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        require idx < rewardTokens.length
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = 10
                                        accTokenPerShare[stor26[idx].field_0] += 0 / ext_call.return_data[0]
                                    else:
                                        if (bonusEndBlock * rewardPerBlock[stor26[idx].field_0] * pRECISION_FACTOR[stor26[idx].field_0]) - (lastRewardBlock * rewardPerBlock[stor26[idx].field_0] * pRECISION_FACTOR[stor26[idx].field_0]) / (bonusEndBlock * rewardPerBlock[stor26[idx].field_0]) - (lastRewardBlock * rewardPerBlock[stor26[idx].field_0]) != pRECISION_FACTOR[stor26[idx].field_0]:
                                            revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _6661 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6661] = 26
                                        mem[_6661 + 32] = 'SafeMath: division by zero'
                                        if not ext_call.return_data[0]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _6661 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        require idx < rewardTokens.length
                                        if ((bonusEndBlock * rewardPerBlock[stor26[idx].field_0] * pRECISION_FACTOR[stor26[idx].field_0]) - (lastRewardBlock * rewardPerBlock[stor26[idx].field_0] * pRECISION_FACTOR[stor26[idx].field_0]) / ext_call.return_data[0]) + accTokenPerShare[stor26[idx].field_0] < accTokenPerShare[stor26[idx].field_0]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        require idx < rewardTokens.length
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = 10
                                        accTokenPerShare[stor26[idx].field_0] += (bonusEndBlock * rewardPerBlock[stor26[idx].field_0] * pRECISION_FACTOR[stor26[idx].field_0]) - (lastRewardBlock * rewardPerBlock[stor26[idx].field_0] * pRECISION_FACTOR[stor26[idx].field_0]) / ext_call.return_data[0]
                                idx = idx + 1
                                continue 
                            lastRewardBlock = block.number
                            if not uint256(lastStakingBlock[msg.sender].field_0):
                                if not arg1:
                                    s = 0
                                    while s < rewardTokens.length:
                                        mem[0] = rewardTokens[s].field_0
                                        mem[32] = 10
                                        if not uint256(lastStakingBlock[msg.sender].field_0):
                                            _11343 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11343] = 26
                                            mem[_11343 + 32] = 'SafeMath: division by zero'
                                            if pRECISION_FACTOR[stor26[s].field_0]:
                                                require s < rewardTokens.length
                                                mem[0] = rewardTokens[s].field_0
                                                mem[32] = sha3(msg.sender, 28) + 2
                                                uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[s].field_0]
                                                s = s + 1
                                                continue 
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _11343 + 32]
                                                idx = idx + 32
                                                continue 
                                        else:
                                            if accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[s].field_0]:
                                                revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _11407 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11407] = 26
                                            mem[_11407 + 32] = 'SafeMath: division by zero'
                                            if pRECISION_FACTOR[stor26[s].field_0]:
                                                require s < rewardTokens.length
                                                mem[0] = rewardTokens[s].field_0
                                                mem[32] = sha3(msg.sender, 28) + 2
                                                uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0) = accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[s].field_0]
                                                s = s + 1
                                                continue 
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            s = 32
                                            while s < 26:
                                                mem[s + mem[64] + 68] = mem[s + _11407 + 32]
                                                s = s + 32
                                                continue 
                                        revert with 0, 'SafeMath: division by zero'
                                else:
                                    if arg1 + uint256(lastStakingBlock[msg.sender].field_0) < uint256(lastStakingBlock[msg.sender].field_0):
                                        revert with 0, 'SafeMath: addition overflow'
                                    uint256(lastStakingBlock[msg.sender].field_0) += arg1
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = this.address
                                    mem[mem[64] + 68] = arg1
                                    require ext_code.size(stakedTokenAddress)
                                    call stakedTokenAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, this.address, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not msg.sender:
                                        revert with 0, 'ERC20: mint to the zero address'
                                    if arg1 + totalSupply < totalSupply:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalSupply += arg1
                                    if arg1 + balanceOf[address(msg.sender)] < balanceOf[address(msg.sender)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[32] = 4
                                    balanceOf[address(msg.sender)] += arg1
                                    mem[mem[64]] = arg1
                                    emit Transfer(arg1, 0, msg.sender);
                                    idx = 0
                                    while idx < rewardTokens.length:
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = 10
                                        if not uint256(lastStakingBlock[msg.sender].field_0):
                                            _11344 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11344] = 26
                                            mem[_11344 + 32] = 'SafeMath: division by zero'
                                            if pRECISION_FACTOR[stor26[idx].field_0]:
                                                require idx < rewardTokens.length
                                                mem[0] = rewardTokens[idx].field_0
                                                mem[32] = sha3(msg.sender, 28) + 2
                                                uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            s = 32
                                            while s < 26:
                                                mem[s + mem[64] + 68] = mem[s + _11344 + 32]
                                                s = s + 32
                                                continue 
                                        else:
                                            if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                                revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _11408 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11408] = 26
                                            mem[_11408 + 32] = 'SafeMath: division by zero'
                                            if pRECISION_FACTOR[stor26[idx].field_0]:
                                                require idx < rewardTokens.length
                                                mem[0] = rewardTokens[idx].field_0
                                                mem[32] = sha3(msg.sender, 28) + 2
                                                uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _11408 + 32]
                                                idx = idx + 32
                                                continue 
                                        revert with 0, 'SafeMath: division by zero'
                            else:
                                s = 0
                                t = 0
                                while s < rewardTokens.length:
                                    mem[0] = rewardTokens[s].field_0
                                    mem[32] = 10
                                    if not uint256(lastStakingBlock[msg.sender].field_0):
                                        _11409 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11409] = 26
                                        mem[_11409 + 32] = 'SafeMath: division by zero'
                                        if not pRECISION_FACTOR[stor26[s].field_0]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _11409 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        _12691 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12691] = 30
                                        mem[_12691 + 32] = 'SafeMath: subtraction overflow'
                                        if uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0) > 0 / pRECISION_FACTOR[stor26[s].field_0]:
                                            _13037 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _13037 + 68] = mem[idx + _12691 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_13037 + 68] = mem[_13037 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _13037 + -mem[64] + 100
                                        if (0 / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0):
                                            require s < rewardTokens.length
                                            mem[0] = 26
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = (0 / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0)
                                            require ext_code.size(rewardTokens[s].field_0)
                                            call rewardTokens[s].field_0.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (0 / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                        s = s + 1
                                        t = (0 / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0)
                                        continue 
                                    if accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[s].field_0]:
                                        revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _11505 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11505] = 26
                                    mem[_11505 + 32] = 'SafeMath: division by zero'
                                    if not pRECISION_FACTOR[stor26[s].field_0]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        s = 32
                                        while s < 26:
                                            mem[s + mem[64] + 68] = mem[s + _11505 + 32]
                                            s = s + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    _12910 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12910] = 30
                                    mem[_12910 + 32] = 'SafeMath: subtraction overflow'
                                    if uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0) > accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[s].field_0]:
                                        _13145 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13145 + 68] = mem[idx + _12910 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13145 + 68] = mem[_13145 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _13145 + -mem[64] + 100
                                    if (accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0):
                                        require s < rewardTokens.length
                                        mem[0] = 26
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = (accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0)
                                        require ext_code.size(rewardTokens[s].field_0)
                                        call rewardTokens[s].field_0.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, (accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                    s = s + 1
                                    t = (accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0)
                                    continue 
                                if not arg1:
                                    idx = 0
                                    while idx < rewardTokens.length:
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = 10
                                        if not uint256(lastStakingBlock[msg.sender].field_0):
                                            _14665 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_14665] = 26
                                            mem[_14665 + 32] = 'SafeMath: division by zero'
                                            if pRECISION_FACTOR[stor26[idx].field_0]:
                                                require idx < rewardTokens.length
                                                mem[0] = rewardTokens[idx].field_0
                                                mem[32] = sha3(msg.sender, 28) + 2
                                                uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            s = 32
                                            while s < 26:
                                                mem[s + mem[64] + 68] = mem[s + _14665 + 32]
                                                s = s + 32
                                                continue 
                                        else:
                                            if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                                revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _14689 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_14689] = 26
                                            mem[_14689 + 32] = 'SafeMath: division by zero'
                                            if pRECISION_FACTOR[stor26[idx].field_0]:
                                                require idx < rewardTokens.length
                                                mem[0] = rewardTokens[idx].field_0
                                                mem[32] = sha3(msg.sender, 28) + 2
                                                uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _14689 + 32]
                                                idx = idx + 32
                                                continue 
                                        revert with 0, 'SafeMath: division by zero'
                                else:
                                    if arg1 + uint256(lastStakingBlock[msg.sender].field_0) < uint256(lastStakingBlock[msg.sender].field_0):
                                        revert with 0, 'SafeMath: addition overflow'
                                    uint256(lastStakingBlock[msg.sender].field_0) += arg1
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = this.address
                                    mem[mem[64] + 68] = arg1
                                    require ext_code.size(stakedTokenAddress)
                                    call stakedTokenAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, this.address, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not msg.sender:
                                        revert with 0, 'ERC20: mint to the zero address'
                                    if arg1 + totalSupply < totalSupply:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalSupply += arg1
                                    if arg1 + balanceOf[address(msg.sender)] < balanceOf[address(msg.sender)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[32] = 4
                                    balanceOf[address(msg.sender)] += arg1
                                    mem[mem[64]] = arg1
                                    emit Transfer(arg1, 0, msg.sender);
                                    idx = 0
                                    while idx < rewardTokens.length:
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = 10
                                        if not uint256(lastStakingBlock[msg.sender].field_0):
                                            _14666 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_14666] = 26
                                            mem[_14666 + 32] = 'SafeMath: division by zero'
                                            if pRECISION_FACTOR[stor26[idx].field_0]:
                                                require idx < rewardTokens.length
                                                mem[0] = rewardTokens[idx].field_0
                                                mem[32] = sha3(msg.sender, 28) + 2
                                                uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            s = 32
                                            while s < 26:
                                                mem[s + mem[64] + 68] = mem[s + _14666 + 32]
                                                s = s + 32
                                                continue 
                                        else:
                                            if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                                revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _14690 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_14690] = 26
                                            mem[_14690 + 32] = 'SafeMath: division by zero'
                                            if pRECISION_FACTOR[stor26[idx].field_0]:
                                                require idx < rewardTokens.length
                                                mem[0] = rewardTokens[idx].field_0
                                                mem[32] = sha3(msg.sender, 28) + 2
                                                uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _14690 + 32]
                                                idx = idx + 32
                                                continue 
                                        revert with 0, 'SafeMath: division by zero'
        else:
            if uint256(lastStakingBlock[msg.sender].field_0) + arg1 < arg1:
                revert with 0, 'SafeMath: addition overflow'
            if uint256(lastStakingBlock[msg.sender].field_0) + arg1 > poolLimitPerUser:
                revert with 0, 'User amount above limit'
            if block.number <= lastRewardBlock:
                if not uint256(lastStakingBlock[msg.sender].field_0):
                    if not arg1:
                        idx = 0
                        while idx < rewardTokens.length:
                            mem[0] = rewardTokens[idx].field_0
                            mem[32] = 10
                            if not uint256(lastStakingBlock[msg.sender].field_0):
                                _5860 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5860] = 26
                                mem[_5860 + 32] = 'SafeMath: division by zero'
                                if pRECISION_FACTOR[stor26[idx].field_0]:
                                    require idx < rewardTokens.length
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = sha3(msg.sender, 28) + 2
                                    uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                s = 32
                                while s < 26:
                                    mem[s + mem[64] + 68] = mem[s + _5860 + 32]
                                    s = s + 32
                                    continue 
                            else:
                                if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                    revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _5934 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5934] = 26
                                mem[_5934 + 32] = 'SafeMath: division by zero'
                                if pRECISION_FACTOR[stor26[idx].field_0]:
                                    require idx < rewardTokens.length
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = sha3(msg.sender, 28) + 2
                                    uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _5934 + 32]
                                    idx = idx + 32
                                    continue 
                            revert with 0, 'SafeMath: division by zero'
                    else:
                        if arg1 + uint256(lastStakingBlock[msg.sender].field_0) < uint256(lastStakingBlock[msg.sender].field_0):
                            revert with 0, 'SafeMath: addition overflow'
                        uint256(lastStakingBlock[msg.sender].field_0) += arg1
                        mem[228] = msg.sender
                        mem[260] = this.address
                        mem[292] = arg1
                        require ext_code.size(stakedTokenAddress)
                        call stakedTokenAddress.0x23b872dd with:
                             gas gas_remaining wei
                            args msg.sender, this.address, arg1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not msg.sender:
                            revert with 0, 'ERC20: mint to the zero address'
                        if arg1 + totalSupply < totalSupply:
                            revert with 0, 'SafeMath: addition overflow'
                        totalSupply += arg1
                        if arg1 + balanceOf[address(msg.sender)] < balanceOf[address(msg.sender)]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[32] = 4
                        balanceOf[address(msg.sender)] += arg1
                        mem[224] = arg1
                        emit Transfer(arg1, 0, msg.sender);
                        idx = 0
                        while idx < rewardTokens.length:
                            mem[0] = rewardTokens[idx].field_0
                            mem[32] = 10
                            if not uint256(lastStakingBlock[msg.sender].field_0):
                                _5861 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5861] = 26
                                mem[_5861 + 32] = 'SafeMath: division by zero'
                                if pRECISION_FACTOR[stor26[idx].field_0]:
                                    require idx < rewardTokens.length
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = sha3(msg.sender, 28) + 2
                                    uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                s = 32
                                while s < 26:
                                    mem[s + mem[64] + 68] = mem[s + _5861 + 32]
                                    s = s + 32
                                    continue 
                            else:
                                if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                    revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _5935 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5935] = 26
                                mem[_5935 + 32] = 'SafeMath: division by zero'
                                if pRECISION_FACTOR[stor26[idx].field_0]:
                                    require idx < rewardTokens.length
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = sha3(msg.sender, 28) + 2
                                    uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _5935 + 32]
                                    idx = idx + 32
                                    continue 
                            revert with 0, 'SafeMath: division by zero'
                else:
                    idx = 0
                    s = 0
                    while idx < rewardTokens.length:
                        mem[0] = rewardTokens[idx].field_0
                        mem[32] = 10
                        if not uint256(lastStakingBlock[msg.sender].field_0):
                            _5936 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5936] = 26
                            mem[_5936 + 32] = 'SafeMath: division by zero'
                            if not pRECISION_FACTOR[stor26[idx].field_0]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _5936 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            _6978 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6978] = 30
                            mem[_6978 + 32] = 'SafeMath: subtraction overflow'
                            if uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) > 0 / pRECISION_FACTOR[stor26[idx].field_0]:
                                _7470 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _7470 + 68] = mem[idx + _6978 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_7470 + 68] = mem[_7470 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _7470 + -mem[64] + 100
                            if (0 / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0):
                                require idx < rewardTokens.length
                                mem[0] = 26
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = (0 / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                                require ext_code.size(rewardTokens[idx].field_0)
                                call rewardTokens[idx].field_0.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, (0 / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                            idx = idx + 1
                            s = (0 / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                            continue 
                        if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                            revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _6052 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6052] = 26
                        mem[_6052 + 32] = 'SafeMath: division by zero'
                        if not pRECISION_FACTOR[stor26[idx].field_0]:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _6052 + 32]
                                idx = idx + 32
                                continue 
                            revert with 0, 'SafeMath: division by zero'
                        _7241 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_7241] = 30
                        mem[_7241 + 32] = 'SafeMath: subtraction overflow'
                        if uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) > accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]:
                            _7730 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _7730 + 68] = mem[idx + _7241 + 32]
                                idx = idx + 32
                                continue 
                            mem[_7730 + 68] = mem[_7730 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _7730 + -mem[64] + 100
                        if (accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0):
                            require idx < rewardTokens.length
                            mem[0] = 26
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = (accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                            require ext_code.size(rewardTokens[idx].field_0)
                            call rewardTokens[idx].field_0.0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, (accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                        idx = idx + 1
                        s = (accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                        continue 
                    if not arg1:
                        idx = 0
                        while idx < rewardTokens.length:
                            mem[0] = rewardTokens[idx].field_0
                            mem[32] = 10
                            if not uint256(lastStakingBlock[msg.sender].field_0):
                                _11379 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11379] = 26
                                mem[_11379 + 32] = 'SafeMath: division by zero'
                                if pRECISION_FACTOR[stor26[idx].field_0]:
                                    require idx < rewardTokens.length
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = sha3(msg.sender, 28) + 2
                                    uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                s = 32
                                while s < 26:
                                    mem[s + mem[64] + 68] = mem[s + _11379 + 32]
                                    s = s + 32
                                    continue 
                            else:
                                if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                    revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _11431 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11431] = 26
                                mem[_11431 + 32] = 'SafeMath: division by zero'
                                if pRECISION_FACTOR[stor26[idx].field_0]:
                                    require idx < rewardTokens.length
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = sha3(msg.sender, 28) + 2
                                    uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _11431 + 32]
                                    idx = idx + 32
                                    continue 
                            revert with 0, 'SafeMath: division by zero'
                    else:
                        if arg1 + uint256(lastStakingBlock[msg.sender].field_0) < uint256(lastStakingBlock[msg.sender].field_0):
                            revert with 0, 'SafeMath: addition overflow'
                        uint256(lastStakingBlock[msg.sender].field_0) += arg1
                        mem[mem[64] + 4] = msg.sender
                        mem[mem[64] + 36] = this.address
                        mem[mem[64] + 68] = arg1
                        require ext_code.size(stakedTokenAddress)
                        call stakedTokenAddress.0x23b872dd with:
                             gas gas_remaining wei
                            args msg.sender, this.address, arg1
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not msg.sender:
                            revert with 0, 'ERC20: mint to the zero address'
                        if arg1 + totalSupply < totalSupply:
                            revert with 0, 'SafeMath: addition overflow'
                        totalSupply += arg1
                        if arg1 + balanceOf[address(msg.sender)] < balanceOf[address(msg.sender)]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[32] = 4
                        balanceOf[address(msg.sender)] += arg1
                        mem[mem[64]] = arg1
                        emit Transfer(arg1, 0, msg.sender);
                        idx = 0
                        while idx < rewardTokens.length:
                            mem[0] = rewardTokens[idx].field_0
                            mem[32] = 10
                            if not uint256(lastStakingBlock[msg.sender].field_0):
                                _11380 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11380] = 26
                                mem[_11380 + 32] = 'SafeMath: division by zero'
                                if pRECISION_FACTOR[stor26[idx].field_0]:
                                    require idx < rewardTokens.length
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = sha3(msg.sender, 28) + 2
                                    uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                s = 32
                                while s < 26:
                                    mem[s + mem[64] + 68] = mem[s + _11380 + 32]
                                    s = s + 32
                                    continue 
                            else:
                                if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                    revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _11432 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11432] = 26
                                mem[_11432 + 32] = 'SafeMath: division by zero'
                                if pRECISION_FACTOR[stor26[idx].field_0]:
                                    require idx < rewardTokens.length
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = sha3(msg.sender, 28) + 2
                                    uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                    idx = idx + 1
                                    continue 
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _11432 + 32]
                                    idx = idx + 32
                                    continue 
                            revert with 0, 'SafeMath: division by zero'
            else:
                mem[228] = this.address
                require ext_code.size(stakedTokenAddress)
                staticcall stakedTokenAddress.0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                mem[224] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if not ext_call.return_data[0]:
                    lastRewardBlock = block.number
                    if not uint256(lastStakingBlock[msg.sender].field_0):
                        if not arg1:
                            idx = 0
                            while idx < rewardTokens.length:
                                mem[0] = rewardTokens[idx].field_0
                                mem[32] = 10
                                if not uint256(lastStakingBlock[msg.sender].field_0):
                                    _5855 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5855] = 26
                                    mem[_5855 + 32] = 'SafeMath: division by zero'
                                    if pRECISION_FACTOR[stor26[idx].field_0]:
                                        require idx < rewardTokens.length
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = sha3(msg.sender, 28) + 2
                                        uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    s = 32
                                    while s < 26:
                                        mem[s + mem[64] + 68] = mem[s + _5855 + 32]
                                        s = s + 32
                                        continue 
                                else:
                                    if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                        revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _5931 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5931] = 26
                                    mem[_5931 + 32] = 'SafeMath: division by zero'
                                    if pRECISION_FACTOR[stor26[idx].field_0]:
                                        require idx < rewardTokens.length
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = sha3(msg.sender, 28) + 2
                                        uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _5931 + 32]
                                        idx = idx + 32
                                        continue 
                                revert with 0, 'SafeMath: division by zero'
                        else:
                            if arg1 + uint256(lastStakingBlock[msg.sender].field_0) < uint256(lastStakingBlock[msg.sender].field_0):
                                revert with 0, 'SafeMath: addition overflow'
                            uint256(lastStakingBlock[msg.sender].field_0) += arg1
                            mem[228] = msg.sender
                            mem[260] = this.address
                            mem[292] = arg1
                            require ext_code.size(stakedTokenAddress)
                            call stakedTokenAddress.0x23b872dd with:
                                 gas gas_remaining wei
                                args msg.sender, this.address, arg1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if not msg.sender:
                                revert with 0, 'ERC20: mint to the zero address'
                            if arg1 + totalSupply < totalSupply:
                                revert with 0, 'SafeMath: addition overflow'
                            totalSupply += arg1
                            if arg1 + balanceOf[address(msg.sender)] < balanceOf[address(msg.sender)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[32] = 4
                            balanceOf[address(msg.sender)] += arg1
                            mem[224] = arg1
                            emit Transfer(arg1, 0, msg.sender);
                            idx = 0
                            while idx < rewardTokens.length:
                                mem[0] = rewardTokens[idx].field_0
                                mem[32] = 10
                                if not uint256(lastStakingBlock[msg.sender].field_0):
                                    _5856 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5856] = 26
                                    mem[_5856 + 32] = 'SafeMath: division by zero'
                                    if pRECISION_FACTOR[stor26[idx].field_0]:
                                        require idx < rewardTokens.length
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = sha3(msg.sender, 28) + 2
                                        uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    s = 32
                                    while s < 26:
                                        mem[s + mem[64] + 68] = mem[s + _5856 + 32]
                                        s = s + 32
                                        continue 
                                else:
                                    if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                        revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _5932 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5932] = 26
                                    mem[_5932 + 32] = 'SafeMath: division by zero'
                                    if pRECISION_FACTOR[stor26[idx].field_0]:
                                        require idx < rewardTokens.length
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = sha3(msg.sender, 28) + 2
                                        uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _5932 + 32]
                                        idx = idx + 32
                                        continue 
                                revert with 0, 'SafeMath: division by zero'
                    else:
                        idx = 0
                        s = 0
                        while idx < rewardTokens.length:
                            mem[0] = rewardTokens[idx].field_0
                            mem[32] = 10
                            if not uint256(lastStakingBlock[msg.sender].field_0):
                                _5933 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5933] = 26
                                mem[_5933 + 32] = 'SafeMath: division by zero'
                                if not pRECISION_FACTOR[stor26[idx].field_0]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _5933 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                _6959 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6959] = 30
                                mem[_6959 + 32] = 'SafeMath: subtraction overflow'
                                if uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) > 0 / pRECISION_FACTOR[stor26[idx].field_0]:
                                    _7461 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _7461 + 68] = mem[idx + _6959 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_7461 + 68] = mem[_7461 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _7461 + -mem[64] + 100
                                if (0 / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0):
                                    require idx < rewardTokens.length
                                    mem[0] = 26
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = (0 / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                                    require ext_code.size(rewardTokens[idx].field_0)
                                    call rewardTokens[idx].field_0.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, (0 / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                idx = idx + 1
                                s = (0 / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                                continue 
                            if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _6045 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_6045] = 26
                            mem[_6045 + 32] = 'SafeMath: division by zero'
                            if not pRECISION_FACTOR[stor26[idx].field_0]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _6045 + 32]
                                    idx = idx + 32
                                    continue 
                                revert with 0, 'SafeMath: division by zero'
                            _7230 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_7230] = 30
                            mem[_7230 + 32] = 'SafeMath: subtraction overflow'
                            if uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) > accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]:
                                _7721 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _7721 + 68] = mem[idx + _7230 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_7721 + 68] = mem[_7721 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _7721 + -mem[64] + 100
                            if (accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0):
                                require idx < rewardTokens.length
                                mem[0] = 26
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = (accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                                require ext_code.size(rewardTokens[idx].field_0)
                                call rewardTokens[idx].field_0.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, (accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                            idx = idx + 1
                            s = (accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0)
                            continue 
                        if not arg1:
                            idx = 0
                            while idx < rewardTokens.length:
                                mem[0] = rewardTokens[idx].field_0
                                mem[32] = 10
                                if not uint256(lastStakingBlock[msg.sender].field_0):
                                    _11377 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11377] = 26
                                    mem[_11377 + 32] = 'SafeMath: division by zero'
                                    if pRECISION_FACTOR[stor26[idx].field_0]:
                                        require idx < rewardTokens.length
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = sha3(msg.sender, 28) + 2
                                        uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    s = 32
                                    while s < 26:
                                        mem[s + mem[64] + 68] = mem[s + _11377 + 32]
                                        s = s + 32
                                        continue 
                                else:
                                    if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                        revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _11429 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11429] = 26
                                    mem[_11429 + 32] = 'SafeMath: division by zero'
                                    if pRECISION_FACTOR[stor26[idx].field_0]:
                                        require idx < rewardTokens.length
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = sha3(msg.sender, 28) + 2
                                        uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _11429 + 32]
                                        idx = idx + 32
                                        continue 
                                revert with 0, 'SafeMath: division by zero'
                        else:
                            if arg1 + uint256(lastStakingBlock[msg.sender].field_0) < uint256(lastStakingBlock[msg.sender].field_0):
                                revert with 0, 'SafeMath: addition overflow'
                            uint256(lastStakingBlock[msg.sender].field_0) += arg1
                            mem[mem[64] + 4] = msg.sender
                            mem[mem[64] + 36] = this.address
                            mem[mem[64] + 68] = arg1
                            require ext_code.size(stakedTokenAddress)
                            call stakedTokenAddress.0x23b872dd with:
                                 gas gas_remaining wei
                                args msg.sender, this.address, arg1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if not msg.sender:
                                revert with 0, 'ERC20: mint to the zero address'
                            if arg1 + totalSupply < totalSupply:
                                revert with 0, 'SafeMath: addition overflow'
                            totalSupply += arg1
                            if arg1 + balanceOf[address(msg.sender)] < balanceOf[address(msg.sender)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[32] = 4
                            balanceOf[address(msg.sender)] += arg1
                            mem[mem[64]] = arg1
                            emit Transfer(arg1, 0, msg.sender);
                            idx = 0
                            while idx < rewardTokens.length:
                                mem[0] = rewardTokens[idx].field_0
                                mem[32] = 10
                                if not uint256(lastStakingBlock[msg.sender].field_0):
                                    _11378 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11378] = 26
                                    mem[_11378 + 32] = 'SafeMath: division by zero'
                                    if pRECISION_FACTOR[stor26[idx].field_0]:
                                        require idx < rewardTokens.length
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = sha3(msg.sender, 28) + 2
                                        uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    s = 32
                                    while s < 26:
                                        mem[s + mem[64] + 68] = mem[s + _11378 + 32]
                                        s = s + 32
                                        continue 
                                else:
                                    if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                        revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _11430 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11430] = 26
                                    mem[_11430 + 32] = 'SafeMath: division by zero'
                                    if pRECISION_FACTOR[stor26[idx].field_0]:
                                        require idx < rewardTokens.length
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = sha3(msg.sender, 28) + 2
                                        uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                        idx = idx + 1
                                        continue 
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _11430 + 32]
                                        idx = idx + 32
                                        continue 
                                revert with 0, 'SafeMath: division by zero'
                else:
                    if block.number <= bonusEndBlock:
                        mem[64] = 288
                        mem[224] = 30
                        mem[256] = 'SafeMath: subtraction overflow'
                        if lastRewardBlock > block.number:
                            revert with 0, 'SafeMath: subtraction overflow'
                        idx = 0
                        while idx < rewardTokens.length:
                            if not block.number - lastRewardBlock:
                                require idx < rewardTokens.length
                                mem[0] = rewardTokens[idx].field_0
                                mem[32] = 25
                                _6338 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6338] = 26
                                mem[_6338 + 32] = 'SafeMath: division by zero'
                                if not ext_call.return_data[0]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _6338 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                require idx < rewardTokens.length
                                if (0 / ext_call.return_data[0]) + accTokenPerShare[stor26[idx].field_0] < accTokenPerShare[stor26[idx].field_0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require idx < rewardTokens.length
                                mem[0] = rewardTokens[idx].field_0
                                mem[32] = 10
                                accTokenPerShare[stor26[idx].field_0] += 0 / ext_call.return_data[0]
                            else:
                                if (block.number * rewardPerBlock[stor26[idx].field_0]) - (lastRewardBlock * rewardPerBlock[stor26[idx].field_0]) / block.number - lastRewardBlock != rewardPerBlock[stor26[idx].field_0]:
                                    revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                require idx < rewardTokens.length
                                mem[0] = rewardTokens[idx].field_0
                                mem[32] = 25
                                if not (block.number * rewardPerBlock[stor26[idx].field_0]) - (lastRewardBlock * rewardPerBlock[stor26[idx].field_0]):
                                    _6524 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6524] = 26
                                    mem[_6524 + 32] = 'SafeMath: division by zero'
                                    if not ext_call.return_data[0]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _6524 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    require idx < rewardTokens.length
                                    if (0 / ext_call.return_data[0]) + accTokenPerShare[stor26[idx].field_0] < accTokenPerShare[stor26[idx].field_0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    require idx < rewardTokens.length
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = 10
                                    accTokenPerShare[stor26[idx].field_0] += 0 / ext_call.return_data[0]
                                else:
                                    if (block.number * rewardPerBlock[stor26[idx].field_0] * pRECISION_FACTOR[stor26[idx].field_0]) - (lastRewardBlock * rewardPerBlock[stor26[idx].field_0] * pRECISION_FACTOR[stor26[idx].field_0]) / (block.number * rewardPerBlock[stor26[idx].field_0]) - (lastRewardBlock * rewardPerBlock[stor26[idx].field_0]) != pRECISION_FACTOR[stor26[idx].field_0]:
                                        revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _6727 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6727] = 26
                                    mem[_6727 + 32] = 'SafeMath: division by zero'
                                    if not ext_call.return_data[0]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _6727 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    require idx < rewardTokens.length
                                    if ((block.number * rewardPerBlock[stor26[idx].field_0] * pRECISION_FACTOR[stor26[idx].field_0]) - (lastRewardBlock * rewardPerBlock[stor26[idx].field_0] * pRECISION_FACTOR[stor26[idx].field_0]) / ext_call.return_data[0]) + accTokenPerShare[stor26[idx].field_0] < accTokenPerShare[stor26[idx].field_0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    require idx < rewardTokens.length
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = 10
                                    accTokenPerShare[stor26[idx].field_0] += (block.number * rewardPerBlock[stor26[idx].field_0] * pRECISION_FACTOR[stor26[idx].field_0]) - (lastRewardBlock * rewardPerBlock[stor26[idx].field_0] * pRECISION_FACTOR[stor26[idx].field_0]) / ext_call.return_data[0]
                            idx = idx + 1
                            continue 
                        lastRewardBlock = block.number
                        if not uint256(lastStakingBlock[msg.sender].field_0):
                            if not arg1:
                                s = 0
                                while s < rewardTokens.length:
                                    mem[0] = rewardTokens[s].field_0
                                    mem[32] = 10
                                    if not uint256(lastStakingBlock[msg.sender].field_0):
                                        _11372 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11372] = 26
                                        mem[_11372 + 32] = 'SafeMath: division by zero'
                                        if pRECISION_FACTOR[stor26[s].field_0]:
                                            require s < rewardTokens.length
                                            mem[0] = rewardTokens[s].field_0
                                            mem[32] = sha3(msg.sender, 28) + 2
                                            uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[s].field_0]
                                            s = s + 1
                                            continue 
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _11372 + 32]
                                            idx = idx + 32
                                            continue 
                                    else:
                                        if accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[s].field_0]:
                                            revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _11426 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11426] = 26
                                        mem[_11426 + 32] = 'SafeMath: division by zero'
                                        if pRECISION_FACTOR[stor26[s].field_0]:
                                            require s < rewardTokens.length
                                            mem[0] = rewardTokens[s].field_0
                                            mem[32] = sha3(msg.sender, 28) + 2
                                            uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0) = accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[s].field_0]
                                            s = s + 1
                                            continue 
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        s = 32
                                        while s < 26:
                                            mem[s + mem[64] + 68] = mem[s + _11426 + 32]
                                            s = s + 32
                                            continue 
                                    revert with 0, 'SafeMath: division by zero'
                            else:
                                if arg1 + uint256(lastStakingBlock[msg.sender].field_0) < uint256(lastStakingBlock[msg.sender].field_0):
                                    revert with 0, 'SafeMath: addition overflow'
                                uint256(lastStakingBlock[msg.sender].field_0) += arg1
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = this.address
                                mem[mem[64] + 68] = arg1
                                require ext_code.size(stakedTokenAddress)
                                call stakedTokenAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, this.address, arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not msg.sender:
                                    revert with 0, 'ERC20: mint to the zero address'
                                if arg1 + totalSupply < totalSupply:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalSupply += arg1
                                if arg1 + balanceOf[address(msg.sender)] < balanceOf[address(msg.sender)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[32] = 4
                                balanceOf[address(msg.sender)] += arg1
                                mem[mem[64]] = arg1
                                emit Transfer(arg1, 0, msg.sender);
                                idx = 0
                                while idx < rewardTokens.length:
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = 10
                                    if not uint256(lastStakingBlock[msg.sender].field_0):
                                        _11373 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11373] = 26
                                        mem[_11373 + 32] = 'SafeMath: division by zero'
                                        if pRECISION_FACTOR[stor26[idx].field_0]:
                                            require idx < rewardTokens.length
                                            mem[0] = rewardTokens[idx].field_0
                                            mem[32] = sha3(msg.sender, 28) + 2
                                            uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                            idx = idx + 1
                                            continue 
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        s = 32
                                        while s < 26:
                                            mem[s + mem[64] + 68] = mem[s + _11373 + 32]
                                            s = s + 32
                                            continue 
                                    else:
                                        if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                            revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _11427 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11427] = 26
                                        mem[_11427 + 32] = 'SafeMath: division by zero'
                                        if pRECISION_FACTOR[stor26[idx].field_0]:
                                            require idx < rewardTokens.length
                                            mem[0] = rewardTokens[idx].field_0
                                            mem[32] = sha3(msg.sender, 28) + 2
                                            uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                            idx = idx + 1
                                            continue 
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _11427 + 32]
                                            idx = idx + 32
                                            continue 
                                    revert with 0, 'SafeMath: division by zero'
                        else:
                            s = 0
                            t = 0
                            while s < rewardTokens.length:
                                mem[0] = rewardTokens[s].field_0
                                mem[32] = 10
                                if not uint256(lastStakingBlock[msg.sender].field_0):
                                    _11428 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11428] = 26
                                    mem[_11428 + 32] = 'SafeMath: division by zero'
                                    if not pRECISION_FACTOR[stor26[s].field_0]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _11428 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    _12806 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12806] = 30
                                    mem[_12806 + 32] = 'SafeMath: subtraction overflow'
                                    if uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0) > 0 / pRECISION_FACTOR[stor26[s].field_0]:
                                        _13082 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13082 + 68] = mem[idx + _12806 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13082 + 68] = mem[_13082 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _13082 + -mem[64] + 100
                                    if (0 / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0):
                                        require s < rewardTokens.length
                                        mem[0] = 26
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = (0 / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0)
                                        require ext_code.size(rewardTokens[s].field_0)
                                        call rewardTokens[s].field_0.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, (0 / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                    s = s + 1
                                    t = (0 / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0)
                                    continue 
                                if accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[s].field_0]:
                                    revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _11552 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11552] = 26
                                mem[_11552 + 32] = 'SafeMath: division by zero'
                                if not pRECISION_FACTOR[stor26[s].field_0]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    s = 32
                                    while s < 26:
                                        mem[s + mem[64] + 68] = mem[s + _11552 + 32]
                                        s = s + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                _12969 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12969] = 30
                                mem[_12969 + 32] = 'SafeMath: subtraction overflow'
                                if uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0) > accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[s].field_0]:
                                    _13190 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13190 + 68] = mem[idx + _12969 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13190 + 68] = mem[_13190 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _13190 + -mem[64] + 100
                                if (accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0):
                                    require s < rewardTokens.length
                                    mem[0] = 26
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = (accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0)
                                    require ext_code.size(rewardTokens[s].field_0)
                                    call rewardTokens[s].field_0.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, (accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0)
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                s = s + 1
                                t = (accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0)
                                continue 
                            if not arg1:
                                idx = 0
                                while idx < rewardTokens.length:
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = 10
                                    if not uint256(lastStakingBlock[msg.sender].field_0):
                                        _14675 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_14675] = 26
                                        mem[_14675 + 32] = 'SafeMath: division by zero'
                                        if pRECISION_FACTOR[stor26[idx].field_0]:
                                            require idx < rewardTokens.length
                                            mem[0] = rewardTokens[idx].field_0
                                            mem[32] = sha3(msg.sender, 28) + 2
                                            uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                            idx = idx + 1
                                            continue 
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        s = 32
                                        while s < 26:
                                            mem[s + mem[64] + 68] = mem[s + _14675 + 32]
                                            s = s + 32
                                            continue 
                                    else:
                                        if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                            revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _14699 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_14699] = 26
                                        mem[_14699 + 32] = 'SafeMath: division by zero'
                                        if pRECISION_FACTOR[stor26[idx].field_0]:
                                            require idx < rewardTokens.length
                                            mem[0] = rewardTokens[idx].field_0
                                            mem[32] = sha3(msg.sender, 28) + 2
                                            uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                            idx = idx + 1
                                            continue 
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _14699 + 32]
                                            idx = idx + 32
                                            continue 
                                    revert with 0, 'SafeMath: division by zero'
                            else:
                                if arg1 + uint256(lastStakingBlock[msg.sender].field_0) < uint256(lastStakingBlock[msg.sender].field_0):
                                    revert with 0, 'SafeMath: addition overflow'
                                uint256(lastStakingBlock[msg.sender].field_0) += arg1
                                mem[mem[64] + 4] = msg.sender
                                mem[mem[64] + 36] = this.address
                                mem[mem[64] + 68] = arg1
                                require ext_code.size(stakedTokenAddress)
                                call stakedTokenAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, this.address, arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not msg.sender:
                                    revert with 0, 'ERC20: mint to the zero address'
                                if arg1 + totalSupply < totalSupply:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalSupply += arg1
                                if arg1 + balanceOf[address(msg.sender)] < balanceOf[address(msg.sender)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[32] = 4
                                balanceOf[address(msg.sender)] += arg1
                                mem[mem[64]] = arg1
                                emit Transfer(arg1, 0, msg.sender);
                                idx = 0
                                while idx < rewardTokens.length:
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = 10
                                    if not uint256(lastStakingBlock[msg.sender].field_0):
                                        _14676 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_14676] = 26
                                        mem[_14676 + 32] = 'SafeMath: division by zero'
                                        if pRECISION_FACTOR[stor26[idx].field_0]:
                                            require idx < rewardTokens.length
                                            mem[0] = rewardTokens[idx].field_0
                                            mem[32] = sha3(msg.sender, 28) + 2
                                            uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                            idx = idx + 1
                                            continue 
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        s = 32
                                        while s < 26:
                                            mem[s + mem[64] + 68] = mem[s + _14676 + 32]
                                            s = s + 32
                                            continue 
                                    else:
                                        if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                            revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _14700 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_14700] = 26
                                        mem[_14700 + 32] = 'SafeMath: division by zero'
                                        if pRECISION_FACTOR[stor26[idx].field_0]:
                                            require idx < rewardTokens.length
                                            mem[0] = rewardTokens[idx].field_0
                                            mem[32] = sha3(msg.sender, 28) + 2
                                            uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                            idx = idx + 1
                                            continue 
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _14700 + 32]
                                            idx = idx + 32
                                            continue 
                                    revert with 0, 'SafeMath: division by zero'
                    else:
                        if lastRewardBlock >= bonusEndBlock:
                            idx = 0
                            while idx < rewardTokens.length:
                                require idx < rewardTokens.length
                                mem[0] = rewardTokens[idx].field_0
                                mem[32] = 25
                                _6333 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6333] = 26
                                mem[_6333 + 32] = 'SafeMath: division by zero'
                                if not ext_call.return_data[0]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _6333 + 32]
                                        idx = idx + 32
                                        continue 
                                    revert with 0, 'SafeMath: division by zero'
                                require idx < rewardTokens.length
                                if (0 / ext_call.return_data[0]) + accTokenPerShare[stor26[idx].field_0] < accTokenPerShare[stor26[idx].field_0]:
                                    revert with 0, 'SafeMath: addition overflow'
                                require idx < rewardTokens.length
                                mem[0] = rewardTokens[idx].field_0
                                mem[32] = 10
                                accTokenPerShare[stor26[idx].field_0] += 0 / ext_call.return_data[0]
                                idx = idx + 1
                                continue 
                            lastRewardBlock = block.number
                            if not uint256(lastStakingBlock[msg.sender].field_0):
                                if not arg1:
                                    s = 0
                                    while s < rewardTokens.length:
                                        mem[0] = rewardTokens[s].field_0
                                        mem[32] = 10
                                        if not uint256(lastStakingBlock[msg.sender].field_0):
                                            _11367 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11367] = 26
                                            mem[_11367 + 32] = 'SafeMath: division by zero'
                                            if pRECISION_FACTOR[stor26[s].field_0]:
                                                require s < rewardTokens.length
                                                mem[0] = rewardTokens[s].field_0
                                                mem[32] = sha3(msg.sender, 28) + 2
                                                uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[s].field_0]
                                                s = s + 1
                                                continue 
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _11367 + 32]
                                                idx = idx + 32
                                                continue 
                                        else:
                                            if accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[s].field_0]:
                                                revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _11423 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11423] = 26
                                            mem[_11423 + 32] = 'SafeMath: division by zero'
                                            if pRECISION_FACTOR[stor26[s].field_0]:
                                                require s < rewardTokens.length
                                                mem[0] = rewardTokens[s].field_0
                                                mem[32] = sha3(msg.sender, 28) + 2
                                                uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0) = accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[s].field_0]
                                                s = s + 1
                                                continue 
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            s = 32
                                            while s < 26:
                                                mem[s + mem[64] + 68] = mem[s + _11423 + 32]
                                                s = s + 32
                                                continue 
                                        revert with 0, 'SafeMath: division by zero'
                                else:
                                    if arg1 + uint256(lastStakingBlock[msg.sender].field_0) < uint256(lastStakingBlock[msg.sender].field_0):
                                        revert with 0, 'SafeMath: addition overflow'
                                    uint256(lastStakingBlock[msg.sender].field_0) += arg1
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = this.address
                                    mem[mem[64] + 68] = arg1
                                    require ext_code.size(stakedTokenAddress)
                                    call stakedTokenAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, this.address, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not msg.sender:
                                        revert with 0, 'ERC20: mint to the zero address'
                                    if arg1 + totalSupply < totalSupply:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalSupply += arg1
                                    if arg1 + balanceOf[address(msg.sender)] < balanceOf[address(msg.sender)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[32] = 4
                                    balanceOf[address(msg.sender)] += arg1
                                    mem[mem[64]] = arg1
                                    emit Transfer(arg1, 0, msg.sender);
                                    idx = 0
                                    while idx < rewardTokens.length:
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = 10
                                        if not uint256(lastStakingBlock[msg.sender].field_0):
                                            _11368 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11368] = 26
                                            mem[_11368 + 32] = 'SafeMath: division by zero'
                                            if pRECISION_FACTOR[stor26[idx].field_0]:
                                                require idx < rewardTokens.length
                                                mem[0] = rewardTokens[idx].field_0
                                                mem[32] = sha3(msg.sender, 28) + 2
                                                uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            s = 32
                                            while s < 26:
                                                mem[s + mem[64] + 68] = mem[s + _11368 + 32]
                                                s = s + 32
                                                continue 
                                        else:
                                            if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                                revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _11424 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11424] = 26
                                            mem[_11424 + 32] = 'SafeMath: division by zero'
                                            if pRECISION_FACTOR[stor26[idx].field_0]:
                                                require idx < rewardTokens.length
                                                mem[0] = rewardTokens[idx].field_0
                                                mem[32] = sha3(msg.sender, 28) + 2
                                                uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _11424 + 32]
                                                idx = idx + 32
                                                continue 
                                        revert with 0, 'SafeMath: division by zero'
                            else:
                                s = 0
                                t = 0
                                while s < rewardTokens.length:
                                    mem[0] = rewardTokens[s].field_0
                                    mem[32] = 10
                                    if not uint256(lastStakingBlock[msg.sender].field_0):
                                        _11425 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11425] = 26
                                        mem[_11425 + 32] = 'SafeMath: division by zero'
                                        if not pRECISION_FACTOR[stor26[s].field_0]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _11425 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        _12787 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12787] = 30
                                        mem[_12787 + 32] = 'SafeMath: subtraction overflow'
                                        if uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0) > 0 / pRECISION_FACTOR[stor26[s].field_0]:
                                            _13073 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _13073 + 68] = mem[idx + _12787 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_13073 + 68] = mem[_13073 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _13073 + -mem[64] + 100
                                        if (0 / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0):
                                            require s < rewardTokens.length
                                            mem[0] = 26
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = (0 / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0)
                                            require ext_code.size(rewardTokens[s].field_0)
                                            call rewardTokens[s].field_0.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (0 / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                        s = s + 1
                                        t = (0 / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0)
                                        continue 
                                    if accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[s].field_0]:
                                        revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _11545 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11545] = 26
                                    mem[_11545 + 32] = 'SafeMath: division by zero'
                                    if not pRECISION_FACTOR[stor26[s].field_0]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        s = 32
                                        while s < 26:
                                            mem[s + mem[64] + 68] = mem[s + _11545 + 32]
                                            s = s + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    _12958 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12958] = 30
                                    mem[_12958 + 32] = 'SafeMath: subtraction overflow'
                                    if uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0) > accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[s].field_0]:
                                        _13181 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13181 + 68] = mem[idx + _12958 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13181 + 68] = mem[_13181 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _13181 + -mem[64] + 100
                                    if (accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0):
                                        require s < rewardTokens.length
                                        mem[0] = 26
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = (accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0)
                                        require ext_code.size(rewardTokens[s].field_0)
                                        call rewardTokens[s].field_0.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, (accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                    s = s + 1
                                    t = (accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0)
                                    continue 
                                if not arg1:
                                    idx = 0
                                    while idx < rewardTokens.length:
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = 10
                                        if not uint256(lastStakingBlock[msg.sender].field_0):
                                            _14673 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_14673] = 26
                                            mem[_14673 + 32] = 'SafeMath: division by zero'
                                            if pRECISION_FACTOR[stor26[idx].field_0]:
                                                require idx < rewardTokens.length
                                                mem[0] = rewardTokens[idx].field_0
                                                mem[32] = sha3(msg.sender, 28) + 2
                                                uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            s = 32
                                            while s < 26:
                                                mem[s + mem[64] + 68] = mem[s + _14673 + 32]
                                                s = s + 32
                                                continue 
                                        else:
                                            if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                                revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _14697 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_14697] = 26
                                            mem[_14697 + 32] = 'SafeMath: division by zero'
                                            if pRECISION_FACTOR[stor26[idx].field_0]:
                                                require idx < rewardTokens.length
                                                mem[0] = rewardTokens[idx].field_0
                                                mem[32] = sha3(msg.sender, 28) + 2
                                                uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _14697 + 32]
                                                idx = idx + 32
                                                continue 
                                        revert with 0, 'SafeMath: division by zero'
                                else:
                                    if arg1 + uint256(lastStakingBlock[msg.sender].field_0) < uint256(lastStakingBlock[msg.sender].field_0):
                                        revert with 0, 'SafeMath: addition overflow'
                                    uint256(lastStakingBlock[msg.sender].field_0) += arg1
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = this.address
                                    mem[mem[64] + 68] = arg1
                                    require ext_code.size(stakedTokenAddress)
                                    call stakedTokenAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, this.address, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not msg.sender:
                                        revert with 0, 'ERC20: mint to the zero address'
                                    if arg1 + totalSupply < totalSupply:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalSupply += arg1
                                    if arg1 + balanceOf[address(msg.sender)] < balanceOf[address(msg.sender)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[32] = 4
                                    balanceOf[address(msg.sender)] += arg1
                                    mem[mem[64]] = arg1
                                    emit Transfer(arg1, 0, msg.sender);
                                    idx = 0
                                    while idx < rewardTokens.length:
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = 10
                                        if not uint256(lastStakingBlock[msg.sender].field_0):
                                            _14674 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_14674] = 26
                                            mem[_14674 + 32] = 'SafeMath: division by zero'
                                            if pRECISION_FACTOR[stor26[idx].field_0]:
                                                require idx < rewardTokens.length
                                                mem[0] = rewardTokens[idx].field_0
                                                mem[32] = sha3(msg.sender, 28) + 2
                                                uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            s = 32
                                            while s < 26:
                                                mem[s + mem[64] + 68] = mem[s + _14674 + 32]
                                                s = s + 32
                                                continue 
                                        else:
                                            if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                                revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _14698 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_14698] = 26
                                            mem[_14698 + 32] = 'SafeMath: division by zero'
                                            if pRECISION_FACTOR[stor26[idx].field_0]:
                                                require idx < rewardTokens.length
                                                mem[0] = rewardTokens[idx].field_0
                                                mem[32] = sha3(msg.sender, 28) + 2
                                                uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _14698 + 32]
                                                idx = idx + 32
                                                continue 
                                        revert with 0, 'SafeMath: division by zero'
                        else:
                            mem[64] = 288
                            mem[224] = 30
                            mem[256] = 'SafeMath: subtraction overflow'
                            if lastRewardBlock > bonusEndBlock:
                                revert with 0, 'SafeMath: subtraction overflow'
                            idx = 0
                            while idx < rewardTokens.length:
                                if not bonusEndBlock - lastRewardBlock:
                                    require idx < rewardTokens.length
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = 25
                                    _6330 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6330] = 26
                                    mem[_6330 + 32] = 'SafeMath: division by zero'
                                    if not ext_call.return_data[0]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _6330 + 32]
                                            idx = idx + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    require idx < rewardTokens.length
                                    if (0 / ext_call.return_data[0]) + accTokenPerShare[stor26[idx].field_0] < accTokenPerShare[stor26[idx].field_0]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    require idx < rewardTokens.length
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = 10
                                    accTokenPerShare[stor26[idx].field_0] += 0 / ext_call.return_data[0]
                                else:
                                    if (bonusEndBlock * rewardPerBlock[stor26[idx].field_0]) - (lastRewardBlock * rewardPerBlock[stor26[idx].field_0]) / bonusEndBlock - lastRewardBlock != rewardPerBlock[stor26[idx].field_0]:
                                        revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    require idx < rewardTokens.length
                                    mem[0] = rewardTokens[idx].field_0
                                    mem[32] = 25
                                    if not (bonusEndBlock * rewardPerBlock[stor26[idx].field_0]) - (lastRewardBlock * rewardPerBlock[stor26[idx].field_0]):
                                        _6509 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6509] = 26
                                        mem[_6509 + 32] = 'SafeMath: division by zero'
                                        if not ext_call.return_data[0]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _6509 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        require idx < rewardTokens.length
                                        if (0 / ext_call.return_data[0]) + accTokenPerShare[stor26[idx].field_0] < accTokenPerShare[stor26[idx].field_0]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        require idx < rewardTokens.length
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = 10
                                        accTokenPerShare[stor26[idx].field_0] += 0 / ext_call.return_data[0]
                                    else:
                                        if (bonusEndBlock * rewardPerBlock[stor26[idx].field_0] * pRECISION_FACTOR[stor26[idx].field_0]) - (lastRewardBlock * rewardPerBlock[stor26[idx].field_0] * pRECISION_FACTOR[stor26[idx].field_0]) / (bonusEndBlock * rewardPerBlock[stor26[idx].field_0]) - (lastRewardBlock * rewardPerBlock[stor26[idx].field_0]) != pRECISION_FACTOR[stor26[idx].field_0]:
                                            revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _6716 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6716] = 26
                                        mem[_6716 + 32] = 'SafeMath: division by zero'
                                        if not ext_call.return_data[0]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _6716 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        require idx < rewardTokens.length
                                        if ((bonusEndBlock * rewardPerBlock[stor26[idx].field_0] * pRECISION_FACTOR[stor26[idx].field_0]) - (lastRewardBlock * rewardPerBlock[stor26[idx].field_0] * pRECISION_FACTOR[stor26[idx].field_0]) / ext_call.return_data[0]) + accTokenPerShare[stor26[idx].field_0] < accTokenPerShare[stor26[idx].field_0]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        require idx < rewardTokens.length
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = 10
                                        accTokenPerShare[stor26[idx].field_0] += (bonusEndBlock * rewardPerBlock[stor26[idx].field_0] * pRECISION_FACTOR[stor26[idx].field_0]) - (lastRewardBlock * rewardPerBlock[stor26[idx].field_0] * pRECISION_FACTOR[stor26[idx].field_0]) / ext_call.return_data[0]
                                idx = idx + 1
                                continue 
                            lastRewardBlock = block.number
                            if not uint256(lastStakingBlock[msg.sender].field_0):
                                if not arg1:
                                    s = 0
                                    while s < rewardTokens.length:
                                        mem[0] = rewardTokens[s].field_0
                                        mem[32] = 10
                                        if not uint256(lastStakingBlock[msg.sender].field_0):
                                            _11362 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11362] = 26
                                            mem[_11362 + 32] = 'SafeMath: division by zero'
                                            if pRECISION_FACTOR[stor26[s].field_0]:
                                                require s < rewardTokens.length
                                                mem[0] = rewardTokens[s].field_0
                                                mem[32] = sha3(msg.sender, 28) + 2
                                                uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[s].field_0]
                                                s = s + 1
                                                continue 
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _11362 + 32]
                                                idx = idx + 32
                                                continue 
                                        else:
                                            if accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[s].field_0]:
                                                revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _11420 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11420] = 26
                                            mem[_11420 + 32] = 'SafeMath: division by zero'
                                            if pRECISION_FACTOR[stor26[s].field_0]:
                                                require s < rewardTokens.length
                                                mem[0] = rewardTokens[s].field_0
                                                mem[32] = sha3(msg.sender, 28) + 2
                                                uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0) = accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[s].field_0]
                                                s = s + 1
                                                continue 
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            s = 32
                                            while s < 26:
                                                mem[s + mem[64] + 68] = mem[s + _11420 + 32]
                                                s = s + 32
                                                continue 
                                        revert with 0, 'SafeMath: division by zero'
                                else:
                                    if arg1 + uint256(lastStakingBlock[msg.sender].field_0) < uint256(lastStakingBlock[msg.sender].field_0):
                                        revert with 0, 'SafeMath: addition overflow'
                                    uint256(lastStakingBlock[msg.sender].field_0) += arg1
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = this.address
                                    mem[mem[64] + 68] = arg1
                                    require ext_code.size(stakedTokenAddress)
                                    call stakedTokenAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, this.address, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not msg.sender:
                                        revert with 0, 'ERC20: mint to the zero address'
                                    if arg1 + totalSupply < totalSupply:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalSupply += arg1
                                    if arg1 + balanceOf[address(msg.sender)] < balanceOf[address(msg.sender)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[32] = 4
                                    balanceOf[address(msg.sender)] += arg1
                                    mem[mem[64]] = arg1
                                    emit Transfer(arg1, 0, msg.sender);
                                    idx = 0
                                    while idx < rewardTokens.length:
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = 10
                                        if not uint256(lastStakingBlock[msg.sender].field_0):
                                            _11363 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11363] = 26
                                            mem[_11363 + 32] = 'SafeMath: division by zero'
                                            if pRECISION_FACTOR[stor26[idx].field_0]:
                                                require idx < rewardTokens.length
                                                mem[0] = rewardTokens[idx].field_0
                                                mem[32] = sha3(msg.sender, 28) + 2
                                                uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            s = 32
                                            while s < 26:
                                                mem[s + mem[64] + 68] = mem[s + _11363 + 32]
                                                s = s + 32
                                                continue 
                                        else:
                                            if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                                revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _11421 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_11421] = 26
                                            mem[_11421 + 32] = 'SafeMath: division by zero'
                                            if pRECISION_FACTOR[stor26[idx].field_0]:
                                                require idx < rewardTokens.length
                                                mem[0] = rewardTokens[idx].field_0
                                                mem[32] = sha3(msg.sender, 28) + 2
                                                uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _11421 + 32]
                                                idx = idx + 32
                                                continue 
                                        revert with 0, 'SafeMath: division by zero'
                            else:
                                s = 0
                                t = 0
                                while s < rewardTokens.length:
                                    mem[0] = rewardTokens[s].field_0
                                    mem[32] = 10
                                    if not uint256(lastStakingBlock[msg.sender].field_0):
                                        _11422 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_11422] = 26
                                        mem[_11422 + 32] = 'SafeMath: division by zero'
                                        if not pRECISION_FACTOR[stor26[s].field_0]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _11422 + 32]
                                                idx = idx + 32
                                                continue 
                                            revert with 0, 'SafeMath: division by zero'
                                        _12768 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12768] = 30
                                        mem[_12768 + 32] = 'SafeMath: subtraction overflow'
                                        if uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0) > 0 / pRECISION_FACTOR[stor26[s].field_0]:
                                            _13064 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _13064 + 68] = mem[idx + _12768 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_13064 + 68] = mem[_13064 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _13064 + -mem[64] + 100
                                        if (0 / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0):
                                            require s < rewardTokens.length
                                            mem[0] = 26
                                            mem[mem[64] + 4] = msg.sender
                                            mem[mem[64] + 36] = (0 / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0)
                                            require ext_code.size(rewardTokens[s].field_0)
                                            call rewardTokens[s].field_0.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (0 / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0)
                                            mem[mem[64]] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                        s = s + 1
                                        t = (0 / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0)
                                        continue 
                                    if accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[s].field_0]:
                                        revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _11538 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11538] = 26
                                    mem[_11538 + 32] = 'SafeMath: division by zero'
                                    if not pRECISION_FACTOR[stor26[s].field_0]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        s = 32
                                        while s < 26:
                                            mem[s + mem[64] + 68] = mem[s + _11538 + 32]
                                            s = s + 32
                                            continue 
                                        revert with 0, 'SafeMath: division by zero'
                                    _12947 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12947] = 30
                                    mem[_12947 + 32] = 'SafeMath: subtraction overflow'
                                    if uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0) > accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[s].field_0]:
                                        _13172 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13172 + 68] = mem[idx + _12947 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13172 + 68] = mem[_13172 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _13172 + -mem[64] + 100
                                    if (accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0):
                                        require s < rewardTokens.length
                                        mem[0] = 26
                                        mem[mem[64] + 4] = msg.sender
                                        mem[mem[64] + 36] = (accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0)
                                        require ext_code.size(rewardTokens[s].field_0)
                                        call rewardTokens[s].field_0.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, (accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0)
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                    s = s + 1
                                    t = (accTokenPerShare[stor26[s].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[s].field_0]) - uint256(lastStakingBlock[msg.sender][2][stor26[s].field_0].field_0)
                                    continue 
                                if not arg1:
                                    idx = 0
                                    while idx < rewardTokens.length:
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = 10
                                        if not uint256(lastStakingBlock[msg.sender].field_0):
                                            _14671 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_14671] = 26
                                            mem[_14671 + 32] = 'SafeMath: division by zero'
                                            if pRECISION_FACTOR[stor26[idx].field_0]:
                                                require idx < rewardTokens.length
                                                mem[0] = rewardTokens[idx].field_0
                                                mem[32] = sha3(msg.sender, 28) + 2
                                                uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            s = 32
                                            while s < 26:
                                                mem[s + mem[64] + 68] = mem[s + _14671 + 32]
                                                s = s + 32
                                                continue 
                                        else:
                                            if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                                revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _14695 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_14695] = 26
                                            mem[_14695 + 32] = 'SafeMath: division by zero'
                                            if pRECISION_FACTOR[stor26[idx].field_0]:
                                                require idx < rewardTokens.length
                                                mem[0] = rewardTokens[idx].field_0
                                                mem[32] = sha3(msg.sender, 28) + 2
                                                uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _14695 + 32]
                                                idx = idx + 32
                                                continue 
                                        revert with 0, 'SafeMath: division by zero'
                                else:
                                    if arg1 + uint256(lastStakingBlock[msg.sender].field_0) < uint256(lastStakingBlock[msg.sender].field_0):
                                        revert with 0, 'SafeMath: addition overflow'
                                    uint256(lastStakingBlock[msg.sender].field_0) += arg1
                                    mem[mem[64] + 4] = msg.sender
                                    mem[mem[64] + 36] = this.address
                                    mem[mem[64] + 68] = arg1
                                    require ext_code.size(stakedTokenAddress)
                                    call stakedTokenAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, this.address, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not msg.sender:
                                        revert with 0, 'ERC20: mint to the zero address'
                                    if arg1 + totalSupply < totalSupply:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalSupply += arg1
                                    if arg1 + balanceOf[address(msg.sender)] < balanceOf[address(msg.sender)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[32] = 4
                                    balanceOf[address(msg.sender)] += arg1
                                    mem[mem[64]] = arg1
                                    emit Transfer(arg1, 0, msg.sender);
                                    idx = 0
                                    while idx < rewardTokens.length:
                                        mem[0] = rewardTokens[idx].field_0
                                        mem[32] = 10
                                        if not uint256(lastStakingBlock[msg.sender].field_0):
                                            _14672 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_14672] = 26
                                            mem[_14672 + 32] = 'SafeMath: division by zero'
                                            if pRECISION_FACTOR[stor26[idx].field_0]:
                                                require idx < rewardTokens.length
                                                mem[0] = rewardTokens[idx].field_0
                                                mem[32] = sha3(msg.sender, 28) + 2
                                                uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = 0 / pRECISION_FACTOR[stor26[idx].field_0]
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            s = 32
                                            while s < 26:
                                                mem[s + mem[64] + 68] = mem[s + _14672 + 32]
                                                s = s + 32
                                                continue 
                                        else:
                                            if accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / uint256(lastStakingBlock[msg.sender].field_0) != accTokenPerShare[stor26[idx].field_0]:
                                                revert with 0, 32, 33, 0x6b536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _14696 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_14696] = 26
                                            mem[_14696 + 32] = 'SafeMath: division by zero'
                                            if pRECISION_FACTOR[stor26[idx].field_0]:
                                                require idx < rewardTokens.length
                                                mem[0] = rewardTokens[idx].field_0
                                                mem[32] = sha3(msg.sender, 28) + 2
                                                uint256(lastStakingBlock[msg.sender][2][stor26[idx].field_0].field_0) = accTokenPerShare[stor26[idx].field_0] * uint256(lastStakingBlock[msg.sender].field_0) / pRECISION_FACTOR[stor26[idx].field_0]
                                                idx = idx + 1
                                                continue 
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _14696 + 32]
                                                idx = idx + 32
                                                continue 
                                        revert with 0, 'SafeMath: division by zero'
    uint256(lastStakingBlock[msg.sender].field_256) = block.number
    totalStaked += arg1
    emit Deposit(arg1, msg.sender);
    stor3 = 1
}



}

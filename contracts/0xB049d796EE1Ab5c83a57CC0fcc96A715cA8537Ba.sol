contract main {




// =====================  Runtime code  =====================


#
#  - transferFrom(address arg1, address arg2, uint256 arg3)
#
const decimals = 18


mapping of uint256 balanceOf;
mapping of struct allowance;
uint256 totalSupply;
array of struct stor3;
array of struct stor4;
address owner;
address uniswapV2RouterAddress;
uint8 stor7; offset 160
address uniswapV2PairAddress;
address dividendTrackerAddress;
address deadWalletAddress;
address sub_4d7effddAddress;
uint256 swapTokensAtAmount;
mapping of uint8 stor12;
uint256 stor13;
uint256 stor14;
uint256 stor15;
uint256 totalFees;
address stor17;
uint256 gasForProcessing;
mapping of uint8 stor19;
mapping of uint8 stor20;

function totalFees() {
    return totalFees
}

function uniswapV2Router() {
    return uniswapV2RouterAddress
}

function totalSupply() {
    return totalSupply
}

function _isBlacklisted(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return bool(stor12[arg1])
}

function dividendTracker() {
    return dividendTrackerAddress
}

function uniswapV2Pair() {
    return uniswapV2PairAddress
}

function sub_4d7effdd(?) {
    return sub_4d7effddAddress
}

function isExcludedFromFees(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return bool(stor19[address(arg1)])
}

function balanceOf(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return balanceOf[address(arg1)]
}

function deadWallet() {
    return deadWalletAddress
}

function owner() {
    return owner
}

function gasForProcessing() {
    return gasForProcessing
}

function automatedMarketMakerPairs(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return bool(stor20[arg1])
}

function allowance(address arg1, address arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    return allowance[address(arg1)][address(arg2)].field_0
}

function swapTokensAtAmount() {
    return swapTokensAtAmount
}

function renounceOwnership() {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    emit OwnershipTransferred(owner, 0);
    owner = 0
}

function setRouter(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    stor17 = arg1
}

function blacklistAddress(address arg1, bool arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    stor12[address(arg1)] = uint8(arg2)
}

function getClaimWait() {
    staticcall dividendTrackerAddress.claimWait() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    return ext_call.return_data[0]
}

function getLastProcessedIndex() {
    staticcall dividendTrackerAddress.0xe7841ec0 with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    return ext_call.return_data[0]
}

function getTotalDividendsDistributed() {
    staticcall dividendTrackerAddress.totalDividendsDistributed() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    return ext_call.return_data[0]
}

function getNumberOfDividendTokenHolders() {
    staticcall dividendTrackerAddress.getNumberOfTokenHolders() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    return ext_call.return_data[0]
}

function claim() {
    call dividendTrackerAddress.processAccount(address arg1, bool arg2) with:
         gas gas_remaining wei
        args msg.sender, 0
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == bool(ext_call.return_data[0])
}

function dividendTokenBalanceOf(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    staticcall dividendTrackerAddress.0x70a08231 with:
            gas gas_remaining wei
           args arg1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    return ext_call.return_data[0]
}

function withdrawableDividendOf(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    staticcall dividendTrackerAddress.0xa8b9d240 with:
            gas gas_remaining wei
           args arg1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    return ext_call.return_data[0]
}

function transferOwnership(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Ownable: new owner is the zero address'
    emit OwnershipTransferred(owner, arg1);
    owner = arg1
}

function updateClaimWait(uint256 arg1) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    require ext_code.size(dividendTrackerAddress)
    call dividendTrackerAddress.0xe98030c7 with:
         gas gas_remaining wei
        args arg1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}

function excludeFromDividends(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    require ext_code.size(dividendTrackerAddress)
    call dividendTrackerAddress.0x31e79db0 with:
         gas gas_remaining wei
        args arg1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}

function processDividendTracker(uint256 arg1) {
    require calldata.size - 4 >= 32
    call dividendTrackerAddress.process(uint256 arg1) with:
         gas gas_remaining wei
        args arg1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 96
    emit ProcessedDividendTracker(ext_call.return_data[0], ext_call.return_data[32], ext_call.return_data[64], arg1, 0, tx.origin);
}

function setburnFee(uint256 arg1) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    stor15 = arg1
    if stor13 > !stor14:
        revert with 0, 17
    if stor13 + stor14 < stor13:
        revert with 0, 'SafeMath: addition overflow'
    if stor13 + stor14 > !arg1:
        revert with 0, 17
    if arg1 < 0:
        revert with 0, 'SafeMath: addition overflow'
    totalFees = stor13 + stor14 + arg1
}

function setLiquiditFee(uint256 arg1) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    stor14 = arg1
    if stor13 > !arg1:
        revert with 0, 17
    if stor13 + arg1 < stor13:
        revert with 0, 'SafeMath: addition overflow'
    if stor13 + arg1 > !stor15:
        revert with 0, 17
    if stor15 < 0:
        revert with 0, 'SafeMath: addition overflow'
    totalFees = stor13 + arg1 + stor15
}

function setDogeRewardsFee(uint256 arg1) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    stor13 = arg1
    if arg1 > !stor14:
        revert with 0, 17
    if arg1 + stor14 < arg1:
        revert with 0, 'SafeMath: addition overflow'
    if arg1 + stor14 > !stor15:
        revert with 0, 17
    if stor15 < 0:
        revert with 0, 'SafeMath: addition overflow'
    totalFees = arg1 + stor14 + stor15
}

function excludeFromFees(address arg1, bool arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if arg2 == bool(stor19[address(arg1)]):
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    'GreatDaneInu: Account is already the value of 'excluded''
    stor19[address(arg1)] = uint8(arg2)
    emit ExcludeFromFees(arg2, arg1);
}

function approve(address arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if not msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve from the zero address'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve to the zero address'
    allowance[address(msg.sender)][address(arg1)].field_0 = arg2
    emit Approval(arg2, msg.sender, arg1);
    return 1
}

function getAccountDividendsInfoAtIndex(uint256 arg1) {
    require calldata.size - 4 >= 32
    staticcall dividendTrackerAddress.getAccountAtIndex(uint256 arg1) with:
            gas gas_remaining wei
           args arg1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 256
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    return ext_call.return_data[12 len 20], 
           ext_call.return_data[32],
           ext_call.return_data[64],
           ext_call.return_data[96],
           ext_call.return_data[128],
           ext_call.return_data[160],
           ext_call.return_data[192],
           ext_call.return_data[224]
}

function getAccountDividendsInfo(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    staticcall dividendTrackerAddress.getAccount(address arg1) with:
            gas gas_remaining wei
           args arg1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 256
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    return ext_call.return_data[12 len 20], 
           ext_call.return_data[32],
           ext_call.return_data[64],
           ext_call.return_data[96],
           ext_call.return_data[128],
           ext_call.return_data[160],
           ext_call.return_data[192],
           ext_call.return_data[224]
}

function decreaseAllowance(address arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if arg2 > allowance[msg.sender][address(arg1)].field_0:
        revert with 0, 32, 37, 0x6545524332303a2064656372656173656420616c6c6f77616e63652062656c6f77207a6572, mem[165 len 27] >> 40, 0
    if allowance[msg.sender][address(arg1)].field_0 < arg2:
        revert with 0, 17
    if not msg.sender:
        revert with 0, 'ERC20: approve from the zero address'
    if not arg1:
        revert with 0, 'ERC20: approve to the zero address'
    allowance[address(msg.sender)][address(arg1)].field_0 = allowance[msg.sender][address(arg1)].field_0 - arg2
    emit Approval((allowance[msg.sender][address(arg1)].field_0 - arg2), msg.sender, arg1);
    return 1
}

function updateGasForProcessing(uint256 arg1) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if arg1 < 200000:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    'GreatDaneInu: gasForProcessing must be between 200,000 and 500,000'
    if arg1 > 500000:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    'GreatDaneInu: gasForProcessing must be between 200,000 and 500,000'
    if arg1 == gasForProcessing:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    'GreatDaneInu: Cannot update gasForProcessing to same value'
    emit GasForProcessingUpdated(arg1, gasForProcessing);
    gasForProcessing = arg1
}

function increaseAllowance(address arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if allowance[msg.sender][address(arg1)].field_0 > !arg2:
        revert with 0, 17
    if allowance[msg.sender][address(arg1)].field_0 + arg2 < allowance[msg.sender][address(arg1)].field_0:
        revert with 0, 'SafeMath: addition overflow'
    if not msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve from the zero address'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve to the zero address'
    allowance[address(msg.sender)][address(arg1)].field_0 = allowance[msg.sender][address(arg1)].field_0 + arg2
    emit Approval((allowance[msg.sender][address(arg1)].field_0 + arg2), msg.sender, arg1);
    return 1
}

function setAutomatedMarketMakerPair(address arg1, bool arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if uniswapV2PairAddress == arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    'GreatDaneInu: The PancakeSwap pair cannot be removed from automatedMarketMakerPairs'
    if arg2 == bool(stor20[address(arg1)]):
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    'GreatDaneInu: Automated market maker pair is already set to that value'
    stor20[address(arg1)] = uint8(arg2)
    if arg2:
        require ext_code.size(dividendTrackerAddress)
        call dividendTrackerAddress.0x31e79db0 with:
             gas gas_remaining wei
            args arg1
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
    emit SetAutomatedMarketMakerPair(arg1, arg2);
}

function excludeMultipleAccountsFromFees(address[] arg1, bool arg2) {
    require calldata.size - 4 >= 64
    require arg1 <= test266151307()
    require arg1 + 35 < calldata.size
    require arg1.length <= test266151307()
    require arg1 + (32 * arg1.length) + 36 <= calldata.size
    require arg2 == arg2
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    idx = 0
    while idx < arg1.length:
        require cd[((32 * idx) + arg1 + 36)] == address(cd[((32 * idx) + arg1 + 36)])
        mem[0] = address(cd[((32 * idx) + arg1 + 36)])
        mem[32] = 19
        stor19[address(cd[((32 * idx) + arg1 + 36)])] = uint8(arg2)
        if idx == -1:
            revert with 0, 17
        idx = idx + 1
        continue 
    idx = 0
    s = 192
    t = arg1 + 36
    while idx < arg1.length:
        require cd[t] == address(cd[t])
        mem[s] = address(cd[t])
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    emit ExcludeMultipleAccountsFromFees(Array(len=arg1.length, data=mem[192 len 32 * arg1.length]), arg2);
}

function updateUniswapV2Router(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if uniswapV2RouterAddress == arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'GreatDaneInu: The router already has that address'
    emit UpdateUniswapV2Router(arg1, uniswapV2RouterAddress);
    uniswapV2RouterAddress = arg1
    staticcall arg1.factory() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    staticcall uniswapV2RouterAddress.WETH() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    call address(ext_call.return_data[0]).createPair(address arg1, address arg2) with:
         gas gas_remaining wei
        args address(this.address), address(ext_call.return_data[0])
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    uniswapV2PairAddress = ext_call.return_data[12 len 20]
}

function updateDividendTracker(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if dividendTrackerAddress == arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    'GreatDaneInu: The dividend tracker already has that address'
    staticcall arg1.0x8da5cb5b with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    if ext_call.return_data[12 len 20] != this.address:
        revert with 0, 'GreatDaneInu: The new dividend tracker must be owned by the GreatDaneInu token contract'
    require ext_code.size(arg1)
    call arg1.0x31e79db0 with:
         gas gas_remaining wei
        args arg1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require ext_code.size(arg1)
    call arg1.0x31e79db0 with:
         gas gas_remaining wei
        args this.address
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require ext_code.size(arg1)
    call arg1.0x31e79db0 with:
         gas gas_remaining wei
        args owner
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require ext_code.size(arg1)
    call arg1.0x31e79db0 with:
         gas gas_remaining wei
        args uniswapV2RouterAddress
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    emit UpdateDividendTracker(arg1, dividendTrackerAddress);
    dividendTrackerAddress = arg1
}

function name() {
    if bool(stor3.length):
        if bool(stor3.length) == uint255(stor3.length) * 0.5 < 32:
            revert with 0, 34
        if bool(stor3.length):
            if bool(stor3.length) == uint255(stor3.length) * 0.5 < 32:
                revert with 0, 34
            if Mask(256, -1, stor3.length):
                if 31 < uint255(stor3.length) * 0.5:
                    mem[128] = uint256(stor3.field_0)
                    idx = 128
                    s = 0
                    while (uint255(stor3.length) * 0.5) + 96 > idx:
                        mem[idx + 32] = stor3[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor3.length), data=mem[128 len ceil32(uint255(stor3.length) * 0.5)])
                mem[128] = 256 * stor3.length.field_8
        else:
            if bool(stor3.length) == stor3.length.field_1 < 32:
                revert with 0, 34
            if stor3.length.field_1:
                if 31 < stor3.length.field_1:
                    mem[128] = uint256(stor3.field_0)
                    idx = 128
                    s = 0
                    while stor3.length.field_1 + 96 > idx:
                        mem[idx + 32] = stor3[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor3.length), data=mem[128 len ceil32(uint255(stor3.length) * 0.5)])
                mem[128] = 256 * stor3.length.field_8
        mem[ceil32(uint255(stor3.length) * 0.5) + 192 len ceil32(uint255(stor3.length) * 0.5)] = mem[128 len ceil32(uint255(stor3.length) * 0.5)]
        if ceil32(uint255(stor3.length) * 0.5) > uint255(stor3.length) * 0.5:
            mem[ceil32(uint255(stor3.length) * 0.5) + (uint255(stor3.length) * 0.5) + 192] = 0
        return Array(len=2 * Mask(256, -1, stor3.length), data=mem[128 len ceil32(uint255(stor3.length) * 0.5)], mem[(2 * ceil32(uint255(stor3.length) * 0.5)) + 192 len 2 * ceil32(uint255(stor3.length) * 0.5)]), 
    if bool(stor3.length) == stor3.length.field_1 < 32:
        revert with 0, 34
    if bool(stor3.length):
        if bool(stor3.length) == uint255(stor3.length) * 0.5 < 32:
            revert with 0, 34
        if Mask(256, -1, stor3.length):
            if 31 < uint255(stor3.length) * 0.5:
                mem[128] = uint256(stor3.field_0)
                idx = 128
                s = 0
                while (uint255(stor3.length) * 0.5) + 96 > idx:
                    mem[idx + 32] = stor3[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor3.length % 128, data=mem[128 len ceil32(stor3.length.field_1)])
            mem[128] = 256 * stor3.length.field_8
    else:
        if bool(stor3.length) == stor3.length.field_1 < 32:
            revert with 0, 34
        if stor3.length.field_1:
            if 31 < stor3.length.field_1:
                mem[128] = uint256(stor3.field_0)
                idx = 128
                s = 0
                while stor3.length.field_1 + 96 > idx:
                    mem[idx + 32] = stor3[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor3.length % 128, data=mem[128 len ceil32(stor3.length.field_1)])
            mem[128] = 256 * stor3.length.field_8
    mem[ceil32(stor3.length.field_1) + 192 len ceil32(stor3.length.field_1)] = mem[128 len ceil32(stor3.length.field_1)]
    if ceil32(stor3.length.field_1) > stor3.length.field_1:
        mem[ceil32(stor3.length.field_1) + stor3.length.field_1 + 192] = 0
    return Array(len=stor3.length % 128, data=mem[128 len ceil32(stor3.length.field_1)], mem[(2 * ceil32(stor3.length.field_1)) + 192 len 2 * ceil32(stor3.length.field_1)]), 
}

function symbol() {
    if bool(stor4.length):
        if bool(stor4.length) == uint255(stor4.length) * 0.5 < 32:
            revert with 0, 34
        if bool(stor4.length):
            if bool(stor4.length) == uint255(stor4.length) * 0.5 < 32:
                revert with 0, 34
            if Mask(256, -1, stor4.length):
                if 31 < uint255(stor4.length) * 0.5:
                    mem[128] = uint256(stor4.field_0)
                    idx = 128
                    s = 0
                    while (uint255(stor4.length) * 0.5) + 96 > idx:
                        mem[idx + 32] = stor4[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor4.length), data=mem[128 len ceil32(uint255(stor4.length) * 0.5)])
                mem[128] = 256 * stor4.length.field_8
        else:
            if bool(stor4.length) == stor4.length.field_1 < 32:
                revert with 0, 34
            if stor4.length.field_1:
                if 31 < stor4.length.field_1:
                    mem[128] = uint256(stor4.field_0)
                    idx = 128
                    s = 0
                    while stor4.length.field_1 + 96 > idx:
                        mem[idx + 32] = stor4[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor4.length), data=mem[128 len ceil32(uint255(stor4.length) * 0.5)])
                mem[128] = 256 * stor4.length.field_8
        mem[ceil32(uint255(stor4.length) * 0.5) + 192 len ceil32(uint255(stor4.length) * 0.5)] = mem[128 len ceil32(uint255(stor4.length) * 0.5)]
        if ceil32(uint255(stor4.length) * 0.5) > uint255(stor4.length) * 0.5:
            mem[ceil32(uint255(stor4.length) * 0.5) + (uint255(stor4.length) * 0.5) + 192] = 0
        return Array(len=2 * Mask(256, -1, stor4.length), data=mem[128 len ceil32(uint255(stor4.length) * 0.5)], mem[(2 * ceil32(uint255(stor4.length) * 0.5)) + 192 len 2 * ceil32(uint255(stor4.length) * 0.5)]), 
    if bool(stor4.length) == stor4.length.field_1 < 32:
        revert with 0, 34
    if bool(stor4.length):
        if bool(stor4.length) == uint255(stor4.length) * 0.5 < 32:
            revert with 0, 34
        if Mask(256, -1, stor4.length):
            if 31 < uint255(stor4.length) * 0.5:
                mem[128] = uint256(stor4.field_0)
                idx = 128
                s = 0
                while (uint255(stor4.length) * 0.5) + 96 > idx:
                    mem[idx + 32] = stor4[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor4.length % 128, data=mem[128 len ceil32(stor4.length.field_1)])
            mem[128] = 256 * stor4.length.field_8
    else:
        if bool(stor4.length) == stor4.length.field_1 < 32:
            revert with 0, 34
        if stor4.length.field_1:
            if 31 < stor4.length.field_1:
                mem[128] = uint256(stor4.field_0)
                idx = 128
                s = 0
                while stor4.length.field_1 + 96 > idx:
                    mem[idx + 32] = stor4[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor4.length % 128, data=mem[128 len ceil32(stor4.length.field_1)])
            mem[128] = 256 * stor4.length.field_8
    mem[ceil32(stor4.length.field_1) + 192 len ceil32(stor4.length.field_1)] = mem[128 len ceil32(stor4.length.field_1)]
    if ceil32(stor4.length.field_1) > stor4.length.field_1:
        mem[ceil32(stor4.length.field_1) + stor4.length.field_1 + 192] = 0
    return Array(len=stor4.length % 128, data=mem[128 len ceil32(stor4.length.field_1)], mem[(2 * ceil32(stor4.length.field_1)) + 192 len 2 * ceil32(stor4.length.field_1)]), 
}

function transfer(address arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if not msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer from the zero address'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer to the zero address'
    if stor12[address(msg.sender)]:
        revert with 0, 'Blacklisted address'
    if stor12[address(arg1)]:
        revert with 0, 'Blacklisted address'
    if not arg2:
        if not msg.sender:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer from the zero address'
        if not arg1:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer to the zero address'
        if 0 > balanceOf[address(msg.sender)]:
            revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
        if balanceOf[address(msg.sender)] < 0:
            revert with 0, 17
        if balanceOf[arg1] > -1:
            revert with 0, 17
        if balanceOf[arg1] < balanceOf[arg1]:
            revert with 0, 'SafeMath: addition overflow'
        balanceOf[address(arg1)] = balanceOf[arg1]
        emit Transfer(0, msg.sender, arg1);
    else:
        if balanceOf[this.address] < swapTokensAtAmount:
            if stor19[address(msg.sender)]:
                if not msg.sender:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer from the zero address'
                if not arg1:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer to the zero address'
                if arg2 > balanceOf[address(msg.sender)]:
                    revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                if balanceOf[address(msg.sender)] < arg2:
                    revert with 0, 17
                balanceOf[address(msg.sender)] -= arg2
                if balanceOf[arg1] > !arg2:
                    revert with 0, 17
                if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                    revert with 0, 'SafeMath: addition overflow'
                balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                emit Transfer(arg2, msg.sender, arg1);
            else:
                if stor19[address(arg1)]:
                    if not msg.sender:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer from the zero address'
                    if not arg1:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer to the zero address'
                    if arg2 > balanceOf[address(msg.sender)]:
                        revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                    if balanceOf[address(msg.sender)] < arg2:
                        revert with 0, 17
                    balanceOf[address(msg.sender)] -= arg2
                    if balanceOf[arg1] > !arg2:
                        revert with 0, 17
                    if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                        revert with 0, 'SafeMath: addition overflow'
                    balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                    emit Transfer(arg2, msg.sender, arg1);
                else:
                    if stor7:
                        if not msg.sender:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer from the zero address'
                        if not arg1:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer to the zero address'
                        if arg2 > balanceOf[address(msg.sender)]:
                            revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                        if balanceOf[address(msg.sender)] < arg2:
                            revert with 0, 17
                        balanceOf[address(msg.sender)] -= arg2
                        if balanceOf[arg1] > !arg2:
                            revert with 0, 17
                        if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                            revert with 0, 'SafeMath: addition overflow'
                        balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                        emit Transfer(arg2, msg.sender, arg1);
                    else:
                        if not arg2:
                            if not stor20[address(arg1)]:
                                if 0 > arg2:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg2 < 0:
                                    revert with 0, 17
                                if not msg.sender:
                                    revert with 0, 'ERC20: transfer from the zero address'
                                if not this.address:
                                    revert with 0, 'ERC20: transfer to the zero address'
                                if 0 > balanceOf[address(msg.sender)]:
                                    revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[294 len 26] >> 48, 0
                                if balanceOf[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if balanceOf[this.address] > -1:
                                    revert with 0, 17
                                if balanceOf[this.address] < balanceOf[this.address]:
                                    revert with 0, 'SafeMath: addition overflow'
                                balanceOf[address(this.address)] = balanceOf[this.address]
                                emit Transfer(0, msg.sender, this.address);
                                if not msg.sender:
                                    revert with 0, 'ERC20: transfer from the zero address'
                                if not arg1:
                                    revert with 0, 'ERC20: transfer to the zero address'
                                if arg2 > balanceOf[address(msg.sender)]:
                                    revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[390 len 26] >> 48, 0
                                if balanceOf[address(msg.sender)] < arg2:
                                    revert with 0, 17
                                balanceOf[address(msg.sender)] -= arg2
                                if balanceOf[arg1] > !arg2:
                                    revert with 0, 17
                                if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                emit Transfer(arg2, msg.sender, arg1);
                            else:
                                if not arg2:
                                    if 0 > arg2:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 < 0:
                                        revert with 0, 17
                                    if not msg.sender:
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if not this.address:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    if 0 > balanceOf[address(msg.sender)]:
                                        revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[358 len 26] >> 48, 0
                                    if balanceOf[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if balanceOf[this.address] > -1:
                                        revert with 0, 17
                                    if balanceOf[this.address] < balanceOf[this.address]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(this.address)] = balanceOf[this.address]
                                    emit Transfer(0, msg.sender, this.address);
                                    if not msg.sender:
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if not arg1:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    if arg2 > balanceOf[address(msg.sender)]:
                                        revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[454 len 26] >> 48, 0
                                    if balanceOf[address(msg.sender)] < arg2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)] -= arg2
                                    if balanceOf[arg1] > !arg2:
                                        revert with 0, 17
                                    if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                    emit Transfer(arg2, msg.sender, arg1);
                                else:
                                    if arg2 and 1 > -1 / arg2:
                                        revert with 0, 17
                                    if not arg2:
                                        revert with 0, 18
                                    if arg2 / arg2 != 1:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 0 > !(arg2 / 100):
                                        revert with 0, 17
                                    if arg2 / 100 > arg2:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 < arg2 / 100:
                                        revert with 0, 17
                                    if not msg.sender:
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if not this.address:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    if arg2 / 100 > balanceOf[address(msg.sender)]:
                                        revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[358 len 26] >> 48, 0
                                    if balanceOf[address(msg.sender)] < arg2 / 100:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)] -= arg2 / 100
                                    if balanceOf[this.address] > !(arg2 / 100):
                                        revert with 0, 17
                                    if balanceOf[this.address] + (arg2 / 100) < balanceOf[this.address]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 100)
                                    emit Transfer((arg2 / 100), msg.sender, this.address);
                                    if not msg.sender:
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if not arg1:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    if arg2 - (arg2 / 100) > balanceOf[address(msg.sender)]:
                                        revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[454 len 26] >> 48, 0
                                    if balanceOf[address(msg.sender)] < arg2 - (arg2 / 100):
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - arg2 + (arg2 / 100)
                                    if balanceOf[arg1] > !(arg2 - (arg2 / 100)):
                                        revert with 0, 17
                                    if balanceOf[arg1] + arg2 - (arg2 / 100) < balanceOf[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(arg1)] = balanceOf[arg1] + arg2 - (arg2 / 100)
                                    emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                        else:
                            if arg2 and totalFees > -1 / arg2:
                                revert with 0, 17
                            if not arg2:
                                revert with 0, 18
                            if arg2 * totalFees / arg2 != totalFees:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
                            if not stor20[address(arg1)]:
                                if arg2 * totalFees / 100 > arg2:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg2 < arg2 * totalFees / 100:
                                    revert with 0, 17
                                if not msg.sender:
                                    revert with 0, 'ERC20: transfer from the zero address'
                                if not this.address:
                                    revert with 0, 'ERC20: transfer to the zero address'
                                if arg2 * totalFees / 100 > balanceOf[address(msg.sender)]:
                                    revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[294 len 26] >> 48, 0
                                if balanceOf[address(msg.sender)] < arg2 * totalFees / 100:
                                    revert with 0, 17
                                balanceOf[address(msg.sender)] -= arg2 * totalFees / 100
                                if balanceOf[this.address] > !(arg2 * totalFees / 100):
                                    revert with 0, 17
                                if balanceOf[this.address] + (arg2 * totalFees / 100) < balanceOf[this.address]:
                                    revert with 0, 'SafeMath: addition overflow'
                                balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 * totalFees / 100)
                                emit Transfer((arg2 * totalFees / 100), msg.sender, this.address);
                                if not msg.sender:
                                    revert with 0, 'ERC20: transfer from the zero address'
                                if not arg1:
                                    revert with 0, 'ERC20: transfer to the zero address'
                                if arg2 - (arg2 * totalFees / 100) > balanceOf[address(msg.sender)]:
                                    revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[390 len 26] >> 48, 0
                                if balanceOf[address(msg.sender)] < arg2 - (arg2 * totalFees / 100):
                                    revert with 0, 17
                                balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - arg2 + (arg2 * totalFees / 100)
                                if balanceOf[arg1] > !(arg2 - (arg2 * totalFees / 100)):
                                    revert with 0, 17
                                if balanceOf[arg1] + arg2 - (arg2 * totalFees / 100) < balanceOf[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                balanceOf[address(arg1)] = balanceOf[arg1] + arg2 - (arg2 * totalFees / 100)
                                emit Transfer((arg2 - (arg2 * totalFees / 100)), msg.sender, arg1);
                            else:
                                if not arg2:
                                    if arg2 * totalFees / 100 > -1:
                                        revert with 0, 17
                                    if arg2 * totalFees / 100 > arg2:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 < arg2 * totalFees / 100:
                                        revert with 0, 17
                                    if not msg.sender:
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if not this.address:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    if arg2 * totalFees / 100 > balanceOf[address(msg.sender)]:
                                        revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[358 len 26] >> 48, 0
                                    if balanceOf[address(msg.sender)] < arg2 * totalFees / 100:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)] -= arg2 * totalFees / 100
                                    if balanceOf[this.address] > !(arg2 * totalFees / 100):
                                        revert with 0, 17
                                    if balanceOf[this.address] + (arg2 * totalFees / 100) < balanceOf[this.address]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 * totalFees / 100)
                                    emit Transfer((arg2 * totalFees / 100), msg.sender, this.address);
                                    if not msg.sender:
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if not arg1:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    if arg2 - (arg2 * totalFees / 100) > balanceOf[address(msg.sender)]:
                                        revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[454 len 26] >> 48, 0
                                    if balanceOf[address(msg.sender)] < arg2 - (arg2 * totalFees / 100):
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - arg2 + (arg2 * totalFees / 100)
                                    if balanceOf[arg1] > !(arg2 - (arg2 * totalFees / 100)):
                                        revert with 0, 17
                                    if balanceOf[arg1] + arg2 - (arg2 * totalFees / 100) < balanceOf[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(arg1)] = balanceOf[arg1] + arg2 - (arg2 * totalFees / 100)
                                    emit Transfer((arg2 - (arg2 * totalFees / 100)), msg.sender, arg1);
                                else:
                                    if arg2 and 1 > -1 / arg2:
                                        revert with 0, 17
                                    if not arg2:
                                        revert with 0, 18
                                    if arg2 / arg2 != 1:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if arg2 * totalFees / 100 > !(arg2 / 100):
                                        revert with 0, 17
                                    if (arg2 * totalFees / 100) + (arg2 / 100) > arg2:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 < (arg2 * totalFees / 100) + (arg2 / 100):
                                        revert with 0, 17
                                    if not msg.sender:
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if not this.address:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    if (arg2 * totalFees / 100) + (arg2 / 100) > balanceOf[address(msg.sender)]:
                                        revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[358 len 26] >> 48, 0
                                    if balanceOf[address(msg.sender)] < (arg2 * totalFees / 100) + (arg2 / 100):
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - (arg2 * totalFees / 100) - (arg2 / 100)
                                    if balanceOf[this.address] > !((arg2 * totalFees / 100) + (arg2 / 100)):
                                        revert with 0, 17
                                    if balanceOf[this.address] + (arg2 * totalFees / 100) + (arg2 / 100) < balanceOf[this.address]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 * totalFees / 100) + (arg2 / 100)
                                    emit Transfer(((arg2 * totalFees / 100) + (arg2 / 100)), msg.sender, this.address);
                                    if not msg.sender:
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if not arg1:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    if arg2 - (arg2 * totalFees / 100) - (arg2 / 100) > balanceOf[address(msg.sender)]:
                                        revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[454 len 26] >> 48, 0
                                    if balanceOf[address(msg.sender)] < arg2 - (arg2 * totalFees / 100) - (arg2 / 100):
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - arg2 + (arg2 * totalFees / 100) + (arg2 / 100)
                                    if balanceOf[arg1] > !(arg2 - (arg2 * totalFees / 100) - (arg2 / 100)):
                                        revert with 0, 17
                                    if balanceOf[arg1] + arg2 - (arg2 * totalFees / 100) - (arg2 / 100) < balanceOf[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(arg1)] = balanceOf[arg1] + arg2 - (arg2 * totalFees / 100) - (arg2 / 100)
                                    emit Transfer((arg2 - (arg2 * totalFees / 100) - (arg2 / 100)), msg.sender, arg1);
            require ext_code.size(dividendTrackerAddress)
            call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args msg.sender, balanceOf[address(msg.sender)]
            require ext_code.size(dividendTrackerAddress)
            call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                 gas gas_remaining wei
                args address(arg1), balanceOf[address(arg1)]
            if not stor7:
                call dividendTrackerAddress.process(uint256 arg1) with:
                     gas gas_remaining wei
                    args gasForProcessing
                if ext_call.success:
                    require return_data.size >= 96
                    emit ProcessedDividendTracker(ext_call.return_data[0], ext_call.return_data[32], ext_call.return_data[64], gasForProcessing, 1, tx.origin);
        else:
            if stor7:
                if stor19[address(msg.sender)]:
                    if not msg.sender:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer from the zero address'
                    if not arg1:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer to the zero address'
                    if arg2 > balanceOf[address(msg.sender)]:
                        revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                    if balanceOf[address(msg.sender)] < arg2:
                        revert with 0, 17
                    balanceOf[address(msg.sender)] -= arg2
                    if balanceOf[arg1] > !arg2:
                        revert with 0, 17
                    if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                        revert with 0, 'SafeMath: addition overflow'
                    balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                    emit Transfer(arg2, msg.sender, arg1);
                else:
                    if stor19[address(arg1)]:
                        if not msg.sender:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer from the zero address'
                        if not arg1:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer to the zero address'
                        if arg2 > balanceOf[address(msg.sender)]:
                            revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                        if balanceOf[address(msg.sender)] < arg2:
                            revert with 0, 17
                        balanceOf[address(msg.sender)] -= arg2
                        if balanceOf[arg1] > !arg2:
                            revert with 0, 17
                        if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                            revert with 0, 'SafeMath: addition overflow'
                        balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                        emit Transfer(arg2, msg.sender, arg1);
                    else:
                        if stor7:
                            if not msg.sender:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer from the zero address'
                            if not arg1:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer to the zero address'
                            if arg2 > balanceOf[address(msg.sender)]:
                                revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                            if balanceOf[address(msg.sender)] < arg2:
                                revert with 0, 17
                            balanceOf[address(msg.sender)] -= arg2
                            if balanceOf[arg1] > !arg2:
                                revert with 0, 17
                            if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                            emit Transfer(arg2, msg.sender, arg1);
                        else:
                            if not arg2:
                                if not stor20[address(arg1)]:
                                    if 0 > arg2:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 < 0:
                                        revert with 0, 17
                                    if not msg.sender:
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if not this.address:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    if 0 > balanceOf[address(msg.sender)]:
                                        revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[294 len 26] >> 48, 0
                                    if balanceOf[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if balanceOf[this.address] > -1:
                                        revert with 0, 17
                                    if balanceOf[this.address] < balanceOf[this.address]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(this.address)] = balanceOf[this.address]
                                    emit Transfer(0, msg.sender, this.address);
                                    if not msg.sender:
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if not arg1:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    if arg2 > balanceOf[address(msg.sender)]:
                                        revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[390 len 26] >> 48, 0
                                    if balanceOf[address(msg.sender)] < arg2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)] -= arg2
                                    if balanceOf[arg1] > !arg2:
                                        revert with 0, 17
                                    if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                    emit Transfer(arg2, msg.sender, arg1);
                                else:
                                    if not arg2:
                                        if 0 > arg2:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg2 < 0:
                                            revert with 0, 17
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not this.address:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        if 0 > balanceOf[address(msg.sender)]:
                                            revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[358 len 26] >> 48, 0
                                        if balanceOf[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if balanceOf[this.address] > -1:
                                            revert with 0, 17
                                        if balanceOf[this.address] < balanceOf[this.address]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(this.address)] = balanceOf[this.address]
                                        emit Transfer(0, msg.sender, this.address);
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not arg1:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        if arg2 > balanceOf[address(msg.sender)]:
                                            revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[454 len 26] >> 48, 0
                                        if balanceOf[address(msg.sender)] < arg2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2
                                        if balanceOf[arg1] > !arg2:
                                            revert with 0, 17
                                        if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                        emit Transfer(arg2, msg.sender, arg1);
                                    else:
                                        if arg2 and 1 > -1 / arg2:
                                            revert with 0, 17
                                        if not arg2:
                                            revert with 0, 18
                                        if arg2 / arg2 != 1:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if 0 > !(arg2 / 100):
                                            revert with 0, 17
                                        if arg2 / 100 > arg2:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg2 < arg2 / 100:
                                            revert with 0, 17
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not this.address:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        if arg2 / 100 > balanceOf[address(msg.sender)]:
                                            revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[358 len 26] >> 48, 0
                                        if balanceOf[address(msg.sender)] < arg2 / 100:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2 / 100
                                        if balanceOf[this.address] > !(arg2 / 100):
                                            revert with 0, 17
                                        if balanceOf[this.address] + (arg2 / 100) < balanceOf[this.address]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 100)
                                        emit Transfer((arg2 / 100), msg.sender, this.address);
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not arg1:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        if arg2 - (arg2 / 100) > balanceOf[address(msg.sender)]:
                                            revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[454 len 26] >> 48, 0
                                        if balanceOf[address(msg.sender)] < arg2 - (arg2 / 100):
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - arg2 + (arg2 / 100)
                                        if balanceOf[arg1] > !(arg2 - (arg2 / 100)):
                                            revert with 0, 17
                                        if balanceOf[arg1] + arg2 - (arg2 / 100) < balanceOf[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(arg1)] = balanceOf[arg1] + arg2 - (arg2 / 100)
                                        emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                            else:
                                if arg2 and totalFees > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * totalFees / arg2 != totalFees:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
                                if not stor20[address(arg1)]:
                                    if arg2 * totalFees / 100 > arg2:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 < arg2 * totalFees / 100:
                                        revert with 0, 17
                                    if not msg.sender:
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if not this.address:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    if arg2 * totalFees / 100 > balanceOf[address(msg.sender)]:
                                        revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[294 len 26] >> 48, 0
                                    if balanceOf[address(msg.sender)] < arg2 * totalFees / 100:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)] -= arg2 * totalFees / 100
                                    if balanceOf[this.address] > !(arg2 * totalFees / 100):
                                        revert with 0, 17
                                    if balanceOf[this.address] + (arg2 * totalFees / 100) < balanceOf[this.address]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 * totalFees / 100)
                                    emit Transfer((arg2 * totalFees / 100), msg.sender, this.address);
                                    if not msg.sender:
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if not arg1:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    if arg2 - (arg2 * totalFees / 100) > balanceOf[address(msg.sender)]:
                                        revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[390 len 26] >> 48, 0
                                    if balanceOf[address(msg.sender)] < arg2 - (arg2 * totalFees / 100):
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - arg2 + (arg2 * totalFees / 100)
                                    if balanceOf[arg1] > !(arg2 - (arg2 * totalFees / 100)):
                                        revert with 0, 17
                                    if balanceOf[arg1] + arg2 - (arg2 * totalFees / 100) < balanceOf[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(arg1)] = balanceOf[arg1] + arg2 - (arg2 * totalFees / 100)
                                    emit Transfer((arg2 - (arg2 * totalFees / 100)), msg.sender, arg1);
                                else:
                                    if not arg2:
                                        if arg2 * totalFees / 100 > -1:
                                            revert with 0, 17
                                        if arg2 * totalFees / 100 > arg2:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg2 < arg2 * totalFees / 100:
                                            revert with 0, 17
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not this.address:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        if arg2 * totalFees / 100 > balanceOf[address(msg.sender)]:
                                            revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[358 len 26] >> 48, 0
                                        if balanceOf[address(msg.sender)] < arg2 * totalFees / 100:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2 * totalFees / 100
                                        if balanceOf[this.address] > !(arg2 * totalFees / 100):
                                            revert with 0, 17
                                        if balanceOf[this.address] + (arg2 * totalFees / 100) < balanceOf[this.address]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 * totalFees / 100)
                                        emit Transfer((arg2 * totalFees / 100), msg.sender, this.address);
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not arg1:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        if arg2 - (arg2 * totalFees / 100) > balanceOf[address(msg.sender)]:
                                            revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[454 len 26] >> 48, 0
                                        if balanceOf[address(msg.sender)] < arg2 - (arg2 * totalFees / 100):
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - arg2 + (arg2 * totalFees / 100)
                                        if balanceOf[arg1] > !(arg2 - (arg2 * totalFees / 100)):
                                            revert with 0, 17
                                        if balanceOf[arg1] + arg2 - (arg2 * totalFees / 100) < balanceOf[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(arg1)] = balanceOf[arg1] + arg2 - (arg2 * totalFees / 100)
                                        emit Transfer((arg2 - (arg2 * totalFees / 100)), msg.sender, arg1);
                                    else:
                                        if arg2 and 1 > -1 / arg2:
                                            revert with 0, 17
                                        if not arg2:
                                            revert with 0, 18
                                        if arg2 / arg2 != 1:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if arg2 * totalFees / 100 > !(arg2 / 100):
                                            revert with 0, 17
                                        if (arg2 * totalFees / 100) + (arg2 / 100) > arg2:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg2 < (arg2 * totalFees / 100) + (arg2 / 100):
                                            revert with 0, 17
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not this.address:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        if (arg2 * totalFees / 100) + (arg2 / 100) > balanceOf[address(msg.sender)]:
                                            revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[358 len 26] >> 48, 0
                                        if balanceOf[address(msg.sender)] < (arg2 * totalFees / 100) + (arg2 / 100):
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - (arg2 * totalFees / 100) - (arg2 / 100)
                                        if balanceOf[this.address] > !((arg2 * totalFees / 100) + (arg2 / 100)):
                                            revert with 0, 17
                                        if balanceOf[this.address] + (arg2 * totalFees / 100) + (arg2 / 100) < balanceOf[this.address]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 * totalFees / 100) + (arg2 / 100)
                                        emit Transfer(((arg2 * totalFees / 100) + (arg2 / 100)), msg.sender, this.address);
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not arg1:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        if arg2 - (arg2 * totalFees / 100) - (arg2 / 100) > balanceOf[address(msg.sender)]:
                                            revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[454 len 26] >> 48, 0
                                        if balanceOf[address(msg.sender)] < arg2 - (arg2 * totalFees / 100) - (arg2 / 100):
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - arg2 + (arg2 * totalFees / 100) + (arg2 / 100)
                                        if balanceOf[arg1] > !(arg2 - (arg2 * totalFees / 100) - (arg2 / 100)):
                                            revert with 0, 17
                                        if balanceOf[arg1] + arg2 - (arg2 * totalFees / 100) - (arg2 / 100) < balanceOf[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(arg1)] = balanceOf[arg1] + arg2 - (arg2 * totalFees / 100) - (arg2 / 100)
                                        emit Transfer((arg2 - (arg2 * totalFees / 100) - (arg2 / 100)), msg.sender, arg1);
                require ext_code.size(dividendTrackerAddress)
                call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args msg.sender, balanceOf[address(msg.sender)]
                require ext_code.size(dividendTrackerAddress)
                call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                     gas gas_remaining wei
                    args address(arg1), balanceOf[address(arg1)]
                if not stor7:
                    call dividendTrackerAddress.process(uint256 arg1) with:
                         gas gas_remaining wei
                        args gasForProcessing
                    if ext_call.success:
                        require return_data.size >= 96
                        emit ProcessedDividendTracker(ext_call.return_data[0], ext_call.return_data[32], ext_call.return_data[64], gasForProcessing, 1, tx.origin);
            else:
                if stor20[address(msg.sender)]:
                    if stor19[address(msg.sender)]:
                        if not msg.sender:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer from the zero address'
                        if not arg1:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer to the zero address'
                        if arg2 > balanceOf[address(msg.sender)]:
                            revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                        if balanceOf[address(msg.sender)] < arg2:
                            revert with 0, 17
                        balanceOf[address(msg.sender)] -= arg2
                        if balanceOf[arg1] > !arg2:
                            revert with 0, 17
                        if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                            revert with 0, 'SafeMath: addition overflow'
                        balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                        emit Transfer(arg2, msg.sender, arg1);
                    else:
                        if stor19[address(arg1)]:
                            if not msg.sender:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer from the zero address'
                            if not arg1:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer to the zero address'
                            if arg2 > balanceOf[address(msg.sender)]:
                                revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                            if balanceOf[address(msg.sender)] < arg2:
                                revert with 0, 17
                            balanceOf[address(msg.sender)] -= arg2
                            if balanceOf[arg1] > !arg2:
                                revert with 0, 17
                            if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                            emit Transfer(arg2, msg.sender, arg1);
                        else:
                            if stor7:
                                if not msg.sender:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer from the zero address'
                                if not arg1:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer to the zero address'
                                if arg2 > balanceOf[address(msg.sender)]:
                                    revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                                if balanceOf[address(msg.sender)] < arg2:
                                    revert with 0, 17
                                balanceOf[address(msg.sender)] -= arg2
                                if balanceOf[arg1] > !arg2:
                                    revert with 0, 17
                                if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                emit Transfer(arg2, msg.sender, arg1);
                            else:
                                if not arg2:
                                    if not stor20[address(arg1)]:
                                        if 0 > arg2:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg2 < 0:
                                            revert with 0, 17
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not this.address:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        if 0 > balanceOf[address(msg.sender)]:
                                            revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[294 len 26] >> 48, 0
                                        if balanceOf[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if balanceOf[this.address] > -1:
                                            revert with 0, 17
                                        if balanceOf[this.address] < balanceOf[this.address]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(this.address)] = balanceOf[this.address]
                                        emit Transfer(0, msg.sender, this.address);
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not arg1:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        if arg2 > balanceOf[address(msg.sender)]:
                                            revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[390 len 26] >> 48, 0
                                        if balanceOf[address(msg.sender)] < arg2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2
                                        if balanceOf[arg1] > !arg2:
                                            revert with 0, 17
                                        if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                        emit Transfer(arg2, msg.sender, arg1);
                                    else:
                                        if not arg2:
                                            if 0 > arg2:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if arg2 < 0:
                                                revert with 0, 17
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not this.address:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            if 0 > balanceOf[address(msg.sender)]:
                                                revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[358 len 26] >> 48, 0
                                            if balanceOf[address(msg.sender)] < 0:
                                                revert with 0, 17
                                            if balanceOf[this.address] > -1:
                                                revert with 0, 17
                                            if balanceOf[this.address] < balanceOf[this.address]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(this.address)] = balanceOf[this.address]
                                            emit Transfer(0, msg.sender, this.address);
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not arg1:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            if arg2 > balanceOf[address(msg.sender)]:
                                                revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[454 len 26] >> 48, 0
                                            if balanceOf[address(msg.sender)] < arg2:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2
                                            if balanceOf[arg1] > !arg2:
                                                revert with 0, 17
                                            if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                            emit Transfer(arg2, msg.sender, arg1);
                                        else:
                                            if arg2 and 1 > -1 / arg2:
                                                revert with 0, 17
                                            if not arg2:
                                                revert with 0, 18
                                            if arg2 / arg2 != 1:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if 0 > !(arg2 / 100):
                                                revert with 0, 17
                                            if arg2 / 100 > arg2:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if arg2 < arg2 / 100:
                                                revert with 0, 17
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not this.address:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[358 len 26] >> 48, 0
                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                            if balanceOf[this.address] > !(arg2 / 100):
                                                revert with 0, 17
                                            if balanceOf[this.address] + (arg2 / 100) < balanceOf[this.address]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 100)
                                            emit Transfer((arg2 / 100), msg.sender, this.address);
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not arg1:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            if arg2 - (arg2 / 100) > balanceOf[address(msg.sender)]:
                                                revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[454 len 26] >> 48, 0
                                            if balanceOf[address(msg.sender)] < arg2 - (arg2 / 100):
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - arg2 + (arg2 / 100)
                                            if balanceOf[arg1] > !(arg2 - (arg2 / 100)):
                                                revert with 0, 17
                                            if balanceOf[arg1] + arg2 - (arg2 / 100) < balanceOf[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2 - (arg2 / 100)
                                            emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                else:
                                    if arg2 and totalFees > -1 / arg2:
                                        revert with 0, 17
                                    if not arg2:
                                        revert with 0, 18
                                    if arg2 * totalFees / arg2 != totalFees:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
                                    if not stor20[address(arg1)]:
                                        if arg2 * totalFees / 100 > arg2:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg2 < arg2 * totalFees / 100:
                                            revert with 0, 17
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not this.address:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        if arg2 * totalFees / 100 > balanceOf[address(msg.sender)]:
                                            revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[294 len 26] >> 48, 0
                                        if balanceOf[address(msg.sender)] < arg2 * totalFees / 100:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2 * totalFees / 100
                                        if balanceOf[this.address] > !(arg2 * totalFees / 100):
                                            revert with 0, 17
                                        if balanceOf[this.address] + (arg2 * totalFees / 100) < balanceOf[this.address]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 * totalFees / 100)
                                        emit Transfer((arg2 * totalFees / 100), msg.sender, this.address);
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not arg1:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        if arg2 - (arg2 * totalFees / 100) > balanceOf[address(msg.sender)]:
                                            revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[390 len 26] >> 48, 0
                                        if balanceOf[address(msg.sender)] < arg2 - (arg2 * totalFees / 100):
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - arg2 + (arg2 * totalFees / 100)
                                        if balanceOf[arg1] > !(arg2 - (arg2 * totalFees / 100)):
                                            revert with 0, 17
                                        if balanceOf[arg1] + arg2 - (arg2 * totalFees / 100) < balanceOf[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(arg1)] = balanceOf[arg1] + arg2 - (arg2 * totalFees / 100)
                                        emit Transfer((arg2 - (arg2 * totalFees / 100)), msg.sender, arg1);
                                    else:
                                        if not arg2:
                                            if arg2 * totalFees / 100 > -1:
                                                revert with 0, 17
                                            if arg2 * totalFees / 100 > arg2:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if arg2 < arg2 * totalFees / 100:
                                                revert with 0, 17
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not this.address:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            if arg2 * totalFees / 100 > balanceOf[address(msg.sender)]:
                                                revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[358 len 26] >> 48, 0
                                            if balanceOf[address(msg.sender)] < arg2 * totalFees / 100:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2 * totalFees / 100
                                            if balanceOf[this.address] > !(arg2 * totalFees / 100):
                                                revert with 0, 17
                                            if balanceOf[this.address] + (arg2 * totalFees / 100) < balanceOf[this.address]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 * totalFees / 100)
                                            emit Transfer((arg2 * totalFees / 100), msg.sender, this.address);
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not arg1:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            if arg2 - (arg2 * totalFees / 100) > balanceOf[address(msg.sender)]:
                                                revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[454 len 26] >> 48, 0
                                            if balanceOf[address(msg.sender)] < arg2 - (arg2 * totalFees / 100):
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - arg2 + (arg2 * totalFees / 100)
                                            if balanceOf[arg1] > !(arg2 - (arg2 * totalFees / 100)):
                                                revert with 0, 17
                                            if balanceOf[arg1] + arg2 - (arg2 * totalFees / 100) < balanceOf[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2 - (arg2 * totalFees / 100)
                                            emit Transfer((arg2 - (arg2 * totalFees / 100)), msg.sender, arg1);
                                        else:
                                            if arg2 and 1 > -1 / arg2:
                                                revert with 0, 17
                                            if not arg2:
                                                revert with 0, 18
                                            if arg2 / arg2 != 1:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if arg2 * totalFees / 100 > !(arg2 / 100):
                                                revert with 0, 17
                                            if (arg2 * totalFees / 100) + (arg2 / 100) > arg2:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if arg2 < (arg2 * totalFees / 100) + (arg2 / 100):
                                                revert with 0, 17
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not this.address:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            if (arg2 * totalFees / 100) + (arg2 / 100) > balanceOf[address(msg.sender)]:
                                                revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[358 len 26] >> 48, 0
                                            if balanceOf[address(msg.sender)] < (arg2 * totalFees / 100) + (arg2 / 100):
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - (arg2 * totalFees / 100) - (arg2 / 100)
                                            if balanceOf[this.address] > !((arg2 * totalFees / 100) + (arg2 / 100)):
                                                revert with 0, 17
                                            if balanceOf[this.address] + (arg2 * totalFees / 100) + (arg2 / 100) < balanceOf[this.address]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 * totalFees / 100) + (arg2 / 100)
                                            emit Transfer(((arg2 * totalFees / 100) + (arg2 / 100)), msg.sender, this.address);
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not arg1:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            if arg2 - (arg2 * totalFees / 100) - (arg2 / 100) > balanceOf[address(msg.sender)]:
                                                revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[454 len 26] >> 48, 0
                                            if balanceOf[address(msg.sender)] < arg2 - (arg2 * totalFees / 100) - (arg2 / 100):
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - arg2 + (arg2 * totalFees / 100) + (arg2 / 100)
                                            if balanceOf[arg1] > !(arg2 - (arg2 * totalFees / 100) - (arg2 / 100)):
                                                revert with 0, 17
                                            if balanceOf[arg1] + arg2 - (arg2 * totalFees / 100) - (arg2 / 100) < balanceOf[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2 - (arg2 * totalFees / 100) - (arg2 / 100)
                                            emit Transfer((arg2 - (arg2 * totalFees / 100) - (arg2 / 100)), msg.sender, arg1);
                    require ext_code.size(dividendTrackerAddress)
                    call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args msg.sender, balanceOf[address(msg.sender)]
                    require ext_code.size(dividendTrackerAddress)
                    call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(arg1), balanceOf[address(arg1)]
                    if not stor7:
                        call dividendTrackerAddress.process(uint256 arg1) with:
                             gas gas_remaining wei
                            args gasForProcessing
                        if ext_call.success:
                            require return_data.size >= 96
                            emit ProcessedDividendTracker(ext_call.return_data[0], ext_call.return_data[32], ext_call.return_data[64], gasForProcessing, 1, tx.origin);
                else:
                    if owner == msg.sender:
                        if stor19[address(msg.sender)]:
                            if not msg.sender:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer from the zero address'
                            if not arg1:
                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer to the zero address'
                            if arg2 > balanceOf[address(msg.sender)]:
                                revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                            if balanceOf[address(msg.sender)] < arg2:
                                revert with 0, 17
                            balanceOf[address(msg.sender)] -= arg2
                            if balanceOf[arg1] > !arg2:
                                revert with 0, 17
                            if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                            emit Transfer(arg2, msg.sender, arg1);
                        else:
                            if stor19[address(arg1)]:
                                if not msg.sender:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer from the zero address'
                                if not arg1:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer to the zero address'
                                if arg2 > balanceOf[address(msg.sender)]:
                                    revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                                if balanceOf[address(msg.sender)] < arg2:
                                    revert with 0, 17
                                balanceOf[address(msg.sender)] -= arg2
                                if balanceOf[arg1] > !arg2:
                                    revert with 0, 17
                                if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                emit Transfer(arg2, msg.sender, arg1);
                            else:
                                if stor7:
                                    if not msg.sender:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer from the zero address'
                                    if not arg1:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer to the zero address'
                                    if arg2 > balanceOf[address(msg.sender)]:
                                        revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                                    if balanceOf[address(msg.sender)] < arg2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)] -= arg2
                                    if balanceOf[arg1] > !arg2:
                                        revert with 0, 17
                                    if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                    emit Transfer(arg2, msg.sender, arg1);
                                else:
                                    if not arg2:
                                        if not stor20[address(arg1)]:
                                            if 0 > arg2:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if arg2 < 0:
                                                revert with 0, 17
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not this.address:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            if 0 > balanceOf[address(msg.sender)]:
                                                revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[294 len 26] >> 48, 0
                                            if balanceOf[address(msg.sender)] < 0:
                                                revert with 0, 17
                                            if balanceOf[this.address] > -1:
                                                revert with 0, 17
                                            if balanceOf[this.address] < balanceOf[this.address]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(this.address)] = balanceOf[this.address]
                                            emit Transfer(0, msg.sender, this.address);
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not arg1:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            if arg2 > balanceOf[address(msg.sender)]:
                                                revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[390 len 26] >> 48, 0
                                            if balanceOf[address(msg.sender)] < arg2:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2
                                            if balanceOf[arg1] > !arg2:
                                                revert with 0, 17
                                            if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                            emit Transfer(arg2, msg.sender, arg1);
                                        else:
                                            if not arg2:
                                                if 0 > arg2:
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if arg2 < 0:
                                                    revert with 0, 17
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not this.address:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                if 0 > balanceOf[address(msg.sender)]:
                                                    revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[358 len 26] >> 48, 0
                                                if balanceOf[address(msg.sender)] < 0:
                                                    revert with 0, 17
                                                if balanceOf[this.address] > -1:
                                                    revert with 0, 17
                                                if balanceOf[this.address] < balanceOf[this.address]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(this.address)] = balanceOf[this.address]
                                                emit Transfer(0, msg.sender, this.address);
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not arg1:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                if arg2 > balanceOf[address(msg.sender)]:
                                                    revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[454 len 26] >> 48, 0
                                                if balanceOf[address(msg.sender)] < arg2:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= arg2
                                                if balanceOf[arg1] > !arg2:
                                                    revert with 0, 17
                                                if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                emit Transfer(arg2, msg.sender, arg1);
                                            else:
                                                if arg2 and 1 > -1 / arg2:
                                                    revert with 0, 17
                                                if not arg2:
                                                    revert with 0, 18
                                                if arg2 / arg2 != 1:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if 0 > !(arg2 / 100):
                                                    revert with 0, 17
                                                if arg2 / 100 > arg2:
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if arg2 < arg2 / 100:
                                                    revert with 0, 17
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not this.address:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                    revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[358 len 26] >> 48, 0
                                                if balanceOf[address(msg.sender)] < arg2 / 100:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= arg2 / 100
                                                if balanceOf[this.address] > !(arg2 / 100):
                                                    revert with 0, 17
                                                if balanceOf[this.address] + (arg2 / 100) < balanceOf[this.address]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 100)
                                                emit Transfer((arg2 / 100), msg.sender, this.address);
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not arg1:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                if arg2 - (arg2 / 100) > balanceOf[address(msg.sender)]:
                                                    revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[454 len 26] >> 48, 0
                                                if balanceOf[address(msg.sender)] < arg2 - (arg2 / 100):
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - arg2 + (arg2 / 100)
                                                if balanceOf[arg1] > !(arg2 - (arg2 / 100)):
                                                    revert with 0, 17
                                                if balanceOf[arg1] + arg2 - (arg2 / 100) < balanceOf[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(arg1)] = balanceOf[arg1] + arg2 - (arg2 / 100)
                                                emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                    else:
                                        if arg2 and totalFees > -1 / arg2:
                                            revert with 0, 17
                                        if not arg2:
                                            revert with 0, 18
                                        if arg2 * totalFees / arg2 != totalFees:
                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
                                        if not stor20[address(arg1)]:
                                            if arg2 * totalFees / 100 > arg2:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if arg2 < arg2 * totalFees / 100:
                                                revert with 0, 17
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not this.address:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            if arg2 * totalFees / 100 > balanceOf[address(msg.sender)]:
                                                revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[294 len 26] >> 48, 0
                                            if balanceOf[address(msg.sender)] < arg2 * totalFees / 100:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2 * totalFees / 100
                                            if balanceOf[this.address] > !(arg2 * totalFees / 100):
                                                revert with 0, 17
                                            if balanceOf[this.address] + (arg2 * totalFees / 100) < balanceOf[this.address]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 * totalFees / 100)
                                            emit Transfer((arg2 * totalFees / 100), msg.sender, this.address);
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not arg1:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            if arg2 - (arg2 * totalFees / 100) > balanceOf[address(msg.sender)]:
                                                revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[390 len 26] >> 48, 0
                                            if balanceOf[address(msg.sender)] < arg2 - (arg2 * totalFees / 100):
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - arg2 + (arg2 * totalFees / 100)
                                            if balanceOf[arg1] > !(arg2 - (arg2 * totalFees / 100)):
                                                revert with 0, 17
                                            if balanceOf[arg1] + arg2 - (arg2 * totalFees / 100) < balanceOf[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2 - (arg2 * totalFees / 100)
                                            emit Transfer((arg2 - (arg2 * totalFees / 100)), msg.sender, arg1);
                                        else:
                                            if not arg2:
                                                if arg2 * totalFees / 100 > -1:
                                                    revert with 0, 17
                                                if arg2 * totalFees / 100 > arg2:
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if arg2 < arg2 * totalFees / 100:
                                                    revert with 0, 17
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not this.address:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                if arg2 * totalFees / 100 > balanceOf[address(msg.sender)]:
                                                    revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[358 len 26] >> 48, 0
                                                if balanceOf[address(msg.sender)] < arg2 * totalFees / 100:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= arg2 * totalFees / 100
                                                if balanceOf[this.address] > !(arg2 * totalFees / 100):
                                                    revert with 0, 17
                                                if balanceOf[this.address] + (arg2 * totalFees / 100) < balanceOf[this.address]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 * totalFees / 100)
                                                emit Transfer((arg2 * totalFees / 100), msg.sender, this.address);
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not arg1:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                if arg2 - (arg2 * totalFees / 100) > balanceOf[address(msg.sender)]:
                                                    revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[454 len 26] >> 48, 0
                                                if balanceOf[address(msg.sender)] < arg2 - (arg2 * totalFees / 100):
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - arg2 + (arg2 * totalFees / 100)
                                                if balanceOf[arg1] > !(arg2 - (arg2 * totalFees / 100)):
                                                    revert with 0, 17
                                                if balanceOf[arg1] + arg2 - (arg2 * totalFees / 100) < balanceOf[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(arg1)] = balanceOf[arg1] + arg2 - (arg2 * totalFees / 100)
                                                emit Transfer((arg2 - (arg2 * totalFees / 100)), msg.sender, arg1);
                                            else:
                                                if arg2 and 1 > -1 / arg2:
                                                    revert with 0, 17
                                                if not arg2:
                                                    revert with 0, 18
                                                if arg2 / arg2 != 1:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if arg2 * totalFees / 100 > !(arg2 / 100):
                                                    revert with 0, 17
                                                if (arg2 * totalFees / 100) + (arg2 / 100) > arg2:
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if arg2 < (arg2 * totalFees / 100) + (arg2 / 100):
                                                    revert with 0, 17
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not this.address:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                if (arg2 * totalFees / 100) + (arg2 / 100) > balanceOf[address(msg.sender)]:
                                                    revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[358 len 26] >> 48, 0
                                                if balanceOf[address(msg.sender)] < (arg2 * totalFees / 100) + (arg2 / 100):
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - (arg2 * totalFees / 100) - (arg2 / 100)
                                                if balanceOf[this.address] > !((arg2 * totalFees / 100) + (arg2 / 100)):
                                                    revert with 0, 17
                                                if balanceOf[this.address] + (arg2 * totalFees / 100) + (arg2 / 100) < balanceOf[this.address]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 * totalFees / 100) + (arg2 / 100)
                                                emit Transfer(((arg2 * totalFees / 100) + (arg2 / 100)), msg.sender, this.address);
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not arg1:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                if arg2 - (arg2 * totalFees / 100) - (arg2 / 100) > balanceOf[address(msg.sender)]:
                                                    revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[454 len 26] >> 48, 0
                                                if balanceOf[address(msg.sender)] < arg2 - (arg2 * totalFees / 100) - (arg2 / 100):
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - arg2 + (arg2 * totalFees / 100) + (arg2 / 100)
                                                if balanceOf[arg1] > !(arg2 - (arg2 * totalFees / 100) - (arg2 / 100)):
                                                    revert with 0, 17
                                                if balanceOf[arg1] + arg2 - (arg2 * totalFees / 100) - (arg2 / 100) < balanceOf[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(arg1)] = balanceOf[arg1] + arg2 - (arg2 * totalFees / 100) - (arg2 / 100)
                                                emit Transfer((arg2 - (arg2 * totalFees / 100) - (arg2 / 100)), msg.sender, arg1);
                        require ext_code.size(dividendTrackerAddress)
                        call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args msg.sender, balanceOf[address(msg.sender)]
                        require ext_code.size(dividendTrackerAddress)
                        call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(arg1), balanceOf[address(arg1)]
                        if not stor7:
                            call dividendTrackerAddress.process(uint256 arg1) with:
                                 gas gas_remaining wei
                                args gasForProcessing
                            if ext_call.success:
                                require return_data.size >= 96
                                emit ProcessedDividendTracker(ext_call.return_data[0], ext_call.return_data[32], ext_call.return_data[64], gasForProcessing, 1, tx.origin);
                    else:
                        if owner == arg1:
                            if stor19[address(msg.sender)]:
                                if not msg.sender:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer from the zero address'
                                if not arg1:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer to the zero address'
                                if arg2 > balanceOf[address(msg.sender)]:
                                    revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                                if balanceOf[address(msg.sender)] < arg2:
                                    revert with 0, 17
                                balanceOf[address(msg.sender)] -= arg2
                                if balanceOf[arg1] > !arg2:
                                    revert with 0, 17
                                if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                emit Transfer(arg2, msg.sender, arg1);
                            else:
                                if stor19[address(arg1)]:
                                    if not msg.sender:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer from the zero address'
                                    if not arg1:
                                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer to the zero address'
                                    if arg2 > balanceOf[address(msg.sender)]:
                                        revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                                    if balanceOf[address(msg.sender)] < arg2:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)] -= arg2
                                    if balanceOf[arg1] > !arg2:
                                        revert with 0, 17
                                    if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                    emit Transfer(arg2, msg.sender, arg1);
                                else:
                                    if stor7:
                                        if not msg.sender:
                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer from the zero address'
                                        if not arg1:
                                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer to the zero address'
                                        if arg2 > balanceOf[address(msg.sender)]:
                                            revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[166 len 26] >> 48, 0
                                        if balanceOf[address(msg.sender)] < arg2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2
                                        if balanceOf[arg1] > !arg2:
                                            revert with 0, 17
                                        if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                        emit Transfer(arg2, msg.sender, arg1);
                                    else:
                                        if not arg2:
                                            if not stor20[address(arg1)]:
                                                if 0 > arg2:
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if arg2 < 0:
                                                    revert with 0, 17
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not this.address:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                if 0 > balanceOf[address(msg.sender)]:
                                                    revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[294 len 26] >> 48, 0
                                                if balanceOf[address(msg.sender)] < 0:
                                                    revert with 0, 17
                                                if balanceOf[this.address] > -1:
                                                    revert with 0, 17
                                                if balanceOf[this.address] < balanceOf[this.address]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(this.address)] = balanceOf[this.address]
                                                emit Transfer(0, msg.sender, this.address);
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not arg1:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                if arg2 > balanceOf[address(msg.sender)]:
                                                    revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[390 len 26] >> 48, 0
                                                if balanceOf[address(msg.sender)] < arg2:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= arg2
                                                if balanceOf[arg1] > !arg2:
                                                    revert with 0, 17
                                                if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                emit Transfer(arg2, msg.sender, arg1);
                                            else:
                                                if not arg2:
                                                    if 0 > arg2:
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if arg2 < 0:
                                                        revert with 0, 17
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not this.address:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    if 0 > balanceOf[address(msg.sender)]:
                                                        revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[358 len 26] >> 48, 0
                                                    if balanceOf[address(msg.sender)] < 0:
                                                        revert with 0, 17
                                                    if balanceOf[this.address] > -1:
                                                        revert with 0, 17
                                                    if balanceOf[this.address] < balanceOf[this.address]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(this.address)] = balanceOf[this.address]
                                                    emit Transfer(0, msg.sender, this.address);
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not arg1:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    if arg2 > balanceOf[address(msg.sender)]:
                                                        revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[454 len 26] >> 48, 0
                                                    if balanceOf[address(msg.sender)] < arg2:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2
                                                    if balanceOf[arg1] > !arg2:
                                                        revert with 0, 17
                                                    if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                    emit Transfer(arg2, msg.sender, arg1);
                                                else:
                                                    if arg2 and 1 > -1 / arg2:
                                                        revert with 0, 17
                                                    if not arg2:
                                                        revert with 0, 18
                                                    if arg2 / arg2 != 1:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if 0 > !(arg2 / 100):
                                                        revert with 0, 17
                                                    if arg2 / 100 > arg2:
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if arg2 < arg2 / 100:
                                                        revert with 0, 17
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not this.address:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                        revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[358 len 26] >> 48, 0
                                                    if balanceOf[address(msg.sender)] < arg2 / 100:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2 / 100
                                                    if balanceOf[this.address] > !(arg2 / 100):
                                                        revert with 0, 17
                                                    if balanceOf[this.address] + (arg2 / 100) < balanceOf[this.address]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 100)
                                                    emit Transfer((arg2 / 100), msg.sender, this.address);
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not arg1:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    if arg2 - (arg2 / 100) > balanceOf[address(msg.sender)]:
                                                        revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[454 len 26] >> 48, 0
                                                    if balanceOf[address(msg.sender)] < arg2 - (arg2 / 100):
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - arg2 + (arg2 / 100)
                                                    if balanceOf[arg1] > !(arg2 - (arg2 / 100)):
                                                        revert with 0, 17
                                                    if balanceOf[arg1] + arg2 - (arg2 / 100) < balanceOf[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(arg1)] = balanceOf[arg1] + arg2 - (arg2 / 100)
                                                    emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                        else:
                                            if arg2 and totalFees > -1 / arg2:
                                                revert with 0, 17
                                            if not arg2:
                                                revert with 0, 18
                                            if arg2 * totalFees / arg2 != totalFees:
                                                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
                                            if not stor20[address(arg1)]:
                                                if arg2 * totalFees / 100 > arg2:
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if arg2 < arg2 * totalFees / 100:
                                                    revert with 0, 17
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not this.address:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                if arg2 * totalFees / 100 > balanceOf[address(msg.sender)]:
                                                    revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[294 len 26] >> 48, 0
                                                if balanceOf[address(msg.sender)] < arg2 * totalFees / 100:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= arg2 * totalFees / 100
                                                if balanceOf[this.address] > !(arg2 * totalFees / 100):
                                                    revert with 0, 17
                                                if balanceOf[this.address] + (arg2 * totalFees / 100) < balanceOf[this.address]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 * totalFees / 100)
                                                emit Transfer((arg2 * totalFees / 100), msg.sender, this.address);
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not arg1:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                if arg2 - (arg2 * totalFees / 100) > balanceOf[address(msg.sender)]:
                                                    revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[390 len 26] >> 48, 0
                                                if balanceOf[address(msg.sender)] < arg2 - (arg2 * totalFees / 100):
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - arg2 + (arg2 * totalFees / 100)
                                                if balanceOf[arg1] > !(arg2 - (arg2 * totalFees / 100)):
                                                    revert with 0, 17
                                                if balanceOf[arg1] + arg2 - (arg2 * totalFees / 100) < balanceOf[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(arg1)] = balanceOf[arg1] + arg2 - (arg2 * totalFees / 100)
                                                emit Transfer((arg2 - (arg2 * totalFees / 100)), msg.sender, arg1);
                                            else:
                                                if not arg2:
                                                    if arg2 * totalFees / 100 > -1:
                                                        revert with 0, 17
                                                    if arg2 * totalFees / 100 > arg2:
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if arg2 < arg2 * totalFees / 100:
                                                        revert with 0, 17
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not this.address:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    if arg2 * totalFees / 100 > balanceOf[address(msg.sender)]:
                                                        revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[358 len 26] >> 48, 0
                                                    if balanceOf[address(msg.sender)] < arg2 * totalFees / 100:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= arg2 * totalFees / 100
                                                    if balanceOf[this.address] > !(arg2 * totalFees / 100):
                                                        revert with 0, 17
                                                    if balanceOf[this.address] + (arg2 * totalFees / 100) < balanceOf[this.address]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 * totalFees / 100)
                                                    emit Transfer((arg2 * totalFees / 100), msg.sender, this.address);
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not arg1:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    if arg2 - (arg2 * totalFees / 100) > balanceOf[address(msg.sender)]:
                                                        revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[454 len 26] >> 48, 0
                                                    if balanceOf[address(msg.sender)] < arg2 - (arg2 * totalFees / 100):
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - arg2 + (arg2 * totalFees / 100)
                                                    if balanceOf[arg1] > !(arg2 - (arg2 * totalFees / 100)):
                                                        revert with 0, 17
                                                    if balanceOf[arg1] + arg2 - (arg2 * totalFees / 100) < balanceOf[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(arg1)] = balanceOf[arg1] + arg2 - (arg2 * totalFees / 100)
                                                    emit Transfer((arg2 - (arg2 * totalFees / 100)), msg.sender, arg1);
                                                else:
                                                    if arg2 and 1 > -1 / arg2:
                                                        revert with 0, 17
                                                    if not arg2:
                                                        revert with 0, 18
                                                    if arg2 / arg2 != 1:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if arg2 * totalFees / 100 > !(arg2 / 100):
                                                        revert with 0, 17
                                                    if (arg2 * totalFees / 100) + (arg2 / 100) > arg2:
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if arg2 < (arg2 * totalFees / 100) + (arg2 / 100):
                                                        revert with 0, 17
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not this.address:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    if (arg2 * totalFees / 100) + (arg2 / 100) > balanceOf[address(msg.sender)]:
                                                        revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[358 len 26] >> 48, 0
                                                    if balanceOf[address(msg.sender)] < (arg2 * totalFees / 100) + (arg2 / 100):
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - (arg2 * totalFees / 100) - (arg2 / 100)
                                                    if balanceOf[this.address] > !((arg2 * totalFees / 100) + (arg2 / 100)):
                                                        revert with 0, 17
                                                    if balanceOf[this.address] + (arg2 * totalFees / 100) + (arg2 / 100) < balanceOf[this.address]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 * totalFees / 100) + (arg2 / 100)
                                                    emit Transfer(((arg2 * totalFees / 100) + (arg2 / 100)), msg.sender, this.address);
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not arg1:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    if arg2 - (arg2 * totalFees / 100) - (arg2 / 100) > balanceOf[address(msg.sender)]:
                                                        revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[454 len 26] >> 48, 0
                                                    if balanceOf[address(msg.sender)] < arg2 - (arg2 * totalFees / 100) - (arg2 / 100):
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - arg2 + (arg2 * totalFees / 100) + (arg2 / 100)
                                                    if balanceOf[arg1] > !(arg2 - (arg2 * totalFees / 100) - (arg2 / 100)):
                                                        revert with 0, 17
                                                    if balanceOf[arg1] + arg2 - (arg2 * totalFees / 100) - (arg2 / 100) < balanceOf[arg1]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(arg1)] = balanceOf[arg1] + arg2 - (arg2 * totalFees / 100) - (arg2 / 100)
                                                    emit Transfer((arg2 - (arg2 * totalFees / 100) - (arg2 / 100)), msg.sender, arg1);
                            require ext_code.size(dividendTrackerAddress)
                            call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args msg.sender, balanceOf[address(msg.sender)]
                            require ext_code.size(dividendTrackerAddress)
                            call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args address(arg1), balanceOf[address(arg1)]
                            if not stor7:
                                call dividendTrackerAddress.process(uint256 arg1) with:
                                     gas gas_remaining wei
                                    args gasForProcessing
                                if ext_call.success:
                                    require return_data.size >= 96
                                    emit ProcessedDividendTracker(ext_call.return_data[0], ext_call.return_data[32], ext_call.return_data[64], gasForProcessing, 1, tx.origin);
                        else:
                            stor7 = 1
                            if balanceOf[this.address]:
                                if balanceOf[this.address] and stor15 > -1 / balanceOf[this.address]:
                                    revert with 0, 17
                                if not balanceOf[this.address]:
                                    revert with 0, 18
                                if balanceOf[this.address] * stor15 / balanceOf[this.address] != stor15:
                                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
                                mem[96] = 26
                                mem[128] = 'SafeMath: division by zero'
                                if not totalFees:
                                    revert with 0, 'SafeMath: division by zero', 0
                                mem[164] = this.address
                                staticcall sub_4d7effddAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[160] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[ceil32(return_data.size) + 160] = 3
                                mem[ceil32(return_data.size) + 192] = this.address
                                staticcall uniswapV2RouterAddress.WETH() with:
                                        gas gas_remaining wei
                                mem[ceil32(return_data.size) + 288] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = (2 * ceil32(return_data.size)) + 288
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                mem[ceil32(return_data.size) + 224] = ext_call.return_data[12 len 20]
                                mem[ceil32(return_data.size) + 256] = sub_4d7effddAddress
                                if not this.address:
                                    mem[(2 * ceil32(return_data.size)) + 288] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[(2 * ceil32(return_data.size)) + 292] = 32
                                    mem[(2 * ceil32(return_data.size)) + 324] = 36
                                    mem[(2 * ceil32(return_data.size)) + 356] = 'ERC20: approve from the zero add'
                                    mem[(2 * ceil32(return_data.size)) + 388] = 0x7265737300000000000000000000000000000000000000000000000000000000
                                    revert with memory
                                      from (2 * ceil32(return_data.size)) + 288
                                       len ceil32(return_data.size) + 132
                                if not uniswapV2RouterAddress:
                                    mem[(2 * ceil32(return_data.size)) + 288] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[(2 * ceil32(return_data.size)) + 292] = 32
                                    mem[(2 * ceil32(return_data.size)) + 324] = 34
                                    mem[(2 * ceil32(return_data.size)) + 356] = 'ERC20: approve to the zero addre'
                                    mem[(2 * ceil32(return_data.size)) + 388] = 0x7373000000000000000000000000000000000000000000000000000000000000
                                    revert with memory
                                      from (2 * ceil32(return_data.size)) + 288
                                       len ceil32(return_data.size) + 132
                                mem[0] = uniswapV2RouterAddress
                                mem[32] = sha3(address(this.address), 1)
                                allowance[address(this.address)][stor6].field_0 = balanceOf[this.address] * stor15 / totalFees
                                mem[(2 * ceil32(return_data.size)) + 288] = balanceOf[this.address] * stor15 / totalFees
                                emit Approval(mem[(2 * ceil32(return_data.size)) + 288 len ceil32(return_data.size) + 32], this.address, uniswapV2RouterAddress);
                                mem[(2 * ceil32(return_data.size)) + 288] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                mem[(2 * ceil32(return_data.size)) + 292] = balanceOf[this.address] * stor15 / totalFees
                                mem[(2 * ceil32(return_data.size)) + 324] = 0
                                mem[(2 * ceil32(return_data.size)) + 356] = 160
                                mem[(2 * ceil32(return_data.size)) + 452] = 3
                                idx = 0
                                s = (2 * ceil32(return_data.size)) + 484
                                t = ceil32(return_data.size) + 192
                                while idx < mem[ceil32(return_data.size) + 160]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(2 * ceil32(return_data.size)) + 388] = this.address
                                mem[(2 * ceil32(return_data.size)) + 420] = block.timestamp
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 576]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[mem[64] + 4] = this.address
                                staticcall sub_4d7effddAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[mem[64]] = ext_call.return_data[0]
                                _5344 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _5346 = mem[_5344]
                                _5348 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5348] = 30
                                mem[_5348 + 32] = 'SafeMath: subtraction overflow'
                                if ext_call.return_data[0] > _5346:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if _5346 < ext_call.return_data[0]:
                                    revert with 0, 17
                                mem[mem[64] + 4] = stor17
                                mem[mem[64] + 36] = _5346 - ext_call.return_data[0]
                                call sub_4d7effddAddress.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args stor17, _5346 - ext_call.return_data[0]
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5362 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_5362] == bool(mem[_5362])
                                if balanceOf[this.address]:
                                    if balanceOf[this.address] and stor14 > -1 / balanceOf[this.address]:
                                        revert with 0, 17
                                    if not balanceOf[this.address]:
                                        revert with 0, 18
                                    if balanceOf[this.address] * stor14 / balanceOf[this.address] != stor14:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _5380 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5380] = 26
                                    mem[_5380 + 32] = 'SafeMath: division by zero'
                                    if not totalFees:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    _5398 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5398] = 26
                                    mem[_5398 + 32] = 'SafeMath: division by zero'
                                    _5408 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5408] = 30
                                    mem[_5408 + 32] = 'SafeMath: subtraction overflow'
                                    if balanceOf[this.address] * stor14 / totalFees / 2 > balanceOf[this.address] * stor14 / totalFees:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if balanceOf[this.address] * stor14 / totalFees < balanceOf[this.address] * stor14 / totalFees / 2:
                                        revert with 0, 17
                                    _5434 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    mem[_5434 + 32 len 64] = call.data[calldata.size len 64]
                                    if 0 >= mem[_5434]:
                                        revert with 0, 50
                                    mem[_5434 + 32] = this.address
                                    staticcall uniswapV2RouterAddress.WETH() with:
                                            gas gas_remaining wei
                                    mem[_5434 + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _5434 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if 1 >= mem[_5434]:
                                        revert with 0, 50
                                    mem[_5434 + 64] = ext_call.return_data[12 len 20]
                                    if not this.address:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not uniswapV2RouterAddress:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    mem[0] = uniswapV2RouterAddress
                                    mem[32] = sha3(address(this.address), 1)
                                    allowance[address(this.address)][stor6].field_0 = balanceOf[this.address] * stor14 / totalFees / 2
                                    allowance[address(this.address)][stor6].field_255 = 0
                                    emit Approval((balanceOf[this.address] * stor14 / totalFees / 2), this.address, uniswapV2RouterAddress);
                                    mem[_5434 + ceil32(return_data.size) + 96] = 0x791ac94700000000000000000000000000000000000000000000000000000000
                                    mem[_5434 + ceil32(return_data.size) + 100] = balanceOf[this.address] * stor14 / totalFees / 2
                                    mem[_5434 + ceil32(return_data.size) + 132] = 0
                                    mem[_5434 + ceil32(return_data.size) + 164] = 160
                                    mem[_5434 + ceil32(return_data.size) + 260] = mem[_5434]
                                    idx = 0
                                    s = _5434 + ceil32(return_data.size) + 292
                                    t = _5434 + 32
                                    while idx < mem[_5434]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args Mask(255, 1, balanceOf[this.address] * stor14 / totalFees), 0, 160, address(this.address), block.timestamp, mem[_5434 + ceil32(return_data.size) + 260 len (32 * mem[_5434]) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_5434 + ceil32(return_data.size) + 96] = 30
                                    mem[_5434 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                    if eth.balance(this.address) > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if eth.balance(this.address) < eth.balance(this.address):
                                        revert with 0, 17
                                    if not this.address:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not uniswapV2RouterAddress:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(this.address)][stor6].field_0 = (balanceOf[this.address] * stor14 / totalFees) - (balanceOf[this.address] * stor14 / totalFees / 2)
                                    emit Approval(((balanceOf[this.address] * stor14 / totalFees) - (balanceOf[this.address] * stor14 / totalFees / 2)), this.address, uniswapV2RouterAddress);
                                    mem[_5434 + ceil32(return_data.size) + 228] = 0
                                    mem[_5434 + ceil32(return_data.size) + 260] = 0
                                    mem[_5434 + ceil32(return_data.size) + 292] = stor17
                                    mem[_5434 + ceil32(return_data.size) + 324] = block.timestamp
                                    call uniswapV2RouterAddress.addLiquidityETH(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                         gas gas_remaining wei
                                        args this.address, (balanceOf[this.address] * stor14 / totalFees) - (balanceOf[this.address] * stor14 / totalFees / 2), 0, 0, stor17, block.timestamp
                                    mem[_5434 + ceil32(return_data.size) + 160 len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 96
                                    emit SwapAndLiquify(Mask(255, 1, balanceOf[this.address] * stor14 / totalFees), 0, (balanceOf[this.address] * stor14 / totalFees) - (balanceOf[this.address] * stor14 / totalFees / 2));
                                    mem[_5434 + (2 * ceil32(return_data.size)) + 160] = 3
                                    mem[_5434 + (2 * ceil32(return_data.size)) + 192] = this.address
                                    staticcall uniswapV2RouterAddress.WETH() with:
                                            gas gas_remaining wei
                                    mem[_5434 + (2 * ceil32(return_data.size)) + 288] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    mem[_5434 + (2 * ceil32(return_data.size)) + 224] = ext_call.return_data[12 len 20]
                                    mem[_5434 + (2 * ceil32(return_data.size)) + 256] = sub_4d7effddAddress
                                    if not this.address:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not uniswapV2RouterAddress:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(this.address)][stor6].field_0 = balanceOf[this.address]
                                    emit Approval(balanceOf[this.address], this.address, uniswapV2RouterAddress);
                                    mem[_5434 + (4 * ceil32(return_data.size)) + 288] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                    mem[_5434 + (4 * ceil32(return_data.size)) + 292] = balanceOf[this.address]
                                    mem[_5434 + (4 * ceil32(return_data.size)) + 324] = 0
                                    mem[_5434 + (4 * ceil32(return_data.size)) + 356] = 160
                                    mem[_5434 + (4 * ceil32(return_data.size)) + 452] = 3
                                    idx = 0
                                    s = _5434 + (4 * ceil32(return_data.size)) + 484
                                    t = _5434 + (2 * ceil32(return_data.size)) + 192
                                    while idx < mem[_5434 + (2 * ceil32(return_data.size)) + 160]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5434 + (4 * ceil32(return_data.size)) + 388] = this.address
                                    mem[_5434 + (4 * ceil32(return_data.size)) + 420] = block.timestamp
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args balanceOf[this.address], 0, 160, address(this.address), block.timestamp, mem[_5434 + (4 * ceil32(return_data.size)) + 452 len (32 * mem[_5434 + (2 * ceil32(return_data.size)) + 160]) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    staticcall sub_4d7effddAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    require return_data.size >= 32
                                    call sub_4d7effddAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args dividendTrackerAddress, ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    if ext_call.return_data[0]:
                                        require ext_code.size(dividendTrackerAddress)
                                        call dividendTrackerAddress.distributeDogeDividends(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        emit SendDividends(balanceOf[this.address], ext_call.return_data[0]);
                                    stor7 = 0
                                    if stor19[address(msg.sender)]:
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not arg1:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        if arg2 > balanceOf[address(msg.sender)]:
                                            revert with 0, 
                                                        32,
                                                        38,
                                                        0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_5434 + (7 * ceil32(return_data.size)) + 358 len 26] >> 48,
                                                        0
                                        if balanceOf[address(msg.sender)] < arg2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2
                                        if balanceOf[arg1] > !arg2:
                                            revert with 0, 17
                                        if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                        emit Transfer(arg2, msg.sender, arg1);
                                    else:
                                        if stor19[address(arg1)]:
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not arg1:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            if arg2 > balanceOf[address(msg.sender)]:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_5434 + (7 * ceil32(return_data.size)) + 358 len 26] >> 48,
                                                            0
                                            if balanceOf[address(msg.sender)] < arg2:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2
                                            if balanceOf[arg1] > !arg2:
                                                revert with 0, 17
                                            if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                            emit Transfer(arg2, msg.sender, arg1);
                                        else:
                                            if stor7:
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not arg1:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                if arg2 > balanceOf[address(msg.sender)]:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_5434 + (7 * ceil32(return_data.size)) + 358 len 26] >> 48,
                                                                0
                                                if balanceOf[address(msg.sender)] < arg2:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= arg2
                                                if balanceOf[arg1] > !arg2:
                                                    revert with 0, 17
                                                if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                emit Transfer(arg2, msg.sender, arg1);
                                            else:
                                                if not arg2:
                                                    if not stor20[address(arg1)]:
                                                        if 0 > arg2:
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if arg2 < 0:
                                                            revert with 0, 17
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not this.address:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        if 0 > balanceOf[address(msg.sender)]:
                                                            revert with 0, 
                                                                        32,
                                                                        38,
                                                                        0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_5434 + (7 * ceil32(return_data.size)) + 486 len 26] >> 48,
                                                                        0
                                                        if balanceOf[address(msg.sender)] < 0:
                                                            revert with 0, 17
                                                        if balanceOf[this.address] > -1:
                                                            revert with 0, 17
                                                        if balanceOf[this.address] < balanceOf[this.address]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(this.address)] = balanceOf[this.address]
                                                        emit Transfer(0, msg.sender, this.address);
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not arg1:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        if arg2 > balanceOf[address(msg.sender)]:
                                                            revert with 0, 
                                                                        32,
                                                                        38,
                                                                        0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_5434 + (7 * ceil32(return_data.size)) + 582 len 26] >> 48,
                                                                        0
                                                        if balanceOf[address(msg.sender)] < arg2:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] -= arg2
                                                        if balanceOf[arg1] > !arg2:
                                                            revert with 0, 17
                                                        if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                        emit Transfer(arg2, msg.sender, arg1);
                                                    else:
                                                        if not arg2:
                                                            if 0 > arg2:
                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                            if arg2 < 0:
                                                                revert with 0, 17
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not this.address:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            if 0 > balanceOf[address(msg.sender)]:
                                                                revert with 0, 
                                                                            32,
                                                                            38,
                                                                            0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_5434 + (7 * ceil32(return_data.size)) + 550 len 26] >> 48,
                                                                            0
                                                            if balanceOf[address(msg.sender)] < 0:
                                                                revert with 0, 17
                                                            if balanceOf[this.address] > -1:
                                                                revert with 0, 17
                                                            if balanceOf[this.address] < balanceOf[this.address]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            balanceOf[address(this.address)] = balanceOf[this.address]
                                                            emit Transfer(0, msg.sender, this.address);
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not arg1:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            if arg2 > balanceOf[address(msg.sender)]:
                                                                revert with 0, 
                                                                            32,
                                                                            38,
                                                                            0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_5434 + (7 * ceil32(return_data.size)) + 646 len 26] >> 48,
                                                                            0
                                                            if balanceOf[address(msg.sender)] < arg2:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2
                                                            if balanceOf[arg1] > !arg2:
                                                                revert with 0, 17
                                                            if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                            emit Transfer(arg2, msg.sender, arg1);
                                                        else:
                                                            if arg2 and 1 > -1 / arg2:
                                                                revert with 0, 17
                                                            if not arg2:
                                                                revert with 0, 18
                                                            if arg2 / arg2 != 1:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if 0 > !(arg2 / 100):
                                                                revert with 0, 17
                                                            if arg2 / 100 > arg2:
                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                            if arg2 < arg2 / 100:
                                                                revert with 0, 17
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not this.address:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                                revert with 0, 
                                                                            32,
                                                                            38,
                                                                            0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_5434 + (7 * ceil32(return_data.size)) + 550 len 26] >> 48,
                                                                            0
                                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                                            if balanceOf[this.address] > !(arg2 / 100):
                                                                revert with 0, 17
                                                            if balanceOf[this.address] + (arg2 / 100) < balanceOf[this.address]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 100)
                                                            emit Transfer((arg2 / 100), msg.sender, this.address);
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not arg1:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            if arg2 - (arg2 / 100) > balanceOf[address(msg.sender)]:
                                                                revert with 0, 
                                                                            32,
                                                                            38,
                                                                            0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_5434 + (7 * ceil32(return_data.size)) + 646 len 26] >> 48,
                                                                            0
                                                            if balanceOf[address(msg.sender)] < arg2 - (arg2 / 100):
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - arg2 + (arg2 / 100)
                                                            if balanceOf[arg1] > !(arg2 - (arg2 / 100)):
                                                                revert with 0, 17
                                                            if balanceOf[arg1] + arg2 - (arg2 / 100) < balanceOf[arg1]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2 - (arg2 / 100)
                                                            emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                                else:
                                                    if arg2 and totalFees > -1 / arg2:
                                                        revert with 0, 17
                                                    if not arg2:
                                                        revert with 0, 18
                                                    if arg2 * totalFees / arg2 != totalFees:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not stor20[address(arg1)]:
                                                        if arg2 * totalFees / 100 > arg2:
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if arg2 < arg2 * totalFees / 100:
                                                            revert with 0, 17
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not this.address:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        if arg2 * totalFees / 100 > balanceOf[address(msg.sender)]:
                                                            revert with 0, 
                                                                        32,
                                                                        38,
                                                                        0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_5434 + (7 * ceil32(return_data.size)) + 486 len 26] >> 48,
                                                                        0
                                                        if balanceOf[address(msg.sender)] < arg2 * totalFees / 100:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] -= arg2 * totalFees / 100
                                                        if balanceOf[this.address] > !(arg2 * totalFees / 100):
                                                            revert with 0, 17
                                                        if balanceOf[this.address] + (arg2 * totalFees / 100) < balanceOf[this.address]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 * totalFees / 100)
                                                        emit Transfer((arg2 * totalFees / 100), msg.sender, this.address);
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not arg1:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        if arg2 - (arg2 * totalFees / 100) > balanceOf[address(msg.sender)]:
                                                            revert with 0, 
                                                                        32,
                                                                        38,
                                                                        0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_5434 + (7 * ceil32(return_data.size)) + 582 len 26] >> 48,
                                                                        0
                                                        if balanceOf[address(msg.sender)] < arg2 - (arg2 * totalFees / 100):
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - arg2 + (arg2 * totalFees / 100)
                                                        if balanceOf[arg1] > !(arg2 - (arg2 * totalFees / 100)):
                                                            revert with 0, 17
                                                        if balanceOf[arg1] + arg2 - (arg2 * totalFees / 100) < balanceOf[arg1]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(arg1)] = balanceOf[arg1] + arg2 - (arg2 * totalFees / 100)
                                                        emit Transfer((arg2 - (arg2 * totalFees / 100)), msg.sender, arg1);
                                                    else:
                                                        if not arg2:
                                                            if arg2 * totalFees / 100 > -1:
                                                                revert with 0, 17
                                                            if arg2 * totalFees / 100 > arg2:
                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                            if arg2 < arg2 * totalFees / 100:
                                                                revert with 0, 17
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not this.address:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            if arg2 * totalFees / 100 > balanceOf[address(msg.sender)]:
                                                                revert with 0, 
                                                                            32,
                                                                            38,
                                                                            0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_5434 + (7 * ceil32(return_data.size)) + 550 len 26] >> 48,
                                                                            0
                                                            if balanceOf[address(msg.sender)] < arg2 * totalFees / 100:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2 * totalFees / 100
                                                            if balanceOf[this.address] > !(arg2 * totalFees / 100):
                                                                revert with 0, 17
                                                            if balanceOf[this.address] + (arg2 * totalFees / 100) < balanceOf[this.address]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 * totalFees / 100)
                                                            emit Transfer((arg2 * totalFees / 100), msg.sender, this.address);
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not arg1:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            if arg2 - (arg2 * totalFees / 100) > balanceOf[address(msg.sender)]:
                                                                revert with 0, 
                                                                            32,
                                                                            38,
                                                                            0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_5434 + (7 * ceil32(return_data.size)) + 646 len 26] >> 48,
                                                                            0
                                                            if balanceOf[address(msg.sender)] < arg2 - (arg2 * totalFees / 100):
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - arg2 + (arg2 * totalFees / 100)
                                                            if balanceOf[arg1] > !(arg2 - (arg2 * totalFees / 100)):
                                                                revert with 0, 17
                                                            if balanceOf[arg1] + arg2 - (arg2 * totalFees / 100) < balanceOf[arg1]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2 - (arg2 * totalFees / 100)
                                                            emit Transfer((arg2 - (arg2 * totalFees / 100)), msg.sender, arg1);
                                                        else:
                                                            if arg2 and 1 > -1 / arg2:
                                                                revert with 0, 17
                                                            if not arg2:
                                                                revert with 0, 18
                                                            if arg2 / arg2 != 1:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if arg2 * totalFees / 100 > !(arg2 / 100):
                                                                revert with 0, 17
                                                            if (arg2 * totalFees / 100) + (arg2 / 100) > arg2:
                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                            if arg2 < (arg2 * totalFees / 100) + (arg2 / 100):
                                                                revert with 0, 17
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not this.address:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            if (arg2 * totalFees / 100) + (arg2 / 100) > balanceOf[address(msg.sender)]:
                                                                revert with 0, 
                                                                            32,
                                                                            38,
                                                                            0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_5434 + (7 * ceil32(return_data.size)) + 550 len 26] >> 48,
                                                                            0
                                                            if balanceOf[address(msg.sender)] < (arg2 * totalFees / 100) + (arg2 / 100):
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - (arg2 * totalFees / 100) - (arg2 / 100)
                                                            if balanceOf[this.address] > !((arg2 * totalFees / 100) + (arg2 / 100)):
                                                                revert with 0, 17
                                                            if balanceOf[this.address] + (arg2 * totalFees / 100) + (arg2 / 100) < balanceOf[this.address]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 * totalFees / 100) + (arg2 / 100)
                                                            emit Transfer(((arg2 * totalFees / 100) + (arg2 / 100)), msg.sender, this.address);
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not arg1:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            if arg2 - (arg2 * totalFees / 100) - (arg2 / 100) > balanceOf[address(msg.sender)]:
                                                                revert with 0, 
                                                                            32,
                                                                            38,
                                                                            0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_5434 + (7 * ceil32(return_data.size)) + 646 len 26] >> 48,
                                                                            0
                                                            if balanceOf[address(msg.sender)] < arg2 - (arg2 * totalFees / 100) - (arg2 / 100):
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - arg2 + (arg2 * totalFees / 100) + (arg2 / 100)
                                                            if balanceOf[arg1] > !(arg2 - (arg2 * totalFees / 100) - (arg2 / 100)):
                                                                revert with 0, 17
                                                            if balanceOf[arg1] + arg2 - (arg2 * totalFees / 100) - (arg2 / 100) < balanceOf[arg1]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2 - (arg2 * totalFees / 100) - (arg2 / 100)
                                                            emit Transfer((arg2 - (arg2 * totalFees / 100) - (arg2 / 100)), msg.sender, arg1);
                                    require ext_code.size(dividendTrackerAddress)
                                    call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args msg.sender, balanceOf[address(msg.sender)]
                                    require ext_code.size(dividendTrackerAddress)
                                    call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args address(arg1), balanceOf[address(arg1)]
                                    if not stor7:
                                        call dividendTrackerAddress.process(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args gasForProcessing
                                        if ext_call.success:
                                            require return_data.size >= 96
                                            emit ProcessedDividendTracker(ext_call.return_data[0], ext_call.return_data[32], ext_call.return_data[64], gasForProcessing, 1, tx.origin);
                                else:
                                    _5368 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5368] = 26
                                    mem[_5368 + 32] = 'SafeMath: division by zero'
                                    if not totalFees:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    _5389 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5389] = 26
                                    mem[_5389 + 32] = 'SafeMath: division by zero'
                                    _5400 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5400] = 30
                                    mem[_5400 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 / totalFees / 2 > 0 / totalFees:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 / totalFees < 0 / totalFees / 2:
                                        revert with 0, 17
                                    _5413 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    mem[_5413 + 32 len 64] = call.data[calldata.size len 64]
                                    if 0 >= mem[_5413]:
                                        revert with 0, 50
                                    mem[_5413 + 32] = this.address
                                    staticcall uniswapV2RouterAddress.WETH() with:
                                            gas gas_remaining wei
                                    mem[_5413 + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _5413 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if 1 >= mem[_5413]:
                                        revert with 0, 50
                                    mem[_5413 + 64] = ext_call.return_data[12 len 20]
                                    if not this.address:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not uniswapV2RouterAddress:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    mem[0] = uniswapV2RouterAddress
                                    mem[32] = sha3(address(this.address), 1)
                                    allowance[address(this.address)][stor6].field_0 = 0 / totalFees / 2
                                    allowance[address(this.address)][stor6].field_255 = 0
                                    emit Approval((0 / totalFees / 2), this.address, uniswapV2RouterAddress);
                                    mem[_5413 + ceil32(return_data.size) + 96] = 0x791ac94700000000000000000000000000000000000000000000000000000000
                                    mem[_5413 + ceil32(return_data.size) + 100] = 0 / totalFees / 2
                                    mem[_5413 + ceil32(return_data.size) + 132] = 0
                                    mem[_5413 + ceil32(return_data.size) + 164] = 160
                                    mem[_5413 + ceil32(return_data.size) + 260] = mem[_5413]
                                    idx = 0
                                    s = _5413 + ceil32(return_data.size) + 292
                                    t = _5413 + 32
                                    while idx < mem[_5413]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args Mask(255, 1, 0 / totalFees), 0, 160, address(this.address), block.timestamp, mem[_5413 + ceil32(return_data.size) + 260 len (32 * mem[_5413]) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_5413 + ceil32(return_data.size) + 96] = 30
                                    mem[_5413 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                    if eth.balance(this.address) > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if eth.balance(this.address) < eth.balance(this.address):
                                        revert with 0, 17
                                    if not this.address:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not uniswapV2RouterAddress:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(this.address)][stor6].field_0 = (0 / totalFees) - (0 / totalFees / 2)
                                    emit Approval(((0 / totalFees) - (0 / totalFees / 2)), this.address, uniswapV2RouterAddress);
                                    mem[_5413 + ceil32(return_data.size) + 228] = 0
                                    mem[_5413 + ceil32(return_data.size) + 260] = 0
                                    mem[_5413 + ceil32(return_data.size) + 292] = stor17
                                    mem[_5413 + ceil32(return_data.size) + 324] = block.timestamp
                                    call uniswapV2RouterAddress.addLiquidityETH(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                         gas gas_remaining wei
                                        args this.address, (0 / totalFees) - (0 / totalFees / 2), 0, 0, stor17, block.timestamp
                                    mem[_5413 + ceil32(return_data.size) + 160 len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 96
                                    emit SwapAndLiquify(Mask(255, 1, 0 / totalFees), 0, (0 / totalFees) - (0 / totalFees / 2));
                                    mem[_5413 + (2 * ceil32(return_data.size)) + 160] = 3
                                    mem[_5413 + (2 * ceil32(return_data.size)) + 192] = this.address
                                    staticcall uniswapV2RouterAddress.WETH() with:
                                            gas gas_remaining wei
                                    mem[_5413 + (2 * ceil32(return_data.size)) + 288] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    mem[_5413 + (2 * ceil32(return_data.size)) + 224] = ext_call.return_data[12 len 20]
                                    mem[_5413 + (2 * ceil32(return_data.size)) + 256] = sub_4d7effddAddress
                                    if not this.address:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not uniswapV2RouterAddress:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(this.address)][stor6].field_0 = balanceOf[this.address]
                                    emit Approval(balanceOf[this.address], this.address, uniswapV2RouterAddress);
                                    mem[_5413 + (4 * ceil32(return_data.size)) + 288] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                    mem[_5413 + (4 * ceil32(return_data.size)) + 292] = balanceOf[this.address]
                                    mem[_5413 + (4 * ceil32(return_data.size)) + 324] = 0
                                    mem[_5413 + (4 * ceil32(return_data.size)) + 356] = 160
                                    mem[_5413 + (4 * ceil32(return_data.size)) + 452] = 3
                                    idx = 0
                                    s = _5413 + (4 * ceil32(return_data.size)) + 484
                                    t = _5413 + (2 * ceil32(return_data.size)) + 192
                                    while idx < mem[_5413 + (2 * ceil32(return_data.size)) + 160]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5413 + (4 * ceil32(return_data.size)) + 388] = this.address
                                    mem[_5413 + (4 * ceil32(return_data.size)) + 420] = block.timestamp
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args balanceOf[this.address], 0, 160, address(this.address), block.timestamp, mem[_5413 + (4 * ceil32(return_data.size)) + 452 len (32 * mem[_5413 + (2 * ceil32(return_data.size)) + 160]) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    staticcall sub_4d7effddAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    require return_data.size >= 32
                                    mem[_5413 + (4 * ceil32(return_data.size)) + 292] = dividendTrackerAddress
                                    mem[_5413 + (4 * ceil32(return_data.size)) + 324] = ext_call.return_data[0]
                                    call sub_4d7effddAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args mem[_5413 + (4 * ceil32(return_data.size)) + 292 len (7 * ceil32(return_data.size)) + 64]
                                    mem[_5413 + (4 * ceil32(return_data.size)) + 288] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    if ext_call.return_data[0]:
                                        require ext_code.size(dividendTrackerAddress)
                                        call dividendTrackerAddress.distributeDogeDividends(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        emit SendDividends(balanceOf[this.address], ext_call.return_data[0]);
                                    stor7 = 0
                                    if stor19[address(msg.sender)]:
                                        if not msg.sender:
                                            mem[_5413 + (8 * ceil32(return_data.size)) + 288] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_5413 + (8 * ceil32(return_data.size)) + 292] = 32
                                            mem[_5413 + (8 * ceil32(return_data.size)) + 324] = 37
                                            mem[_5413 + (8 * ceil32(return_data.size)) + 356] = 'ERC20: transfer from the zero ad'
                                            mem[_5413 + (8 * ceil32(return_data.size)) + 388] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                            revert with memory
                                              from _5413 + (8 * ceil32(return_data.size)) + 288
                                               len (13 * ceil32(return_data.size)) + 132
                                        if not arg1:
                                            mem[_5413 + (8 * ceil32(return_data.size)) + 288] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_5413 + (8 * ceil32(return_data.size)) + 292] = 32
                                            mem[_5413 + (8 * ceil32(return_data.size)) + 324] = 35
                                            mem[_5413 + (8 * ceil32(return_data.size)) + 356] = 'ERC20: transfer to the zero addr'
                                            mem[_5413 + (8 * ceil32(return_data.size)) + 388] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                            revert with memory
                                              from _5413 + (8 * ceil32(return_data.size)) + 288
                                               len (13 * ceil32(return_data.size)) + 132
                                        if arg2 > balanceOf[address(msg.sender)]:
                                            mem[_5413 + (8 * ceil32(return_data.size)) + 384] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_5413 + (8 * ceil32(return_data.size)) + 388] = 32
                                            mem[_5413 + (8 * ceil32(return_data.size)) + 420] = 38
                                            mem[_5413 + (8 * ceil32(return_data.size)) + 452 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_5413 + (8 * ceil32(return_data.size)) + 358 len 26]
                                            mem[_5413 + (8 * ceil32(return_data.size)) + 490] = 0
                                            revert with memory
                                              from _5413 + (8 * ceil32(return_data.size)) + 384
                                               len (13 * ceil32(return_data.size)) + 132
                                        if balanceOf[address(msg.sender)] < arg2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2
                                        if balanceOf[arg1] > !arg2:
                                            revert with 0, 17
                                        if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                            mem[_5413 + (8 * ceil32(return_data.size)) + 384] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_5413 + (8 * ceil32(return_data.size)) + 388] = 32
                                            mem[_5413 + (8 * ceil32(return_data.size)) + 420] = 27
                                            mem[_5413 + (8 * ceil32(return_data.size)) + 452] = 'SafeMath: addition overflow'
                                            revert with memory
                                              from _5413 + (8 * ceil32(return_data.size)) + 384
                                               len (13 * ceil32(return_data.size)) + 100
                                        balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                        emit Transfer(arg2, msg.sender, arg1);
                                        mem[_5413 + (8 * ceil32(return_data.size)) + 388] = msg.sender
                                        mem[_5413 + (8 * ceil32(return_data.size)) + 420] = balanceOf[address(msg.sender)]
                                        require ext_code.size(dividendTrackerAddress)
                                        call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                             gas gas_remaining wei
                                            args mem[_5413 + (8 * ceil32(return_data.size)) + 388 len (13 * ceil32(return_data.size)) + 64]
                                        mem[_5413 + (8 * ceil32(return_data.size)) + 388] = arg1
                                        mem[_5413 + (8 * ceil32(return_data.size)) + 420] = balanceOf[address(arg1)]
                                        require ext_code.size(dividendTrackerAddress)
                                        call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                             gas gas_remaining wei
                                            args mem[_5413 + (8 * ceil32(return_data.size)) + 388 len (13 * ceil32(return_data.size)) + 64]
                                        if not stor7:
                                            call dividendTrackerAddress.process(uint256 arg1) with:
                                                 gas gas_remaining wei
                                                args gasForProcessing
                                            if ext_call.success:
                                                require return_data.size >= 96
                                                emit ProcessedDividendTracker(uint256 arg1, uint256 arg2, uint256 arg3, bool arg4, uint256 arg5, address arg6):
                                                                              ext_call.return_data[0],
                                                                              ext_call.return_data[32],
                                                                              ext_call.return_data[64],
                                                                              gasForProcessing,
                                                                              mem[_5413 + (9 * ceil32(return_data.size)) + 512 len 5 * ceil32(return_data.size)],
                                                                              1,
                                                                              tx.origin,
                                    else:
                                        if stor19[address(arg1)]:
                                            if not msg.sender:
                                                mem[_5413 + (8 * ceil32(return_data.size)) + 288] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[_5413 + (8 * ceil32(return_data.size)) + 292] = 32
                                                mem[_5413 + (8 * ceil32(return_data.size)) + 324] = 37
                                                mem[_5413 + (8 * ceil32(return_data.size)) + 356] = 'ERC20: transfer from the zero ad'
                                                mem[_5413 + (8 * ceil32(return_data.size)) + 388] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                revert with memory
                                                  from _5413 + (8 * ceil32(return_data.size)) + 288
                                                   len (13 * ceil32(return_data.size)) + 132
                                            if not arg1:
                                                mem[_5413 + (8 * ceil32(return_data.size)) + 288] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[_5413 + (8 * ceil32(return_data.size)) + 292] = 32
                                                mem[_5413 + (8 * ceil32(return_data.size)) + 324] = 35
                                                mem[_5413 + (8 * ceil32(return_data.size)) + 356] = 'ERC20: transfer to the zero addr'
                                                mem[_5413 + (8 * ceil32(return_data.size)) + 388] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                revert with memory
                                                  from _5413 + (8 * ceil32(return_data.size)) + 288
                                                   len (13 * ceil32(return_data.size)) + 132
                                            if arg2 > balanceOf[address(msg.sender)]:
                                                mem[_5413 + (8 * ceil32(return_data.size)) + 384] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[_5413 + (8 * ceil32(return_data.size)) + 388] = 32
                                                mem[_5413 + (8 * ceil32(return_data.size)) + 420] = 38
                                                mem[_5413 + (8 * ceil32(return_data.size)) + 452 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_5413 + (8 * ceil32(return_data.size)) + 358 len 26]
                                                mem[_5413 + (8 * ceil32(return_data.size)) + 490] = 0
                                                revert with memory
                                                  from _5413 + (8 * ceil32(return_data.size)) + 384
                                                   len (13 * ceil32(return_data.size)) + 132
                                            if balanceOf[address(msg.sender)] < arg2:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2
                                            if balanceOf[arg1] > !arg2:
                                                revert with 0, 17
                                            if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                mem[_5413 + (8 * ceil32(return_data.size)) + 384] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[_5413 + (8 * ceil32(return_data.size)) + 388] = 32
                                                mem[_5413 + (8 * ceil32(return_data.size)) + 420] = 27
                                                mem[_5413 + (8 * ceil32(return_data.size)) + 452] = 'SafeMath: addition overflow'
                                                revert with memory
                                                  from _5413 + (8 * ceil32(return_data.size)) + 384
                                                   len (13 * ceil32(return_data.size)) + 100
                                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                            emit Transfer(arg2, msg.sender, arg1);
                                            mem[_5413 + (8 * ceil32(return_data.size)) + 388] = msg.sender
                                            mem[_5413 + (8 * ceil32(return_data.size)) + 420] = balanceOf[address(msg.sender)]
                                            require ext_code.size(dividendTrackerAddress)
                                            call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args mem[_5413 + (8 * ceil32(return_data.size)) + 388 len (13 * ceil32(return_data.size)) + 64]
                                            mem[_5413 + (8 * ceil32(return_data.size)) + 388] = arg1
                                            mem[_5413 + (8 * ceil32(return_data.size)) + 420] = balanceOf[address(arg1)]
                                            require ext_code.size(dividendTrackerAddress)
                                            call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args mem[_5413 + (8 * ceil32(return_data.size)) + 388 len (13 * ceil32(return_data.size)) + 64]
                                            if not stor7:
                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                     gas gas_remaining wei
                                                    args gasForProcessing
                                                if ext_call.success:
                                                    require return_data.size >= 96
                                                    emit ProcessedDividendTracker(uint256 arg1, uint256 arg2, uint256 arg3, bool arg4, uint256 arg5, address arg6):
                                                                                  ext_call.return_data[0],
                                                                                  ext_call.return_data[32],
                                                                                  ext_call.return_data[64],
                                                                                  gasForProcessing,
                                                                                  mem[_5413 + (9 * ceil32(return_data.size)) + 512 len 5 * ceil32(return_data.size)],
                                                                                  1,
                                                                                  tx.origin,
                                        else:
                                            if stor7:
                                                if not msg.sender:
                                                    mem[_5413 + (8 * ceil32(return_data.size)) + 288] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_5413 + (8 * ceil32(return_data.size)) + 292] = 32
                                                    mem[_5413 + (8 * ceil32(return_data.size)) + 324] = 37
                                                    mem[_5413 + (8 * ceil32(return_data.size)) + 356] = 'ERC20: transfer from the zero ad'
                                                    mem[_5413 + (8 * ceil32(return_data.size)) + 388] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                    revert with memory
                                                      from _5413 + (8 * ceil32(return_data.size)) + 288
                                                       len (13 * ceil32(return_data.size)) + 132
                                                if not arg1:
                                                    mem[_5413 + (8 * ceil32(return_data.size)) + 288] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_5413 + (8 * ceil32(return_data.size)) + 292] = 32
                                                    mem[_5413 + (8 * ceil32(return_data.size)) + 324] = 35
                                                    mem[_5413 + (8 * ceil32(return_data.size)) + 356] = 'ERC20: transfer to the zero addr'
                                                    mem[_5413 + (8 * ceil32(return_data.size)) + 388] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                    revert with memory
                                                      from _5413 + (8 * ceil32(return_data.size)) + 288
                                                       len (13 * ceil32(return_data.size)) + 132
                                                if arg2 > balanceOf[address(msg.sender)]:
                                                    mem[_5413 + (8 * ceil32(return_data.size)) + 384] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_5413 + (8 * ceil32(return_data.size)) + 388] = 32
                                                    mem[_5413 + (8 * ceil32(return_data.size)) + 420] = 38
                                                    mem[_5413 + (8 * ceil32(return_data.size)) + 452 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_5413 + (8 * ceil32(return_data.size)) + 358 len 26]
                                                    mem[_5413 + (8 * ceil32(return_data.size)) + 490] = 0
                                                    revert with memory
                                                      from _5413 + (8 * ceil32(return_data.size)) + 384
                                                       len (13 * ceil32(return_data.size)) + 132
                                                if balanceOf[address(msg.sender)] < arg2:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= arg2
                                                if balanceOf[arg1] > !arg2:
                                                    revert with 0, 17
                                                if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                    mem[_5413 + (8 * ceil32(return_data.size)) + 384] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_5413 + (8 * ceil32(return_data.size)) + 388] = 32
                                                    mem[_5413 + (8 * ceil32(return_data.size)) + 420] = 27
                                                    mem[_5413 + (8 * ceil32(return_data.size)) + 452] = 'SafeMath: addition overflow'
                                                    revert with memory
                                                      from _5413 + (8 * ceil32(return_data.size)) + 384
                                                       len (13 * ceil32(return_data.size)) + 100
                                                balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                emit Transfer(arg2, msg.sender, arg1);
                                                mem[_5413 + (8 * ceil32(return_data.size)) + 388] = msg.sender
                                                mem[_5413 + (8 * ceil32(return_data.size)) + 420] = balanceOf[address(msg.sender)]
                                                require ext_code.size(dividendTrackerAddress)
                                                call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args mem[_5413 + (8 * ceil32(return_data.size)) + 388 len (13 * ceil32(return_data.size)) + 64]
                                                mem[_5413 + (8 * ceil32(return_data.size)) + 388] = arg1
                                                mem[_5413 + (8 * ceil32(return_data.size)) + 420] = balanceOf[address(arg1)]
                                                require ext_code.size(dividendTrackerAddress)
                                                call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args mem[_5413 + (8 * ceil32(return_data.size)) + 388 len (13 * ceil32(return_data.size)) + 64]
                                                if not stor7:
                                                    call dividendTrackerAddress.process(uint256 arg1) with:
                                                         gas gas_remaining wei
                                                        args gasForProcessing
                                                    if ext_call.success:
                                                        require return_data.size >= 96
                                                        emit ProcessedDividendTracker(uint256 arg1, uint256 arg2, uint256 arg3, bool arg4, uint256 arg5, address arg6):
                                                                                      ext_call.return_data[0],
                                                                                      ext_call.return_data[32],
                                                                                      ext_call.return_data[64],
                                                                                      gasForProcessing,
                                                                                      mem[_5413 + (9 * ceil32(return_data.size)) + 512 len 5 * ceil32(return_data.size)],
                                                                                      1,
                                                                                      tx.origin,
                                            else:
                                                if not arg2:
                                                    if not stor20[address(arg1)]:
                                                        if 0 > arg2:
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 420] = 32
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 452] = 30
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 484] = 'SafeMath: subtraction overflow'
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 514] = 0
                                                            revert with memory
                                                              from _5413 + (8 * ceil32(return_data.size)) + 416
                                                               len (13 * ceil32(return_data.size)) + 100
                                                        if arg2 < 0:
                                                            revert with 0, 17
                                                        if not msg.sender:
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 420] = 32
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 452] = 37
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 484] = 'ERC20: transfer from the zero ad'
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 516] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                            revert with memory
                                                              from _5413 + (8 * ceil32(return_data.size)) + 416
                                                               len (13 * ceil32(return_data.size)) + 132
                                                        if not this.address:
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 420] = 32
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 452] = 35
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 484] = 'ERC20: transfer to the zero addr'
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 516] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                            revert with memory
                                                              from _5413 + (8 * ceil32(return_data.size)) + 416
                                                               len (13 * ceil32(return_data.size)) + 132
                                                        if 0 > balanceOf[address(msg.sender)]:
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 512] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 516] = 32
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 548] = 38
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 580 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_5413 + (8 * ceil32(return_data.size)) + 486 len 26]
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 618] = 0
                                                            revert with memory
                                                              from _5413 + (8 * ceil32(return_data.size)) + 512
                                                               len (13 * ceil32(return_data.size)) + 132
                                                        if balanceOf[address(msg.sender)] < 0:
                                                            revert with 0, 17
                                                        if balanceOf[this.address] > -1:
                                                            revert with 0, 17
                                                        if balanceOf[this.address] < balanceOf[this.address]:
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 512] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 516] = 32
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 548] = 27
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 580] = 'SafeMath: addition overflow'
                                                            revert with memory
                                                              from _5413 + (8 * ceil32(return_data.size)) + 512
                                                               len (13 * ceil32(return_data.size)) + 100
                                                        balanceOf[address(this.address)] = balanceOf[this.address]
                                                        emit Transfer(0, msg.sender, this.address);
                                                        if not msg.sender:
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 512] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 516] = 32
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 548] = 37
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 580] = 'ERC20: transfer from the zero ad'
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 612] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                            revert with memory
                                                              from _5413 + (8 * ceil32(return_data.size)) + 512
                                                               len (13 * ceil32(return_data.size)) + 132
                                                        if not arg1:
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 512] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 516] = 32
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 548] = 35
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 580] = 'ERC20: transfer to the zero addr'
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 612] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                            revert with memory
                                                              from _5413 + (8 * ceil32(return_data.size)) + 512
                                                               len (13 * ceil32(return_data.size)) + 132
                                                        if arg2 > balanceOf[address(msg.sender)]:
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 608] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 612] = 32
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 644] = 38
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 676 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_5413 + (8 * ceil32(return_data.size)) + 582 len 26]
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 714] = 0
                                                            revert with memory
                                                              from _5413 + (8 * ceil32(return_data.size)) + 608
                                                               len (13 * ceil32(return_data.size)) + 132
                                                        if balanceOf[address(msg.sender)] < arg2:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] -= arg2
                                                        if balanceOf[arg1] > !arg2:
                                                            revert with 0, 17
                                                        if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 608] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 612] = 32
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 644] = 27
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 676] = 'SafeMath: addition overflow'
                                                            revert with memory
                                                              from _5413 + (8 * ceil32(return_data.size)) + 608
                                                               len (13 * ceil32(return_data.size)) + 100
                                                        balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                        emit Transfer(arg2, msg.sender, arg1);
                                                        mem[_5413 + (8 * ceil32(return_data.size)) + 612] = msg.sender
                                                        mem[_5413 + (8 * ceil32(return_data.size)) + 644] = balanceOf[address(msg.sender)]
                                                        require ext_code.size(dividendTrackerAddress)
                                                        call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args mem[_5413 + (8 * ceil32(return_data.size)) + 612 len (13 * ceil32(return_data.size)) + 64]
                                                        mem[_5413 + (8 * ceil32(return_data.size)) + 612] = arg1
                                                        mem[_5413 + (8 * ceil32(return_data.size)) + 644] = balanceOf[address(arg1)]
                                                        require ext_code.size(dividendTrackerAddress)
                                                        call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args mem[_5413 + (8 * ceil32(return_data.size)) + 612 len (13 * ceil32(return_data.size)) + 64]
                                                        if not stor7:
                                                            call dividendTrackerAddress.process(uint256 arg1) with:
                                                                 gas gas_remaining wei
                                                                args gasForProcessing
                                                            if ext_call.success:
                                                                require return_data.size >= 96
                                                                emit ProcessedDividendTracker(uint256 arg1, uint256 arg2, uint256 arg3, bool arg4, uint256 arg5, address arg6):
                                                                                              ext_call.return_data[0],
                                                                                              ext_call.return_data[32],
                                                                                              ext_call.return_data[64],
                                                                                              gasForProcessing,
                                                                                              mem[_5413 + (9 * ceil32(return_data.size)) + 736 len 5 * ceil32(return_data.size)],
                                                                                              1,
                                                                                              tx.origin,
                                                    else:
                                                        if not arg2:
                                                            if 0 > arg2:
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 480] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 484] = 32
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 516] = 30
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 548] = 'SafeMath: subtraction overflow'
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 578] = 0
                                                                revert with memory
                                                                  from _5413 + (8 * ceil32(return_data.size)) + 480
                                                                   len (13 * ceil32(return_data.size)) + 100
                                                            if arg2 < 0:
                                                                revert with 0, 17
                                                            if not msg.sender:
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 480] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 484] = 32
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 516] = 37
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 548] = 'ERC20: transfer from the zero ad'
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 580] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                                revert with memory
                                                                  from _5413 + (8 * ceil32(return_data.size)) + 480
                                                                   len (13 * ceil32(return_data.size)) + 132
                                                            if not this.address:
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 480] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 484] = 32
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 516] = 35
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 548] = 'ERC20: transfer to the zero addr'
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 580] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                                revert with memory
                                                                  from _5413 + (8 * ceil32(return_data.size)) + 480
                                                                   len (13 * ceil32(return_data.size)) + 132
                                                            if 0 > balanceOf[address(msg.sender)]:
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 576] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 580] = 32
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 612] = 38
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 644 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_5413 + (8 * ceil32(return_data.size)) + 550 len 26]
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 682] = 0
                                                                revert with memory
                                                                  from _5413 + (8 * ceil32(return_data.size)) + 576
                                                                   len (13 * ceil32(return_data.size)) + 132
                                                            if balanceOf[address(msg.sender)] < 0:
                                                                revert with 0, 17
                                                            if balanceOf[this.address] > -1:
                                                                revert with 0, 17
                                                            if balanceOf[this.address] < balanceOf[this.address]:
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 576] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 580] = 32
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 612] = 27
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 644] = 'SafeMath: addition overflow'
                                                                revert with memory
                                                                  from _5413 + (8 * ceil32(return_data.size)) + 576
                                                                   len (13 * ceil32(return_data.size)) + 100
                                                            balanceOf[address(this.address)] = balanceOf[this.address]
                                                            emit Transfer(0, msg.sender, this.address);
                                                            if not msg.sender:
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 576] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 580] = 32
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 612] = 37
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 644] = 'ERC20: transfer from the zero ad'
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 676] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                                revert with memory
                                                                  from _5413 + (8 * ceil32(return_data.size)) + 576
                                                                   len (13 * ceil32(return_data.size)) + 132
                                                            if not arg1:
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 576] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 580] = 32
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 612] = 35
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 644] = 'ERC20: transfer to the zero addr'
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 676] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                                revert with memory
                                                                  from _5413 + (8 * ceil32(return_data.size)) + 576
                                                                   len (13 * ceil32(return_data.size)) + 132
                                                            if arg2 > balanceOf[address(msg.sender)]:
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 672] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 676] = 32
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 708] = 38
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 740 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_5413 + (8 * ceil32(return_data.size)) + 646 len 26]
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 778] = 0
                                                                revert with memory
                                                                  from _5413 + (8 * ceil32(return_data.size)) + 672
                                                                   len (13 * ceil32(return_data.size)) + 132
                                                            if balanceOf[address(msg.sender)] < arg2:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2
                                                            if balanceOf[arg1] > !arg2:
                                                                revert with 0, 17
                                                            if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 672] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 676] = 32
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 708] = 27
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 740] = 'SafeMath: addition overflow'
                                                                revert with memory
                                                                  from _5413 + (8 * ceil32(return_data.size)) + 672
                                                                   len (13 * ceil32(return_data.size)) + 100
                                                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                            emit Transfer(arg2, msg.sender, arg1);
                                                        else:
                                                            if arg2 and 1 > -1 / arg2:
                                                                revert with 0, 17
                                                            if not arg2:
                                                                revert with 0, 18
                                                            if arg2 / arg2 != 1:
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 352] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 356] = 32
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 388] = 33
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 420] = 'SafeMath: multiplication overflo'
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 452] = 0x7700000000000000000000000000000000000000000000000000000000000000
                                                                revert with memory
                                                                  from _5413 + (8 * ceil32(return_data.size)) + 352
                                                                   len (13 * ceil32(return_data.size)) + 132
                                                            if 0 > !(arg2 / 100):
                                                                revert with 0, 17
                                                            if arg2 / 100 > arg2:
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 480] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 484] = 32
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 516] = 30
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 548] = 'SafeMath: subtraction overflow'
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 578] = 0
                                                                revert with memory
                                                                  from _5413 + (8 * ceil32(return_data.size)) + 480
                                                                   len (13 * ceil32(return_data.size)) + 100
                                                            if arg2 < arg2 / 100:
                                                                revert with 0, 17
                                                            if not msg.sender:
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 480] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 484] = 32
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 516] = 37
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 548] = 'ERC20: transfer from the zero ad'
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 580] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                                revert with memory
                                                                  from _5413 + (8 * ceil32(return_data.size)) + 480
                                                                   len (13 * ceil32(return_data.size)) + 132
                                                            if not this.address:
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 480] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 484] = 32
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 516] = 35
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 548] = 'ERC20: transfer to the zero addr'
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 580] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                                revert with memory
                                                                  from _5413 + (8 * ceil32(return_data.size)) + 480
                                                                   len (13 * ceil32(return_data.size)) + 132
                                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 576] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 580] = 32
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 612] = 38
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 644 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_5413 + (8 * ceil32(return_data.size)) + 550 len 26]
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 682] = 0
                                                                revert with memory
                                                                  from _5413 + (8 * ceil32(return_data.size)) + 576
                                                                   len (13 * ceil32(return_data.size)) + 132
                                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                                            if balanceOf[this.address] > !(arg2 / 100):
                                                                revert with 0, 17
                                                            if balanceOf[this.address] + (arg2 / 100) < balanceOf[this.address]:
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 576] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 580] = 32
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 612] = 27
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 644] = 'SafeMath: addition overflow'
                                                                revert with memory
                                                                  from _5413 + (8 * ceil32(return_data.size)) + 576
                                                                   len (13 * ceil32(return_data.size)) + 100
                                                            balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 100)
                                                            emit Transfer((arg2 / 100), msg.sender, this.address);
                                                            if not msg.sender:
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 576] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 580] = 32
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 612] = 37
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 644] = 'ERC20: transfer from the zero ad'
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 676] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                                revert with memory
                                                                  from _5413 + (8 * ceil32(return_data.size)) + 576
                                                                   len (13 * ceil32(return_data.size)) + 132
                                                            if not arg1:
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 576] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 580] = 32
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 612] = 35
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 644] = 'ERC20: transfer to the zero addr'
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 676] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                                revert with memory
                                                                  from _5413 + (8 * ceil32(return_data.size)) + 576
                                                                   len (13 * ceil32(return_data.size)) + 132
                                                            if arg2 - (arg2 / 100) > balanceOf[address(msg.sender)]:
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 672] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 676] = 32
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 708] = 38
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 740 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_5413 + (8 * ceil32(return_data.size)) + 646 len 26]
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 778] = 0
                                                                revert with memory
                                                                  from _5413 + (8 * ceil32(return_data.size)) + 672
                                                                   len (13 * ceil32(return_data.size)) + 132
                                                            if balanceOf[address(msg.sender)] < arg2 - (arg2 / 100):
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - arg2 + (arg2 / 100)
                                                            if balanceOf[arg1] > !(arg2 - (arg2 / 100)):
                                                                revert with 0, 17
                                                            if balanceOf[arg1] + arg2 - (arg2 / 100) < balanceOf[arg1]:
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 672] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 676] = 32
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 708] = 27
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 740] = 'SafeMath: addition overflow'
                                                                revert with memory
                                                                  from _5413 + (8 * ceil32(return_data.size)) + 672
                                                                   len (13 * ceil32(return_data.size)) + 100
                                                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2 - (arg2 / 100)
                                                            emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                                        mem[_5413 + (8 * ceil32(return_data.size)) + 676] = msg.sender
                                                        mem[_5413 + (8 * ceil32(return_data.size)) + 708] = balanceOf[address(msg.sender)]
                                                        require ext_code.size(dividendTrackerAddress)
                                                        call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args mem[_5413 + (8 * ceil32(return_data.size)) + 676 len (13 * ceil32(return_data.size)) + 64]
                                                        mem[_5413 + (8 * ceil32(return_data.size)) + 676] = arg1
                                                        mem[_5413 + (8 * ceil32(return_data.size)) + 708] = balanceOf[address(arg1)]
                                                        require ext_code.size(dividendTrackerAddress)
                                                        call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args mem[_5413 + (8 * ceil32(return_data.size)) + 676 len (13 * ceil32(return_data.size)) + 64]
                                                        if not stor7:
                                                            call dividendTrackerAddress.process(uint256 arg1) with:
                                                                 gas gas_remaining wei
                                                                args gasForProcessing
                                                            if ext_call.success:
                                                                require return_data.size >= 96
                                                                emit ProcessedDividendTracker(uint256 arg1, uint256 arg2, uint256 arg3, bool arg4, uint256 arg5, address arg6):
                                                                                              ext_call.return_data[0],
                                                                                              ext_call.return_data[32],
                                                                                              ext_call.return_data[64],
                                                                                              gasForProcessing,
                                                                                              mem[_5413 + (9 * ceil32(return_data.size)) + 800 len 5 * ceil32(return_data.size)],
                                                                                              1,
                                                                                              tx.origin,
                                                else:
                                                    if arg2 and totalFees > -1 / arg2:
                                                        revert with 0, 17
                                                    if not arg2:
                                                        revert with 0, 18
                                                    if arg2 * totalFees / arg2 != totalFees:
                                                        mem[_5413 + (8 * ceil32(return_data.size)) + 288] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_5413 + (8 * ceil32(return_data.size)) + 292] = 32
                                                        mem[_5413 + (8 * ceil32(return_data.size)) + 324] = 33
                                                        mem[_5413 + (8 * ceil32(return_data.size)) + 356] = 'SafeMath: multiplication overflo'
                                                        mem[_5413 + (8 * ceil32(return_data.size)) + 388] = 0x7700000000000000000000000000000000000000000000000000000000000000
                                                        revert with memory
                                                          from _5413 + (8 * ceil32(return_data.size)) + 288
                                                           len (13 * ceil32(return_data.size)) + 132
                                                    if not stor20[address(arg1)]:
                                                        if arg2 * totalFees / 100 > arg2:
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 420] = 32
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 452] = 30
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 484] = 'SafeMath: subtraction overflow'
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 514] = 0
                                                            revert with memory
                                                              from _5413 + (8 * ceil32(return_data.size)) + 416
                                                               len (13 * ceil32(return_data.size)) + 100
                                                        if arg2 < arg2 * totalFees / 100:
                                                            revert with 0, 17
                                                        if not msg.sender:
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 420] = 32
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 452] = 37
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 484] = 'ERC20: transfer from the zero ad'
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 516] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                            revert with memory
                                                              from _5413 + (8 * ceil32(return_data.size)) + 416
                                                               len (13 * ceil32(return_data.size)) + 132
                                                        if not this.address:
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 420] = 32
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 452] = 35
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 484] = 'ERC20: transfer to the zero addr'
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 516] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                            revert with memory
                                                              from _5413 + (8 * ceil32(return_data.size)) + 416
                                                               len (13 * ceil32(return_data.size)) + 132
                                                        if arg2 * totalFees / 100 > balanceOf[address(msg.sender)]:
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 512] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 516] = 32
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 548] = 38
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 580 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_5413 + (8 * ceil32(return_data.size)) + 486 len 26]
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 618] = 0
                                                            revert with memory
                                                              from _5413 + (8 * ceil32(return_data.size)) + 512
                                                               len (13 * ceil32(return_data.size)) + 132
                                                        if balanceOf[address(msg.sender)] < arg2 * totalFees / 100:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] -= arg2 * totalFees / 100
                                                        if balanceOf[this.address] > !(arg2 * totalFees / 100):
                                                            revert with 0, 17
                                                        if balanceOf[this.address] + (arg2 * totalFees / 100) < balanceOf[this.address]:
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 512] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 516] = 32
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 548] = 27
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 580] = 'SafeMath: addition overflow'
                                                            revert with memory
                                                              from _5413 + (8 * ceil32(return_data.size)) + 512
                                                               len (13 * ceil32(return_data.size)) + 100
                                                        balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 * totalFees / 100)
                                                        emit Transfer((arg2 * totalFees / 100), msg.sender, this.address);
                                                        if not msg.sender:
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 512] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 516] = 32
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 548] = 37
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 580] = 'ERC20: transfer from the zero ad'
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 612] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                            revert with memory
                                                              from _5413 + (8 * ceil32(return_data.size)) + 512
                                                               len (13 * ceil32(return_data.size)) + 132
                                                        if not arg1:
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 512] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 516] = 32
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 548] = 35
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 580] = 'ERC20: transfer to the zero addr'
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 612] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                            revert with memory
                                                              from _5413 + (8 * ceil32(return_data.size)) + 512
                                                               len (13 * ceil32(return_data.size)) + 132
                                                        if arg2 - (arg2 * totalFees / 100) > balanceOf[address(msg.sender)]:
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 608] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 612] = 32
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 644] = 38
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 676 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_5413 + (8 * ceil32(return_data.size)) + 582 len 26]
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 714] = 0
                                                            revert with memory
                                                              from _5413 + (8 * ceil32(return_data.size)) + 608
                                                               len (13 * ceil32(return_data.size)) + 132
                                                        if balanceOf[address(msg.sender)] < arg2 - (arg2 * totalFees / 100):
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - arg2 + (arg2 * totalFees / 100)
                                                        if balanceOf[arg1] > !(arg2 - (arg2 * totalFees / 100)):
                                                            revert with 0, 17
                                                        if balanceOf[arg1] + arg2 - (arg2 * totalFees / 100) < balanceOf[arg1]:
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 608] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 612] = 32
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 644] = 27
                                                            mem[_5413 + (8 * ceil32(return_data.size)) + 676] = 'SafeMath: addition overflow'
                                                            revert with memory
                                                              from _5413 + (8 * ceil32(return_data.size)) + 608
                                                               len (13 * ceil32(return_data.size)) + 100
                                                        balanceOf[address(arg1)] = balanceOf[arg1] + arg2 - (arg2 * totalFees / 100)
                                                        emit Transfer((arg2 - (arg2 * totalFees / 100)), msg.sender, arg1);
                                                        mem[_5413 + (8 * ceil32(return_data.size)) + 612] = msg.sender
                                                        mem[_5413 + (8 * ceil32(return_data.size)) + 644] = balanceOf[address(msg.sender)]
                                                        require ext_code.size(dividendTrackerAddress)
                                                        call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args mem[_5413 + (8 * ceil32(return_data.size)) + 612 len (13 * ceil32(return_data.size)) + 64]
                                                        mem[_5413 + (8 * ceil32(return_data.size)) + 612] = arg1
                                                        mem[_5413 + (8 * ceil32(return_data.size)) + 644] = balanceOf[address(arg1)]
                                                        require ext_code.size(dividendTrackerAddress)
                                                        call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args mem[_5413 + (8 * ceil32(return_data.size)) + 612 len (13 * ceil32(return_data.size)) + 64]
                                                        if not stor7:
                                                            call dividendTrackerAddress.process(uint256 arg1) with:
                                                                 gas gas_remaining wei
                                                                args gasForProcessing
                                                            if ext_call.success:
                                                                require return_data.size >= 96
                                                                emit ProcessedDividendTracker(uint256 arg1, uint256 arg2, uint256 arg3, bool arg4, uint256 arg5, address arg6):
                                                                                              ext_call.return_data[0],
                                                                                              ext_call.return_data[32],
                                                                                              ext_call.return_data[64],
                                                                                              gasForProcessing,
                                                                                              mem[_5413 + (9 * ceil32(return_data.size)) + 736 len 5 * ceil32(return_data.size)],
                                                                                              1,
                                                                                              tx.origin,
                                                    else:
                                                        if not arg2:
                                                            if arg2 * totalFees / 100 > -1:
                                                                revert with 0, 17
                                                            if arg2 * totalFees / 100 > arg2:
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 480] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 484] = 32
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 516] = 30
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 548] = 'SafeMath: subtraction overflow'
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 578] = 0
                                                                revert with memory
                                                                  from _5413 + (8 * ceil32(return_data.size)) + 480
                                                                   len (13 * ceil32(return_data.size)) + 100
                                                            if arg2 < arg2 * totalFees / 100:
                                                                revert with 0, 17
                                                            if not msg.sender:
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 480] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 484] = 32
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 516] = 37
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 548] = 'ERC20: transfer from the zero ad'
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 580] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                                revert with memory
                                                                  from _5413 + (8 * ceil32(return_data.size)) + 480
                                                                   len (13 * ceil32(return_data.size)) + 132
                                                            if not this.address:
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 480] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 484] = 32
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 516] = 35
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 548] = 'ERC20: transfer to the zero addr'
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 580] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                                revert with memory
                                                                  from _5413 + (8 * ceil32(return_data.size)) + 480
                                                                   len (13 * ceil32(return_data.size)) + 132
                                                            if arg2 * totalFees / 100 > balanceOf[address(msg.sender)]:
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 576] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 580] = 32
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 612] = 38
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 644 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_5413 + (8 * ceil32(return_data.size)) + 550 len 26]
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 682] = 0
                                                                revert with memory
                                                                  from _5413 + (8 * ceil32(return_data.size)) + 576
                                                                   len (13 * ceil32(return_data.size)) + 132
                                                            if balanceOf[address(msg.sender)] < arg2 * totalFees / 100:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2 * totalFees / 100
                                                            if balanceOf[this.address] > !(arg2 * totalFees / 100):
                                                                revert with 0, 17
                                                            if balanceOf[this.address] + (arg2 * totalFees / 100) < balanceOf[this.address]:
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 576] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 580] = 32
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 612] = 27
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 644] = 'SafeMath: addition overflow'
                                                                revert with memory
                                                                  from _5413 + (8 * ceil32(return_data.size)) + 576
                                                                   len (13 * ceil32(return_data.size)) + 100
                                                            balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 * totalFees / 100)
                                                            emit Transfer((arg2 * totalFees / 100), msg.sender, this.address);
                                                            if not msg.sender:
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 576] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 580] = 32
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 612] = 37
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 644] = 'ERC20: transfer from the zero ad'
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 676] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                                revert with memory
                                                                  from _5413 + (8 * ceil32(return_data.size)) + 576
                                                                   len (13 * ceil32(return_data.size)) + 132
                                                            if not arg1:
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 576] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 580] = 32
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 612] = 35
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 644] = 'ERC20: transfer to the zero addr'
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 676] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                                revert with memory
                                                                  from _5413 + (8 * ceil32(return_data.size)) + 576
                                                                   len (13 * ceil32(return_data.size)) + 132
                                                            if arg2 - (arg2 * totalFees / 100) > balanceOf[address(msg.sender)]:
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 672] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 676] = 32
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 708] = 38
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 740 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_5413 + (8 * ceil32(return_data.size)) + 646 len 26]
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 778] = 0
                                                                revert with memory
                                                                  from _5413 + (8 * ceil32(return_data.size)) + 672
                                                                   len (13 * ceil32(return_data.size)) + 132
                                                            if balanceOf[address(msg.sender)] < arg2 - (arg2 * totalFees / 100):
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - arg2 + (arg2 * totalFees / 100)
                                                            if balanceOf[arg1] > !(arg2 - (arg2 * totalFees / 100)):
                                                                revert with 0, 17
                                                            if balanceOf[arg1] + arg2 - (arg2 * totalFees / 100) < balanceOf[arg1]:
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 672] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 676] = 32
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 708] = 27
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 740] = 'SafeMath: addition overflow'
                                                                revert with memory
                                                                  from _5413 + (8 * ceil32(return_data.size)) + 672
                                                                   len (13 * ceil32(return_data.size)) + 100
                                                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2 - (arg2 * totalFees / 100)
                                                            emit Transfer((arg2 - (arg2 * totalFees / 100)), msg.sender, arg1);
                                                        else:
                                                            if arg2 and 1 > -1 / arg2:
                                                                revert with 0, 17
                                                            if not arg2:
                                                                revert with 0, 18
                                                            if arg2 / arg2 != 1:
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 352] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 356] = 32
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 388] = 33
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 420] = 'SafeMath: multiplication overflo'
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 452] = 0x7700000000000000000000000000000000000000000000000000000000000000
                                                                revert with memory
                                                                  from _5413 + (8 * ceil32(return_data.size)) + 352
                                                                   len (13 * ceil32(return_data.size)) + 132
                                                            if arg2 * totalFees / 100 > !(arg2 / 100):
                                                                revert with 0, 17
                                                            if (arg2 * totalFees / 100) + (arg2 / 100) > arg2:
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 480] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 484] = 32
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 516] = 30
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 548] = 'SafeMath: subtraction overflow'
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 578] = 0
                                                                revert with memory
                                                                  from _5413 + (8 * ceil32(return_data.size)) + 480
                                                                   len (13 * ceil32(return_data.size)) + 100
                                                            if arg2 < (arg2 * totalFees / 100) + (arg2 / 100):
                                                                revert with 0, 17
                                                            if not msg.sender:
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 480] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 484] = 32
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 516] = 37
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 548] = 'ERC20: transfer from the zero ad'
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 580] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                                revert with memory
                                                                  from _5413 + (8 * ceil32(return_data.size)) + 480
                                                                   len (13 * ceil32(return_data.size)) + 132
                                                            if not this.address:
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 480] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 484] = 32
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 516] = 35
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 548] = 'ERC20: transfer to the zero addr'
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 580] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                                revert with memory
                                                                  from _5413 + (8 * ceil32(return_data.size)) + 480
                                                                   len (13 * ceil32(return_data.size)) + 132
                                                            if (arg2 * totalFees / 100) + (arg2 / 100) > balanceOf[address(msg.sender)]:
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 576] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 580] = 32
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 612] = 38
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 644 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_5413 + (8 * ceil32(return_data.size)) + 550 len 26]
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 682] = 0
                                                                revert with memory
                                                                  from _5413 + (8 * ceil32(return_data.size)) + 576
                                                                   len (13 * ceil32(return_data.size)) + 132
                                                            if balanceOf[address(msg.sender)] < (arg2 * totalFees / 100) + (arg2 / 100):
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - (arg2 * totalFees / 100) - (arg2 / 100)
                                                            if balanceOf[this.address] > !((arg2 * totalFees / 100) + (arg2 / 100)):
                                                                revert with 0, 17
                                                            if balanceOf[this.address] + (arg2 * totalFees / 100) + (arg2 / 100) < balanceOf[this.address]:
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 576] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 580] = 32
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 612] = 27
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 644] = 'SafeMath: addition overflow'
                                                                revert with memory
                                                                  from _5413 + (8 * ceil32(return_data.size)) + 576
                                                                   len (13 * ceil32(return_data.size)) + 100
                                                            balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 * totalFees / 100) + (arg2 / 100)
                                                            emit Transfer(((arg2 * totalFees / 100) + (arg2 / 100)), msg.sender, this.address);
                                                            if not msg.sender:
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 576] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 580] = 32
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 612] = 37
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 644] = 'ERC20: transfer from the zero ad'
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 676] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                                revert with memory
                                                                  from _5413 + (8 * ceil32(return_data.size)) + 576
                                                                   len (13 * ceil32(return_data.size)) + 132
                                                            if not arg1:
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 576] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 580] = 32
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 612] = 35
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 644] = 'ERC20: transfer to the zero addr'
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 676] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                                revert with memory
                                                                  from _5413 + (8 * ceil32(return_data.size)) + 576
                                                                   len (13 * ceil32(return_data.size)) + 132
                                                            if arg2 - (arg2 * totalFees / 100) - (arg2 / 100) > balanceOf[address(msg.sender)]:
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 672] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 676] = 32
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 708] = 38
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 740 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_5413 + (8 * ceil32(return_data.size)) + 646 len 26]
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 778] = 0
                                                                revert with memory
                                                                  from _5413 + (8 * ceil32(return_data.size)) + 672
                                                                   len (13 * ceil32(return_data.size)) + 132
                                                            if balanceOf[address(msg.sender)] < arg2 - (arg2 * totalFees / 100) - (arg2 / 100):
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - arg2 + (arg2 * totalFees / 100) + (arg2 / 100)
                                                            if balanceOf[arg1] > !(arg2 - (arg2 * totalFees / 100) - (arg2 / 100)):
                                                                revert with 0, 17
                                                            if balanceOf[arg1] + arg2 - (arg2 * totalFees / 100) - (arg2 / 100) < balanceOf[arg1]:
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 672] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 676] = 32
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 708] = 27
                                                                mem[_5413 + (8 * ceil32(return_data.size)) + 740] = 'SafeMath: addition overflow'
                                                                revert with memory
                                                                  from _5413 + (8 * ceil32(return_data.size)) + 672
                                                                   len (13 * ceil32(return_data.size)) + 100
                                                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2 - (arg2 * totalFees / 100) - (arg2 / 100)
                                                            emit Transfer((arg2 - (arg2 * totalFees / 100) - (arg2 / 100)), msg.sender, arg1);
                                                        mem[_5413 + (8 * ceil32(return_data.size)) + 676] = msg.sender
                                                        mem[_5413 + (8 * ceil32(return_data.size)) + 708] = balanceOf[address(msg.sender)]
                                                        require ext_code.size(dividendTrackerAddress)
                                                        call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args mem[_5413 + (8 * ceil32(return_data.size)) + 676 len (13 * ceil32(return_data.size)) + 64]
                                                        mem[_5413 + (8 * ceil32(return_data.size)) + 676] = arg1
                                                        mem[_5413 + (8 * ceil32(return_data.size)) + 708] = balanceOf[address(arg1)]
                                                        require ext_code.size(dividendTrackerAddress)
                                                        call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args mem[_5413 + (8 * ceil32(return_data.size)) + 676 len (13 * ceil32(return_data.size)) + 64]
                                                        if not stor7:
                                                            call dividendTrackerAddress.process(uint256 arg1) with:
                                                                 gas gas_remaining wei
                                                                args gasForProcessing
                                                            if ext_call.success:
                                                                require return_data.size >= 96
                                                                emit ProcessedDividendTracker(uint256 arg1, uint256 arg2, uint256 arg3, bool arg4, uint256 arg5, address arg6):
                                                                                              ext_call.return_data[0],
                                                                                              ext_call.return_data[32],
                                                                                              ext_call.return_data[64],
                                                                                              gasForProcessing,
                                                                                              mem[_5413 + (9 * ceil32(return_data.size)) + 800 len 5 * ceil32(return_data.size)],
                                                                                              1,
                                                                                              tx.origin,
                            else:
                                mem[96] = 26
                                mem[128] = 'SafeMath: division by zero'
                                if not totalFees:
                                    revert with 0, 'SafeMath: division by zero', 0
                                mem[164] = this.address
                                staticcall sub_4d7effddAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[160] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                mem[ceil32(return_data.size) + 160] = 3
                                mem[ceil32(return_data.size) + 192] = this.address
                                staticcall uniswapV2RouterAddress.WETH() with:
                                        gas gas_remaining wei
                                mem[ceil32(return_data.size) + 288] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = (2 * ceil32(return_data.size)) + 288
                                require return_data.size >= 32
                                require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                mem[ceil32(return_data.size) + 224] = ext_call.return_data[12 len 20]
                                mem[ceil32(return_data.size) + 256] = sub_4d7effddAddress
                                if not this.address:
                                    mem[(2 * ceil32(return_data.size)) + 288] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[(2 * ceil32(return_data.size)) + 292] = 32
                                    mem[(2 * ceil32(return_data.size)) + 324] = 36
                                    mem[(2 * ceil32(return_data.size)) + 356] = 'ERC20: approve from the zero add'
                                    mem[(2 * ceil32(return_data.size)) + 388] = 0x7265737300000000000000000000000000000000000000000000000000000000
                                    revert with memory
                                      from (2 * ceil32(return_data.size)) + 288
                                       len ceil32(return_data.size) + 132
                                if not uniswapV2RouterAddress:
                                    mem[(2 * ceil32(return_data.size)) + 288] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[(2 * ceil32(return_data.size)) + 292] = 32
                                    mem[(2 * ceil32(return_data.size)) + 324] = 34
                                    mem[(2 * ceil32(return_data.size)) + 356] = 'ERC20: approve to the zero addre'
                                    mem[(2 * ceil32(return_data.size)) + 388] = 0x7373000000000000000000000000000000000000000000000000000000000000
                                    revert with memory
                                      from (2 * ceil32(return_data.size)) + 288
                                       len ceil32(return_data.size) + 132
                                mem[0] = uniswapV2RouterAddress
                                mem[32] = sha3(address(this.address), 1)
                                allowance[address(this.address)][stor6].field_0 = 0 / totalFees
                                mem[(2 * ceil32(return_data.size)) + 288] = 0 / totalFees
                                emit Approval(mem[(2 * ceil32(return_data.size)) + 288 len ceil32(return_data.size) + 32], this.address, uniswapV2RouterAddress);
                                mem[(2 * ceil32(return_data.size)) + 288] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                mem[(2 * ceil32(return_data.size)) + 292] = 0 / totalFees
                                mem[(2 * ceil32(return_data.size)) + 324] = 0
                                mem[(2 * ceil32(return_data.size)) + 356] = 160
                                mem[(2 * ceil32(return_data.size)) + 452] = 3
                                idx = 0
                                s = (2 * ceil32(return_data.size)) + 484
                                t = ceil32(return_data.size) + 192
                                while idx < mem[ceil32(return_data.size) + 160]:
                                    mem[s] = mem[t + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[(2 * ceil32(return_data.size)) + 388] = this.address
                                mem[(2 * ceil32(return_data.size)) + 420] = block.timestamp
                                require ext_code.size(uniswapV2RouterAddress)
                                call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 576]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[mem[64] + 4] = this.address
                                staticcall sub_4d7effddAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[mem[64]] = ext_call.return_data[0]
                                _5345 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                _5347 = mem[_5345]
                                _5349 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_5349] = 30
                                mem[_5349 + 32] = 'SafeMath: subtraction overflow'
                                if ext_call.return_data[0] > _5347:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if _5347 < ext_call.return_data[0]:
                                    revert with 0, 17
                                mem[mem[64] + 4] = stor17
                                mem[mem[64] + 36] = _5347 - ext_call.return_data[0]
                                call sub_4d7effddAddress.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args stor17, _5347 - ext_call.return_data[0]
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _5364 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                require mem[_5364] == bool(mem[_5364])
                                if not balanceOf[this.address]:
                                    _5369 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5369] = 26
                                    mem[_5369 + 32] = 'SafeMath: division by zero'
                                    if not totalFees:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    _5391 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5391] = 26
                                    mem[_5391 + 32] = 'SafeMath: division by zero'
                                    _5401 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5401] = 30
                                    mem[_5401 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 / totalFees / 2 > 0 / totalFees:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 / totalFees < 0 / totalFees / 2:
                                        revert with 0, 17
                                    _5417 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    mem[_5417 + 32 len 64] = call.data[calldata.size len 64]
                                    if 0 >= mem[_5417]:
                                        revert with 0, 50
                                    mem[_5417 + 32] = this.address
                                    staticcall uniswapV2RouterAddress.WETH() with:
                                            gas gas_remaining wei
                                    mem[_5417 + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _5417 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if 1 >= mem[_5417]:
                                        revert with 0, 50
                                    mem[_5417 + 64] = ext_call.return_data[12 len 20]
                                    if not this.address:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not uniswapV2RouterAddress:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    mem[0] = uniswapV2RouterAddress
                                    mem[32] = sha3(address(this.address), 1)
                                    allowance[address(this.address)][stor6].field_0 = 0 / totalFees / 2
                                    allowance[address(this.address)][stor6].field_255 = 0
                                    emit Approval((0 / totalFees / 2), this.address, uniswapV2RouterAddress);
                                    mem[_5417 + ceil32(return_data.size) + 96] = 0x791ac94700000000000000000000000000000000000000000000000000000000
                                    mem[_5417 + ceil32(return_data.size) + 100] = 0 / totalFees / 2
                                    mem[_5417 + ceil32(return_data.size) + 132] = 0
                                    mem[_5417 + ceil32(return_data.size) + 164] = 160
                                    mem[_5417 + ceil32(return_data.size) + 260] = mem[_5417]
                                    idx = 0
                                    s = _5417 + ceil32(return_data.size) + 292
                                    t = _5417 + 32
                                    while idx < mem[_5417]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args Mask(255, 1, 0 / totalFees), 0, 160, address(this.address), block.timestamp, mem[_5417 + ceil32(return_data.size) + 260 len (32 * mem[_5417]) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_5417 + ceil32(return_data.size) + 96] = 30
                                    mem[_5417 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                    if eth.balance(this.address) > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if eth.balance(this.address) < eth.balance(this.address):
                                        revert with 0, 17
                                    if not this.address:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not uniswapV2RouterAddress:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(this.address)][stor6].field_0 = (0 / totalFees) - (0 / totalFees / 2)
                                    emit Approval(((0 / totalFees) - (0 / totalFees / 2)), this.address, uniswapV2RouterAddress);
                                    mem[_5417 + ceil32(return_data.size) + 228] = 0
                                    mem[_5417 + ceil32(return_data.size) + 260] = 0
                                    mem[_5417 + ceil32(return_data.size) + 292] = stor17
                                    mem[_5417 + ceil32(return_data.size) + 324] = block.timestamp
                                    call uniswapV2RouterAddress.addLiquidityETH(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                         gas gas_remaining wei
                                        args this.address, (0 / totalFees) - (0 / totalFees / 2), 0, 0, stor17, block.timestamp
                                    mem[_5417 + ceil32(return_data.size) + 160 len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 96
                                    emit SwapAndLiquify(Mask(255, 1, 0 / totalFees), 0, (0 / totalFees) - (0 / totalFees / 2));
                                    mem[_5417 + (2 * ceil32(return_data.size)) + 160] = 3
                                    mem[_5417 + (2 * ceil32(return_data.size)) + 192] = this.address
                                    staticcall uniswapV2RouterAddress.WETH() with:
                                            gas gas_remaining wei
                                    mem[_5417 + (2 * ceil32(return_data.size)) + 288] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    mem[_5417 + (2 * ceil32(return_data.size)) + 224] = ext_call.return_data[12 len 20]
                                    mem[_5417 + (2 * ceil32(return_data.size)) + 256] = sub_4d7effddAddress
                                    if not this.address:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not uniswapV2RouterAddress:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(this.address)][stor6].field_0 = balanceOf[this.address]
                                    emit Approval(balanceOf[this.address], this.address, uniswapV2RouterAddress);
                                    mem[_5417 + (4 * ceil32(return_data.size)) + 288] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                    mem[_5417 + (4 * ceil32(return_data.size)) + 292] = balanceOf[this.address]
                                    mem[_5417 + (4 * ceil32(return_data.size)) + 324] = 0
                                    mem[_5417 + (4 * ceil32(return_data.size)) + 356] = 160
                                    mem[_5417 + (4 * ceil32(return_data.size)) + 452] = 3
                                    idx = 0
                                    s = _5417 + (4 * ceil32(return_data.size)) + 484
                                    t = _5417 + (2 * ceil32(return_data.size)) + 192
                                    while idx < mem[_5417 + (2 * ceil32(return_data.size)) + 160]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5417 + (4 * ceil32(return_data.size)) + 388] = this.address
                                    mem[_5417 + (4 * ceil32(return_data.size)) + 420] = block.timestamp
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args balanceOf[this.address], 0, 160, address(this.address), block.timestamp, mem[_5417 + (4 * ceil32(return_data.size)) + 452 len (32 * mem[_5417 + (2 * ceil32(return_data.size)) + 160]) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    staticcall sub_4d7effddAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    require return_data.size >= 32
                                    mem[_5417 + (4 * ceil32(return_data.size)) + 292] = dividendTrackerAddress
                                    mem[_5417 + (4 * ceil32(return_data.size)) + 324] = ext_call.return_data[0]
                                    call sub_4d7effddAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args mem[_5417 + (4 * ceil32(return_data.size)) + 292 len (7 * ceil32(return_data.size)) + 64]
                                    mem[_5417 + (4 * ceil32(return_data.size)) + 288] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    if ext_call.return_data[0]:
                                        require ext_code.size(dividendTrackerAddress)
                                        call dividendTrackerAddress.distributeDogeDividends(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        emit SendDividends(balanceOf[this.address], ext_call.return_data[0]);
                                    stor7 = 0
                                    if stor19[address(msg.sender)]:
                                        if not msg.sender:
                                            mem[_5417 + (8 * ceil32(return_data.size)) + 288] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_5417 + (8 * ceil32(return_data.size)) + 292] = 32
                                            mem[_5417 + (8 * ceil32(return_data.size)) + 324] = 37
                                            mem[_5417 + (8 * ceil32(return_data.size)) + 356] = 'ERC20: transfer from the zero ad'
                                            mem[_5417 + (8 * ceil32(return_data.size)) + 388] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                            revert with memory
                                              from _5417 + (8 * ceil32(return_data.size)) + 288
                                               len (13 * ceil32(return_data.size)) + 132
                                        if not arg1:
                                            mem[_5417 + (8 * ceil32(return_data.size)) + 288] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_5417 + (8 * ceil32(return_data.size)) + 292] = 32
                                            mem[_5417 + (8 * ceil32(return_data.size)) + 324] = 35
                                            mem[_5417 + (8 * ceil32(return_data.size)) + 356] = 'ERC20: transfer to the zero addr'
                                            mem[_5417 + (8 * ceil32(return_data.size)) + 388] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                            revert with memory
                                              from _5417 + (8 * ceil32(return_data.size)) + 288
                                               len (13 * ceil32(return_data.size)) + 132
                                        if arg2 > balanceOf[address(msg.sender)]:
                                            mem[_5417 + (8 * ceil32(return_data.size)) + 384] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_5417 + (8 * ceil32(return_data.size)) + 388] = 32
                                            mem[_5417 + (8 * ceil32(return_data.size)) + 420] = 38
                                            mem[_5417 + (8 * ceil32(return_data.size)) + 452 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_5417 + (8 * ceil32(return_data.size)) + 358 len 26]
                                            mem[_5417 + (8 * ceil32(return_data.size)) + 490] = 0
                                            revert with memory
                                              from _5417 + (8 * ceil32(return_data.size)) + 384
                                               len (13 * ceil32(return_data.size)) + 132
                                        if balanceOf[address(msg.sender)] < arg2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2
                                        if balanceOf[arg1] > !arg2:
                                            revert with 0, 17
                                        if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                            mem[_5417 + (8 * ceil32(return_data.size)) + 384] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_5417 + (8 * ceil32(return_data.size)) + 388] = 32
                                            mem[_5417 + (8 * ceil32(return_data.size)) + 420] = 27
                                            mem[_5417 + (8 * ceil32(return_data.size)) + 452] = 'SafeMath: addition overflow'
                                            revert with memory
                                              from _5417 + (8 * ceil32(return_data.size)) + 384
                                               len (13 * ceil32(return_data.size)) + 100
                                        balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                        emit Transfer(arg2, msg.sender, arg1);
                                        mem[_5417 + (8 * ceil32(return_data.size)) + 388] = msg.sender
                                        mem[_5417 + (8 * ceil32(return_data.size)) + 420] = balanceOf[address(msg.sender)]
                                        require ext_code.size(dividendTrackerAddress)
                                        call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                             gas gas_remaining wei
                                            args mem[_5417 + (8 * ceil32(return_data.size)) + 388 len (13 * ceil32(return_data.size)) + 64]
                                        mem[_5417 + (8 * ceil32(return_data.size)) + 388] = arg1
                                        mem[_5417 + (8 * ceil32(return_data.size)) + 420] = balanceOf[address(arg1)]
                                        require ext_code.size(dividendTrackerAddress)
                                        call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                             gas gas_remaining wei
                                            args mem[_5417 + (8 * ceil32(return_data.size)) + 388 len (13 * ceil32(return_data.size)) + 64]
                                        if not stor7:
                                            call dividendTrackerAddress.process(uint256 arg1) with:
                                                 gas gas_remaining wei
                                                args gasForProcessing
                                            if ext_call.success:
                                                require return_data.size >= 96
                                                emit ProcessedDividendTracker(uint256 arg1, uint256 arg2, uint256 arg3, bool arg4, uint256 arg5, address arg6):
                                                                              ext_call.return_data[0],
                                                                              ext_call.return_data[32],
                                                                              ext_call.return_data[64],
                                                                              gasForProcessing,
                                                                              mem[_5417 + (9 * ceil32(return_data.size)) + 512 len 5 * ceil32(return_data.size)],
                                                                              1,
                                                                              tx.origin,
                                    else:
                                        if stor19[address(arg1)]:
                                            if not msg.sender:
                                                mem[_5417 + (8 * ceil32(return_data.size)) + 288] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[_5417 + (8 * ceil32(return_data.size)) + 292] = 32
                                                mem[_5417 + (8 * ceil32(return_data.size)) + 324] = 37
                                                mem[_5417 + (8 * ceil32(return_data.size)) + 356] = 'ERC20: transfer from the zero ad'
                                                mem[_5417 + (8 * ceil32(return_data.size)) + 388] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                revert with memory
                                                  from _5417 + (8 * ceil32(return_data.size)) + 288
                                                   len (13 * ceil32(return_data.size)) + 132
                                            if not arg1:
                                                mem[_5417 + (8 * ceil32(return_data.size)) + 288] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[_5417 + (8 * ceil32(return_data.size)) + 292] = 32
                                                mem[_5417 + (8 * ceil32(return_data.size)) + 324] = 35
                                                mem[_5417 + (8 * ceil32(return_data.size)) + 356] = 'ERC20: transfer to the zero addr'
                                                mem[_5417 + (8 * ceil32(return_data.size)) + 388] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                revert with memory
                                                  from _5417 + (8 * ceil32(return_data.size)) + 288
                                                   len (13 * ceil32(return_data.size)) + 132
                                            if arg2 > balanceOf[address(msg.sender)]:
                                                mem[_5417 + (8 * ceil32(return_data.size)) + 384] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[_5417 + (8 * ceil32(return_data.size)) + 388] = 32
                                                mem[_5417 + (8 * ceil32(return_data.size)) + 420] = 38
                                                mem[_5417 + (8 * ceil32(return_data.size)) + 452 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_5417 + (8 * ceil32(return_data.size)) + 358 len 26]
                                                mem[_5417 + (8 * ceil32(return_data.size)) + 490] = 0
                                                revert with memory
                                                  from _5417 + (8 * ceil32(return_data.size)) + 384
                                                   len (13 * ceil32(return_data.size)) + 132
                                            if balanceOf[address(msg.sender)] < arg2:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2
                                            if balanceOf[arg1] > !arg2:
                                                revert with 0, 17
                                            if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                mem[_5417 + (8 * ceil32(return_data.size)) + 384] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[_5417 + (8 * ceil32(return_data.size)) + 388] = 32
                                                mem[_5417 + (8 * ceil32(return_data.size)) + 420] = 27
                                                mem[_5417 + (8 * ceil32(return_data.size)) + 452] = 'SafeMath: addition overflow'
                                                revert with memory
                                                  from _5417 + (8 * ceil32(return_data.size)) + 384
                                                   len (13 * ceil32(return_data.size)) + 100
                                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                            emit Transfer(arg2, msg.sender, arg1);
                                            mem[_5417 + (8 * ceil32(return_data.size)) + 388] = msg.sender
                                            mem[_5417 + (8 * ceil32(return_data.size)) + 420] = balanceOf[address(msg.sender)]
                                            require ext_code.size(dividendTrackerAddress)
                                            call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args mem[_5417 + (8 * ceil32(return_data.size)) + 388 len (13 * ceil32(return_data.size)) + 64]
                                            mem[_5417 + (8 * ceil32(return_data.size)) + 388] = arg1
                                            mem[_5417 + (8 * ceil32(return_data.size)) + 420] = balanceOf[address(arg1)]
                                            require ext_code.size(dividendTrackerAddress)
                                            call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args mem[_5417 + (8 * ceil32(return_data.size)) + 388 len (13 * ceil32(return_data.size)) + 64]
                                            if not stor7:
                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                     gas gas_remaining wei
                                                    args gasForProcessing
                                                if ext_call.success:
                                                    require return_data.size >= 96
                                                    emit ProcessedDividendTracker(uint256 arg1, uint256 arg2, uint256 arg3, bool arg4, uint256 arg5, address arg6):
                                                                                  ext_call.return_data[0],
                                                                                  ext_call.return_data[32],
                                                                                  ext_call.return_data[64],
                                                                                  gasForProcessing,
                                                                                  mem[_5417 + (9 * ceil32(return_data.size)) + 512 len 5 * ceil32(return_data.size)],
                                                                                  1,
                                                                                  tx.origin,
                                        else:
                                            if stor7:
                                                if not msg.sender:
                                                    mem[_5417 + (8 * ceil32(return_data.size)) + 288] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_5417 + (8 * ceil32(return_data.size)) + 292] = 32
                                                    mem[_5417 + (8 * ceil32(return_data.size)) + 324] = 37
                                                    mem[_5417 + (8 * ceil32(return_data.size)) + 356] = 'ERC20: transfer from the zero ad'
                                                    mem[_5417 + (8 * ceil32(return_data.size)) + 388] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                    revert with memory
                                                      from _5417 + (8 * ceil32(return_data.size)) + 288
                                                       len (13 * ceil32(return_data.size)) + 132
                                                if not arg1:
                                                    mem[_5417 + (8 * ceil32(return_data.size)) + 288] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_5417 + (8 * ceil32(return_data.size)) + 292] = 32
                                                    mem[_5417 + (8 * ceil32(return_data.size)) + 324] = 35
                                                    mem[_5417 + (8 * ceil32(return_data.size)) + 356] = 'ERC20: transfer to the zero addr'
                                                    mem[_5417 + (8 * ceil32(return_data.size)) + 388] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                    revert with memory
                                                      from _5417 + (8 * ceil32(return_data.size)) + 288
                                                       len (13 * ceil32(return_data.size)) + 132
                                                if arg2 > balanceOf[address(msg.sender)]:
                                                    mem[_5417 + (8 * ceil32(return_data.size)) + 384] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_5417 + (8 * ceil32(return_data.size)) + 388] = 32
                                                    mem[_5417 + (8 * ceil32(return_data.size)) + 420] = 38
                                                    mem[_5417 + (8 * ceil32(return_data.size)) + 452 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_5417 + (8 * ceil32(return_data.size)) + 358 len 26]
                                                    mem[_5417 + (8 * ceil32(return_data.size)) + 490] = 0
                                                    revert with memory
                                                      from _5417 + (8 * ceil32(return_data.size)) + 384
                                                       len (13 * ceil32(return_data.size)) + 132
                                                if balanceOf[address(msg.sender)] < arg2:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= arg2
                                                if balanceOf[arg1] > !arg2:
                                                    revert with 0, 17
                                                if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                    mem[_5417 + (8 * ceil32(return_data.size)) + 384] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_5417 + (8 * ceil32(return_data.size)) + 388] = 32
                                                    mem[_5417 + (8 * ceil32(return_data.size)) + 420] = 27
                                                    mem[_5417 + (8 * ceil32(return_data.size)) + 452] = 'SafeMath: addition overflow'
                                                    revert with memory
                                                      from _5417 + (8 * ceil32(return_data.size)) + 384
                                                       len (13 * ceil32(return_data.size)) + 100
                                                balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                emit Transfer(arg2, msg.sender, arg1);
                                                mem[_5417 + (8 * ceil32(return_data.size)) + 388] = msg.sender
                                                mem[_5417 + (8 * ceil32(return_data.size)) + 420] = balanceOf[address(msg.sender)]
                                                require ext_code.size(dividendTrackerAddress)
                                                call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args mem[_5417 + (8 * ceil32(return_data.size)) + 388 len (13 * ceil32(return_data.size)) + 64]
                                                mem[_5417 + (8 * ceil32(return_data.size)) + 388] = arg1
                                                mem[_5417 + (8 * ceil32(return_data.size)) + 420] = balanceOf[address(arg1)]
                                                require ext_code.size(dividendTrackerAddress)
                                                call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args mem[_5417 + (8 * ceil32(return_data.size)) + 388 len (13 * ceil32(return_data.size)) + 64]
                                                if not stor7:
                                                    call dividendTrackerAddress.process(uint256 arg1) with:
                                                         gas gas_remaining wei
                                                        args gasForProcessing
                                                    if ext_call.success:
                                                        require return_data.size >= 96
                                                        emit ProcessedDividendTracker(uint256 arg1, uint256 arg2, uint256 arg3, bool arg4, uint256 arg5, address arg6):
                                                                                      ext_call.return_data[0],
                                                                                      ext_call.return_data[32],
                                                                                      ext_call.return_data[64],
                                                                                      gasForProcessing,
                                                                                      mem[_5417 + (9 * ceil32(return_data.size)) + 512 len 5 * ceil32(return_data.size)],
                                                                                      1,
                                                                                      tx.origin,
                                            else:
                                                if not arg2:
                                                    if not stor20[address(arg1)]:
                                                        if 0 > arg2:
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 420] = 32
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 452] = 30
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 484] = 'SafeMath: subtraction overflow'
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 514] = 0
                                                            revert with memory
                                                              from _5417 + (8 * ceil32(return_data.size)) + 416
                                                               len (13 * ceil32(return_data.size)) + 100
                                                        if arg2 < 0:
                                                            revert with 0, 17
                                                        if not msg.sender:
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 420] = 32
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 452] = 37
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 484] = 'ERC20: transfer from the zero ad'
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 516] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                            revert with memory
                                                              from _5417 + (8 * ceil32(return_data.size)) + 416
                                                               len (13 * ceil32(return_data.size)) + 132
                                                        if not this.address:
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 420] = 32
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 452] = 35
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 484] = 'ERC20: transfer to the zero addr'
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 516] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                            revert with memory
                                                              from _5417 + (8 * ceil32(return_data.size)) + 416
                                                               len (13 * ceil32(return_data.size)) + 132
                                                        if 0 > balanceOf[address(msg.sender)]:
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 512] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 516] = 32
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 548] = 38
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 580 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_5417 + (8 * ceil32(return_data.size)) + 486 len 26]
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 618] = 0
                                                            revert with memory
                                                              from _5417 + (8 * ceil32(return_data.size)) + 512
                                                               len (13 * ceil32(return_data.size)) + 132
                                                        if balanceOf[address(msg.sender)] < 0:
                                                            revert with 0, 17
                                                        if balanceOf[this.address] > -1:
                                                            revert with 0, 17
                                                        if balanceOf[this.address] < balanceOf[this.address]:
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 512] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 516] = 32
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 548] = 27
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 580] = 'SafeMath: addition overflow'
                                                            revert with memory
                                                              from _5417 + (8 * ceil32(return_data.size)) + 512
                                                               len (13 * ceil32(return_data.size)) + 100
                                                        balanceOf[address(this.address)] = balanceOf[this.address]
                                                        emit Transfer(0, msg.sender, this.address);
                                                        if not msg.sender:
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 512] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 516] = 32
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 548] = 37
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 580] = 'ERC20: transfer from the zero ad'
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 612] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                            revert with memory
                                                              from _5417 + (8 * ceil32(return_data.size)) + 512
                                                               len (13 * ceil32(return_data.size)) + 132
                                                        if not arg1:
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 512] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 516] = 32
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 548] = 35
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 580] = 'ERC20: transfer to the zero addr'
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 612] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                            revert with memory
                                                              from _5417 + (8 * ceil32(return_data.size)) + 512
                                                               len (13 * ceil32(return_data.size)) + 132
                                                        if arg2 > balanceOf[address(msg.sender)]:
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 608] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 612] = 32
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 644] = 38
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 676 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_5417 + (8 * ceil32(return_data.size)) + 582 len 26]
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 714] = 0
                                                            revert with memory
                                                              from _5417 + (8 * ceil32(return_data.size)) + 608
                                                               len (13 * ceil32(return_data.size)) + 132
                                                        if balanceOf[address(msg.sender)] < arg2:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] -= arg2
                                                        if balanceOf[arg1] > !arg2:
                                                            revert with 0, 17
                                                        if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 608] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 612] = 32
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 644] = 27
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 676] = 'SafeMath: addition overflow'
                                                            revert with memory
                                                              from _5417 + (8 * ceil32(return_data.size)) + 608
                                                               len (13 * ceil32(return_data.size)) + 100
                                                        balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                        emit Transfer(arg2, msg.sender, arg1);
                                                        mem[_5417 + (8 * ceil32(return_data.size)) + 612] = msg.sender
                                                        mem[_5417 + (8 * ceil32(return_data.size)) + 644] = balanceOf[address(msg.sender)]
                                                        require ext_code.size(dividendTrackerAddress)
                                                        call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args mem[_5417 + (8 * ceil32(return_data.size)) + 612 len (13 * ceil32(return_data.size)) + 64]
                                                        mem[_5417 + (8 * ceil32(return_data.size)) + 612] = arg1
                                                        mem[_5417 + (8 * ceil32(return_data.size)) + 644] = balanceOf[address(arg1)]
                                                        require ext_code.size(dividendTrackerAddress)
                                                        call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args mem[_5417 + (8 * ceil32(return_data.size)) + 612 len (13 * ceil32(return_data.size)) + 64]
                                                        if not stor7:
                                                            call dividendTrackerAddress.process(uint256 arg1) with:
                                                                 gas gas_remaining wei
                                                                args gasForProcessing
                                                            if ext_call.success:
                                                                require return_data.size >= 96
                                                                emit ProcessedDividendTracker(uint256 arg1, uint256 arg2, uint256 arg3, bool arg4, uint256 arg5, address arg6):
                                                                                              ext_call.return_data[0],
                                                                                              ext_call.return_data[32],
                                                                                              ext_call.return_data[64],
                                                                                              gasForProcessing,
                                                                                              mem[_5417 + (9 * ceil32(return_data.size)) + 736 len 5 * ceil32(return_data.size)],
                                                                                              1,
                                                                                              tx.origin,
                                                    else:
                                                        if not arg2:
                                                            if 0 > arg2:
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 480] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 484] = 32
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 516] = 30
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 548] = 'SafeMath: subtraction overflow'
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 578] = 0
                                                                revert with memory
                                                                  from _5417 + (8 * ceil32(return_data.size)) + 480
                                                                   len (13 * ceil32(return_data.size)) + 100
                                                            if arg2 < 0:
                                                                revert with 0, 17
                                                            if not msg.sender:
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 480] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 484] = 32
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 516] = 37
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 548] = 'ERC20: transfer from the zero ad'
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 580] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                                revert with memory
                                                                  from _5417 + (8 * ceil32(return_data.size)) + 480
                                                                   len (13 * ceil32(return_data.size)) + 132
                                                            if not this.address:
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 480] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 484] = 32
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 516] = 35
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 548] = 'ERC20: transfer to the zero addr'
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 580] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                                revert with memory
                                                                  from _5417 + (8 * ceil32(return_data.size)) + 480
                                                                   len (13 * ceil32(return_data.size)) + 132
                                                            if 0 > balanceOf[address(msg.sender)]:
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 576] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 580] = 32
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 612] = 38
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 644 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_5417 + (8 * ceil32(return_data.size)) + 550 len 26]
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 682] = 0
                                                                revert with memory
                                                                  from _5417 + (8 * ceil32(return_data.size)) + 576
                                                                   len (13 * ceil32(return_data.size)) + 132
                                                            if balanceOf[address(msg.sender)] < 0:
                                                                revert with 0, 17
                                                            if balanceOf[this.address] > -1:
                                                                revert with 0, 17
                                                            if balanceOf[this.address] < balanceOf[this.address]:
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 576] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 580] = 32
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 612] = 27
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 644] = 'SafeMath: addition overflow'
                                                                revert with memory
                                                                  from _5417 + (8 * ceil32(return_data.size)) + 576
                                                                   len (13 * ceil32(return_data.size)) + 100
                                                            balanceOf[address(this.address)] = balanceOf[this.address]
                                                            emit Transfer(0, msg.sender, this.address);
                                                            if not msg.sender:
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 576] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 580] = 32
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 612] = 37
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 644] = 'ERC20: transfer from the zero ad'
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 676] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                                revert with memory
                                                                  from _5417 + (8 * ceil32(return_data.size)) + 576
                                                                   len (13 * ceil32(return_data.size)) + 132
                                                            if not arg1:
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 576] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 580] = 32
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 612] = 35
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 644] = 'ERC20: transfer to the zero addr'
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 676] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                                revert with memory
                                                                  from _5417 + (8 * ceil32(return_data.size)) + 576
                                                                   len (13 * ceil32(return_data.size)) + 132
                                                            if arg2 > balanceOf[address(msg.sender)]:
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 672] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 676] = 32
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 708] = 38
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 740 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_5417 + (8 * ceil32(return_data.size)) + 646 len 26]
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 778] = 0
                                                                revert with memory
                                                                  from _5417 + (8 * ceil32(return_data.size)) + 672
                                                                   len (13 * ceil32(return_data.size)) + 132
                                                            if balanceOf[address(msg.sender)] < arg2:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2
                                                            if balanceOf[arg1] > !arg2:
                                                                revert with 0, 17
                                                            if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 672] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 676] = 32
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 708] = 27
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 740] = 'SafeMath: addition overflow'
                                                                revert with memory
                                                                  from _5417 + (8 * ceil32(return_data.size)) + 672
                                                                   len (13 * ceil32(return_data.size)) + 100
                                                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                            emit Transfer(arg2, msg.sender, arg1);
                                                        else:
                                                            if arg2 and 1 > -1 / arg2:
                                                                revert with 0, 17
                                                            if not arg2:
                                                                revert with 0, 18
                                                            if arg2 / arg2 != 1:
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 352] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 356] = 32
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 388] = 33
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 420] = 'SafeMath: multiplication overflo'
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 452] = 0x7700000000000000000000000000000000000000000000000000000000000000
                                                                revert with memory
                                                                  from _5417 + (8 * ceil32(return_data.size)) + 352
                                                                   len (13 * ceil32(return_data.size)) + 132
                                                            if 0 > !(arg2 / 100):
                                                                revert with 0, 17
                                                            if arg2 / 100 > arg2:
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 480] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 484] = 32
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 516] = 30
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 548] = 'SafeMath: subtraction overflow'
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 578] = 0
                                                                revert with memory
                                                                  from _5417 + (8 * ceil32(return_data.size)) + 480
                                                                   len (13 * ceil32(return_data.size)) + 100
                                                            if arg2 < arg2 / 100:
                                                                revert with 0, 17
                                                            if not msg.sender:
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 480] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 484] = 32
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 516] = 37
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 548] = 'ERC20: transfer from the zero ad'
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 580] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                                revert with memory
                                                                  from _5417 + (8 * ceil32(return_data.size)) + 480
                                                                   len (13 * ceil32(return_data.size)) + 132
                                                            if not this.address:
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 480] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 484] = 32
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 516] = 35
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 548] = 'ERC20: transfer to the zero addr'
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 580] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                                revert with memory
                                                                  from _5417 + (8 * ceil32(return_data.size)) + 480
                                                                   len (13 * ceil32(return_data.size)) + 132
                                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 576] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 580] = 32
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 612] = 38
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 644 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_5417 + (8 * ceil32(return_data.size)) + 550 len 26]
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 682] = 0
                                                                revert with memory
                                                                  from _5417 + (8 * ceil32(return_data.size)) + 576
                                                                   len (13 * ceil32(return_data.size)) + 132
                                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                                            if balanceOf[this.address] > !(arg2 / 100):
                                                                revert with 0, 17
                                                            if balanceOf[this.address] + (arg2 / 100) < balanceOf[this.address]:
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 576] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 580] = 32
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 612] = 27
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 644] = 'SafeMath: addition overflow'
                                                                revert with memory
                                                                  from _5417 + (8 * ceil32(return_data.size)) + 576
                                                                   len (13 * ceil32(return_data.size)) + 100
                                                            balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 100)
                                                            emit Transfer((arg2 / 100), msg.sender, this.address);
                                                            if not msg.sender:
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 576] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 580] = 32
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 612] = 37
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 644] = 'ERC20: transfer from the zero ad'
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 676] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                                revert with memory
                                                                  from _5417 + (8 * ceil32(return_data.size)) + 576
                                                                   len (13 * ceil32(return_data.size)) + 132
                                                            if not arg1:
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 576] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 580] = 32
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 612] = 35
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 644] = 'ERC20: transfer to the zero addr'
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 676] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                                revert with memory
                                                                  from _5417 + (8 * ceil32(return_data.size)) + 576
                                                                   len (13 * ceil32(return_data.size)) + 132
                                                            if arg2 - (arg2 / 100) > balanceOf[address(msg.sender)]:
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 672] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 676] = 32
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 708] = 38
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 740 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_5417 + (8 * ceil32(return_data.size)) + 646 len 26]
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 778] = 0
                                                                revert with memory
                                                                  from _5417 + (8 * ceil32(return_data.size)) + 672
                                                                   len (13 * ceil32(return_data.size)) + 132
                                                            if balanceOf[address(msg.sender)] < arg2 - (arg2 / 100):
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - arg2 + (arg2 / 100)
                                                            if balanceOf[arg1] > !(arg2 - (arg2 / 100)):
                                                                revert with 0, 17
                                                            if balanceOf[arg1] + arg2 - (arg2 / 100) < balanceOf[arg1]:
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 672] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 676] = 32
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 708] = 27
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 740] = 'SafeMath: addition overflow'
                                                                revert with memory
                                                                  from _5417 + (8 * ceil32(return_data.size)) + 672
                                                                   len (13 * ceil32(return_data.size)) + 100
                                                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2 - (arg2 / 100)
                                                            emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                                        mem[_5417 + (8 * ceil32(return_data.size)) + 676] = msg.sender
                                                        mem[_5417 + (8 * ceil32(return_data.size)) + 708] = balanceOf[address(msg.sender)]
                                                        require ext_code.size(dividendTrackerAddress)
                                                        call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args mem[_5417 + (8 * ceil32(return_data.size)) + 676 len (13 * ceil32(return_data.size)) + 64]
                                                        mem[_5417 + (8 * ceil32(return_data.size)) + 676] = arg1
                                                        mem[_5417 + (8 * ceil32(return_data.size)) + 708] = balanceOf[address(arg1)]
                                                        require ext_code.size(dividendTrackerAddress)
                                                        call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args mem[_5417 + (8 * ceil32(return_data.size)) + 676 len (13 * ceil32(return_data.size)) + 64]
                                                        if not stor7:
                                                            call dividendTrackerAddress.process(uint256 arg1) with:
                                                                 gas gas_remaining wei
                                                                args gasForProcessing
                                                            if ext_call.success:
                                                                require return_data.size >= 96
                                                                emit ProcessedDividendTracker(uint256 arg1, uint256 arg2, uint256 arg3, bool arg4, uint256 arg5, address arg6):
                                                                                              ext_call.return_data[0],
                                                                                              ext_call.return_data[32],
                                                                                              ext_call.return_data[64],
                                                                                              gasForProcessing,
                                                                                              mem[_5417 + (9 * ceil32(return_data.size)) + 800 len 5 * ceil32(return_data.size)],
                                                                                              1,
                                                                                              tx.origin,
                                                else:
                                                    if arg2 and totalFees > -1 / arg2:
                                                        revert with 0, 17
                                                    if not arg2:
                                                        revert with 0, 18
                                                    if arg2 * totalFees / arg2 != totalFees:
                                                        mem[_5417 + (8 * ceil32(return_data.size)) + 288] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_5417 + (8 * ceil32(return_data.size)) + 292] = 32
                                                        mem[_5417 + (8 * ceil32(return_data.size)) + 324] = 33
                                                        mem[_5417 + (8 * ceil32(return_data.size)) + 356] = 'SafeMath: multiplication overflo'
                                                        mem[_5417 + (8 * ceil32(return_data.size)) + 388] = 0x7700000000000000000000000000000000000000000000000000000000000000
                                                        revert with memory
                                                          from _5417 + (8 * ceil32(return_data.size)) + 288
                                                           len (13 * ceil32(return_data.size)) + 132
                                                    if not stor20[address(arg1)]:
                                                        if arg2 * totalFees / 100 > arg2:
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 420] = 32
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 452] = 30
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 484] = 'SafeMath: subtraction overflow'
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 514] = 0
                                                            revert with memory
                                                              from _5417 + (8 * ceil32(return_data.size)) + 416
                                                               len (13 * ceil32(return_data.size)) + 100
                                                        if arg2 < arg2 * totalFees / 100:
                                                            revert with 0, 17
                                                        if not msg.sender:
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 420] = 32
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 452] = 37
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 484] = 'ERC20: transfer from the zero ad'
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 516] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                            revert with memory
                                                              from _5417 + (8 * ceil32(return_data.size)) + 416
                                                               len (13 * ceil32(return_data.size)) + 132
                                                        if not this.address:
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 420] = 32
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 452] = 35
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 484] = 'ERC20: transfer to the zero addr'
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 516] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                            revert with memory
                                                              from _5417 + (8 * ceil32(return_data.size)) + 416
                                                               len (13 * ceil32(return_data.size)) + 132
                                                        if arg2 * totalFees / 100 > balanceOf[address(msg.sender)]:
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 512] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 516] = 32
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 548] = 38
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 580 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_5417 + (8 * ceil32(return_data.size)) + 486 len 26]
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 618] = 0
                                                            revert with memory
                                                              from _5417 + (8 * ceil32(return_data.size)) + 512
                                                               len (13 * ceil32(return_data.size)) + 132
                                                        if balanceOf[address(msg.sender)] < arg2 * totalFees / 100:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] -= arg2 * totalFees / 100
                                                        if balanceOf[this.address] > !(arg2 * totalFees / 100):
                                                            revert with 0, 17
                                                        if balanceOf[this.address] + (arg2 * totalFees / 100) < balanceOf[this.address]:
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 512] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 516] = 32
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 548] = 27
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 580] = 'SafeMath: addition overflow'
                                                            revert with memory
                                                              from _5417 + (8 * ceil32(return_data.size)) + 512
                                                               len (13 * ceil32(return_data.size)) + 100
                                                        balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 * totalFees / 100)
                                                        emit Transfer((arg2 * totalFees / 100), msg.sender, this.address);
                                                        if not msg.sender:
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 512] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 516] = 32
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 548] = 37
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 580] = 'ERC20: transfer from the zero ad'
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 612] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                            revert with memory
                                                              from _5417 + (8 * ceil32(return_data.size)) + 512
                                                               len (13 * ceil32(return_data.size)) + 132
                                                        if not arg1:
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 512] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 516] = 32
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 548] = 35
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 580] = 'ERC20: transfer to the zero addr'
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 612] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                            revert with memory
                                                              from _5417 + (8 * ceil32(return_data.size)) + 512
                                                               len (13 * ceil32(return_data.size)) + 132
                                                        if arg2 - (arg2 * totalFees / 100) > balanceOf[address(msg.sender)]:
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 608] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 612] = 32
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 644] = 38
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 676 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_5417 + (8 * ceil32(return_data.size)) + 582 len 26]
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 714] = 0
                                                            revert with memory
                                                              from _5417 + (8 * ceil32(return_data.size)) + 608
                                                               len (13 * ceil32(return_data.size)) + 132
                                                        if balanceOf[address(msg.sender)] < arg2 - (arg2 * totalFees / 100):
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - arg2 + (arg2 * totalFees / 100)
                                                        if balanceOf[arg1] > !(arg2 - (arg2 * totalFees / 100)):
                                                            revert with 0, 17
                                                        if balanceOf[arg1] + arg2 - (arg2 * totalFees / 100) < balanceOf[arg1]:
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 608] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 612] = 32
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 644] = 27
                                                            mem[_5417 + (8 * ceil32(return_data.size)) + 676] = 'SafeMath: addition overflow'
                                                            revert with memory
                                                              from _5417 + (8 * ceil32(return_data.size)) + 608
                                                               len (13 * ceil32(return_data.size)) + 100
                                                        balanceOf[address(arg1)] = balanceOf[arg1] + arg2 - (arg2 * totalFees / 100)
                                                        emit Transfer((arg2 - (arg2 * totalFees / 100)), msg.sender, arg1);
                                                        mem[_5417 + (8 * ceil32(return_data.size)) + 612] = msg.sender
                                                        mem[_5417 + (8 * ceil32(return_data.size)) + 644] = balanceOf[address(msg.sender)]
                                                        require ext_code.size(dividendTrackerAddress)
                                                        call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args mem[_5417 + (8 * ceil32(return_data.size)) + 612 len (13 * ceil32(return_data.size)) + 64]
                                                        mem[_5417 + (8 * ceil32(return_data.size)) + 612] = arg1
                                                        mem[_5417 + (8 * ceil32(return_data.size)) + 644] = balanceOf[address(arg1)]
                                                        require ext_code.size(dividendTrackerAddress)
                                                        call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args mem[_5417 + (8 * ceil32(return_data.size)) + 612 len (13 * ceil32(return_data.size)) + 64]
                                                        if not stor7:
                                                            call dividendTrackerAddress.process(uint256 arg1) with:
                                                                 gas gas_remaining wei
                                                                args gasForProcessing
                                                            if ext_call.success:
                                                                require return_data.size >= 96
                                                                emit ProcessedDividendTracker(uint256 arg1, uint256 arg2, uint256 arg3, bool arg4, uint256 arg5, address arg6):
                                                                                              ext_call.return_data[0],
                                                                                              ext_call.return_data[32],
                                                                                              ext_call.return_data[64],
                                                                                              gasForProcessing,
                                                                                              mem[_5417 + (9 * ceil32(return_data.size)) + 736 len 5 * ceil32(return_data.size)],
                                                                                              1,
                                                                                              tx.origin,
                                                    else:
                                                        if not arg2:
                                                            if arg2 * totalFees / 100 > -1:
                                                                revert with 0, 17
                                                            if arg2 * totalFees / 100 > arg2:
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 480] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 484] = 32
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 516] = 30
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 548] = 'SafeMath: subtraction overflow'
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 578] = 0
                                                                revert with memory
                                                                  from _5417 + (8 * ceil32(return_data.size)) + 480
                                                                   len (13 * ceil32(return_data.size)) + 100
                                                            if arg2 < arg2 * totalFees / 100:
                                                                revert with 0, 17
                                                            if not msg.sender:
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 480] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 484] = 32
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 516] = 37
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 548] = 'ERC20: transfer from the zero ad'
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 580] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                                revert with memory
                                                                  from _5417 + (8 * ceil32(return_data.size)) + 480
                                                                   len (13 * ceil32(return_data.size)) + 132
                                                            if not this.address:
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 480] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 484] = 32
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 516] = 35
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 548] = 'ERC20: transfer to the zero addr'
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 580] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                                revert with memory
                                                                  from _5417 + (8 * ceil32(return_data.size)) + 480
                                                                   len (13 * ceil32(return_data.size)) + 132
                                                            if arg2 * totalFees / 100 > balanceOf[address(msg.sender)]:
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 576] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 580] = 32
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 612] = 38
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 644 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_5417 + (8 * ceil32(return_data.size)) + 550 len 26]
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 682] = 0
                                                                revert with memory
                                                                  from _5417 + (8 * ceil32(return_data.size)) + 576
                                                                   len (13 * ceil32(return_data.size)) + 132
                                                            if balanceOf[address(msg.sender)] < arg2 * totalFees / 100:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2 * totalFees / 100
                                                            if balanceOf[this.address] > !(arg2 * totalFees / 100):
                                                                revert with 0, 17
                                                            if balanceOf[this.address] + (arg2 * totalFees / 100) < balanceOf[this.address]:
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 576] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 580] = 32
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 612] = 27
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 644] = 'SafeMath: addition overflow'
                                                                revert with memory
                                                                  from _5417 + (8 * ceil32(return_data.size)) + 576
                                                                   len (13 * ceil32(return_data.size)) + 100
                                                            balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 * totalFees / 100)
                                                            emit Transfer((arg2 * totalFees / 100), msg.sender, this.address);
                                                            if not msg.sender:
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 576] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 580] = 32
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 612] = 37
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 644] = 'ERC20: transfer from the zero ad'
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 676] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                                revert with memory
                                                                  from _5417 + (8 * ceil32(return_data.size)) + 576
                                                                   len (13 * ceil32(return_data.size)) + 132
                                                            if not arg1:
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 576] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 580] = 32
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 612] = 35
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 644] = 'ERC20: transfer to the zero addr'
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 676] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                                revert with memory
                                                                  from _5417 + (8 * ceil32(return_data.size)) + 576
                                                                   len (13 * ceil32(return_data.size)) + 132
                                                            if arg2 - (arg2 * totalFees / 100) > balanceOf[address(msg.sender)]:
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 672] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 676] = 32
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 708] = 38
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 740 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_5417 + (8 * ceil32(return_data.size)) + 646 len 26]
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 778] = 0
                                                                revert with memory
                                                                  from _5417 + (8 * ceil32(return_data.size)) + 672
                                                                   len (13 * ceil32(return_data.size)) + 132
                                                            if balanceOf[address(msg.sender)] < arg2 - (arg2 * totalFees / 100):
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - arg2 + (arg2 * totalFees / 100)
                                                            if balanceOf[arg1] > !(arg2 - (arg2 * totalFees / 100)):
                                                                revert with 0, 17
                                                            if balanceOf[arg1] + arg2 - (arg2 * totalFees / 100) < balanceOf[arg1]:
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 672] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 676] = 32
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 708] = 27
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 740] = 'SafeMath: addition overflow'
                                                                revert with memory
                                                                  from _5417 + (8 * ceil32(return_data.size)) + 672
                                                                   len (13 * ceil32(return_data.size)) + 100
                                                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2 - (arg2 * totalFees / 100)
                                                            emit Transfer((arg2 - (arg2 * totalFees / 100)), msg.sender, arg1);
                                                        else:
                                                            if arg2 and 1 > -1 / arg2:
                                                                revert with 0, 17
                                                            if not arg2:
                                                                revert with 0, 18
                                                            if arg2 / arg2 != 1:
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 352] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 356] = 32
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 388] = 33
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 420] = 'SafeMath: multiplication overflo'
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 452] = 0x7700000000000000000000000000000000000000000000000000000000000000
                                                                revert with memory
                                                                  from _5417 + (8 * ceil32(return_data.size)) + 352
                                                                   len (13 * ceil32(return_data.size)) + 132
                                                            if arg2 * totalFees / 100 > !(arg2 / 100):
                                                                revert with 0, 17
                                                            if (arg2 * totalFees / 100) + (arg2 / 100) > arg2:
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 480] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 484] = 32
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 516] = 30
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 548] = 'SafeMath: subtraction overflow'
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 578] = 0
                                                                revert with memory
                                                                  from _5417 + (8 * ceil32(return_data.size)) + 480
                                                                   len (13 * ceil32(return_data.size)) + 100
                                                            if arg2 < (arg2 * totalFees / 100) + (arg2 / 100):
                                                                revert with 0, 17
                                                            if not msg.sender:
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 480] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 484] = 32
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 516] = 37
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 548] = 'ERC20: transfer from the zero ad'
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 580] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                                revert with memory
                                                                  from _5417 + (8 * ceil32(return_data.size)) + 480
                                                                   len (13 * ceil32(return_data.size)) + 132
                                                            if not this.address:
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 480] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 484] = 32
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 516] = 35
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 548] = 'ERC20: transfer to the zero addr'
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 580] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                                revert with memory
                                                                  from _5417 + (8 * ceil32(return_data.size)) + 480
                                                                   len (13 * ceil32(return_data.size)) + 132
                                                            if (arg2 * totalFees / 100) + (arg2 / 100) > balanceOf[address(msg.sender)]:
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 576] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 580] = 32
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 612] = 38
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 644 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_5417 + (8 * ceil32(return_data.size)) + 550 len 26]
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 682] = 0
                                                                revert with memory
                                                                  from _5417 + (8 * ceil32(return_data.size)) + 576
                                                                   len (13 * ceil32(return_data.size)) + 132
                                                            if balanceOf[address(msg.sender)] < (arg2 * totalFees / 100) + (arg2 / 100):
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - (arg2 * totalFees / 100) - (arg2 / 100)
                                                            if balanceOf[this.address] > !((arg2 * totalFees / 100) + (arg2 / 100)):
                                                                revert with 0, 17
                                                            if balanceOf[this.address] + (arg2 * totalFees / 100) + (arg2 / 100) < balanceOf[this.address]:
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 576] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 580] = 32
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 612] = 27
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 644] = 'SafeMath: addition overflow'
                                                                revert with memory
                                                                  from _5417 + (8 * ceil32(return_data.size)) + 576
                                                                   len (13 * ceil32(return_data.size)) + 100
                                                            balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 * totalFees / 100) + (arg2 / 100)
                                                            emit Transfer(((arg2 * totalFees / 100) + (arg2 / 100)), msg.sender, this.address);
                                                            if not msg.sender:
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 576] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 580] = 32
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 612] = 37
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 644] = 'ERC20: transfer from the zero ad'
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 676] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                                revert with memory
                                                                  from _5417 + (8 * ceil32(return_data.size)) + 576
                                                                   len (13 * ceil32(return_data.size)) + 132
                                                            if not arg1:
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 576] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 580] = 32
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 612] = 35
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 644] = 'ERC20: transfer to the zero addr'
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 676] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                                revert with memory
                                                                  from _5417 + (8 * ceil32(return_data.size)) + 576
                                                                   len (13 * ceil32(return_data.size)) + 132
                                                            if arg2 - (arg2 * totalFees / 100) - (arg2 / 100) > balanceOf[address(msg.sender)]:
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 672] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 676] = 32
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 708] = 38
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 740 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_5417 + (8 * ceil32(return_data.size)) + 646 len 26]
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 778] = 0
                                                                revert with memory
                                                                  from _5417 + (8 * ceil32(return_data.size)) + 672
                                                                   len (13 * ceil32(return_data.size)) + 132
                                                            if balanceOf[address(msg.sender)] < arg2 - (arg2 * totalFees / 100) - (arg2 / 100):
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - arg2 + (arg2 * totalFees / 100) + (arg2 / 100)
                                                            if balanceOf[arg1] > !(arg2 - (arg2 * totalFees / 100) - (arg2 / 100)):
                                                                revert with 0, 17
                                                            if balanceOf[arg1] + arg2 - (arg2 * totalFees / 100) - (arg2 / 100) < balanceOf[arg1]:
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 672] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 676] = 32
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 708] = 27
                                                                mem[_5417 + (8 * ceil32(return_data.size)) + 740] = 'SafeMath: addition overflow'
                                                                revert with memory
                                                                  from _5417 + (8 * ceil32(return_data.size)) + 672
                                                                   len (13 * ceil32(return_data.size)) + 100
                                                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2 - (arg2 * totalFees / 100) - (arg2 / 100)
                                                            emit Transfer((arg2 - (arg2 * totalFees / 100) - (arg2 / 100)), msg.sender, arg1);
                                                        mem[_5417 + (8 * ceil32(return_data.size)) + 676] = msg.sender
                                                        mem[_5417 + (8 * ceil32(return_data.size)) + 708] = balanceOf[address(msg.sender)]
                                                        require ext_code.size(dividendTrackerAddress)
                                                        call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args mem[_5417 + (8 * ceil32(return_data.size)) + 676 len (13 * ceil32(return_data.size)) + 64]
                                                        mem[_5417 + (8 * ceil32(return_data.size)) + 676] = arg1
                                                        mem[_5417 + (8 * ceil32(return_data.size)) + 708] = balanceOf[address(arg1)]
                                                        require ext_code.size(dividendTrackerAddress)
                                                        call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args mem[_5417 + (8 * ceil32(return_data.size)) + 676 len (13 * ceil32(return_data.size)) + 64]
                                                        if not stor7:
                                                            call dividendTrackerAddress.process(uint256 arg1) with:
                                                                 gas gas_remaining wei
                                                                args gasForProcessing
                                                            if ext_call.success:
                                                                require return_data.size >= 96
                                                                emit ProcessedDividendTracker(uint256 arg1, uint256 arg2, uint256 arg3, bool arg4, uint256 arg5, address arg6):
                                                                                              ext_call.return_data[0],
                                                                                              ext_call.return_data[32],
                                                                                              ext_call.return_data[64],
                                                                                              gasForProcessing,
                                                                                              mem[_5417 + (9 * ceil32(return_data.size)) + 800 len 5 * ceil32(return_data.size)],
                                                                                              1,
                                                                                              tx.origin,
                                else:
                                    if balanceOf[this.address] and stor14 > -1 / balanceOf[this.address]:
                                        revert with 0, 17
                                    if not balanceOf[this.address]:
                                        revert with 0, 18
                                    if balanceOf[this.address] * stor14 / balanceOf[this.address] != stor14:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _5381 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5381] = 26
                                    mem[_5381 + 32] = 'SafeMath: division by zero'
                                    if not totalFees:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    _5399 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5399] = 26
                                    mem[_5399 + 32] = 'SafeMath: division by zero'
                                    _5409 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5409] = 30
                                    mem[_5409 + 32] = 'SafeMath: subtraction overflow'
                                    if balanceOf[this.address] * stor14 / totalFees / 2 > balanceOf[this.address] * stor14 / totalFees:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if balanceOf[this.address] * stor14 / totalFees < balanceOf[this.address] * stor14 / totalFees / 2:
                                        revert with 0, 17
                                    _5437 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    mem[_5437 + 32 len 64] = call.data[calldata.size len 64]
                                    if 0 >= mem[_5437]:
                                        revert with 0, 50
                                    mem[_5437 + 32] = this.address
                                    staticcall uniswapV2RouterAddress.WETH() with:
                                            gas gas_remaining wei
                                    mem[_5437 + 96] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = _5437 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    if 1 >= mem[_5437]:
                                        revert with 0, 50
                                    mem[_5437 + 64] = ext_call.return_data[12 len 20]
                                    if not this.address:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not uniswapV2RouterAddress:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    mem[0] = uniswapV2RouterAddress
                                    mem[32] = sha3(address(this.address), 1)
                                    allowance[address(this.address)][stor6].field_0 = balanceOf[this.address] * stor14 / totalFees / 2
                                    allowance[address(this.address)][stor6].field_255 = 0
                                    emit Approval((balanceOf[this.address] * stor14 / totalFees / 2), this.address, uniswapV2RouterAddress);
                                    mem[_5437 + ceil32(return_data.size) + 96] = 0x791ac94700000000000000000000000000000000000000000000000000000000
                                    mem[_5437 + ceil32(return_data.size) + 100] = balanceOf[this.address] * stor14 / totalFees / 2
                                    mem[_5437 + ceil32(return_data.size) + 132] = 0
                                    mem[_5437 + ceil32(return_data.size) + 164] = 160
                                    mem[_5437 + ceil32(return_data.size) + 260] = mem[_5437]
                                    idx = 0
                                    s = _5437 + ceil32(return_data.size) + 292
                                    t = _5437 + 32
                                    while idx < mem[_5437]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args Mask(255, 1, balanceOf[this.address] * stor14 / totalFees), 0, 160, address(this.address), block.timestamp, mem[_5437 + ceil32(return_data.size) + 260 len (32 * mem[_5437]) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_5437 + ceil32(return_data.size) + 96] = 30
                                    mem[_5437 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                    if eth.balance(this.address) > eth.balance(this.address):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if eth.balance(this.address) < eth.balance(this.address):
                                        revert with 0, 17
                                    if not this.address:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not uniswapV2RouterAddress:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(this.address)][stor6].field_0 = (balanceOf[this.address] * stor14 / totalFees) - (balanceOf[this.address] * stor14 / totalFees / 2)
                                    emit Approval(((balanceOf[this.address] * stor14 / totalFees) - (balanceOf[this.address] * stor14 / totalFees / 2)), this.address, uniswapV2RouterAddress);
                                    mem[_5437 + ceil32(return_data.size) + 228] = 0
                                    mem[_5437 + ceil32(return_data.size) + 260] = 0
                                    mem[_5437 + ceil32(return_data.size) + 292] = stor17
                                    mem[_5437 + ceil32(return_data.size) + 324] = block.timestamp
                                    call uniswapV2RouterAddress.addLiquidityETH(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                         gas gas_remaining wei
                                        args this.address, (balanceOf[this.address] * stor14 / totalFees) - (balanceOf[this.address] * stor14 / totalFees / 2), 0, 0, stor17, block.timestamp
                                    mem[_5437 + ceil32(return_data.size) + 160 len 96] = ext_call.return_data[0 len 96]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 96
                                    emit SwapAndLiquify(Mask(255, 1, balanceOf[this.address] * stor14 / totalFees), 0, (balanceOf[this.address] * stor14 / totalFees) - (balanceOf[this.address] * stor14 / totalFees / 2));
                                    mem[_5437 + (2 * ceil32(return_data.size)) + 160] = 3
                                    mem[_5437 + (2 * ceil32(return_data.size)) + 192] = this.address
                                    staticcall uniswapV2RouterAddress.WETH() with:
                                            gas gas_remaining wei
                                    mem[_5437 + (2 * ceil32(return_data.size)) + 288] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    mem[_5437 + (2 * ceil32(return_data.size)) + 224] = ext_call.return_data[12 len 20]
                                    mem[_5437 + (2 * ceil32(return_data.size)) + 256] = sub_4d7effddAddress
                                    if not this.address:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not uniswapV2RouterAddress:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(this.address)][stor6].field_0 = balanceOf[this.address]
                                    emit Approval(balanceOf[this.address], this.address, uniswapV2RouterAddress);
                                    mem[_5437 + (4 * ceil32(return_data.size)) + 288] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                    mem[_5437 + (4 * ceil32(return_data.size)) + 292] = balanceOf[this.address]
                                    mem[_5437 + (4 * ceil32(return_data.size)) + 324] = 0
                                    mem[_5437 + (4 * ceil32(return_data.size)) + 356] = 160
                                    mem[_5437 + (4 * ceil32(return_data.size)) + 452] = 3
                                    idx = 0
                                    s = _5437 + (4 * ceil32(return_data.size)) + 484
                                    t = _5437 + (2 * ceil32(return_data.size)) + 192
                                    while idx < mem[_5437 + (2 * ceil32(return_data.size)) + 160]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[_5437 + (4 * ceil32(return_data.size)) + 388] = this.address
                                    mem[_5437 + (4 * ceil32(return_data.size)) + 420] = block.timestamp
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                         gas gas_remaining wei
                                        args balanceOf[this.address], 0, 160, address(this.address), block.timestamp, mem[_5437 + (4 * ceil32(return_data.size)) + 452 len (32 * mem[_5437 + (2 * ceil32(return_data.size)) + 160]) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    staticcall sub_4d7effddAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    require return_data.size >= 32
                                    mem[_5437 + (4 * ceil32(return_data.size)) + 292] = dividendTrackerAddress
                                    mem[_5437 + (4 * ceil32(return_data.size)) + 324] = ext_call.return_data[0]
                                    call sub_4d7effddAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args mem[_5437 + (4 * ceil32(return_data.size)) + 292 len (7 * ceil32(return_data.size)) + 64]
                                    mem[_5437 + (4 * ceil32(return_data.size)) + 288] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                    if ext_call.return_data[0]:
                                        require ext_code.size(dividendTrackerAddress)
                                        call dividendTrackerAddress.distributeDogeDividends(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        emit SendDividends(balanceOf[this.address], ext_call.return_data[0]);
                                    stor7 = 0
                                    if stor19[address(msg.sender)]:
                                        if not msg.sender:
                                            mem[_5437 + (8 * ceil32(return_data.size)) + 288] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_5437 + (8 * ceil32(return_data.size)) + 292] = 32
                                            mem[_5437 + (8 * ceil32(return_data.size)) + 324] = 37
                                            mem[_5437 + (8 * ceil32(return_data.size)) + 356] = 'ERC20: transfer from the zero ad'
                                            mem[_5437 + (8 * ceil32(return_data.size)) + 388] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                            revert with memory
                                              from _5437 + (8 * ceil32(return_data.size)) + 288
                                               len (13 * ceil32(return_data.size)) + 132
                                        if not arg1:
                                            mem[_5437 + (8 * ceil32(return_data.size)) + 288] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_5437 + (8 * ceil32(return_data.size)) + 292] = 32
                                            mem[_5437 + (8 * ceil32(return_data.size)) + 324] = 35
                                            mem[_5437 + (8 * ceil32(return_data.size)) + 356] = 'ERC20: transfer to the zero addr'
                                            mem[_5437 + (8 * ceil32(return_data.size)) + 388] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                            revert with memory
                                              from _5437 + (8 * ceil32(return_data.size)) + 288
                                               len (13 * ceil32(return_data.size)) + 132
                                        if arg2 > balanceOf[address(msg.sender)]:
                                            mem[_5437 + (8 * ceil32(return_data.size)) + 384] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_5437 + (8 * ceil32(return_data.size)) + 388] = 32
                                            mem[_5437 + (8 * ceil32(return_data.size)) + 420] = 38
                                            mem[_5437 + (8 * ceil32(return_data.size)) + 452 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_5437 + (8 * ceil32(return_data.size)) + 358 len 26]
                                            mem[_5437 + (8 * ceil32(return_data.size)) + 490] = 0
                                            revert with memory
                                              from _5437 + (8 * ceil32(return_data.size)) + 384
                                               len (13 * ceil32(return_data.size)) + 132
                                        if balanceOf[address(msg.sender)] < arg2:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= arg2
                                        if balanceOf[arg1] > !arg2:
                                            revert with 0, 17
                                        if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                            mem[_5437 + (8 * ceil32(return_data.size)) + 384] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[_5437 + (8 * ceil32(return_data.size)) + 388] = 32
                                            mem[_5437 + (8 * ceil32(return_data.size)) + 420] = 27
                                            mem[_5437 + (8 * ceil32(return_data.size)) + 452] = 'SafeMath: addition overflow'
                                            revert with memory
                                              from _5437 + (8 * ceil32(return_data.size)) + 384
                                               len (13 * ceil32(return_data.size)) + 100
                                        balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                        emit Transfer(arg2, msg.sender, arg1);
                                        mem[_5437 + (8 * ceil32(return_data.size)) + 388] = msg.sender
                                        mem[_5437 + (8 * ceil32(return_data.size)) + 420] = balanceOf[address(msg.sender)]
                                        require ext_code.size(dividendTrackerAddress)
                                        call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                             gas gas_remaining wei
                                            args mem[_5437 + (8 * ceil32(return_data.size)) + 388 len (13 * ceil32(return_data.size)) + 64]
                                        mem[_5437 + (8 * ceil32(return_data.size)) + 388] = arg1
                                        mem[_5437 + (8 * ceil32(return_data.size)) + 420] = balanceOf[address(arg1)]
                                        require ext_code.size(dividendTrackerAddress)
                                        call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                             gas gas_remaining wei
                                            args mem[_5437 + (8 * ceil32(return_data.size)) + 388 len (13 * ceil32(return_data.size)) + 64]
                                        if not stor7:
                                            call dividendTrackerAddress.process(uint256 arg1) with:
                                                 gas gas_remaining wei
                                                args gasForProcessing
                                            if ext_call.success:
                                                require return_data.size >= 96
                                                emit ProcessedDividendTracker(uint256 arg1, uint256 arg2, uint256 arg3, bool arg4, uint256 arg5, address arg6):
                                                                              ext_call.return_data[0],
                                                                              ext_call.return_data[32],
                                                                              ext_call.return_data[64],
                                                                              gasForProcessing,
                                                                              mem[_5437 + (9 * ceil32(return_data.size)) + 512 len 5 * ceil32(return_data.size)],
                                                                              1,
                                                                              tx.origin,
                                    else:
                                        if stor19[address(arg1)]:
                                            if not msg.sender:
                                                mem[_5437 + (8 * ceil32(return_data.size)) + 288] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[_5437 + (8 * ceil32(return_data.size)) + 292] = 32
                                                mem[_5437 + (8 * ceil32(return_data.size)) + 324] = 37
                                                mem[_5437 + (8 * ceil32(return_data.size)) + 356] = 'ERC20: transfer from the zero ad'
                                                mem[_5437 + (8 * ceil32(return_data.size)) + 388] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                revert with memory
                                                  from _5437 + (8 * ceil32(return_data.size)) + 288
                                                   len (13 * ceil32(return_data.size)) + 132
                                            if not arg1:
                                                mem[_5437 + (8 * ceil32(return_data.size)) + 288] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[_5437 + (8 * ceil32(return_data.size)) + 292] = 32
                                                mem[_5437 + (8 * ceil32(return_data.size)) + 324] = 35
                                                mem[_5437 + (8 * ceil32(return_data.size)) + 356] = 'ERC20: transfer to the zero addr'
                                                mem[_5437 + (8 * ceil32(return_data.size)) + 388] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                revert with memory
                                                  from _5437 + (8 * ceil32(return_data.size)) + 288
                                                   len (13 * ceil32(return_data.size)) + 132
                                            if arg2 > balanceOf[address(msg.sender)]:
                                                mem[_5437 + (8 * ceil32(return_data.size)) + 384] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[_5437 + (8 * ceil32(return_data.size)) + 388] = 32
                                                mem[_5437 + (8 * ceil32(return_data.size)) + 420] = 38
                                                mem[_5437 + (8 * ceil32(return_data.size)) + 452 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_5437 + (8 * ceil32(return_data.size)) + 358 len 26]
                                                mem[_5437 + (8 * ceil32(return_data.size)) + 490] = 0
                                                revert with memory
                                                  from _5437 + (8 * ceil32(return_data.size)) + 384
                                                   len (13 * ceil32(return_data.size)) + 132
                                            if balanceOf[address(msg.sender)] < arg2:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= arg2
                                            if balanceOf[arg1] > !arg2:
                                                revert with 0, 17
                                            if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                mem[_5437 + (8 * ceil32(return_data.size)) + 384] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[_5437 + (8 * ceil32(return_data.size)) + 388] = 32
                                                mem[_5437 + (8 * ceil32(return_data.size)) + 420] = 27
                                                mem[_5437 + (8 * ceil32(return_data.size)) + 452] = 'SafeMath: addition overflow'
                                                revert with memory
                                                  from _5437 + (8 * ceil32(return_data.size)) + 384
                                                   len (13 * ceil32(return_data.size)) + 100
                                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                            emit Transfer(arg2, msg.sender, arg1);
                                            mem[_5437 + (8 * ceil32(return_data.size)) + 388] = msg.sender
                                            mem[_5437 + (8 * ceil32(return_data.size)) + 420] = balanceOf[address(msg.sender)]
                                            require ext_code.size(dividendTrackerAddress)
                                            call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args mem[_5437 + (8 * ceil32(return_data.size)) + 388 len (13 * ceil32(return_data.size)) + 64]
                                            mem[_5437 + (8 * ceil32(return_data.size)) + 388] = arg1
                                            mem[_5437 + (8 * ceil32(return_data.size)) + 420] = balanceOf[address(arg1)]
                                            require ext_code.size(dividendTrackerAddress)
                                            call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args mem[_5437 + (8 * ceil32(return_data.size)) + 388 len (13 * ceil32(return_data.size)) + 64]
                                            if not stor7:
                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                     gas gas_remaining wei
                                                    args gasForProcessing
                                                if ext_call.success:
                                                    require return_data.size >= 96
                                                    emit ProcessedDividendTracker(uint256 arg1, uint256 arg2, uint256 arg3, bool arg4, uint256 arg5, address arg6):
                                                                                  ext_call.return_data[0],
                                                                                  ext_call.return_data[32],
                                                                                  ext_call.return_data[64],
                                                                                  gasForProcessing,
                                                                                  mem[_5437 + (9 * ceil32(return_data.size)) + 512 len 5 * ceil32(return_data.size)],
                                                                                  1,
                                                                                  tx.origin,
                                        else:
                                            if stor7:
                                                if not msg.sender:
                                                    mem[_5437 + (8 * ceil32(return_data.size)) + 288] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_5437 + (8 * ceil32(return_data.size)) + 292] = 32
                                                    mem[_5437 + (8 * ceil32(return_data.size)) + 324] = 37
                                                    mem[_5437 + (8 * ceil32(return_data.size)) + 356] = 'ERC20: transfer from the zero ad'
                                                    mem[_5437 + (8 * ceil32(return_data.size)) + 388] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                    revert with memory
                                                      from _5437 + (8 * ceil32(return_data.size)) + 288
                                                       len (13 * ceil32(return_data.size)) + 132
                                                if not arg1:
                                                    mem[_5437 + (8 * ceil32(return_data.size)) + 288] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_5437 + (8 * ceil32(return_data.size)) + 292] = 32
                                                    mem[_5437 + (8 * ceil32(return_data.size)) + 324] = 35
                                                    mem[_5437 + (8 * ceil32(return_data.size)) + 356] = 'ERC20: transfer to the zero addr'
                                                    mem[_5437 + (8 * ceil32(return_data.size)) + 388] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                    revert with memory
                                                      from _5437 + (8 * ceil32(return_data.size)) + 288
                                                       len (13 * ceil32(return_data.size)) + 132
                                                if arg2 > balanceOf[address(msg.sender)]:
                                                    mem[_5437 + (8 * ceil32(return_data.size)) + 384] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_5437 + (8 * ceil32(return_data.size)) + 388] = 32
                                                    mem[_5437 + (8 * ceil32(return_data.size)) + 420] = 38
                                                    mem[_5437 + (8 * ceil32(return_data.size)) + 452 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_5437 + (8 * ceil32(return_data.size)) + 358 len 26]
                                                    mem[_5437 + (8 * ceil32(return_data.size)) + 490] = 0
                                                    revert with memory
                                                      from _5437 + (8 * ceil32(return_data.size)) + 384
                                                       len (13 * ceil32(return_data.size)) + 132
                                                if balanceOf[address(msg.sender)] < arg2:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= arg2
                                                if balanceOf[arg1] > !arg2:
                                                    revert with 0, 17
                                                if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                    mem[_5437 + (8 * ceil32(return_data.size)) + 384] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_5437 + (8 * ceil32(return_data.size)) + 388] = 32
                                                    mem[_5437 + (8 * ceil32(return_data.size)) + 420] = 27
                                                    mem[_5437 + (8 * ceil32(return_data.size)) + 452] = 'SafeMath: addition overflow'
                                                    revert with memory
                                                      from _5437 + (8 * ceil32(return_data.size)) + 384
                                                       len (13 * ceil32(return_data.size)) + 100
                                                balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                emit Transfer(arg2, msg.sender, arg1);
                                                mem[_5437 + (8 * ceil32(return_data.size)) + 388] = msg.sender
                                                mem[_5437 + (8 * ceil32(return_data.size)) + 420] = balanceOf[address(msg.sender)]
                                                require ext_code.size(dividendTrackerAddress)
                                                call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args mem[_5437 + (8 * ceil32(return_data.size)) + 388 len (13 * ceil32(return_data.size)) + 64]
                                                mem[_5437 + (8 * ceil32(return_data.size)) + 388] = arg1
                                                mem[_5437 + (8 * ceil32(return_data.size)) + 420] = balanceOf[address(arg1)]
                                                require ext_code.size(dividendTrackerAddress)
                                                call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args mem[_5437 + (8 * ceil32(return_data.size)) + 388 len (13 * ceil32(return_data.size)) + 64]
                                                if not stor7:
                                                    call dividendTrackerAddress.process(uint256 arg1) with:
                                                         gas gas_remaining wei
                                                        args gasForProcessing
                                                    if ext_call.success:
                                                        require return_data.size >= 96
                                                        emit ProcessedDividendTracker(uint256 arg1, uint256 arg2, uint256 arg3, bool arg4, uint256 arg5, address arg6):
                                                                                      ext_call.return_data[0],
                                                                                      ext_call.return_data[32],
                                                                                      ext_call.return_data[64],
                                                                                      gasForProcessing,
                                                                                      mem[_5437 + (9 * ceil32(return_data.size)) + 512 len 5 * ceil32(return_data.size)],
                                                                                      1,
                                                                                      tx.origin,
                                            else:
                                                if not arg2:
                                                    if not stor20[address(arg1)]:
                                                        if 0 > arg2:
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 420] = 32
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 452] = 30
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 484] = 'SafeMath: subtraction overflow'
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 514] = 0
                                                            revert with memory
                                                              from _5437 + (8 * ceil32(return_data.size)) + 416
                                                               len (13 * ceil32(return_data.size)) + 100
                                                        if arg2 < 0:
                                                            revert with 0, 17
                                                        if not msg.sender:
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 420] = 32
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 452] = 37
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 484] = 'ERC20: transfer from the zero ad'
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 516] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                            revert with memory
                                                              from _5437 + (8 * ceil32(return_data.size)) + 416
                                                               len (13 * ceil32(return_data.size)) + 132
                                                        if not this.address:
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 420] = 32
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 452] = 35
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 484] = 'ERC20: transfer to the zero addr'
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 516] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                            revert with memory
                                                              from _5437 + (8 * ceil32(return_data.size)) + 416
                                                               len (13 * ceil32(return_data.size)) + 132
                                                        if 0 > balanceOf[address(msg.sender)]:
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 512] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 516] = 32
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 548] = 38
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 580 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_5437 + (8 * ceil32(return_data.size)) + 486 len 26]
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 618] = 0
                                                            revert with memory
                                                              from _5437 + (8 * ceil32(return_data.size)) + 512
                                                               len (13 * ceil32(return_data.size)) + 132
                                                        if balanceOf[address(msg.sender)] < 0:
                                                            revert with 0, 17
                                                        if balanceOf[this.address] > -1:
                                                            revert with 0, 17
                                                        if balanceOf[this.address] < balanceOf[this.address]:
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 512] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 516] = 32
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 548] = 27
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 580] = 'SafeMath: addition overflow'
                                                            revert with memory
                                                              from _5437 + (8 * ceil32(return_data.size)) + 512
                                                               len (13 * ceil32(return_data.size)) + 100
                                                        balanceOf[address(this.address)] = balanceOf[this.address]
                                                        emit Transfer(0, msg.sender, this.address);
                                                        if not msg.sender:
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 512] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 516] = 32
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 548] = 37
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 580] = 'ERC20: transfer from the zero ad'
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 612] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                            revert with memory
                                                              from _5437 + (8 * ceil32(return_data.size)) + 512
                                                               len (13 * ceil32(return_data.size)) + 132
                                                        if not arg1:
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 512] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 516] = 32
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 548] = 35
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 580] = 'ERC20: transfer to the zero addr'
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 612] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                            revert with memory
                                                              from _5437 + (8 * ceil32(return_data.size)) + 512
                                                               len (13 * ceil32(return_data.size)) + 132
                                                        if arg2 > balanceOf[address(msg.sender)]:
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 608] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 612] = 32
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 644] = 38
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 676 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_5437 + (8 * ceil32(return_data.size)) + 582 len 26]
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 714] = 0
                                                            revert with memory
                                                              from _5437 + (8 * ceil32(return_data.size)) + 608
                                                               len (13 * ceil32(return_data.size)) + 132
                                                        if balanceOf[address(msg.sender)] < arg2:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] -= arg2
                                                        if balanceOf[arg1] > !arg2:
                                                            revert with 0, 17
                                                        if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 608] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 612] = 32
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 644] = 27
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 676] = 'SafeMath: addition overflow'
                                                            revert with memory
                                                              from _5437 + (8 * ceil32(return_data.size)) + 608
                                                               len (13 * ceil32(return_data.size)) + 100
                                                        balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                        emit Transfer(arg2, msg.sender, arg1);
                                                        mem[_5437 + (8 * ceil32(return_data.size)) + 612] = msg.sender
                                                        mem[_5437 + (8 * ceil32(return_data.size)) + 644] = balanceOf[address(msg.sender)]
                                                        require ext_code.size(dividendTrackerAddress)
                                                        call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args mem[_5437 + (8 * ceil32(return_data.size)) + 612 len (13 * ceil32(return_data.size)) + 64]
                                                        mem[_5437 + (8 * ceil32(return_data.size)) + 612] = arg1
                                                        mem[_5437 + (8 * ceil32(return_data.size)) + 644] = balanceOf[address(arg1)]
                                                        require ext_code.size(dividendTrackerAddress)
                                                        call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args mem[_5437 + (8 * ceil32(return_data.size)) + 612 len (13 * ceil32(return_data.size)) + 64]
                                                        if not stor7:
                                                            call dividendTrackerAddress.process(uint256 arg1) with:
                                                                 gas gas_remaining wei
                                                                args gasForProcessing
                                                            if ext_call.success:
                                                                require return_data.size >= 96
                                                                emit ProcessedDividendTracker(uint256 arg1, uint256 arg2, uint256 arg3, bool arg4, uint256 arg5, address arg6):
                                                                                              ext_call.return_data[0],
                                                                                              ext_call.return_data[32],
                                                                                              ext_call.return_data[64],
                                                                                              gasForProcessing,
                                                                                              mem[_5437 + (9 * ceil32(return_data.size)) + 736 len 5 * ceil32(return_data.size)],
                                                                                              1,
                                                                                              tx.origin,
                                                    else:
                                                        if not arg2:
                                                            if 0 > arg2:
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 480] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 484] = 32
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 516] = 30
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 548] = 'SafeMath: subtraction overflow'
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 578] = 0
                                                                revert with memory
                                                                  from _5437 + (8 * ceil32(return_data.size)) + 480
                                                                   len (13 * ceil32(return_data.size)) + 100
                                                            if arg2 < 0:
                                                                revert with 0, 17
                                                            if not msg.sender:
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 480] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 484] = 32
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 516] = 37
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 548] = 'ERC20: transfer from the zero ad'
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 580] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                                revert with memory
                                                                  from _5437 + (8 * ceil32(return_data.size)) + 480
                                                                   len (13 * ceil32(return_data.size)) + 132
                                                            if not this.address:
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 480] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 484] = 32
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 516] = 35
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 548] = 'ERC20: transfer to the zero addr'
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 580] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                                revert with memory
                                                                  from _5437 + (8 * ceil32(return_data.size)) + 480
                                                                   len (13 * ceil32(return_data.size)) + 132
                                                            if 0 > balanceOf[address(msg.sender)]:
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 576] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 580] = 32
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 612] = 38
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 644 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_5437 + (8 * ceil32(return_data.size)) + 550 len 26]
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 682] = 0
                                                                revert with memory
                                                                  from _5437 + (8 * ceil32(return_data.size)) + 576
                                                                   len (13 * ceil32(return_data.size)) + 132
                                                            if balanceOf[address(msg.sender)] < 0:
                                                                revert with 0, 17
                                                            if balanceOf[this.address] > -1:
                                                                revert with 0, 17
                                                            if balanceOf[this.address] < balanceOf[this.address]:
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 576] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 580] = 32
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 612] = 27
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 644] = 'SafeMath: addition overflow'
                                                                revert with memory
                                                                  from _5437 + (8 * ceil32(return_data.size)) + 576
                                                                   len (13 * ceil32(return_data.size)) + 100
                                                            balanceOf[address(this.address)] = balanceOf[this.address]
                                                            emit Transfer(0, msg.sender, this.address);
                                                            if not msg.sender:
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 576] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 580] = 32
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 612] = 37
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 644] = 'ERC20: transfer from the zero ad'
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 676] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                                revert with memory
                                                                  from _5437 + (8 * ceil32(return_data.size)) + 576
                                                                   len (13 * ceil32(return_data.size)) + 132
                                                            if not arg1:
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 576] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 580] = 32
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 612] = 35
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 644] = 'ERC20: transfer to the zero addr'
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 676] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                                revert with memory
                                                                  from _5437 + (8 * ceil32(return_data.size)) + 576
                                                                   len (13 * ceil32(return_data.size)) + 132
                                                            if arg2 > balanceOf[address(msg.sender)]:
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 672] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 676] = 32
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 708] = 38
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 740 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_5437 + (8 * ceil32(return_data.size)) + 646 len 26]
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 778] = 0
                                                                revert with memory
                                                                  from _5437 + (8 * ceil32(return_data.size)) + 672
                                                                   len (13 * ceil32(return_data.size)) + 132
                                                            if balanceOf[address(msg.sender)] < arg2:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2
                                                            if balanceOf[arg1] > !arg2:
                                                                revert with 0, 17
                                                            if balanceOf[arg1] + arg2 < balanceOf[arg1]:
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 672] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 676] = 32
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 708] = 27
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 740] = 'SafeMath: addition overflow'
                                                                revert with memory
                                                                  from _5437 + (8 * ceil32(return_data.size)) + 672
                                                                   len (13 * ceil32(return_data.size)) + 100
                                                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2
                                                            emit Transfer(arg2, msg.sender, arg1);
                                                        else:
                                                            if arg2 and 1 > -1 / arg2:
                                                                revert with 0, 17
                                                            if not arg2:
                                                                revert with 0, 18
                                                            if arg2 / arg2 != 1:
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 352] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 356] = 32
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 388] = 33
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 420] = 'SafeMath: multiplication overflo'
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 452] = 0x7700000000000000000000000000000000000000000000000000000000000000
                                                                revert with memory
                                                                  from _5437 + (8 * ceil32(return_data.size)) + 352
                                                                   len (13 * ceil32(return_data.size)) + 132
                                                            if 0 > !(arg2 / 100):
                                                                revert with 0, 17
                                                            if arg2 / 100 > arg2:
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 480] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 484] = 32
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 516] = 30
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 548] = 'SafeMath: subtraction overflow'
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 578] = 0
                                                                revert with memory
                                                                  from _5437 + (8 * ceil32(return_data.size)) + 480
                                                                   len (13 * ceil32(return_data.size)) + 100
                                                            if arg2 < arg2 / 100:
                                                                revert with 0, 17
                                                            if not msg.sender:
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 480] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 484] = 32
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 516] = 37
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 548] = 'ERC20: transfer from the zero ad'
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 580] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                                revert with memory
                                                                  from _5437 + (8 * ceil32(return_data.size)) + 480
                                                                   len (13 * ceil32(return_data.size)) + 132
                                                            if not this.address:
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 480] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 484] = 32
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 516] = 35
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 548] = 'ERC20: transfer to the zero addr'
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 580] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                                revert with memory
                                                                  from _5437 + (8 * ceil32(return_data.size)) + 480
                                                                   len (13 * ceil32(return_data.size)) + 132
                                                            if arg2 / 100 > balanceOf[address(msg.sender)]:
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 576] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 580] = 32
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 612] = 38
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 644 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_5437 + (8 * ceil32(return_data.size)) + 550 len 26]
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 682] = 0
                                                                revert with memory
                                                                  from _5437 + (8 * ceil32(return_data.size)) + 576
                                                                   len (13 * ceil32(return_data.size)) + 132
                                                            if balanceOf[address(msg.sender)] < arg2 / 100:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2 / 100
                                                            if balanceOf[this.address] > !(arg2 / 100):
                                                                revert with 0, 17
                                                            if balanceOf[this.address] + (arg2 / 100) < balanceOf[this.address]:
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 576] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 580] = 32
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 612] = 27
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 644] = 'SafeMath: addition overflow'
                                                                revert with memory
                                                                  from _5437 + (8 * ceil32(return_data.size)) + 576
                                                                   len (13 * ceil32(return_data.size)) + 100
                                                            balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 / 100)
                                                            emit Transfer((arg2 / 100), msg.sender, this.address);
                                                            if not msg.sender:
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 576] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 580] = 32
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 612] = 37
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 644] = 'ERC20: transfer from the zero ad'
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 676] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                                revert with memory
                                                                  from _5437 + (8 * ceil32(return_data.size)) + 576
                                                                   len (13 * ceil32(return_data.size)) + 132
                                                            if not arg1:
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 576] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 580] = 32
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 612] = 35
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 644] = 'ERC20: transfer to the zero addr'
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 676] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                                revert with memory
                                                                  from _5437 + (8 * ceil32(return_data.size)) + 576
                                                                   len (13 * ceil32(return_data.size)) + 132
                                                            if arg2 - (arg2 / 100) > balanceOf[address(msg.sender)]:
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 672] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 676] = 32
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 708] = 38
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 740 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_5437 + (8 * ceil32(return_data.size)) + 646 len 26]
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 778] = 0
                                                                revert with memory
                                                                  from _5437 + (8 * ceil32(return_data.size)) + 672
                                                                   len (13 * ceil32(return_data.size)) + 132
                                                            if balanceOf[address(msg.sender)] < arg2 - (arg2 / 100):
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - arg2 + (arg2 / 100)
                                                            if balanceOf[arg1] > !(arg2 - (arg2 / 100)):
                                                                revert with 0, 17
                                                            if balanceOf[arg1] + arg2 - (arg2 / 100) < balanceOf[arg1]:
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 672] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 676] = 32
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 708] = 27
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 740] = 'SafeMath: addition overflow'
                                                                revert with memory
                                                                  from _5437 + (8 * ceil32(return_data.size)) + 672
                                                                   len (13 * ceil32(return_data.size)) + 100
                                                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2 - (arg2 / 100)
                                                            emit Transfer((arg2 - (arg2 / 100)), msg.sender, arg1);
                                                        mem[_5437 + (8 * ceil32(return_data.size)) + 676] = msg.sender
                                                        mem[_5437 + (8 * ceil32(return_data.size)) + 708] = balanceOf[address(msg.sender)]
                                                        require ext_code.size(dividendTrackerAddress)
                                                        call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args mem[_5437 + (8 * ceil32(return_data.size)) + 676 len (13 * ceil32(return_data.size)) + 64]
                                                        mem[_5437 + (8 * ceil32(return_data.size)) + 676] = arg1
                                                        mem[_5437 + (8 * ceil32(return_data.size)) + 708] = balanceOf[address(arg1)]
                                                        require ext_code.size(dividendTrackerAddress)
                                                        call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args mem[_5437 + (8 * ceil32(return_data.size)) + 676 len (13 * ceil32(return_data.size)) + 64]
                                                        if not stor7:
                                                            call dividendTrackerAddress.process(uint256 arg1) with:
                                                                 gas gas_remaining wei
                                                                args gasForProcessing
                                                            if ext_call.success:
                                                                require return_data.size >= 96
                                                                emit ProcessedDividendTracker(uint256 arg1, uint256 arg2, uint256 arg3, bool arg4, uint256 arg5, address arg6):
                                                                                              ext_call.return_data[0],
                                                                                              ext_call.return_data[32],
                                                                                              ext_call.return_data[64],
                                                                                              gasForProcessing,
                                                                                              mem[_5437 + (9 * ceil32(return_data.size)) + 800 len 5 * ceil32(return_data.size)],
                                                                                              1,
                                                                                              tx.origin,
                                                else:
                                                    if arg2 and totalFees > -1 / arg2:
                                                        revert with 0, 17
                                                    if not arg2:
                                                        revert with 0, 18
                                                    if arg2 * totalFees / arg2 != totalFees:
                                                        mem[_5437 + (8 * ceil32(return_data.size)) + 288] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_5437 + (8 * ceil32(return_data.size)) + 292] = 32
                                                        mem[_5437 + (8 * ceil32(return_data.size)) + 324] = 33
                                                        mem[_5437 + (8 * ceil32(return_data.size)) + 356] = 'SafeMath: multiplication overflo'
                                                        mem[_5437 + (8 * ceil32(return_data.size)) + 388] = 0x7700000000000000000000000000000000000000000000000000000000000000
                                                        revert with memory
                                                          from _5437 + (8 * ceil32(return_data.size)) + 288
                                                           len (13 * ceil32(return_data.size)) + 132
                                                    if not stor20[address(arg1)]:
                                                        if arg2 * totalFees / 100 > arg2:
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 420] = 32
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 452] = 30
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 484] = 'SafeMath: subtraction overflow'
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 514] = 0
                                                            revert with memory
                                                              from _5437 + (8 * ceil32(return_data.size)) + 416
                                                               len (13 * ceil32(return_data.size)) + 100
                                                        if arg2 < arg2 * totalFees / 100:
                                                            revert with 0, 17
                                                        if not msg.sender:
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 420] = 32
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 452] = 37
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 484] = 'ERC20: transfer from the zero ad'
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 516] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                            revert with memory
                                                              from _5437 + (8 * ceil32(return_data.size)) + 416
                                                               len (13 * ceil32(return_data.size)) + 132
                                                        if not this.address:
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 420] = 32
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 452] = 35
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 484] = 'ERC20: transfer to the zero addr'
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 516] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                            revert with memory
                                                              from _5437 + (8 * ceil32(return_data.size)) + 416
                                                               len (13 * ceil32(return_data.size)) + 132
                                                        if arg2 * totalFees / 100 > balanceOf[address(msg.sender)]:
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 512] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 516] = 32
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 548] = 38
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 580 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_5437 + (8 * ceil32(return_data.size)) + 486 len 26]
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 618] = 0
                                                            revert with memory
                                                              from _5437 + (8 * ceil32(return_data.size)) + 512
                                                               len (13 * ceil32(return_data.size)) + 132
                                                        if balanceOf[address(msg.sender)] < arg2 * totalFees / 100:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] -= arg2 * totalFees / 100
                                                        if balanceOf[this.address] > !(arg2 * totalFees / 100):
                                                            revert with 0, 17
                                                        if balanceOf[this.address] + (arg2 * totalFees / 100) < balanceOf[this.address]:
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 512] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 516] = 32
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 548] = 27
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 580] = 'SafeMath: addition overflow'
                                                            revert with memory
                                                              from _5437 + (8 * ceil32(return_data.size)) + 512
                                                               len (13 * ceil32(return_data.size)) + 100
                                                        balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 * totalFees / 100)
                                                        emit Transfer((arg2 * totalFees / 100), msg.sender, this.address);
                                                        if not msg.sender:
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 512] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 516] = 32
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 548] = 37
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 580] = 'ERC20: transfer from the zero ad'
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 612] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                            revert with memory
                                                              from _5437 + (8 * ceil32(return_data.size)) + 512
                                                               len (13 * ceil32(return_data.size)) + 132
                                                        if not arg1:
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 512] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 516] = 32
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 548] = 35
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 580] = 'ERC20: transfer to the zero addr'
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 612] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                            revert with memory
                                                              from _5437 + (8 * ceil32(return_data.size)) + 512
                                                               len (13 * ceil32(return_data.size)) + 132
                                                        if arg2 - (arg2 * totalFees / 100) > balanceOf[address(msg.sender)]:
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 608] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 612] = 32
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 644] = 38
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 676 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_5437 + (8 * ceil32(return_data.size)) + 582 len 26]
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 714] = 0
                                                            revert with memory
                                                              from _5437 + (8 * ceil32(return_data.size)) + 608
                                                               len (13 * ceil32(return_data.size)) + 132
                                                        if balanceOf[address(msg.sender)] < arg2 - (arg2 * totalFees / 100):
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - arg2 + (arg2 * totalFees / 100)
                                                        if balanceOf[arg1] > !(arg2 - (arg2 * totalFees / 100)):
                                                            revert with 0, 17
                                                        if balanceOf[arg1] + arg2 - (arg2 * totalFees / 100) < balanceOf[arg1]:
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 608] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 612] = 32
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 644] = 27
                                                            mem[_5437 + (8 * ceil32(return_data.size)) + 676] = 'SafeMath: addition overflow'
                                                            revert with memory
                                                              from _5437 + (8 * ceil32(return_data.size)) + 608
                                                               len (13 * ceil32(return_data.size)) + 100
                                                        balanceOf[address(arg1)] = balanceOf[arg1] + arg2 - (arg2 * totalFees / 100)
                                                        emit Transfer((arg2 - (arg2 * totalFees / 100)), msg.sender, arg1);
                                                        mem[_5437 + (8 * ceil32(return_data.size)) + 612] = msg.sender
                                                        mem[_5437 + (8 * ceil32(return_data.size)) + 644] = balanceOf[address(msg.sender)]
                                                        require ext_code.size(dividendTrackerAddress)
                                                        call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args mem[_5437 + (8 * ceil32(return_data.size)) + 612 len (13 * ceil32(return_data.size)) + 64]
                                                        mem[_5437 + (8 * ceil32(return_data.size)) + 612] = arg1
                                                        mem[_5437 + (8 * ceil32(return_data.size)) + 644] = balanceOf[address(arg1)]
                                                        require ext_code.size(dividendTrackerAddress)
                                                        call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args mem[_5437 + (8 * ceil32(return_data.size)) + 612 len (13 * ceil32(return_data.size)) + 64]
                                                        if not stor7:
                                                            call dividendTrackerAddress.process(uint256 arg1) with:
                                                                 gas gas_remaining wei
                                                                args gasForProcessing
                                                            if ext_call.success:
                                                                require return_data.size >= 96
                                                                emit ProcessedDividendTracker(uint256 arg1, uint256 arg2, uint256 arg3, bool arg4, uint256 arg5, address arg6):
                                                                                              ext_call.return_data[0],
                                                                                              ext_call.return_data[32],
                                                                                              ext_call.return_data[64],
                                                                                              gasForProcessing,
                                                                                              mem[_5437 + (9 * ceil32(return_data.size)) + 736 len 5 * ceil32(return_data.size)],
                                                                                              1,
                                                                                              tx.origin,
                                                    else:
                                                        if not arg2:
                                                            if arg2 * totalFees / 100 > -1:
                                                                revert with 0, 17
                                                            if arg2 * totalFees / 100 > arg2:
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 480] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 484] = 32
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 516] = 30
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 548] = 'SafeMath: subtraction overflow'
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 578] = 0
                                                                revert with memory
                                                                  from _5437 + (8 * ceil32(return_data.size)) + 480
                                                                   len (13 * ceil32(return_data.size)) + 100
                                                            if arg2 < arg2 * totalFees / 100:
                                                                revert with 0, 17
                                                            if not msg.sender:
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 480] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 484] = 32
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 516] = 37
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 548] = 'ERC20: transfer from the zero ad'
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 580] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                                revert with memory
                                                                  from _5437 + (8 * ceil32(return_data.size)) + 480
                                                                   len (13 * ceil32(return_data.size)) + 132
                                                            if not this.address:
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 480] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 484] = 32
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 516] = 35
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 548] = 'ERC20: transfer to the zero addr'
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 580] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                                revert with memory
                                                                  from _5437 + (8 * ceil32(return_data.size)) + 480
                                                                   len (13 * ceil32(return_data.size)) + 132
                                                            if arg2 * totalFees / 100 > balanceOf[address(msg.sender)]:
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 576] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 580] = 32
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 612] = 38
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 644 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_5437 + (8 * ceil32(return_data.size)) + 550 len 26]
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 682] = 0
                                                                revert with memory
                                                                  from _5437 + (8 * ceil32(return_data.size)) + 576
                                                                   len (13 * ceil32(return_data.size)) + 132
                                                            if balanceOf[address(msg.sender)] < arg2 * totalFees / 100:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= arg2 * totalFees / 100
                                                            if balanceOf[this.address] > !(arg2 * totalFees / 100):
                                                                revert with 0, 17
                                                            if balanceOf[this.address] + (arg2 * totalFees / 100) < balanceOf[this.address]:
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 576] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 580] = 32
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 612] = 27
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 644] = 'SafeMath: addition overflow'
                                                                revert with memory
                                                                  from _5437 + (8 * ceil32(return_data.size)) + 576
                                                                   len (13 * ceil32(return_data.size)) + 100
                                                            balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 * totalFees / 100)
                                                            emit Transfer((arg2 * totalFees / 100), msg.sender, this.address);
                                                            if not msg.sender:
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 576] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 580] = 32
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 612] = 37
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 644] = 'ERC20: transfer from the zero ad'
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 676] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                                revert with memory
                                                                  from _5437 + (8 * ceil32(return_data.size)) + 576
                                                                   len (13 * ceil32(return_data.size)) + 132
                                                            if not arg1:
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 576] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 580] = 32
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 612] = 35
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 644] = 'ERC20: transfer to the zero addr'
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 676] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                                revert with memory
                                                                  from _5437 + (8 * ceil32(return_data.size)) + 576
                                                                   len (13 * ceil32(return_data.size)) + 132
                                                            if arg2 - (arg2 * totalFees / 100) > balanceOf[address(msg.sender)]:
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 672] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 676] = 32
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 708] = 38
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 740 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_5437 + (8 * ceil32(return_data.size)) + 646 len 26]
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 778] = 0
                                                                revert with memory
                                                                  from _5437 + (8 * ceil32(return_data.size)) + 672
                                                                   len (13 * ceil32(return_data.size)) + 132
                                                            if balanceOf[address(msg.sender)] < arg2 - (arg2 * totalFees / 100):
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - arg2 + (arg2 * totalFees / 100)
                                                            if balanceOf[arg1] > !(arg2 - (arg2 * totalFees / 100)):
                                                                revert with 0, 17
                                                            if balanceOf[arg1] + arg2 - (arg2 * totalFees / 100) < balanceOf[arg1]:
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 672] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 676] = 32
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 708] = 27
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 740] = 'SafeMath: addition overflow'
                                                                revert with memory
                                                                  from _5437 + (8 * ceil32(return_data.size)) + 672
                                                                   len (13 * ceil32(return_data.size)) + 100
                                                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2 - (arg2 * totalFees / 100)
                                                            emit Transfer((arg2 - (arg2 * totalFees / 100)), msg.sender, arg1);
                                                        else:
                                                            if arg2 and 1 > -1 / arg2:
                                                                revert with 0, 17
                                                            if not arg2:
                                                                revert with 0, 18
                                                            if arg2 / arg2 != 1:
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 352] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 356] = 32
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 388] = 33
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 420] = 'SafeMath: multiplication overflo'
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 452] = 0x7700000000000000000000000000000000000000000000000000000000000000
                                                                revert with memory
                                                                  from _5437 + (8 * ceil32(return_data.size)) + 352
                                                                   len (13 * ceil32(return_data.size)) + 132
                                                            if arg2 * totalFees / 100 > !(arg2 / 100):
                                                                revert with 0, 17
                                                            if (arg2 * totalFees / 100) + (arg2 / 100) > arg2:
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 480] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 484] = 32
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 516] = 30
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 548] = 'SafeMath: subtraction overflow'
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 578] = 0
                                                                revert with memory
                                                                  from _5437 + (8 * ceil32(return_data.size)) + 480
                                                                   len (13 * ceil32(return_data.size)) + 100
                                                            if arg2 < (arg2 * totalFees / 100) + (arg2 / 100):
                                                                revert with 0, 17
                                                            if not msg.sender:
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 480] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 484] = 32
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 516] = 37
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 548] = 'ERC20: transfer from the zero ad'
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 580] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                                revert with memory
                                                                  from _5437 + (8 * ceil32(return_data.size)) + 480
                                                                   len (13 * ceil32(return_data.size)) + 132
                                                            if not this.address:
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 480] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 484] = 32
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 516] = 35
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 548] = 'ERC20: transfer to the zero addr'
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 580] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                                revert with memory
                                                                  from _5437 + (8 * ceil32(return_data.size)) + 480
                                                                   len (13 * ceil32(return_data.size)) + 132
                                                            if (arg2 * totalFees / 100) + (arg2 / 100) > balanceOf[address(msg.sender)]:
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 576] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 580] = 32
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 612] = 38
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 644 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_5437 + (8 * ceil32(return_data.size)) + 550 len 26]
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 682] = 0
                                                                revert with memory
                                                                  from _5437 + (8 * ceil32(return_data.size)) + 576
                                                                   len (13 * ceil32(return_data.size)) + 132
                                                            if balanceOf[address(msg.sender)] < (arg2 * totalFees / 100) + (arg2 / 100):
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - (arg2 * totalFees / 100) - (arg2 / 100)
                                                            if balanceOf[this.address] > !((arg2 * totalFees / 100) + (arg2 / 100)):
                                                                revert with 0, 17
                                                            if balanceOf[this.address] + (arg2 * totalFees / 100) + (arg2 / 100) < balanceOf[this.address]:
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 576] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 580] = 32
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 612] = 27
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 644] = 'SafeMath: addition overflow'
                                                                revert with memory
                                                                  from _5437 + (8 * ceil32(return_data.size)) + 576
                                                                   len (13 * ceil32(return_data.size)) + 100
                                                            balanceOf[address(this.address)] = balanceOf[this.address] + (arg2 * totalFees / 100) + (arg2 / 100)
                                                            emit Transfer(((arg2 * totalFees / 100) + (arg2 / 100)), msg.sender, this.address);
                                                            if not msg.sender:
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 576] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 580] = 32
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 612] = 37
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 644] = 'ERC20: transfer from the zero ad'
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 676] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                                revert with memory
                                                                  from _5437 + (8 * ceil32(return_data.size)) + 576
                                                                   len (13 * ceil32(return_data.size)) + 132
                                                            if not arg1:
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 576] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 580] = 32
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 612] = 35
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 644] = 'ERC20: transfer to the zero addr'
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 676] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                                revert with memory
                                                                  from _5437 + (8 * ceil32(return_data.size)) + 576
                                                                   len (13 * ceil32(return_data.size)) + 132
                                                            if arg2 - (arg2 * totalFees / 100) - (arg2 / 100) > balanceOf[address(msg.sender)]:
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 672] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 676] = 32
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 708] = 38
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 740 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_5437 + (8 * ceil32(return_data.size)) + 646 len 26]
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 778] = 0
                                                                revert with memory
                                                                  from _5437 + (8 * ceil32(return_data.size)) + 672
                                                                   len (13 * ceil32(return_data.size)) + 132
                                                            if balanceOf[address(msg.sender)] < arg2 - (arg2 * totalFees / 100) - (arg2 / 100):
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - arg2 + (arg2 * totalFees / 100) + (arg2 / 100)
                                                            if balanceOf[arg1] > !(arg2 - (arg2 * totalFees / 100) - (arg2 / 100)):
                                                                revert with 0, 17
                                                            if balanceOf[arg1] + arg2 - (arg2 * totalFees / 100) - (arg2 / 100) < balanceOf[arg1]:
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 672] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 676] = 32
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 708] = 27
                                                                mem[_5437 + (8 * ceil32(return_data.size)) + 740] = 'SafeMath: addition overflow'
                                                                revert with memory
                                                                  from _5437 + (8 * ceil32(return_data.size)) + 672
                                                                   len (13 * ceil32(return_data.size)) + 100
                                                            balanceOf[address(arg1)] = balanceOf[arg1] + arg2 - (arg2 * totalFees / 100) - (arg2 / 100)
                                                            emit Transfer((arg2 - (arg2 * totalFees / 100) - (arg2 / 100)), msg.sender, arg1);
                                                        mem[_5437 + (8 * ceil32(return_data.size)) + 676] = msg.sender
                                                        mem[_5437 + (8 * ceil32(return_data.size)) + 708] = balanceOf[address(msg.sender)]
                                                        require ext_code.size(dividendTrackerAddress)
                                                        call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args mem[_5437 + (8 * ceil32(return_data.size)) + 676 len (13 * ceil32(return_data.size)) + 64]
                                                        mem[_5437 + (8 * ceil32(return_data.size)) + 676] = arg1
                                                        mem[_5437 + (8 * ceil32(return_data.size)) + 708] = balanceOf[address(arg1)]
                                                        require ext_code.size(dividendTrackerAddress)
                                                        call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args mem[_5437 + (8 * ceil32(return_data.size)) + 676 len (13 * ceil32(return_data.size)) + 64]
                                                        if not stor7:
                                                            call dividendTrackerAddress.process(uint256 arg1) with:
                                                                 gas gas_remaining wei
                                                                args gasForProcessing
                                                            if ext_call.success:
                                                                require return_data.size >= 96
                                                                emit ProcessedDividendTracker(uint256 arg1, uint256 arg2, uint256 arg3, bool arg4, uint256 arg5, address arg6):
                                                                                              ext_call.return_data[0],
                                                                                              ext_call.return_data[32],
                                                                                              ext_call.return_data[64],
                                                                                              gasForProcessing,
                                                                                              mem[_5437 + (9 * ceil32(return_data.size)) + 800 len 5 * ceil32(return_data.size)],
                                                                                              1,
                                                                                              tx.origin,
    return 1
}

function _fallback() payable {
    if calldata.size < 4:
        require not calldata.size
    if unknown_0x715018a6(?????) <= uint32(call.func_hash) >> 224:
        if unknown_0xad56c13c(?????) <= uint32(call.func_hash) >> 224:
            if unknown_0xdd62ed3e(?????) <= uint32(call.func_hash) >> 224:
                if unknown_0xdd62ed3e(?????) == uint32(call.func_hash) >> 224:
                    require not msg.value
                    require calldata.size - 4 >= 64
                    require cd[4] == address(cd[4])
                    require cd[36] == address(cd[36])
                    return allowance[address(cd[4])][address(cd[36])].field_0
                if unknown_0xe2f45605(?????) == uint32(call.func_hash) >> 224:
                    require not msg.value
                    return swapTokensAtAmount
                if unknown_0xe7841ec0(?????) == uint32(call.func_hash) >> 224:
                    require not msg.value
                    staticcall dividendTrackerAddress.0xe7841ec0 with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                if unknown_0xe98030c7(?????) == uint32(call.func_hash) >> 224:
                    require not msg.value
                    require calldata.size - 4 >= 32
                    if owner != msg.sender:
                        revert with 0, 'Ownable: caller is not the owner'
                    require ext_code.size(dividendTrackerAddress)
                    call dividendTrackerAddress.0xe98030c7 with:
                         gas gas_remaining wei
                        args cd[4]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                else:
                    if unknown_0xf27fd254(?????) == uint32(call.func_hash) >> 224:
                        require not msg.value
                        require calldata.size - 4 >= 32
                        staticcall dividendTrackerAddress.getAccountAtIndex(uint256 arg1) with:
                                gas gas_remaining wei
                               args cd[4]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 256
                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                        return ext_call.return_data[12 len 20], 
                               ext_call.return_data[32],
                               ext_call.return_data[64],
                               ext_call.return_data[96],
                               ext_call.return_data[128],
                               ext_call.return_data[160],
                               ext_call.return_data[192],
                               ext_call.return_data[224]
                    require unknown_0xf2fde38b(?????) == uint32(call.func_hash) >> 224
                    require not msg.value
                    require calldata.size - 4 >= 32
                    require cd[4] == address(cd[4])
                    if owner != msg.sender:
                        revert with 0, 'Ownable: caller is not the owner'
                    if not address(cd[4]):
                        revert with 0, 'Ownable: new owner is the zero address'
                    emit OwnershipTransferred(owner, address(cd[4]));
                    owner = address(cd[4])
            else:
                if unknown_0xad56c13c(?????) == uint32(call.func_hash) >> 224:
                    require not msg.value
                    require calldata.size - 4 >= 32
                    require cd[4] == address(cd[4])
                    staticcall dividendTrackerAddress.getAccount(address arg1) with:
                            gas gas_remaining wei
                           args address(cd[4])
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 256
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    return ext_call.return_data[12 len 20], 
                           ext_call.return_data[32],
                           ext_call.return_data[64],
                           ext_call.return_data[96],
                           ext_call.return_data[128],
                           ext_call.return_data[160],
                           ext_call.return_data[192],
                           ext_call.return_data[224]
                if unknown_0xadefd90c(?????) == uint32(call.func_hash) >> 224:
                    require not msg.value
                    require calldata.size - 4 >= 32
                    if owner != msg.sender:
                        revert with 0, 'Ownable: caller is not the owner'
                    stor14 = cd[4]
                    if stor13 > !cd[4]:
                        revert with 0, 17
                    if stor13 + cd[4] < stor13:
                        revert with 0, 'SafeMath: addition overflow'
                    if stor13 + cd[4] > !stor15:
                        revert with 0, 17
                    if stor15 < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    totalFees = stor13 + cd[4] + stor15
                else:
                    if unknown_0xb62496f5(?????) == uint32(call.func_hash) >> 224:
                        require not msg.value
                        require calldata.size - 4 >= 32
                        require cd[4] == address(cd[4])
                        return bool(stor20[cd[4]])
                    if unknown_0xc0246668(?????) == uint32(call.func_hash) >> 224:
                        require not msg.value
                        require calldata.size - 4 >= 64
                        require cd[4] == address(cd[4])
                        require cd[36] == bool(cd[36])
                        if owner != msg.sender:
                            revert with 0, 'Ownable: caller is not the owner'
                        if bool(cd[36]) == bool(stor19[address(cd[4])]):
                            revert with 0, 'GreatDaneInu: Account is already the value of 'excluded''
                        stor19[address(cd[4])] = uint8(bool(cd[36]))
                        emit ExcludeFromFees(bool(cd[36]), address(cd[4]));
                    else:
                        if unknown_0xc0d78655(?????) == uint32(call.func_hash) >> 224:
                            require not msg.value
                            require calldata.size - 4 >= 32
                            require cd[4] == address(cd[4])
                            if owner != msg.sender:
                                revert with 0, 'Ownable: caller is not the owner'
                            stor17 = address(cd[4])
                        else:
                            require unknown_0xc492f046(?????) == uint32(call.func_hash) >> 224
                            require not msg.value
                            require calldata.size - 4 >= 64
                            require cd[4] <= test266151307()
                            require cd[4] + 35 < calldata.size
                            require ('cd', 4).length <= test266151307()
                            require cd[4] + (32 * ('cd', 4).length) + 36 <= calldata.size
                            require cd[36] == bool(cd[36])
                            if owner != msg.sender:
                                revert with 0, 'Ownable: caller is not the owner'
                            idx = 0
                            while idx < ('cd', 4).length:
                                require cd[((32 * idx) + cd[4] + 36)] == address(cd[((32 * idx) + cd[4] + 36)])
                                mem[0] = address(cd[((32 * idx) + cd[4] + 36)])
                                mem[32] = 19
                                stor19[address(cd[((32 * idx) + cd[4] + 36)])] = uint8(bool(cd[36]))
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            idx = 0
                            s = 224
                            t = cd[4] + 36
                            while idx < ('cd', 4).length:
                                require cd[t] == address(cd[t])
                                mem[s] = address(cd[t])
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            emit ExcludeMultipleAccountsFromFees(Array(len=('cd', 4).length, data=mem[224 len 32 * ('cd', 4).length]), bool(cd[36]));
        if unknown_0x9a7a23d6(?????) > uint32(call.func_hash) >> 224:
            if unknown_0x715018a6(?????) == uint32(call.func_hash) >> 224:
                require not msg.value
                if owner != msg.sender:
                    revert with 0, 'Ownable: caller is not the owner'
                emit OwnershipTransferred(owner, 0);
                owner = 0
            else:
                if unknown_0x85141a77(?????) == uint32(call.func_hash) >> 224:
                    require not msg.value
                    return deadWalletAddress
                if unknown_0x871c128d(?????) == uint32(call.func_hash) >> 224:
                    require not msg.value
                    require calldata.size - 4 >= 32
                    if owner != msg.sender:
                        revert with 0, 'Ownable: caller is not the owner'
                    if cd[4] < 200000:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    'GreatDaneInu: gasForProcessing must be between 200,000 and 500,000'
                    if cd[4] > 500000:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    'GreatDaneInu: gasForProcessing must be between 200,000 and 500,000'
                    if cd[4] == gasForProcessing:
                        revert with 0, 'GreatDaneInu: Cannot update gasForProcessing to same value'
                    emit GasForProcessingUpdated(cd[4], gasForProcessing);
                    gasForProcessing = cd[4]
                else:
                    if uint32(call.func_hash) >> 224 != unknown_0x88bdd9be(?????):
                        if unknown_0x8da5cb5b(?????) == uint32(call.func_hash) >> 224:
                            require not msg.value
                            return owner
                        require unknown_0x95d89b41(?????) == uint32(call.func_hash) >> 224
                        require not msg.value
                        if bool(stor4.length):
                            if bool(stor4.length) == uint255(stor4.length) * 0.5 < 32:
                                revert with 0, 34
                            if bool(stor4.length):
                                if bool(stor4.length) == uint255(stor4.length) * 0.5 < 32:
                                    revert with 0, 34
                                if Mask(256, -1, stor4.length):
                                    if 31 < uint255(stor4.length) * 0.5:
                                        mem[160] = uint256(stor4.field_0)
                                        idx = 160
                                        s = 0
                                        while (uint255(stor4.length) * 0.5) + 128 > idx:
                                            mem[idx + 32] = stor4[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                                        return Array(len=2 * Mask(256, -1, stor4.length), data=mem[160 len ceil32(uint255(stor4.length) * 0.5)])
                                    mem[160] = 256 * stor4.length.field_8
                            else:
                                if bool(stor4.length) == stor4.length.field_1 < 32:
                                    revert with 0, 34
                                if stor4.length.field_1:
                                    if 31 < stor4.length.field_1:
                                        mem[160] = uint256(stor4.field_0)
                                        idx = 160
                                        s = 0
                                        while stor4.length.field_1 + 128 > idx:
                                            mem[idx + 32] = stor4[s].field_256
                                            idx = idx + 32
                                            s = s + 1
                                            continue 
                                        return Array(len=2 * Mask(256, -1, stor4.length), data=mem[160 len ceil32(uint255(stor4.length) * 0.5)])
                                    mem[160] = 256 * stor4.length.field_8
                            mem[ceil32(uint255(stor4.length) * 0.5) + 224 len ceil32(uint255(stor4.length) * 0.5)] = mem[160 len ceil32(uint255(stor4.length) * 0.5)]
                            if ceil32(uint255(stor4.length) * 0.5) > uint255(stor4.length) * 0.5:
                                mem[ceil32(uint255(stor4.length) * 0.5) + (uint255(stor4.length) * 0.5) + 224] = 0
                            return Array(len=2 * Mask(256, -1, stor4.length), data=mem[160 len ceil32(uint255(stor4.length) * 0.5)], mem[(2 * ceil32(uint255(stor4.length) * 0.5)) + 224 len 2 * ceil32(uint255(stor4.length) * 0.5)]), 
                        if bool(stor4.length) == stor4.length.field_1 < 32:
                            revert with 0, 34
                        if bool(stor4.length):
                            if bool(stor4.length) == uint255(stor4.length) * 0.5 < 32:
                                revert with 0, 34
                            if Mask(256, -1, stor4.length):
                                if 31 < uint255(stor4.length) * 0.5:
                                    mem[160] = uint256(stor4.field_0)
                                    idx = 160
                                    s = 0
                                    while (uint255(stor4.length) * 0.5) + 128 > idx:
                                        mem[idx + 32] = stor4[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    return Array(len=stor4.length % 128, data=mem[160 len ceil32(stor4.length.field_1)])
                                mem[160] = 256 * stor4.length.field_8
                        else:
                            if bool(stor4.length) == stor4.length.field_1 < 32:
                                revert with 0, 34
                            if stor4.length.field_1:
                                if 31 < stor4.length.field_1:
                                    mem[160] = uint256(stor4.field_0)
                                    idx = 160
                                    s = 0
                                    while stor4.length.field_1 + 128 > idx:
                                        mem[idx + 32] = stor4[s].field_256
                                        idx = idx + 32
                                        s = s + 1
                                        continue 
                                    return Array(len=stor4.length % 128, data=mem[160 len ceil32(stor4.length.field_1)])
                                mem[160] = 256 * stor4.length.field_8
                        mem[ceil32(stor4.length.field_1) + 224 len ceil32(stor4.length.field_1)] = mem[160 len ceil32(stor4.length.field_1)]
                        if ceil32(stor4.length.field_1) > stor4.length.field_1:
                            mem[ceil32(stor4.length.field_1) + stor4.length.field_1 + 224] = 0
                        return Array(len=stor4.length % 128, data=mem[160 len ceil32(stor4.length.field_1)], mem[(2 * ceil32(stor4.length.field_1)) + 224 len 2 * ceil32(stor4.length.field_1)]), 
                    require not msg.value
                    require calldata.size - 4 >= 32
                    require cd[4] == address(cd[4])
                    if owner != msg.sender:
                        revert with 0, 'Ownable: caller is not the owner'
                    if dividendTrackerAddress == address(cd[4]):
                        revert with 0, 'GreatDaneInu: The dividend tracker already has that address'
                    staticcall address(cd[4]).0x8da5cb5b with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                    if ext_call.return_data[12 len 20] != this.address:
                        revert with 0, 'GreatDaneInu: The new dividend tracker must be owned by the GreatDaneInu token contract'
                    require ext_code.size(address(cd[4]))
                    call address(cd[4]).0x31e79db0 with:
                         gas gas_remaining wei
                        args address(cd[4])
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require ext_code.size(address(cd[4]))
                    call address(cd[4]).0x31e79db0 with:
                         gas gas_remaining wei
                        args this.address
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require ext_code.size(address(cd[4]))
                    call address(cd[4]).0x31e79db0 with:
                         gas gas_remaining wei
                        args owner
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require ext_code.size(address(cd[4]))
                    call address(cd[4]).0x31e79db0 with:
                         gas gas_remaining wei
                        args uniswapV2RouterAddress
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    emit UpdateDividendTracker(address(cd[4]), dividendTrackerAddress);
                    dividendTrackerAddress = address(cd[4])
        if unknown_0x9a7a23d6(?????) == uint32(call.func_hash) >> 224:
            require not msg.value
            require calldata.size - 4 >= 64
            require cd[4] == address(cd[4])
            require cd[36] == bool(cd[36])
            if owner != msg.sender:
                revert with 0, 'Ownable: caller is not the owner'
            if uniswapV2PairAddress == address(cd[4]):
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            'GreatDaneInu: The PancakeSwap pair cannot be removed from automatedMarketMakerPairs'
            if bool(cd[36]) == bool(stor20[address(cd[4])]):
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            'GreatDaneInu: Automated market maker pair is already set to that value'
            stor20[address(cd[4])] = uint8(bool(cd[36]))
            if cd[36]:
                require ext_code.size(dividendTrackerAddress)
                call dividendTrackerAddress.0x31e79db0 with:
                     gas gas_remaining wei
                    args address(cd[4])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
            emit SetAutomatedMarketMakerPair(address(cd[4]), bool(cd[36]));
        if unknown_0x9c1b8af5(?????) == uint32(call.func_hash) >> 224:
            require not msg.value
            return gasForProcessing
        if unknown_0xa26579ad(?????) == uint32(call.func_hash) >> 224:
            require not msg.value
            staticcall dividendTrackerAddress.claimWait() with:
                    gas gas_remaining wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            return ext_call.return_data[0]
        if unknown_0xa457c2d7(?????) == uint32(call.func_hash) >> 224:
            require not msg.value
            require calldata.size - 4 >= 64
            require cd[4] == address(cd[4])
            if cd[36] > allowance[msg.sender][address(cd[4])].field_0:
                revert with 0, 32, 37, 0x6545524332303a2064656372656173656420616c6c6f77616e63652062656c6f77207a6572, mem[197 len 27] >> 40, 0
            if allowance[msg.sender][address(cd[4])].field_0 < cd[36]:
                revert with 0, 17
            if not msg.sender:
                revert with 0, 'ERC20: approve from the zero address'
            if not address(cd[4]):
                revert with 0, 'ERC20: approve to the zero address'
            allowance[address(msg.sender)][address(cd[4])].field_0 = allowance[msg.sender][address(cd[4])].field_0 - cd[36]
            emit Approval((allowance[msg.sender][address(cd[4])].field_0 - cd[36]), msg.sender, address(cd[4]));
        else:
            if unknown_0xa8b9d240(?????) == uint32(call.func_hash) >> 224:
                require not msg.value
                require calldata.size - 4 >= 32
                require cd[4] == address(cd[4])
                staticcall dividendTrackerAddress.0xa8b9d240 with:
                        gas gas_remaining wei
                       args address(cd[4])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                return ext_call.return_data[0]
            require unknown_0xa9059cbb(?????) == uint32(call.func_hash) >> 224
            require not msg.value
            require calldata.size - 4 >= 64
            require cd[4] == address(cd[4])
            if not msg.sender:
                revert with 0, 'ERC20: transfer from the zero address'
            if not address(cd[4]):
                revert with 0, 'ERC20: transfer to the zero address'
            if stor12[address(msg.sender)]:
                revert with 0, 'Blacklisted address'
            if stor12[address(cd[4])]:
                revert with 0, 'Blacklisted address'
            if not cd[36]:
                if not msg.sender:
                    revert with 0, 'ERC20: transfer from the zero address'
                if not address(cd[4]):
                    revert with 0, 'ERC20: transfer to the zero address'
                if 0 > balanceOf[address(msg.sender)]:
                    revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                if balanceOf[address(msg.sender)] < 0:
                    revert with 0, 17
                if balanceOf[address(cd[4])] > -1:
                    revert with 0, 17
                if balanceOf[address(cd[4])] < balanceOf[address(cd[4])]:
                    revert with 0, 'SafeMath: addition overflow'
                balanceOf[address(cd[4])] = balanceOf[address(cd[4])]
                emit Transfer(0, msg.sender, address(cd[4]));
            else:
                if balanceOf[this.address] < swapTokensAtAmount:
                    if stor19[address(msg.sender)]:
                        if not msg.sender:
                            revert with 0, 'ERC20: transfer from the zero address'
                        if not address(cd[4]):
                            revert with 0, 'ERC20: transfer to the zero address'
                        if cd[36] > balanceOf[address(msg.sender)]:
                            revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                        if balanceOf[address(msg.sender)] < cd[36]:
                            revert with 0, 17
                        balanceOf[address(msg.sender)] -= cd[36]
                        if balanceOf[address(cd[4])] > !cd[36]:
                            revert with 0, 17
                        if balanceOf[address(cd[4])] + cd[36] < balanceOf[address(cd[4])]:
                            revert with 0, 'SafeMath: addition overflow'
                        balanceOf[address(cd[4])] += cd[36]
                        emit Transfer(cd[36], msg.sender, address(cd[4]));
                    else:
                        if stor19[address(cd[4])]:
                            if not msg.sender:
                                revert with 0, 'ERC20: transfer from the zero address'
                            if not address(cd[4]):
                                revert with 0, 'ERC20: transfer to the zero address'
                            if cd[36] > balanceOf[address(msg.sender)]:
                                revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                            if balanceOf[address(msg.sender)] < cd[36]:
                                revert with 0, 17
                            balanceOf[address(msg.sender)] -= cd[36]
                            if balanceOf[address(cd[4])] > !cd[36]:
                                revert with 0, 17
                            if balanceOf[address(cd[4])] + cd[36] < balanceOf[address(cd[4])]:
                                revert with 0, 'SafeMath: addition overflow'
                            balanceOf[address(cd[4])] += cd[36]
                            emit Transfer(cd[36], msg.sender, address(cd[4]));
                        else:
                            if stor7:
                                if not msg.sender:
                                    revert with 0, 'ERC20: transfer from the zero address'
                                if not address(cd[4]):
                                    revert with 0, 'ERC20: transfer to the zero address'
                                if cd[36] > balanceOf[address(msg.sender)]:
                                    revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                if balanceOf[address(msg.sender)] < cd[36]:
                                    revert with 0, 17
                                balanceOf[address(msg.sender)] -= cd[36]
                                if balanceOf[address(cd[4])] > !cd[36]:
                                    revert with 0, 17
                                if balanceOf[address(cd[4])] + cd[36] < balanceOf[address(cd[4])]:
                                    revert with 0, 'SafeMath: addition overflow'
                                balanceOf[address(cd[4])] += cd[36]
                                emit Transfer(cd[36], msg.sender, address(cd[4]));
                            else:
                                if not cd[36]:
                                    if not stor20[address(cd[4])]:
                                        if 0 > cd[36]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if cd[36] < 0:
                                            revert with 0, 17
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not this.address:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        if 0 > balanceOf[address(msg.sender)]:
                                            revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[326 len 26] >> 48, 0
                                        if balanceOf[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if balanceOf[this.address] > -1:
                                            revert with 0, 17
                                        if balanceOf[this.address] < balanceOf[this.address]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(this.address)] = balanceOf[this.address]
                                        emit Transfer(0, msg.sender, this.address);
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not address(cd[4]):
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        if cd[36] > balanceOf[address(msg.sender)]:
                                            revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[422 len 26] >> 48, 0
                                        if balanceOf[address(msg.sender)] < cd[36]:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= cd[36]
                                        if balanceOf[address(cd[4])] > !cd[36]:
                                            revert with 0, 17
                                        if balanceOf[address(cd[4])] + cd[36] < balanceOf[address(cd[4])]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(cd[4])] += cd[36]
                                        emit Transfer(cd[36], msg.sender, address(cd[4]));
                                    else:
                                        if not cd[36]:
                                            if 0 > cd[36]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if cd[36] < 0:
                                                revert with 0, 17
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not this.address:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            if 0 > balanceOf[address(msg.sender)]:
                                                revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[390 len 26] >> 48, 0
                                            if balanceOf[address(msg.sender)] < 0:
                                                revert with 0, 17
                                            if balanceOf[this.address] > -1:
                                                revert with 0, 17
                                            if balanceOf[this.address] < balanceOf[this.address]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(this.address)] = balanceOf[this.address]
                                            emit Transfer(0, msg.sender, this.address);
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not address(cd[4]):
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            if cd[36] > balanceOf[address(msg.sender)]:
                                                revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[486 len 26] >> 48, 0
                                            if balanceOf[address(msg.sender)] < cd[36]:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= cd[36]
                                            if balanceOf[address(cd[4])] > !cd[36]:
                                                revert with 0, 17
                                            if balanceOf[address(cd[4])] + cd[36] < balanceOf[address(cd[4])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(cd[4])] += cd[36]
                                            emit Transfer(cd[36], msg.sender, address(cd[4]));
                                        else:
                                            if cd[36] and 1 > -1 / cd[36]:
                                                revert with 0, 17
                                            if not cd[36]:
                                                revert with 0, 18
                                            if cd[36] / cd[36] != 1:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if 0 > !(cd[36] / 100):
                                                revert with 0, 17
                                            if cd[36] / 100 > cd[36]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if cd[36] < cd[36] / 100:
                                                revert with 0, 17
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not this.address:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            if cd[36] / 100 > balanceOf[address(msg.sender)]:
                                                revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[390 len 26] >> 48, 0
                                            if balanceOf[address(msg.sender)] < cd[36] / 100:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= cd[36] / 100
                                            if balanceOf[this.address] > !(cd[36] / 100):
                                                revert with 0, 17
                                            if balanceOf[this.address] + (cd[36] / 100) < balanceOf[this.address]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(this.address)] = balanceOf[this.address] + (cd[36] / 100)
                                            emit Transfer((cd[36] / 100), msg.sender, this.address);
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not address(cd[4]):
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            if cd[36] - (cd[36] / 100) > balanceOf[address(msg.sender)]:
                                                revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[486 len 26] >> 48, 0
                                            if balanceOf[address(msg.sender)] < cd[36] - (cd[36] / 100):
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - cd[36] + (cd[36] / 100)
                                            if balanceOf[address(cd[4])] > !(cd[36] - (cd[36] / 100)):
                                                revert with 0, 17
                                            if balanceOf[address(cd[4])] + cd[36] - (cd[36] / 100) < balanceOf[address(cd[4])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(cd[4])] = balanceOf[address(cd[4])] + cd[36] - (cd[36] / 100)
                                            emit Transfer((cd[36] - (cd[36] / 100)), msg.sender, address(cd[4]));
                                else:
                                    if cd[36] and totalFees > -1 / cd[36]:
                                        revert with 0, 17
                                    if not cd[36]:
                                        revert with 0, 18
                                    if cd[36] * totalFees / cd[36] != totalFees:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not stor20[address(cd[4])]:
                                        if cd[36] * totalFees / 100 > cd[36]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if cd[36] < cd[36] * totalFees / 100:
                                            revert with 0, 17
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not this.address:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        if cd[36] * totalFees / 100 > balanceOf[address(msg.sender)]:
                                            revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[326 len 26] >> 48, 0
                                        if balanceOf[address(msg.sender)] < cd[36] * totalFees / 100:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= cd[36] * totalFees / 100
                                        if balanceOf[this.address] > !(cd[36] * totalFees / 100):
                                            revert with 0, 17
                                        if balanceOf[this.address] + (cd[36] * totalFees / 100) < balanceOf[this.address]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(this.address)] = balanceOf[this.address] + (cd[36] * totalFees / 100)
                                        emit Transfer((cd[36] * totalFees / 100), msg.sender, this.address);
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not address(cd[4]):
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        if cd[36] - (cd[36] * totalFees / 100) > balanceOf[address(msg.sender)]:
                                            revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[422 len 26] >> 48, 0
                                        if balanceOf[address(msg.sender)] < cd[36] - (cd[36] * totalFees / 100):
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - cd[36] + (cd[36] * totalFees / 100)
                                        if balanceOf[address(cd[4])] > !(cd[36] - (cd[36] * totalFees / 100)):
                                            revert with 0, 17
                                        if balanceOf[address(cd[4])] + cd[36] - (cd[36] * totalFees / 100) < balanceOf[address(cd[4])]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(cd[4])] = balanceOf[address(cd[4])] + cd[36] - (cd[36] * totalFees / 100)
                                        emit Transfer((cd[36] - (cd[36] * totalFees / 100)), msg.sender, address(cd[4]));
                                    else:
                                        if not cd[36]:
                                            if cd[36] * totalFees / 100 > -1:
                                                revert with 0, 17
                                            if cd[36] * totalFees / 100 > cd[36]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if cd[36] < cd[36] * totalFees / 100:
                                                revert with 0, 17
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not this.address:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            if cd[36] * totalFees / 100 > balanceOf[address(msg.sender)]:
                                                revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[390 len 26] >> 48, 0
                                            if balanceOf[address(msg.sender)] < cd[36] * totalFees / 100:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= cd[36] * totalFees / 100
                                            if balanceOf[this.address] > !(cd[36] * totalFees / 100):
                                                revert with 0, 17
                                            if balanceOf[this.address] + (cd[36] * totalFees / 100) < balanceOf[this.address]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(this.address)] = balanceOf[this.address] + (cd[36] * totalFees / 100)
                                            emit Transfer((cd[36] * totalFees / 100), msg.sender, this.address);
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not address(cd[4]):
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            if cd[36] - (cd[36] * totalFees / 100) > balanceOf[address(msg.sender)]:
                                                revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[486 len 26] >> 48, 0
                                            if balanceOf[address(msg.sender)] < cd[36] - (cd[36] * totalFees / 100):
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - cd[36] + (cd[36] * totalFees / 100)
                                            if balanceOf[address(cd[4])] > !(cd[36] - (cd[36] * totalFees / 100)):
                                                revert with 0, 17
                                            if balanceOf[address(cd[4])] + cd[36] - (cd[36] * totalFees / 100) < balanceOf[address(cd[4])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(cd[4])] = balanceOf[address(cd[4])] + cd[36] - (cd[36] * totalFees / 100)
                                            emit Transfer((cd[36] - (cd[36] * totalFees / 100)), msg.sender, address(cd[4]));
                                        else:
                                            if cd[36] and 1 > -1 / cd[36]:
                                                revert with 0, 17
                                            if not cd[36]:
                                                revert with 0, 18
                                            if cd[36] / cd[36] != 1:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if cd[36] * totalFees / 100 > !(cd[36] / 100):
                                                revert with 0, 17
                                            if (cd[36] * totalFees / 100) + (cd[36] / 100) > cd[36]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if cd[36] < (cd[36] * totalFees / 100) + (cd[36] / 100):
                                                revert with 0, 17
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not this.address:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            if (cd[36] * totalFees / 100) + (cd[36] / 100) > balanceOf[address(msg.sender)]:
                                                revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[390 len 26] >> 48, 0
                                            if balanceOf[address(msg.sender)] < (cd[36] * totalFees / 100) + (cd[36] / 100):
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - (cd[36] * totalFees / 100) - (cd[36] / 100)
                                            if balanceOf[this.address] > !((cd[36] * totalFees / 100) + (cd[36] / 100)):
                                                revert with 0, 17
                                            if balanceOf[this.address] + (cd[36] * totalFees / 100) + (cd[36] / 100) < balanceOf[this.address]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(this.address)] = balanceOf[this.address] + (cd[36] * totalFees / 100) + (cd[36] / 100)
                                            emit Transfer(((cd[36] * totalFees / 100) + (cd[36] / 100)), msg.sender, this.address);
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not address(cd[4]):
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            if cd[36] - (cd[36] * totalFees / 100) - (cd[36] / 100) > balanceOf[address(msg.sender)]:
                                                revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[486 len 26] >> 48, 0
                                            if balanceOf[address(msg.sender)] < cd[36] - (cd[36] * totalFees / 100) - (cd[36] / 100):
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - cd[36] + (cd[36] * totalFees / 100) + (cd[36] / 100)
                                            if balanceOf[address(cd[4])] > !(cd[36] - (cd[36] * totalFees / 100) - (cd[36] / 100)):
                                                revert with 0, 17
                                            if balanceOf[address(cd[4])] + cd[36] - (cd[36] * totalFees / 100) - (cd[36] / 100) < balanceOf[address(cd[4])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(cd[4])] = balanceOf[address(cd[4])] + cd[36] - (cd[36] * totalFees / 100) - (cd[36] / 100)
                                            emit Transfer((cd[36] - (cd[36] * totalFees / 100) - (cd[36] / 100)), msg.sender, address(cd[4]));
                    require ext_code.size(dividendTrackerAddress)
                    call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args msg.sender, balanceOf[address(msg.sender)]
                    require ext_code.size(dividendTrackerAddress)
                    call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(cd[4]), balanceOf[address(cd[4])]
                    if not stor7:
                        call dividendTrackerAddress.process(uint256 arg1) with:
                             gas gas_remaining wei
                            args gasForProcessing
                        if ext_call.success:
                            require return_data.size >= 96
                            emit ProcessedDividendTracker(ext_call.return_data[0], ext_call.return_data[32], ext_call.return_data[64], gasForProcessing, 1, tx.origin);
                else:
                    if stor7:
                        if stor19[address(msg.sender)]:
                            if not msg.sender:
                                revert with 0, 'ERC20: transfer from the zero address'
                            if not address(cd[4]):
                                revert with 0, 'ERC20: transfer to the zero address'
                            if cd[36] > balanceOf[address(msg.sender)]:
                                revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                            if balanceOf[address(msg.sender)] < cd[36]:
                                revert with 0, 17
                            balanceOf[address(msg.sender)] -= cd[36]
                            if balanceOf[address(cd[4])] > !cd[36]:
                                revert with 0, 17
                            if balanceOf[address(cd[4])] + cd[36] < balanceOf[address(cd[4])]:
                                revert with 0, 'SafeMath: addition overflow'
                            balanceOf[address(cd[4])] += cd[36]
                            emit Transfer(cd[36], msg.sender, address(cd[4]));
                        else:
                            if stor19[address(cd[4])]:
                                if not msg.sender:
                                    revert with 0, 'ERC20: transfer from the zero address'
                                if not address(cd[4]):
                                    revert with 0, 'ERC20: transfer to the zero address'
                                if cd[36] > balanceOf[address(msg.sender)]:
                                    revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                if balanceOf[address(msg.sender)] < cd[36]:
                                    revert with 0, 17
                                balanceOf[address(msg.sender)] -= cd[36]
                                if balanceOf[address(cd[4])] > !cd[36]:
                                    revert with 0, 17
                                if balanceOf[address(cd[4])] + cd[36] < balanceOf[address(cd[4])]:
                                    revert with 0, 'SafeMath: addition overflow'
                                balanceOf[address(cd[4])] += cd[36]
                                emit Transfer(cd[36], msg.sender, address(cd[4]));
                            else:
                                if stor7:
                                    if not msg.sender:
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if not address(cd[4]):
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    if cd[36] > balanceOf[address(msg.sender)]:
                                        revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                    if balanceOf[address(msg.sender)] < cd[36]:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)] -= cd[36]
                                    if balanceOf[address(cd[4])] > !cd[36]:
                                        revert with 0, 17
                                    if balanceOf[address(cd[4])] + cd[36] < balanceOf[address(cd[4])]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(cd[4])] += cd[36]
                                    emit Transfer(cd[36], msg.sender, address(cd[4]));
                                else:
                                    if not cd[36]:
                                        if not stor20[address(cd[4])]:
                                            if 0 > cd[36]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if cd[36] < 0:
                                                revert with 0, 17
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not this.address:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            if 0 > balanceOf[address(msg.sender)]:
                                                revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[326 len 26] >> 48, 0
                                            if balanceOf[address(msg.sender)] < 0:
                                                revert with 0, 17
                                            if balanceOf[this.address] > -1:
                                                revert with 0, 17
                                            if balanceOf[this.address] < balanceOf[this.address]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(this.address)] = balanceOf[this.address]
                                            emit Transfer(0, msg.sender, this.address);
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not address(cd[4]):
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            if cd[36] > balanceOf[address(msg.sender)]:
                                                revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[422 len 26] >> 48, 0
                                            if balanceOf[address(msg.sender)] < cd[36]:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= cd[36]
                                            if balanceOf[address(cd[4])] > !cd[36]:
                                                revert with 0, 17
                                            if balanceOf[address(cd[4])] + cd[36] < balanceOf[address(cd[4])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(cd[4])] += cd[36]
                                            emit Transfer(cd[36], msg.sender, address(cd[4]));
                                        else:
                                            if not cd[36]:
                                                if 0 > cd[36]:
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if cd[36] < 0:
                                                    revert with 0, 17
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not this.address:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                if 0 > balanceOf[address(msg.sender)]:
                                                    revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[390 len 26] >> 48, 0
                                                if balanceOf[address(msg.sender)] < 0:
                                                    revert with 0, 17
                                                if balanceOf[this.address] > -1:
                                                    revert with 0, 17
                                                if balanceOf[this.address] < balanceOf[this.address]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(this.address)] = balanceOf[this.address]
                                                emit Transfer(0, msg.sender, this.address);
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not address(cd[4]):
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                if cd[36] > balanceOf[address(msg.sender)]:
                                                    revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[486 len 26] >> 48, 0
                                                if balanceOf[address(msg.sender)] < cd[36]:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= cd[36]
                                                if balanceOf[address(cd[4])] > !cd[36]:
                                                    revert with 0, 17
                                                if balanceOf[address(cd[4])] + cd[36] < balanceOf[address(cd[4])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(cd[4])] += cd[36]
                                                emit Transfer(cd[36], msg.sender, address(cd[4]));
                                            else:
                                                if cd[36] and 1 > -1 / cd[36]:
                                                    revert with 0, 17
                                                if not cd[36]:
                                                    revert with 0, 18
                                                if cd[36] / cd[36] != 1:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if 0 > !(cd[36] / 100):
                                                    revert with 0, 17
                                                if cd[36] / 100 > cd[36]:
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if cd[36] < cd[36] / 100:
                                                    revert with 0, 17
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not this.address:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                if cd[36] / 100 > balanceOf[address(msg.sender)]:
                                                    revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[390 len 26] >> 48, 0
                                                if balanceOf[address(msg.sender)] < cd[36] / 100:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= cd[36] / 100
                                                if balanceOf[this.address] > !(cd[36] / 100):
                                                    revert with 0, 17
                                                if balanceOf[this.address] + (cd[36] / 100) < balanceOf[this.address]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(this.address)] = balanceOf[this.address] + (cd[36] / 100)
                                                emit Transfer((cd[36] / 100), msg.sender, this.address);
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not address(cd[4]):
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                if cd[36] - (cd[36] / 100) > balanceOf[address(msg.sender)]:
                                                    revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[486 len 26] >> 48, 0
                                                if balanceOf[address(msg.sender)] < cd[36] - (cd[36] / 100):
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - cd[36] + (cd[36] / 100)
                                                if balanceOf[address(cd[4])] > !(cd[36] - (cd[36] / 100)):
                                                    revert with 0, 17
                                                if balanceOf[address(cd[4])] + cd[36] - (cd[36] / 100) < balanceOf[address(cd[4])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(cd[4])] = balanceOf[address(cd[4])] + cd[36] - (cd[36] / 100)
                                                emit Transfer((cd[36] - (cd[36] / 100)), msg.sender, address(cd[4]));
                                    else:
                                        if cd[36] and totalFees > -1 / cd[36]:
                                            revert with 0, 17
                                        if not cd[36]:
                                            revert with 0, 18
                                        if cd[36] * totalFees / cd[36] != totalFees:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not stor20[address(cd[4])]:
                                            if cd[36] * totalFees / 100 > cd[36]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if cd[36] < cd[36] * totalFees / 100:
                                                revert with 0, 17
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not this.address:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            if cd[36] * totalFees / 100 > balanceOf[address(msg.sender)]:
                                                revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[326 len 26] >> 48, 0
                                            if balanceOf[address(msg.sender)] < cd[36] * totalFees / 100:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= cd[36] * totalFees / 100
                                            if balanceOf[this.address] > !(cd[36] * totalFees / 100):
                                                revert with 0, 17
                                            if balanceOf[this.address] + (cd[36] * totalFees / 100) < balanceOf[this.address]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(this.address)] = balanceOf[this.address] + (cd[36] * totalFees / 100)
                                            emit Transfer((cd[36] * totalFees / 100), msg.sender, this.address);
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not address(cd[4]):
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            if cd[36] - (cd[36] * totalFees / 100) > balanceOf[address(msg.sender)]:
                                                revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[422 len 26] >> 48, 0
                                            if balanceOf[address(msg.sender)] < cd[36] - (cd[36] * totalFees / 100):
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - cd[36] + (cd[36] * totalFees / 100)
                                            if balanceOf[address(cd[4])] > !(cd[36] - (cd[36] * totalFees / 100)):
                                                revert with 0, 17
                                            if balanceOf[address(cd[4])] + cd[36] - (cd[36] * totalFees / 100) < balanceOf[address(cd[4])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(cd[4])] = balanceOf[address(cd[4])] + cd[36] - (cd[36] * totalFees / 100)
                                            emit Transfer((cd[36] - (cd[36] * totalFees / 100)), msg.sender, address(cd[4]));
                                        else:
                                            if not cd[36]:
                                                if cd[36] * totalFees / 100 > -1:
                                                    revert with 0, 17
                                                if cd[36] * totalFees / 100 > cd[36]:
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if cd[36] < cd[36] * totalFees / 100:
                                                    revert with 0, 17
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not this.address:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                if cd[36] * totalFees / 100 > balanceOf[address(msg.sender)]:
                                                    revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[390 len 26] >> 48, 0
                                                if balanceOf[address(msg.sender)] < cd[36] * totalFees / 100:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= cd[36] * totalFees / 100
                                                if balanceOf[this.address] > !(cd[36] * totalFees / 100):
                                                    revert with 0, 17
                                                if balanceOf[this.address] + (cd[36] * totalFees / 100) < balanceOf[this.address]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(this.address)] = balanceOf[this.address] + (cd[36] * totalFees / 100)
                                                emit Transfer((cd[36] * totalFees / 100), msg.sender, this.address);
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not address(cd[4]):
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                if cd[36] - (cd[36] * totalFees / 100) > balanceOf[address(msg.sender)]:
                                                    revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[486 len 26] >> 48, 0
                                                if balanceOf[address(msg.sender)] < cd[36] - (cd[36] * totalFees / 100):
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - cd[36] + (cd[36] * totalFees / 100)
                                                if balanceOf[address(cd[4])] > !(cd[36] - (cd[36] * totalFees / 100)):
                                                    revert with 0, 17
                                                if balanceOf[address(cd[4])] + cd[36] - (cd[36] * totalFees / 100) < balanceOf[address(cd[4])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(cd[4])] = balanceOf[address(cd[4])] + cd[36] - (cd[36] * totalFees / 100)
                                                emit Transfer((cd[36] - (cd[36] * totalFees / 100)), msg.sender, address(cd[4]));
                                            else:
                                                if cd[36] and 1 > -1 / cd[36]:
                                                    revert with 0, 17
                                                if not cd[36]:
                                                    revert with 0, 18
                                                if cd[36] / cd[36] != 1:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if cd[36] * totalFees / 100 > !(cd[36] / 100):
                                                    revert with 0, 17
                                                if (cd[36] * totalFees / 100) + (cd[36] / 100) > cd[36]:
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if cd[36] < (cd[36] * totalFees / 100) + (cd[36] / 100):
                                                    revert with 0, 17
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not this.address:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                if (cd[36] * totalFees / 100) + (cd[36] / 100) > balanceOf[address(msg.sender)]:
                                                    revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[390 len 26] >> 48, 0
                                                if balanceOf[address(msg.sender)] < (cd[36] * totalFees / 100) + (cd[36] / 100):
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - (cd[36] * totalFees / 100) - (cd[36] / 100)
                                                if balanceOf[this.address] > !((cd[36] * totalFees / 100) + (cd[36] / 100)):
                                                    revert with 0, 17
                                                if balanceOf[this.address] + (cd[36] * totalFees / 100) + (cd[36] / 100) < balanceOf[this.address]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(this.address)] = balanceOf[this.address] + (cd[36] * totalFees / 100) + (cd[36] / 100)
                                                emit Transfer(((cd[36] * totalFees / 100) + (cd[36] / 100)), msg.sender, this.address);
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not address(cd[4]):
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                if cd[36] - (cd[36] * totalFees / 100) - (cd[36] / 100) > balanceOf[address(msg.sender)]:
                                                    revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[486 len 26] >> 48, 0
                                                if balanceOf[address(msg.sender)] < cd[36] - (cd[36] * totalFees / 100) - (cd[36] / 100):
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - cd[36] + (cd[36] * totalFees / 100) + (cd[36] / 100)
                                                if balanceOf[address(cd[4])] > !(cd[36] - (cd[36] * totalFees / 100) - (cd[36] / 100)):
                                                    revert with 0, 17
                                                if balanceOf[address(cd[4])] + cd[36] - (cd[36] * totalFees / 100) - (cd[36] / 100) < balanceOf[address(cd[4])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(cd[4])] = balanceOf[address(cd[4])] + cd[36] - (cd[36] * totalFees / 100) - (cd[36] / 100)
                                                emit Transfer((cd[36] - (cd[36] * totalFees / 100) - (cd[36] / 100)), msg.sender, address(cd[4]));
                        require ext_code.size(dividendTrackerAddress)
                        call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args msg.sender, balanceOf[address(msg.sender)]
                        require ext_code.size(dividendTrackerAddress)
                        call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(cd[4]), balanceOf[address(cd[4])]
                        if not stor7:
                            call dividendTrackerAddress.process(uint256 arg1) with:
                                 gas gas_remaining wei
                                args gasForProcessing
                            if ext_call.success:
                                require return_data.size >= 96
                                emit ProcessedDividendTracker(ext_call.return_data[0], ext_call.return_data[32], ext_call.return_data[64], gasForProcessing, 1, tx.origin);
                    else:
                        if stor20[address(msg.sender)]:
                            if stor19[address(msg.sender)]:
                                if not msg.sender:
                                    revert with 0, 'ERC20: transfer from the zero address'
                                if not address(cd[4]):
                                    revert with 0, 'ERC20: transfer to the zero address'
                                if cd[36] > balanceOf[address(msg.sender)]:
                                    revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                if balanceOf[address(msg.sender)] < cd[36]:
                                    revert with 0, 17
                                balanceOf[address(msg.sender)] -= cd[36]
                                if balanceOf[address(cd[4])] > !cd[36]:
                                    revert with 0, 17
                                if balanceOf[address(cd[4])] + cd[36] < balanceOf[address(cd[4])]:
                                    revert with 0, 'SafeMath: addition overflow'
                                balanceOf[address(cd[4])] += cd[36]
                                emit Transfer(cd[36], msg.sender, address(cd[4]));
                            else:
                                if stor19[address(cd[4])]:
                                    if not msg.sender:
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if not address(cd[4]):
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    if cd[36] > balanceOf[address(msg.sender)]:
                                        revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                    if balanceOf[address(msg.sender)] < cd[36]:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)] -= cd[36]
                                    if balanceOf[address(cd[4])] > !cd[36]:
                                        revert with 0, 17
                                    if balanceOf[address(cd[4])] + cd[36] < balanceOf[address(cd[4])]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(cd[4])] += cd[36]
                                    emit Transfer(cd[36], msg.sender, address(cd[4]));
                                else:
                                    if stor7:
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not address(cd[4]):
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        if cd[36] > balanceOf[address(msg.sender)]:
                                            revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                        if balanceOf[address(msg.sender)] < cd[36]:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= cd[36]
                                        if balanceOf[address(cd[4])] > !cd[36]:
                                            revert with 0, 17
                                        if balanceOf[address(cd[4])] + cd[36] < balanceOf[address(cd[4])]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(cd[4])] += cd[36]
                                        emit Transfer(cd[36], msg.sender, address(cd[4]));
                                    else:
                                        if not cd[36]:
                                            if not stor20[address(cd[4])]:
                                                if 0 > cd[36]:
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if cd[36] < 0:
                                                    revert with 0, 17
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not this.address:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                if 0 > balanceOf[address(msg.sender)]:
                                                    revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[326 len 26] >> 48, 0
                                                if balanceOf[address(msg.sender)] < 0:
                                                    revert with 0, 17
                                                if balanceOf[this.address] > -1:
                                                    revert with 0, 17
                                                if balanceOf[this.address] < balanceOf[this.address]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(this.address)] = balanceOf[this.address]
                                                emit Transfer(0, msg.sender, this.address);
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not address(cd[4]):
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                if cd[36] > balanceOf[address(msg.sender)]:
                                                    revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[422 len 26] >> 48, 0
                                                if balanceOf[address(msg.sender)] < cd[36]:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= cd[36]
                                                if balanceOf[address(cd[4])] > !cd[36]:
                                                    revert with 0, 17
                                                if balanceOf[address(cd[4])] + cd[36] < balanceOf[address(cd[4])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(cd[4])] += cd[36]
                                                emit Transfer(cd[36], msg.sender, address(cd[4]));
                                            else:
                                                if not cd[36]:
                                                    if 0 > cd[36]:
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if cd[36] < 0:
                                                        revert with 0, 17
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not this.address:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    if 0 > balanceOf[address(msg.sender)]:
                                                        revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[390 len 26] >> 48, 0
                                                    if balanceOf[address(msg.sender)] < 0:
                                                        revert with 0, 17
                                                    if balanceOf[this.address] > -1:
                                                        revert with 0, 17
                                                    if balanceOf[this.address] < balanceOf[this.address]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(this.address)] = balanceOf[this.address]
                                                    emit Transfer(0, msg.sender, this.address);
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not address(cd[4]):
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    if cd[36] > balanceOf[address(msg.sender)]:
                                                        revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[486 len 26] >> 48, 0
                                                    if balanceOf[address(msg.sender)] < cd[36]:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= cd[36]
                                                    if balanceOf[address(cd[4])] > !cd[36]:
                                                        revert with 0, 17
                                                    if balanceOf[address(cd[4])] + cd[36] < balanceOf[address(cd[4])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(cd[4])] += cd[36]
                                                    emit Transfer(cd[36], msg.sender, address(cd[4]));
                                                else:
                                                    if cd[36] and 1 > -1 / cd[36]:
                                                        revert with 0, 17
                                                    if not cd[36]:
                                                        revert with 0, 18
                                                    if cd[36] / cd[36] != 1:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if 0 > !(cd[36] / 100):
                                                        revert with 0, 17
                                                    if cd[36] / 100 > cd[36]:
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if cd[36] < cd[36] / 100:
                                                        revert with 0, 17
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not this.address:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    if cd[36] / 100 > balanceOf[address(msg.sender)]:
                                                        revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[390 len 26] >> 48, 0
                                                    if balanceOf[address(msg.sender)] < cd[36] / 100:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= cd[36] / 100
                                                    if balanceOf[this.address] > !(cd[36] / 100):
                                                        revert with 0, 17
                                                    if balanceOf[this.address] + (cd[36] / 100) < balanceOf[this.address]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(this.address)] = balanceOf[this.address] + (cd[36] / 100)
                                                    emit Transfer((cd[36] / 100), msg.sender, this.address);
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not address(cd[4]):
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    if cd[36] - (cd[36] / 100) > balanceOf[address(msg.sender)]:
                                                        revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[486 len 26] >> 48, 0
                                                    if balanceOf[address(msg.sender)] < cd[36] - (cd[36] / 100):
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - cd[36] + (cd[36] / 100)
                                                    if balanceOf[address(cd[4])] > !(cd[36] - (cd[36] / 100)):
                                                        revert with 0, 17
                                                    if balanceOf[address(cd[4])] + cd[36] - (cd[36] / 100) < balanceOf[address(cd[4])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(cd[4])] = balanceOf[address(cd[4])] + cd[36] - (cd[36] / 100)
                                                    emit Transfer((cd[36] - (cd[36] / 100)), msg.sender, address(cd[4]));
                                        else:
                                            if cd[36] and totalFees > -1 / cd[36]:
                                                revert with 0, 17
                                            if not cd[36]:
                                                revert with 0, 18
                                            if cd[36] * totalFees / cd[36] != totalFees:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not stor20[address(cd[4])]:
                                                if cd[36] * totalFees / 100 > cd[36]:
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if cd[36] < cd[36] * totalFees / 100:
                                                    revert with 0, 17
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not this.address:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                if cd[36] * totalFees / 100 > balanceOf[address(msg.sender)]:
                                                    revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[326 len 26] >> 48, 0
                                                if balanceOf[address(msg.sender)] < cd[36] * totalFees / 100:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= cd[36] * totalFees / 100
                                                if balanceOf[this.address] > !(cd[36] * totalFees / 100):
                                                    revert with 0, 17
                                                if balanceOf[this.address] + (cd[36] * totalFees / 100) < balanceOf[this.address]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(this.address)] = balanceOf[this.address] + (cd[36] * totalFees / 100)
                                                emit Transfer((cd[36] * totalFees / 100), msg.sender, this.address);
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not address(cd[4]):
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                if cd[36] - (cd[36] * totalFees / 100) > balanceOf[address(msg.sender)]:
                                                    revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[422 len 26] >> 48, 0
                                                if balanceOf[address(msg.sender)] < cd[36] - (cd[36] * totalFees / 100):
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - cd[36] + (cd[36] * totalFees / 100)
                                                if balanceOf[address(cd[4])] > !(cd[36] - (cd[36] * totalFees / 100)):
                                                    revert with 0, 17
                                                if balanceOf[address(cd[4])] + cd[36] - (cd[36] * totalFees / 100) < balanceOf[address(cd[4])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(cd[4])] = balanceOf[address(cd[4])] + cd[36] - (cd[36] * totalFees / 100)
                                                emit Transfer((cd[36] - (cd[36] * totalFees / 100)), msg.sender, address(cd[4]));
                                            else:
                                                if not cd[36]:
                                                    if cd[36] * totalFees / 100 > -1:
                                                        revert with 0, 17
                                                    if cd[36] * totalFees / 100 > cd[36]:
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if cd[36] < cd[36] * totalFees / 100:
                                                        revert with 0, 17
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not this.address:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    if cd[36] * totalFees / 100 > balanceOf[address(msg.sender)]:
                                                        revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[390 len 26] >> 48, 0
                                                    if balanceOf[address(msg.sender)] < cd[36] * totalFees / 100:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= cd[36] * totalFees / 100
                                                    if balanceOf[this.address] > !(cd[36] * totalFees / 100):
                                                        revert with 0, 17
                                                    if balanceOf[this.address] + (cd[36] * totalFees / 100) < balanceOf[this.address]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(this.address)] = balanceOf[this.address] + (cd[36] * totalFees / 100)
                                                    emit Transfer((cd[36] * totalFees / 100), msg.sender, this.address);
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not address(cd[4]):
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    if cd[36] - (cd[36] * totalFees / 100) > balanceOf[address(msg.sender)]:
                                                        revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[486 len 26] >> 48, 0
                                                    if balanceOf[address(msg.sender)] < cd[36] - (cd[36] * totalFees / 100):
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - cd[36] + (cd[36] * totalFees / 100)
                                                    if balanceOf[address(cd[4])] > !(cd[36] - (cd[36] * totalFees / 100)):
                                                        revert with 0, 17
                                                    if balanceOf[address(cd[4])] + cd[36] - (cd[36] * totalFees / 100) < balanceOf[address(cd[4])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(cd[4])] = balanceOf[address(cd[4])] + cd[36] - (cd[36] * totalFees / 100)
                                                    emit Transfer((cd[36] - (cd[36] * totalFees / 100)), msg.sender, address(cd[4]));
                                                else:
                                                    if cd[36] and 1 > -1 / cd[36]:
                                                        revert with 0, 17
                                                    if not cd[36]:
                                                        revert with 0, 18
                                                    if cd[36] / cd[36] != 1:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if cd[36] * totalFees / 100 > !(cd[36] / 100):
                                                        revert with 0, 17
                                                    if (cd[36] * totalFees / 100) + (cd[36] / 100) > cd[36]:
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if cd[36] < (cd[36] * totalFees / 100) + (cd[36] / 100):
                                                        revert with 0, 17
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not this.address:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    if (cd[36] * totalFees / 100) + (cd[36] / 100) > balanceOf[address(msg.sender)]:
                                                        revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[390 len 26] >> 48, 0
                                                    if balanceOf[address(msg.sender)] < (cd[36] * totalFees / 100) + (cd[36] / 100):
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - (cd[36] * totalFees / 100) - (cd[36] / 100)
                                                    if balanceOf[this.address] > !((cd[36] * totalFees / 100) + (cd[36] / 100)):
                                                        revert with 0, 17
                                                    if balanceOf[this.address] + (cd[36] * totalFees / 100) + (cd[36] / 100) < balanceOf[this.address]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(this.address)] = balanceOf[this.address] + (cd[36] * totalFees / 100) + (cd[36] / 100)
                                                    emit Transfer(((cd[36] * totalFees / 100) + (cd[36] / 100)), msg.sender, this.address);
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not address(cd[4]):
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    if cd[36] - (cd[36] * totalFees / 100) - (cd[36] / 100) > balanceOf[address(msg.sender)]:
                                                        revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[486 len 26] >> 48, 0
                                                    if balanceOf[address(msg.sender)] < cd[36] - (cd[36] * totalFees / 100) - (cd[36] / 100):
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - cd[36] + (cd[36] * totalFees / 100) + (cd[36] / 100)
                                                    if balanceOf[address(cd[4])] > !(cd[36] - (cd[36] * totalFees / 100) - (cd[36] / 100)):
                                                        revert with 0, 17
                                                    if balanceOf[address(cd[4])] + cd[36] - (cd[36] * totalFees / 100) - (cd[36] / 100) < balanceOf[address(cd[4])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(cd[4])] = balanceOf[address(cd[4])] + cd[36] - (cd[36] * totalFees / 100) - (cd[36] / 100)
                                                    emit Transfer((cd[36] - (cd[36] * totalFees / 100) - (cd[36] / 100)), msg.sender, address(cd[4]));
                            require ext_code.size(dividendTrackerAddress)
                            call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args msg.sender, balanceOf[address(msg.sender)]
                            require ext_code.size(dividendTrackerAddress)
                            call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args address(cd[4]), balanceOf[address(cd[4])]
                            if not stor7:
                                call dividendTrackerAddress.process(uint256 arg1) with:
                                     gas gas_remaining wei
                                    args gasForProcessing
                                if ext_call.success:
                                    require return_data.size >= 96
                                    emit ProcessedDividendTracker(ext_call.return_data[0], ext_call.return_data[32], ext_call.return_data[64], gasForProcessing, 1, tx.origin);
                        else:
                            if owner == msg.sender:
                                if stor19[address(msg.sender)]:
                                    if not msg.sender:
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if not address(cd[4]):
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    if cd[36] > balanceOf[address(msg.sender)]:
                                        revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                    if balanceOf[address(msg.sender)] < cd[36]:
                                        revert with 0, 17
                                    balanceOf[address(msg.sender)] -= cd[36]
                                    if balanceOf[address(cd[4])] > !cd[36]:
                                        revert with 0, 17
                                    if balanceOf[address(cd[4])] + cd[36] < balanceOf[address(cd[4])]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(cd[4])] += cd[36]
                                    emit Transfer(cd[36], msg.sender, address(cd[4]));
                                else:
                                    if stor19[address(cd[4])]:
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not address(cd[4]):
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        if cd[36] > balanceOf[address(msg.sender)]:
                                            revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                        if balanceOf[address(msg.sender)] < cd[36]:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= cd[36]
                                        if balanceOf[address(cd[4])] > !cd[36]:
                                            revert with 0, 17
                                        if balanceOf[address(cd[4])] + cd[36] < balanceOf[address(cd[4])]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(cd[4])] += cd[36]
                                        emit Transfer(cd[36], msg.sender, address(cd[4]));
                                    else:
                                        if stor7:
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not address(cd[4]):
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            if cd[36] > balanceOf[address(msg.sender)]:
                                                revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                            if balanceOf[address(msg.sender)] < cd[36]:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= cd[36]
                                            if balanceOf[address(cd[4])] > !cd[36]:
                                                revert with 0, 17
                                            if balanceOf[address(cd[4])] + cd[36] < balanceOf[address(cd[4])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(cd[4])] += cd[36]
                                            emit Transfer(cd[36], msg.sender, address(cd[4]));
                                        else:
                                            if not cd[36]:
                                                if not stor20[address(cd[4])]:
                                                    if 0 > cd[36]:
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if cd[36] < 0:
                                                        revert with 0, 17
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not this.address:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    if 0 > balanceOf[address(msg.sender)]:
                                                        revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[326 len 26] >> 48, 0
                                                    if balanceOf[address(msg.sender)] < 0:
                                                        revert with 0, 17
                                                    if balanceOf[this.address] > -1:
                                                        revert with 0, 17
                                                    if balanceOf[this.address] < balanceOf[this.address]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(this.address)] = balanceOf[this.address]
                                                    emit Transfer(0, msg.sender, this.address);
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not address(cd[4]):
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    if cd[36] > balanceOf[address(msg.sender)]:
                                                        revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[422 len 26] >> 48, 0
                                                    if balanceOf[address(msg.sender)] < cd[36]:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= cd[36]
                                                    if balanceOf[address(cd[4])] > !cd[36]:
                                                        revert with 0, 17
                                                    if balanceOf[address(cd[4])] + cd[36] < balanceOf[address(cd[4])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(cd[4])] += cd[36]
                                                    emit Transfer(cd[36], msg.sender, address(cd[4]));
                                                else:
                                                    if not cd[36]:
                                                        if 0 > cd[36]:
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if cd[36] < 0:
                                                            revert with 0, 17
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not this.address:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        if 0 > balanceOf[address(msg.sender)]:
                                                            revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[390 len 26] >> 48, 0
                                                        if balanceOf[address(msg.sender)] < 0:
                                                            revert with 0, 17
                                                        if balanceOf[this.address] > -1:
                                                            revert with 0, 17
                                                        if balanceOf[this.address] < balanceOf[this.address]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(this.address)] = balanceOf[this.address]
                                                        emit Transfer(0, msg.sender, this.address);
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not address(cd[4]):
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        if cd[36] > balanceOf[address(msg.sender)]:
                                                            revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[486 len 26] >> 48, 0
                                                        if balanceOf[address(msg.sender)] < cd[36]:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] -= cd[36]
                                                        if balanceOf[address(cd[4])] > !cd[36]:
                                                            revert with 0, 17
                                                        if balanceOf[address(cd[4])] + cd[36] < balanceOf[address(cd[4])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(cd[4])] += cd[36]
                                                        emit Transfer(cd[36], msg.sender, address(cd[4]));
                                                    else:
                                                        if cd[36] and 1 > -1 / cd[36]:
                                                            revert with 0, 17
                                                        if not cd[36]:
                                                            revert with 0, 18
                                                        if cd[36] / cd[36] != 1:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if 0 > !(cd[36] / 100):
                                                            revert with 0, 17
                                                        if cd[36] / 100 > cd[36]:
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if cd[36] < cd[36] / 100:
                                                            revert with 0, 17
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not this.address:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        if cd[36] / 100 > balanceOf[address(msg.sender)]:
                                                            revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[390 len 26] >> 48, 0
                                                        if balanceOf[address(msg.sender)] < cd[36] / 100:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] -= cd[36] / 100
                                                        if balanceOf[this.address] > !(cd[36] / 100):
                                                            revert with 0, 17
                                                        if balanceOf[this.address] + (cd[36] / 100) < balanceOf[this.address]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(this.address)] = balanceOf[this.address] + (cd[36] / 100)
                                                        emit Transfer((cd[36] / 100), msg.sender, this.address);
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not address(cd[4]):
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        if cd[36] - (cd[36] / 100) > balanceOf[address(msg.sender)]:
                                                            revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[486 len 26] >> 48, 0
                                                        if balanceOf[address(msg.sender)] < cd[36] - (cd[36] / 100):
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - cd[36] + (cd[36] / 100)
                                                        if balanceOf[address(cd[4])] > !(cd[36] - (cd[36] / 100)):
                                                            revert with 0, 17
                                                        if balanceOf[address(cd[4])] + cd[36] - (cd[36] / 100) < balanceOf[address(cd[4])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(cd[4])] = balanceOf[address(cd[4])] + cd[36] - (cd[36] / 100)
                                                        emit Transfer((cd[36] - (cd[36] / 100)), msg.sender, address(cd[4]));
                                            else:
                                                if cd[36] and totalFees > -1 / cd[36]:
                                                    revert with 0, 17
                                                if not cd[36]:
                                                    revert with 0, 18
                                                if cd[36] * totalFees / cd[36] != totalFees:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not stor20[address(cd[4])]:
                                                    if cd[36] * totalFees / 100 > cd[36]:
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if cd[36] < cd[36] * totalFees / 100:
                                                        revert with 0, 17
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not this.address:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    if cd[36] * totalFees / 100 > balanceOf[address(msg.sender)]:
                                                        revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[326 len 26] >> 48, 0
                                                    if balanceOf[address(msg.sender)] < cd[36] * totalFees / 100:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= cd[36] * totalFees / 100
                                                    if balanceOf[this.address] > !(cd[36] * totalFees / 100):
                                                        revert with 0, 17
                                                    if balanceOf[this.address] + (cd[36] * totalFees / 100) < balanceOf[this.address]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(this.address)] = balanceOf[this.address] + (cd[36] * totalFees / 100)
                                                    emit Transfer((cd[36] * totalFees / 100), msg.sender, this.address);
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not address(cd[4]):
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    if cd[36] - (cd[36] * totalFees / 100) > balanceOf[address(msg.sender)]:
                                                        revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[422 len 26] >> 48, 0
                                                    if balanceOf[address(msg.sender)] < cd[36] - (cd[36] * totalFees / 100):
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - cd[36] + (cd[36] * totalFees / 100)
                                                    if balanceOf[address(cd[4])] > !(cd[36] - (cd[36] * totalFees / 100)):
                                                        revert with 0, 17
                                                    if balanceOf[address(cd[4])] + cd[36] - (cd[36] * totalFees / 100) < balanceOf[address(cd[4])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(cd[4])] = balanceOf[address(cd[4])] + cd[36] - (cd[36] * totalFees / 100)
                                                    emit Transfer((cd[36] - (cd[36] * totalFees / 100)), msg.sender, address(cd[4]));
                                                else:
                                                    if not cd[36]:
                                                        if cd[36] * totalFees / 100 > -1:
                                                            revert with 0, 17
                                                        if cd[36] * totalFees / 100 > cd[36]:
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if cd[36] < cd[36] * totalFees / 100:
                                                            revert with 0, 17
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not this.address:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        if cd[36] * totalFees / 100 > balanceOf[address(msg.sender)]:
                                                            revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[390 len 26] >> 48, 0
                                                        if balanceOf[address(msg.sender)] < cd[36] * totalFees / 100:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] -= cd[36] * totalFees / 100
                                                        if balanceOf[this.address] > !(cd[36] * totalFees / 100):
                                                            revert with 0, 17
                                                        if balanceOf[this.address] + (cd[36] * totalFees / 100) < balanceOf[this.address]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(this.address)] = balanceOf[this.address] + (cd[36] * totalFees / 100)
                                                        emit Transfer((cd[36] * totalFees / 100), msg.sender, this.address);
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not address(cd[4]):
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        if cd[36] - (cd[36] * totalFees / 100) > balanceOf[address(msg.sender)]:
                                                            revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[486 len 26] >> 48, 0
                                                        if balanceOf[address(msg.sender)] < cd[36] - (cd[36] * totalFees / 100):
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - cd[36] + (cd[36] * totalFees / 100)
                                                        if balanceOf[address(cd[4])] > !(cd[36] - (cd[36] * totalFees / 100)):
                                                            revert with 0, 17
                                                        if balanceOf[address(cd[4])] + cd[36] - (cd[36] * totalFees / 100) < balanceOf[address(cd[4])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(cd[4])] = balanceOf[address(cd[4])] + cd[36] - (cd[36] * totalFees / 100)
                                                        emit Transfer((cd[36] - (cd[36] * totalFees / 100)), msg.sender, address(cd[4]));
                                                    else:
                                                        if cd[36] and 1 > -1 / cd[36]:
                                                            revert with 0, 17
                                                        if not cd[36]:
                                                            revert with 0, 18
                                                        if cd[36] / cd[36] != 1:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if cd[36] * totalFees / 100 > !(cd[36] / 100):
                                                            revert with 0, 17
                                                        if (cd[36] * totalFees / 100) + (cd[36] / 100) > cd[36]:
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if cd[36] < (cd[36] * totalFees / 100) + (cd[36] / 100):
                                                            revert with 0, 17
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not this.address:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        if (cd[36] * totalFees / 100) + (cd[36] / 100) > balanceOf[address(msg.sender)]:
                                                            revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[390 len 26] >> 48, 0
                                                        if balanceOf[address(msg.sender)] < (cd[36] * totalFees / 100) + (cd[36] / 100):
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - (cd[36] * totalFees / 100) - (cd[36] / 100)
                                                        if balanceOf[this.address] > !((cd[36] * totalFees / 100) + (cd[36] / 100)):
                                                            revert with 0, 17
                                                        if balanceOf[this.address] + (cd[36] * totalFees / 100) + (cd[36] / 100) < balanceOf[this.address]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(this.address)] = balanceOf[this.address] + (cd[36] * totalFees / 100) + (cd[36] / 100)
                                                        emit Transfer(((cd[36] * totalFees / 100) + (cd[36] / 100)), msg.sender, this.address);
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not address(cd[4]):
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        if cd[36] - (cd[36] * totalFees / 100) - (cd[36] / 100) > balanceOf[address(msg.sender)]:
                                                            revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[486 len 26] >> 48, 0
                                                        if balanceOf[address(msg.sender)] < cd[36] - (cd[36] * totalFees / 100) - (cd[36] / 100):
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - cd[36] + (cd[36] * totalFees / 100) + (cd[36] / 100)
                                                        if balanceOf[address(cd[4])] > !(cd[36] - (cd[36] * totalFees / 100) - (cd[36] / 100)):
                                                            revert with 0, 17
                                                        if balanceOf[address(cd[4])] + cd[36] - (cd[36] * totalFees / 100) - (cd[36] / 100) < balanceOf[address(cd[4])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(cd[4])] = balanceOf[address(cd[4])] + cd[36] - (cd[36] * totalFees / 100) - (cd[36] / 100)
                                                        emit Transfer((cd[36] - (cd[36] * totalFees / 100) - (cd[36] / 100)), msg.sender, address(cd[4]));
                                require ext_code.size(dividendTrackerAddress)
                                call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args msg.sender, balanceOf[address(msg.sender)]
                                require ext_code.size(dividendTrackerAddress)
                                call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args address(cd[4]), balanceOf[address(cd[4])]
                                if not stor7:
                                    call dividendTrackerAddress.process(uint256 arg1) with:
                                         gas gas_remaining wei
                                        args gasForProcessing
                                    if ext_call.success:
                                        require return_data.size >= 96
                                        emit ProcessedDividendTracker(ext_call.return_data[0], ext_call.return_data[32], ext_call.return_data[64], gasForProcessing, 1, tx.origin);
                            else:
                                if owner == address(cd[4]):
                                    if stor19[address(msg.sender)]:
                                        if not msg.sender:
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not address(cd[4]):
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        if cd[36] > balanceOf[address(msg.sender)]:
                                            revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                        if balanceOf[address(msg.sender)] < cd[36]:
                                            revert with 0, 17
                                        balanceOf[address(msg.sender)] -= cd[36]
                                        if balanceOf[address(cd[4])] > !cd[36]:
                                            revert with 0, 17
                                        if balanceOf[address(cd[4])] + cd[36] < balanceOf[address(cd[4])]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(cd[4])] += cd[36]
                                        emit Transfer(cd[36], msg.sender, address(cd[4]));
                                    else:
                                        if stor19[address(cd[4])]:
                                            if not msg.sender:
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not address(cd[4]):
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            if cd[36] > balanceOf[address(msg.sender)]:
                                                revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                            if balanceOf[address(msg.sender)] < cd[36]:
                                                revert with 0, 17
                                            balanceOf[address(msg.sender)] -= cd[36]
                                            if balanceOf[address(cd[4])] > !cd[36]:
                                                revert with 0, 17
                                            if balanceOf[address(cd[4])] + cd[36] < balanceOf[address(cd[4])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(cd[4])] += cd[36]
                                            emit Transfer(cd[36], msg.sender, address(cd[4]));
                                        else:
                                            if stor7:
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not address(cd[4]):
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                if cd[36] > balanceOf[address(msg.sender)]:
                                                    revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                                if balanceOf[address(msg.sender)] < cd[36]:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= cd[36]
                                                if balanceOf[address(cd[4])] > !cd[36]:
                                                    revert with 0, 17
                                                if balanceOf[address(cd[4])] + cd[36] < balanceOf[address(cd[4])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(cd[4])] += cd[36]
                                                emit Transfer(cd[36], msg.sender, address(cd[4]));
                                            else:
                                                if not cd[36]:
                                                    if not stor20[address(cd[4])]:
                                                        if 0 > cd[36]:
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if cd[36] < 0:
                                                            revert with 0, 17
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not this.address:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        if 0 > balanceOf[address(msg.sender)]:
                                                            revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[326 len 26] >> 48, 0
                                                        if balanceOf[address(msg.sender)] < 0:
                                                            revert with 0, 17
                                                        if balanceOf[this.address] > -1:
                                                            revert with 0, 17
                                                        if balanceOf[this.address] < balanceOf[this.address]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(this.address)] = balanceOf[this.address]
                                                        emit Transfer(0, msg.sender, this.address);
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not address(cd[4]):
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        if cd[36] > balanceOf[address(msg.sender)]:
                                                            revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[422 len 26] >> 48, 0
                                                        if balanceOf[address(msg.sender)] < cd[36]:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] -= cd[36]
                                                        if balanceOf[address(cd[4])] > !cd[36]:
                                                            revert with 0, 17
                                                        if balanceOf[address(cd[4])] + cd[36] < balanceOf[address(cd[4])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(cd[4])] += cd[36]
                                                        emit Transfer(cd[36], msg.sender, address(cd[4]));
                                                    else:
                                                        if not cd[36]:
                                                            if 0 > cd[36]:
                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                            if cd[36] < 0:
                                                                revert with 0, 17
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not this.address:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            if 0 > balanceOf[address(msg.sender)]:
                                                                revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[390 len 26] >> 48, 0
                                                            if balanceOf[address(msg.sender)] < 0:
                                                                revert with 0, 17
                                                            if balanceOf[this.address] > -1:
                                                                revert with 0, 17
                                                            if balanceOf[this.address] < balanceOf[this.address]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            balanceOf[address(this.address)] = balanceOf[this.address]
                                                            emit Transfer(0, msg.sender, this.address);
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not address(cd[4]):
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            if cd[36] > balanceOf[address(msg.sender)]:
                                                                revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[486 len 26] >> 48, 0
                                                            if balanceOf[address(msg.sender)] < cd[36]:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= cd[36]
                                                            if balanceOf[address(cd[4])] > !cd[36]:
                                                                revert with 0, 17
                                                            if balanceOf[address(cd[4])] + cd[36] < balanceOf[address(cd[4])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            balanceOf[address(cd[4])] += cd[36]
                                                            emit Transfer(cd[36], msg.sender, address(cd[4]));
                                                        else:
                                                            if cd[36] and 1 > -1 / cd[36]:
                                                                revert with 0, 17
                                                            if not cd[36]:
                                                                revert with 0, 18
                                                            if cd[36] / cd[36] != 1:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if 0 > !(cd[36] / 100):
                                                                revert with 0, 17
                                                            if cd[36] / 100 > cd[36]:
                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                            if cd[36] < cd[36] / 100:
                                                                revert with 0, 17
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not this.address:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            if cd[36] / 100 > balanceOf[address(msg.sender)]:
                                                                revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[390 len 26] >> 48, 0
                                                            if balanceOf[address(msg.sender)] < cd[36] / 100:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= cd[36] / 100
                                                            if balanceOf[this.address] > !(cd[36] / 100):
                                                                revert with 0, 17
                                                            if balanceOf[this.address] + (cd[36] / 100) < balanceOf[this.address]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            balanceOf[address(this.address)] = balanceOf[this.address] + (cd[36] / 100)
                                                            emit Transfer((cd[36] / 100), msg.sender, this.address);
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not address(cd[4]):
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            if cd[36] - (cd[36] / 100) > balanceOf[address(msg.sender)]:
                                                                revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[486 len 26] >> 48, 0
                                                            if balanceOf[address(msg.sender)] < cd[36] - (cd[36] / 100):
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - cd[36] + (cd[36] / 100)
                                                            if balanceOf[address(cd[4])] > !(cd[36] - (cd[36] / 100)):
                                                                revert with 0, 17
                                                            if balanceOf[address(cd[4])] + cd[36] - (cd[36] / 100) < balanceOf[address(cd[4])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            balanceOf[address(cd[4])] = balanceOf[address(cd[4])] + cd[36] - (cd[36] / 100)
                                                            emit Transfer((cd[36] - (cd[36] / 100)), msg.sender, address(cd[4]));
                                                else:
                                                    if cd[36] and totalFees > -1 / cd[36]:
                                                        revert with 0, 17
                                                    if not cd[36]:
                                                        revert with 0, 18
                                                    if cd[36] * totalFees / cd[36] != totalFees:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not stor20[address(cd[4])]:
                                                        if cd[36] * totalFees / 100 > cd[36]:
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if cd[36] < cd[36] * totalFees / 100:
                                                            revert with 0, 17
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not this.address:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        if cd[36] * totalFees / 100 > balanceOf[address(msg.sender)]:
                                                            revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[326 len 26] >> 48, 0
                                                        if balanceOf[address(msg.sender)] < cd[36] * totalFees / 100:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] -= cd[36] * totalFees / 100
                                                        if balanceOf[this.address] > !(cd[36] * totalFees / 100):
                                                            revert with 0, 17
                                                        if balanceOf[this.address] + (cd[36] * totalFees / 100) < balanceOf[this.address]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(this.address)] = balanceOf[this.address] + (cd[36] * totalFees / 100)
                                                        emit Transfer((cd[36] * totalFees / 100), msg.sender, this.address);
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not address(cd[4]):
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        if cd[36] - (cd[36] * totalFees / 100) > balanceOf[address(msg.sender)]:
                                                            revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[422 len 26] >> 48, 0
                                                        if balanceOf[address(msg.sender)] < cd[36] - (cd[36] * totalFees / 100):
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - cd[36] + (cd[36] * totalFees / 100)
                                                        if balanceOf[address(cd[4])] > !(cd[36] - (cd[36] * totalFees / 100)):
                                                            revert with 0, 17
                                                        if balanceOf[address(cd[4])] + cd[36] - (cd[36] * totalFees / 100) < balanceOf[address(cd[4])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(cd[4])] = balanceOf[address(cd[4])] + cd[36] - (cd[36] * totalFees / 100)
                                                        emit Transfer((cd[36] - (cd[36] * totalFees / 100)), msg.sender, address(cd[4]));
                                                    else:
                                                        if not cd[36]:
                                                            if cd[36] * totalFees / 100 > -1:
                                                                revert with 0, 17
                                                            if cd[36] * totalFees / 100 > cd[36]:
                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                            if cd[36] < cd[36] * totalFees / 100:
                                                                revert with 0, 17
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not this.address:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            if cd[36] * totalFees / 100 > balanceOf[address(msg.sender)]:
                                                                revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[390 len 26] >> 48, 0
                                                            if balanceOf[address(msg.sender)] < cd[36] * totalFees / 100:
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] -= cd[36] * totalFees / 100
                                                            if balanceOf[this.address] > !(cd[36] * totalFees / 100):
                                                                revert with 0, 17
                                                            if balanceOf[this.address] + (cd[36] * totalFees / 100) < balanceOf[this.address]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            balanceOf[address(this.address)] = balanceOf[this.address] + (cd[36] * totalFees / 100)
                                                            emit Transfer((cd[36] * totalFees / 100), msg.sender, this.address);
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not address(cd[4]):
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            if cd[36] - (cd[36] * totalFees / 100) > balanceOf[address(msg.sender)]:
                                                                revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[486 len 26] >> 48, 0
                                                            if balanceOf[address(msg.sender)] < cd[36] - (cd[36] * totalFees / 100):
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - cd[36] + (cd[36] * totalFees / 100)
                                                            if balanceOf[address(cd[4])] > !(cd[36] - (cd[36] * totalFees / 100)):
                                                                revert with 0, 17
                                                            if balanceOf[address(cd[4])] + cd[36] - (cd[36] * totalFees / 100) < balanceOf[address(cd[4])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            balanceOf[address(cd[4])] = balanceOf[address(cd[4])] + cd[36] - (cd[36] * totalFees / 100)
                                                            emit Transfer((cd[36] - (cd[36] * totalFees / 100)), msg.sender, address(cd[4]));
                                                        else:
                                                            if cd[36] and 1 > -1 / cd[36]:
                                                                revert with 0, 17
                                                            if not cd[36]:
                                                                revert with 0, 18
                                                            if cd[36] / cd[36] != 1:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if cd[36] * totalFees / 100 > !(cd[36] / 100):
                                                                revert with 0, 17
                                                            if (cd[36] * totalFees / 100) + (cd[36] / 100) > cd[36]:
                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                            if cd[36] < (cd[36] * totalFees / 100) + (cd[36] / 100):
                                                                revert with 0, 17
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not this.address:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            if (cd[36] * totalFees / 100) + (cd[36] / 100) > balanceOf[address(msg.sender)]:
                                                                revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[390 len 26] >> 48, 0
                                                            if balanceOf[address(msg.sender)] < (cd[36] * totalFees / 100) + (cd[36] / 100):
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - (cd[36] * totalFees / 100) - (cd[36] / 100)
                                                            if balanceOf[this.address] > !((cd[36] * totalFees / 100) + (cd[36] / 100)):
                                                                revert with 0, 17
                                                            if balanceOf[this.address] + (cd[36] * totalFees / 100) + (cd[36] / 100) < balanceOf[this.address]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            balanceOf[address(this.address)] = balanceOf[this.address] + (cd[36] * totalFees / 100) + (cd[36] / 100)
                                                            emit Transfer(((cd[36] * totalFees / 100) + (cd[36] / 100)), msg.sender, this.address);
                                                            if not msg.sender:
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not address(cd[4]):
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            if cd[36] - (cd[36] * totalFees / 100) - (cd[36] / 100) > balanceOf[address(msg.sender)]:
                                                                revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[486 len 26] >> 48, 0
                                                            if balanceOf[address(msg.sender)] < cd[36] - (cd[36] * totalFees / 100) - (cd[36] / 100):
                                                                revert with 0, 17
                                                            balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - cd[36] + (cd[36] * totalFees / 100) + (cd[36] / 100)
                                                            if balanceOf[address(cd[4])] > !(cd[36] - (cd[36] * totalFees / 100) - (cd[36] / 100)):
                                                                revert with 0, 17
                                                            if balanceOf[address(cd[4])] + cd[36] - (cd[36] * totalFees / 100) - (cd[36] / 100) < balanceOf[address(cd[4])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            balanceOf[address(cd[4])] = balanceOf[address(cd[4])] + cd[36] - (cd[36] * totalFees / 100) - (cd[36] / 100)
                                                            emit Transfer((cd[36] - (cd[36] * totalFees / 100) - (cd[36] / 100)), msg.sender, address(cd[4]));
                                    require ext_code.size(dividendTrackerAddress)
                                    call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args msg.sender, balanceOf[address(msg.sender)]
                                    require ext_code.size(dividendTrackerAddress)
                                    call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args address(cd[4]), balanceOf[address(cd[4])]
                                    if not stor7:
                                        call dividendTrackerAddress.process(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args gasForProcessing
                                        if ext_call.success:
                                            require return_data.size >= 96
                                            emit ProcessedDividendTracker(ext_call.return_data[0], ext_call.return_data[32], ext_call.return_data[64], gasForProcessing, 1, tx.origin);
                                else:
                                    stor7 = 1
                                    if balanceOf[this.address]:
                                        if balanceOf[this.address] and stor15 > -1 / balanceOf[this.address]:
                                            revert with 0, 17
                                        if not balanceOf[this.address]:
                                            revert with 0, 18
                                        if balanceOf[this.address] * stor15 / balanceOf[this.address] != stor15:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        mem[128] = 26
                                        mem[160] = 'SafeMath: division by zero'
                                        if not totalFees:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        mem[196] = this.address
                                        staticcall sub_4d7effddAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[192] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(return_data.size) + 192] = 3
                                        mem[ceil32(return_data.size) + 224] = this.address
                                        staticcall uniswapV2RouterAddress.WETH() with:
                                                gas gas_remaining wei
                                        mem[ceil32(return_data.size) + 320] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = (2 * ceil32(return_data.size)) + 320
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                        mem[ceil32(return_data.size) + 256] = ext_call.return_data[12 len 20]
                                        mem[ceil32(return_data.size) + 288] = sub_4d7effddAddress
                                        if not this.address:
                                            mem[(2 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[(2 * ceil32(return_data.size)) + 324] = 32
                                            mem[(2 * ceil32(return_data.size)) + 356] = 36
                                            mem[(2 * ceil32(return_data.size)) + 388] = 'ERC20: approve from the zero add'
                                            mem[(2 * ceil32(return_data.size)) + 420] = 0x7265737300000000000000000000000000000000000000000000000000000000
                                            revert with memory
                                              from (2 * ceil32(return_data.size)) + 320
                                               len ceil32(return_data.size) + 132
                                        if not uniswapV2RouterAddress:
                                            mem[(2 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[(2 * ceil32(return_data.size)) + 324] = 32
                                            mem[(2 * ceil32(return_data.size)) + 356] = 34
                                            mem[(2 * ceil32(return_data.size)) + 388] = 'ERC20: approve to the zero addre'
                                            mem[(2 * ceil32(return_data.size)) + 420] = 0x7373000000000000000000000000000000000000000000000000000000000000
                                            revert with memory
                                              from (2 * ceil32(return_data.size)) + 320
                                               len ceil32(return_data.size) + 132
                                        mem[0] = uniswapV2RouterAddress
                                        mem[32] = sha3(address(this.address), 1)
                                        allowance[address(this.address)][stor6].field_0 = balanceOf[this.address] * stor15 / totalFees
                                        mem[(2 * ceil32(return_data.size)) + 320] = balanceOf[this.address] * stor15 / totalFees
                                        emit Approval(mem[(2 * ceil32(return_data.size)) + 320 len ceil32(return_data.size) + 32], this.address, uniswapV2RouterAddress);
                                        mem[(2 * ceil32(return_data.size)) + 320] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                        mem[(2 * ceil32(return_data.size)) + 324] = balanceOf[this.address] * stor15 / totalFees
                                        mem[(2 * ceil32(return_data.size)) + 356] = 0
                                        mem[(2 * ceil32(return_data.size)) + 388] = 160
                                        mem[(2 * ceil32(return_data.size)) + 484] = 3
                                        idx = 0
                                        s = (2 * ceil32(return_data.size)) + 516
                                        t = ceil32(return_data.size) + 224
                                        while idx < mem[ceil32(return_data.size) + 192]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(2 * ceil32(return_data.size)) + 420] = this.address
                                        mem[(2 * ceil32(return_data.size)) + 452] = block.timestamp
                                        require ext_code.size(uniswapV2RouterAddress)
                                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 608]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[mem[64] + 4] = this.address
                                        staticcall sub_4d7effddAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[mem[64]] = ext_call.return_data[0]
                                        _21386 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _21398 = mem[_21386]
                                        _21411 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_21411] = 30
                                        mem[_21411 + 32] = 'SafeMath: subtraction overflow'
                                        if ext_call.return_data[0] > _21398:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if _21398 < ext_call.return_data[0]:
                                            revert with 0, 17
                                        mem[mem[64] + 4] = stor17
                                        mem[mem[64] + 36] = _21398 - ext_call.return_data[0]
                                        call sub_4d7effddAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args stor17, _21398 - ext_call.return_data[0]
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _21441 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_21441] == bool(mem[_21441])
                                        if not balanceOf[this.address]:
                                            _21451 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_21451] = 26
                                            mem[_21451 + 32] = 'SafeMath: division by zero'
                                            if not totalFees:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            _21494 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_21494] = 26
                                            mem[_21494 + 32] = 'SafeMath: division by zero'
                                            _21515 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_21515] = 30
                                            mem[_21515 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 / totalFees / 2 > 0 / totalFees:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if 0 / totalFees < 0 / totalFees / 2:
                                                revert with 0, 17
                                            _21546 = mem[64]
                                            mem[mem[64]] = 2
                                            mem[64] = mem[64] + 96
                                            mem[_21546 + 32 len 64] = call.data[calldata.size len 64]
                                            if 0 >= mem[_21546]:
                                                revert with 0, 50
                                            mem[_21546 + 32] = this.address
                                            staticcall uniswapV2RouterAddress.WETH() with:
                                                    gas gas_remaining wei
                                            mem[_21546 + 96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[64] = _21546 + ceil32(return_data.size) + 96
                                            require return_data.size >= 32
                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                            if 1 >= mem[_21546]:
                                                revert with 0, 50
                                            mem[_21546 + 64] = ext_call.return_data[12 len 20]
                                            if not this.address:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not uniswapV2RouterAddress:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            mem[0] = uniswapV2RouterAddress
                                            mem[32] = sha3(address(this.address), 1)
                                            allowance[address(this.address)][stor6].field_0 = 0 / totalFees / 2
                                            allowance[address(this.address)][stor6].field_255 = 0
                                            emit Approval((0 / totalFees / 2), this.address, uniswapV2RouterAddress);
                                            mem[_21546 + ceil32(return_data.size) + 96] = 0x791ac94700000000000000000000000000000000000000000000000000000000
                                            mem[_21546 + ceil32(return_data.size) + 100] = 0 / totalFees / 2
                                            mem[_21546 + ceil32(return_data.size) + 132] = 0
                                            mem[_21546 + ceil32(return_data.size) + 164] = 160
                                            mem[_21546 + ceil32(return_data.size) + 260] = mem[_21546]
                                            idx = 0
                                            s = _21546 + ceil32(return_data.size) + 292
                                            t = _21546 + 32
                                            while idx < mem[_21546]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            require ext_code.size(uniswapV2RouterAddress)
                                            call uniswapV2RouterAddress.swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                 gas gas_remaining wei
                                                args Mask(255, 1, 0 / totalFees), 0, 160, address(this.address), block.timestamp, mem[_21546 + ceil32(return_data.size) + 260 len (32 * mem[_21546]) + 32]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[_21546 + ceil32(return_data.size) + 96] = 30
                                            mem[_21546 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if eth.balance(this.address) < eth.balance(this.address):
                                                revert with 0, 17
                                            if not this.address:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not uniswapV2RouterAddress:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(this.address)][stor6].field_0 = (0 / totalFees) - (0 / totalFees / 2)
                                            emit Approval(((0 / totalFees) - (0 / totalFees / 2)), this.address, uniswapV2RouterAddress);
                                            mem[_21546 + ceil32(return_data.size) + 228] = 0
                                            mem[_21546 + ceil32(return_data.size) + 260] = 0
                                            mem[_21546 + ceil32(return_data.size) + 292] = stor17
                                            mem[_21546 + ceil32(return_data.size) + 324] = block.timestamp
                                            call uniswapV2RouterAddress.addLiquidityETH(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                 gas gas_remaining wei
                                                args this.address, (0 / totalFees) - (0 / totalFees / 2), 0, 0, stor17, block.timestamp
                                            mem[_21546 + ceil32(return_data.size) + 160 len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 96
                                            emit SwapAndLiquify(Mask(255, 1, 0 / totalFees), 0, (0 / totalFees) - (0 / totalFees / 2));
                                            mem[_21546 + (2 * ceil32(return_data.size)) + 160] = 3
                                            mem[_21546 + (2 * ceil32(return_data.size)) + 192] = this.address
                                            staticcall uniswapV2RouterAddress.WETH() with:
                                                    gas gas_remaining wei
                                            mem[_21546 + (2 * ceil32(return_data.size)) + 288] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                            mem[_21546 + (2 * ceil32(return_data.size)) + 224] = ext_call.return_data[12 len 20]
                                            mem[_21546 + (2 * ceil32(return_data.size)) + 256] = sub_4d7effddAddress
                                            if not this.address:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not uniswapV2RouterAddress:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(this.address)][stor6].field_0 = balanceOf[this.address]
                                            emit Approval(balanceOf[this.address], this.address, uniswapV2RouterAddress);
                                            mem[_21546 + (4 * ceil32(return_data.size)) + 288] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                            mem[_21546 + (4 * ceil32(return_data.size)) + 292] = balanceOf[this.address]
                                            mem[_21546 + (4 * ceil32(return_data.size)) + 324] = 0
                                            mem[_21546 + (4 * ceil32(return_data.size)) + 356] = 160
                                            mem[_21546 + (4 * ceil32(return_data.size)) + 452] = 3
                                            idx = 0
                                            s = _21546 + (4 * ceil32(return_data.size)) + 484
                                            t = _21546 + (2 * ceil32(return_data.size)) + 192
                                            while idx < mem[_21546 + (2 * ceil32(return_data.size)) + 160]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_21546 + (4 * ceil32(return_data.size)) + 388] = this.address
                                            mem[_21546 + (4 * ceil32(return_data.size)) + 420] = block.timestamp
                                            require ext_code.size(uniswapV2RouterAddress)
                                            call uniswapV2RouterAddress.swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                 gas gas_remaining wei
                                                args balanceOf[this.address], 0, 160, address(this.address), block.timestamp, mem[_21546 + (4 * ceil32(return_data.size)) + 452 len (32 * mem[_21546 + (2 * ceil32(return_data.size)) + 160]) + 32]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            staticcall sub_4d7effddAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            require return_data.size >= 32
                                            call sub_4d7effddAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args dividendTrackerAddress, ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                            if ext_call.return_data[0]:
                                                require ext_code.size(dividendTrackerAddress)
                                                call dividendTrackerAddress.distributeDogeDividends(uint256 arg1) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                emit SendDividends(balanceOf[this.address], ext_call.return_data[0]);
                                            stor7 = 0
                                            if stor19[address(msg.sender)]:
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not address(cd[4]):
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                if cd[36] > balanceOf[address(msg.sender)]:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_21546 + (7 * ceil32(return_data.size)) + 358 len 26] >> 48,
                                                                0
                                                if balanceOf[address(msg.sender)] < cd[36]:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= cd[36]
                                                if balanceOf[address(cd[4])] > !cd[36]:
                                                    revert with 0, 17
                                                if balanceOf[address(cd[4])] + cd[36] < balanceOf[address(cd[4])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(cd[4])] += cd[36]
                                                emit Transfer(cd[36], msg.sender, address(cd[4]));
                                            else:
                                                if stor19[address(cd[4])]:
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not address(cd[4]):
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    if cd[36] > balanceOf[address(msg.sender)]:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_21546 + (7 * ceil32(return_data.size)) + 358 len 26] >> 48,
                                                                    0
                                                    if balanceOf[address(msg.sender)] < cd[36]:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= cd[36]
                                                    if balanceOf[address(cd[4])] > !cd[36]:
                                                        revert with 0, 17
                                                    if balanceOf[address(cd[4])] + cd[36] < balanceOf[address(cd[4])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(cd[4])] += cd[36]
                                                    emit Transfer(cd[36], msg.sender, address(cd[4]));
                                                else:
                                                    if stor7:
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not address(cd[4]):
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        if cd[36] > balanceOf[address(msg.sender)]:
                                                            revert with 0, 
                                                                        32,
                                                                        38,
                                                                        0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_21546 + (7 * ceil32(return_data.size)) + 358 len 26] >> 48,
                                                                        0
                                                        if balanceOf[address(msg.sender)] < cd[36]:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] -= cd[36]
                                                        if balanceOf[address(cd[4])] > !cd[36]:
                                                            revert with 0, 17
                                                        if balanceOf[address(cd[4])] + cd[36] < balanceOf[address(cd[4])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(cd[4])] += cd[36]
                                                        emit Transfer(cd[36], msg.sender, address(cd[4]));
                                                    else:
                                                        if not cd[36]:
                                                            if not stor20[address(cd[4])]:
                                                                if 0 > cd[36]:
                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                if cd[36] < 0:
                                                                    revert with 0, 17
                                                                if not msg.sender:
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not this.address:
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                if 0 > balanceOf[address(msg.sender)]:
                                                                    revert with 0, 
                                                                                32,
                                                                                38,
                                                                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_21546 + (7 * ceil32(return_data.size)) + 486 len 26] >> 48,
                                                                                0
                                                                if balanceOf[address(msg.sender)] < 0:
                                                                    revert with 0, 17
                                                                if balanceOf[this.address] > -1:
                                                                    revert with 0, 17
                                                                if balanceOf[this.address] < balanceOf[this.address]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                balanceOf[address(this.address)] = balanceOf[this.address]
                                                                emit Transfer(0, msg.sender, this.address);
                                                                if not msg.sender:
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not address(cd[4]):
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                if cd[36] > balanceOf[address(msg.sender)]:
                                                                    revert with 0, 
                                                                                32,
                                                                                38,
                                                                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_21546 + (7 * ceil32(return_data.size)) + 582 len 26] >> 48,
                                                                                0
                                                                if balanceOf[address(msg.sender)] < cd[36]:
                                                                    revert with 0, 17
                                                                balanceOf[address(msg.sender)] -= cd[36]
                                                                if balanceOf[address(cd[4])] > !cd[36]:
                                                                    revert with 0, 17
                                                                if balanceOf[address(cd[4])] + cd[36] < balanceOf[address(cd[4])]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                balanceOf[address(cd[4])] += cd[36]
                                                                emit Transfer(cd[36], msg.sender, address(cd[4]));
                                                            else:
                                                                if not cd[36]:
                                                                    if 0 > cd[36]:
                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                    if cd[36] < 0:
                                                                        revert with 0, 17
                                                                    if not msg.sender:
                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                    if not this.address:
                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                    if 0 > balanceOf[address(msg.sender)]:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    38,
                                                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_21546 + (7 * ceil32(return_data.size)) + 550 len 26] >> 48,
                                                                                    0
                                                                    if balanceOf[address(msg.sender)] < 0:
                                                                        revert with 0, 17
                                                                    if balanceOf[this.address] > -1:
                                                                        revert with 0, 17
                                                                    if balanceOf[this.address] < balanceOf[this.address]:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    balanceOf[address(this.address)] = balanceOf[this.address]
                                                                    emit Transfer(0, msg.sender, this.address);
                                                                    if not msg.sender:
                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                    if not address(cd[4]):
                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                    if cd[36] > balanceOf[address(msg.sender)]:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    38,
                                                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_21546 + (7 * ceil32(return_data.size)) + 646 len 26] >> 48,
                                                                                    0
                                                                    if balanceOf[address(msg.sender)] < cd[36]:
                                                                        revert with 0, 17
                                                                    balanceOf[address(msg.sender)] -= cd[36]
                                                                    if balanceOf[address(cd[4])] > !cd[36]:
                                                                        revert with 0, 17
                                                                    if balanceOf[address(cd[4])] + cd[36] < balanceOf[address(cd[4])]:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    balanceOf[address(cd[4])] += cd[36]
                                                                    emit Transfer(cd[36], msg.sender, address(cd[4]));
                                                                else:
                                                                    if cd[36] and 1 > -1 / cd[36]:
                                                                        revert with 0, 17
                                                                    if not cd[36]:
                                                                        revert with 0, 18
                                                                    if cd[36] / cd[36] != 1:
                                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                                    if 0 > !(cd[36] / 100):
                                                                        revert with 0, 17
                                                                    if cd[36] / 100 > cd[36]:
                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                    if cd[36] < cd[36] / 100:
                                                                        revert with 0, 17
                                                                    if not msg.sender:
                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                    if not this.address:
                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                    if cd[36] / 100 > balanceOf[address(msg.sender)]:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    38,
                                                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_21546 + (7 * ceil32(return_data.size)) + 550 len 26] >> 48,
                                                                                    0
                                                                    if balanceOf[address(msg.sender)] < cd[36] / 100:
                                                                        revert with 0, 17
                                                                    balanceOf[address(msg.sender)] -= cd[36] / 100
                                                                    if balanceOf[this.address] > !(cd[36] / 100):
                                                                        revert with 0, 17
                                                                    if balanceOf[this.address] + (cd[36] / 100) < balanceOf[this.address]:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    balanceOf[address(this.address)] = balanceOf[this.address] + (cd[36] / 100)
                                                                    emit Transfer((cd[36] / 100), msg.sender, this.address);
                                                                    if not msg.sender:
                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                    if not address(cd[4]):
                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                    if cd[36] - (cd[36] / 100) > balanceOf[address(msg.sender)]:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    38,
                                                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_21546 + (7 * ceil32(return_data.size)) + 646 len 26] >> 48,
                                                                                    0
                                                                    if balanceOf[address(msg.sender)] < cd[36] - (cd[36] / 100):
                                                                        revert with 0, 17
                                                                    balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - cd[36] + (cd[36] / 100)
                                                                    if balanceOf[address(cd[4])] > !(cd[36] - (cd[36] / 100)):
                                                                        revert with 0, 17
                                                                    if balanceOf[address(cd[4])] + cd[36] - (cd[36] / 100) < balanceOf[address(cd[4])]:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    balanceOf[address(cd[4])] = balanceOf[address(cd[4])] + cd[36] - (cd[36] / 100)
                                                                    emit Transfer((cd[36] - (cd[36] / 100)), msg.sender, address(cd[4]));
                                                        else:
                                                            if cd[36] and totalFees > -1 / cd[36]:
                                                                revert with 0, 17
                                                            if not cd[36]:
                                                                revert with 0, 18
                                                            if cd[36] * totalFees / cd[36] != totalFees:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if not stor20[address(cd[4])]:
                                                                if cd[36] * totalFees / 100 > cd[36]:
                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                if cd[36] < cd[36] * totalFees / 100:
                                                                    revert with 0, 17
                                                                if not msg.sender:
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not this.address:
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                if cd[36] * totalFees / 100 > balanceOf[address(msg.sender)]:
                                                                    revert with 0, 
                                                                                32,
                                                                                38,
                                                                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_21546 + (7 * ceil32(return_data.size)) + 486 len 26] >> 48,
                                                                                0
                                                                if balanceOf[address(msg.sender)] < cd[36] * totalFees / 100:
                                                                    revert with 0, 17
                                                                balanceOf[address(msg.sender)] -= cd[36] * totalFees / 100
                                                                if balanceOf[this.address] > !(cd[36] * totalFees / 100):
                                                                    revert with 0, 17
                                                                if balanceOf[this.address] + (cd[36] * totalFees / 100) < balanceOf[this.address]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                balanceOf[address(this.address)] = balanceOf[this.address] + (cd[36] * totalFees / 100)
                                                                emit Transfer((cd[36] * totalFees / 100), msg.sender, this.address);
                                                                if not msg.sender:
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not address(cd[4]):
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                if cd[36] - (cd[36] * totalFees / 100) > balanceOf[address(msg.sender)]:
                                                                    revert with 0, 
                                                                                32,
                                                                                38,
                                                                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_21546 + (7 * ceil32(return_data.size)) + 582 len 26] >> 48,
                                                                                0
                                                                if balanceOf[address(msg.sender)] < cd[36] - (cd[36] * totalFees / 100):
                                                                    revert with 0, 17
                                                                balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - cd[36] + (cd[36] * totalFees / 100)
                                                                if balanceOf[address(cd[4])] > !(cd[36] - (cd[36] * totalFees / 100)):
                                                                    revert with 0, 17
                                                                if balanceOf[address(cd[4])] + cd[36] - (cd[36] * totalFees / 100) < balanceOf[address(cd[4])]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                balanceOf[address(cd[4])] = balanceOf[address(cd[4])] + cd[36] - (cd[36] * totalFees / 100)
                                                                emit Transfer((cd[36] - (cd[36] * totalFees / 100)), msg.sender, address(cd[4]));
                                                            else:
                                                                if not cd[36]:
                                                                    if cd[36] * totalFees / 100 > -1:
                                                                        revert with 0, 17
                                                                    if cd[36] * totalFees / 100 > cd[36]:
                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                    if cd[36] < cd[36] * totalFees / 100:
                                                                        revert with 0, 17
                                                                    if not msg.sender:
                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                    if not this.address:
                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                    if cd[36] * totalFees / 100 > balanceOf[address(msg.sender)]:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    38,
                                                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_21546 + (7 * ceil32(return_data.size)) + 550 len 26] >> 48,
                                                                                    0
                                                                    if balanceOf[address(msg.sender)] < cd[36] * totalFees / 100:
                                                                        revert with 0, 17
                                                                    balanceOf[address(msg.sender)] -= cd[36] * totalFees / 100
                                                                    if balanceOf[this.address] > !(cd[36] * totalFees / 100):
                                                                        revert with 0, 17
                                                                    if balanceOf[this.address] + (cd[36] * totalFees / 100) < balanceOf[this.address]:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    balanceOf[address(this.address)] = balanceOf[this.address] + (cd[36] * totalFees / 100)
                                                                    emit Transfer((cd[36] * totalFees / 100), msg.sender, this.address);
                                                                    if not msg.sender:
                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                    if not address(cd[4]):
                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                    if cd[36] - (cd[36] * totalFees / 100) > balanceOf[address(msg.sender)]:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    38,
                                                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_21546 + (7 * ceil32(return_data.size)) + 646 len 26] >> 48,
                                                                                    0
                                                                    if balanceOf[address(msg.sender)] < cd[36] - (cd[36] * totalFees / 100):
                                                                        revert with 0, 17
                                                                    balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - cd[36] + (cd[36] * totalFees / 100)
                                                                    if balanceOf[address(cd[4])] > !(cd[36] - (cd[36] * totalFees / 100)):
                                                                        revert with 0, 17
                                                                    if balanceOf[address(cd[4])] + cd[36] - (cd[36] * totalFees / 100) < balanceOf[address(cd[4])]:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    balanceOf[address(cd[4])] = balanceOf[address(cd[4])] + cd[36] - (cd[36] * totalFees / 100)
                                                                    emit Transfer((cd[36] - (cd[36] * totalFees / 100)), msg.sender, address(cd[4]));
                                                                else:
                                                                    if cd[36] and 1 > -1 / cd[36]:
                                                                        revert with 0, 17
                                                                    if not cd[36]:
                                                                        revert with 0, 18
                                                                    if cd[36] / cd[36] != 1:
                                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                                    if cd[36] * totalFees / 100 > !(cd[36] / 100):
                                                                        revert with 0, 17
                                                                    if (cd[36] * totalFees / 100) + (cd[36] / 100) > cd[36]:
                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                    if cd[36] < (cd[36] * totalFees / 100) + (cd[36] / 100):
                                                                        revert with 0, 17
                                                                    if not msg.sender:
                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                    if not this.address:
                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                    if (cd[36] * totalFees / 100) + (cd[36] / 100) > balanceOf[address(msg.sender)]:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    38,
                                                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_21546 + (7 * ceil32(return_data.size)) + 550 len 26] >> 48,
                                                                                    0
                                                                    if balanceOf[address(msg.sender)] < (cd[36] * totalFees / 100) + (cd[36] / 100):
                                                                        revert with 0, 17
                                                                    balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - (cd[36] * totalFees / 100) - (cd[36] / 100)
                                                                    if balanceOf[this.address] > !((cd[36] * totalFees / 100) + (cd[36] / 100)):
                                                                        revert with 0, 17
                                                                    if balanceOf[this.address] + (cd[36] * totalFees / 100) + (cd[36] / 100) < balanceOf[this.address]:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    balanceOf[address(this.address)] = balanceOf[this.address] + (cd[36] * totalFees / 100) + (cd[36] / 100)
                                                                    emit Transfer(((cd[36] * totalFees / 100) + (cd[36] / 100)), msg.sender, this.address);
                                                                    if not msg.sender:
                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                    if not address(cd[4]):
                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                    if cd[36] - (cd[36] * totalFees / 100) - (cd[36] / 100) > balanceOf[address(msg.sender)]:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    38,
                                                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_21546 + (7 * ceil32(return_data.size)) + 646 len 26] >> 48,
                                                                                    0
                                                                    if balanceOf[address(msg.sender)] < cd[36] - (cd[36] * totalFees / 100) - (cd[36] / 100):
                                                                        revert with 0, 17
                                                                    balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - cd[36] + (cd[36] * totalFees / 100) + (cd[36] / 100)
                                                                    if balanceOf[address(cd[4])] > !(cd[36] - (cd[36] * totalFees / 100) - (cd[36] / 100)):
                                                                        revert with 0, 17
                                                                    if balanceOf[address(cd[4])] + cd[36] - (cd[36] * totalFees / 100) - (cd[36] / 100) < balanceOf[address(cd[4])]:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    balanceOf[address(cd[4])] = balanceOf[address(cd[4])] + cd[36] - (cd[36] * totalFees / 100) - (cd[36] / 100)
                                                                    emit Transfer((cd[36] - (cd[36] * totalFees / 100) - (cd[36] / 100)), msg.sender, address(cd[4]));
                                            require ext_code.size(dividendTrackerAddress)
                                            call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args msg.sender, balanceOf[address(msg.sender)]
                                            require ext_code.size(dividendTrackerAddress)
                                            call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args address(cd[4]), balanceOf[address(cd[4])]
                                            if not stor7:
                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                     gas gas_remaining wei
                                                    args gasForProcessing
                                                if ext_call.success:
                                                    require return_data.size >= 96
                                                    emit ProcessedDividendTracker(ext_call.return_data[0], ext_call.return_data[32], ext_call.return_data[64], gasForProcessing, 1, tx.origin);
                                        else:
                                            if balanceOf[this.address] and stor14 > -1 / balanceOf[this.address]:
                                                revert with 0, 17
                                            if not balanceOf[this.address]:
                                                revert with 0, 18
                                            if balanceOf[this.address] * stor14 / balanceOf[this.address] != stor14:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _21475 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_21475] = 26
                                            mem[_21475 + 32] = 'SafeMath: division by zero'
                                            if not totalFees:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            _21511 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_21511] = 26
                                            mem[_21511 + 32] = 'SafeMath: division by zero'
                                            _21531 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_21531] = 30
                                            mem[_21531 + 32] = 'SafeMath: subtraction overflow'
                                            if balanceOf[this.address] * stor14 / totalFees / 2 > balanceOf[this.address] * stor14 / totalFees:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if balanceOf[this.address] * stor14 / totalFees < balanceOf[this.address] * stor14 / totalFees / 2:
                                                revert with 0, 17
                                            _21587 = mem[64]
                                            mem[mem[64]] = 2
                                            mem[64] = mem[64] + 96
                                            mem[_21587 + 32 len 64] = call.data[calldata.size len 64]
                                            if 0 >= mem[_21587]:
                                                revert with 0, 50
                                            mem[_21587 + 32] = this.address
                                            staticcall uniswapV2RouterAddress.WETH() with:
                                                    gas gas_remaining wei
                                            mem[_21587 + 96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[64] = _21587 + ceil32(return_data.size) + 96
                                            require return_data.size >= 32
                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                            if 1 >= mem[_21587]:
                                                revert with 0, 50
                                            mem[_21587 + 64] = ext_call.return_data[12 len 20]
                                            if not this.address:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not uniswapV2RouterAddress:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            mem[0] = uniswapV2RouterAddress
                                            mem[32] = sha3(address(this.address), 1)
                                            allowance[address(this.address)][stor6].field_0 = balanceOf[this.address] * stor14 / totalFees / 2
                                            allowance[address(this.address)][stor6].field_255 = 0
                                            emit Approval((balanceOf[this.address] * stor14 / totalFees / 2), this.address, uniswapV2RouterAddress);
                                            mem[_21587 + ceil32(return_data.size) + 96] = 0x791ac94700000000000000000000000000000000000000000000000000000000
                                            mem[_21587 + ceil32(return_data.size) + 100] = balanceOf[this.address] * stor14 / totalFees / 2
                                            mem[_21587 + ceil32(return_data.size) + 132] = 0
                                            mem[_21587 + ceil32(return_data.size) + 164] = 160
                                            mem[_21587 + ceil32(return_data.size) + 260] = mem[_21587]
                                            idx = 0
                                            s = _21587 + ceil32(return_data.size) + 292
                                            t = _21587 + 32
                                            while idx < mem[_21587]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            require ext_code.size(uniswapV2RouterAddress)
                                            call uniswapV2RouterAddress.swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                 gas gas_remaining wei
                                                args Mask(255, 1, balanceOf[this.address] * stor14 / totalFees), 0, 160, address(this.address), block.timestamp, mem[_21587 + ceil32(return_data.size) + 260 len (32 * mem[_21587]) + 32]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[_21587 + ceil32(return_data.size) + 96] = 30
                                            mem[_21587 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if eth.balance(this.address) < eth.balance(this.address):
                                                revert with 0, 17
                                            if not this.address:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not uniswapV2RouterAddress:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(this.address)][stor6].field_0 = (balanceOf[this.address] * stor14 / totalFees) - (balanceOf[this.address] * stor14 / totalFees / 2)
                                            emit Approval(((balanceOf[this.address] * stor14 / totalFees) - (balanceOf[this.address] * stor14 / totalFees / 2)), this.address, uniswapV2RouterAddress);
                                            mem[_21587 + ceil32(return_data.size) + 228] = 0
                                            mem[_21587 + ceil32(return_data.size) + 260] = 0
                                            mem[_21587 + ceil32(return_data.size) + 292] = stor17
                                            mem[_21587 + ceil32(return_data.size) + 324] = block.timestamp
                                            call uniswapV2RouterAddress.addLiquidityETH(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                 gas gas_remaining wei
                                                args this.address, (balanceOf[this.address] * stor14 / totalFees) - (balanceOf[this.address] * stor14 / totalFees / 2), 0, 0, stor17, block.timestamp
                                            mem[_21587 + ceil32(return_data.size) + 160 len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 96
                                            emit SwapAndLiquify(Mask(255, 1, balanceOf[this.address] * stor14 / totalFees), 0, (balanceOf[this.address] * stor14 / totalFees) - (balanceOf[this.address] * stor14 / totalFees / 2));
                                            mem[_21587 + (2 * ceil32(return_data.size)) + 160] = 3
                                            mem[_21587 + (2 * ceil32(return_data.size)) + 192] = this.address
                                            staticcall uniswapV2RouterAddress.WETH() with:
                                                    gas gas_remaining wei
                                            mem[_21587 + (2 * ceil32(return_data.size)) + 288] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                            mem[_21587 + (2 * ceil32(return_data.size)) + 224] = ext_call.return_data[12 len 20]
                                            mem[_21587 + (2 * ceil32(return_data.size)) + 256] = sub_4d7effddAddress
                                            if not this.address:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not uniswapV2RouterAddress:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(this.address)][stor6].field_0 = balanceOf[this.address]
                                            emit Approval(balanceOf[this.address], this.address, uniswapV2RouterAddress);
                                            mem[_21587 + (4 * ceil32(return_data.size)) + 288] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                            mem[_21587 + (4 * ceil32(return_data.size)) + 292] = balanceOf[this.address]
                                            mem[_21587 + (4 * ceil32(return_data.size)) + 324] = 0
                                            mem[_21587 + (4 * ceil32(return_data.size)) + 356] = 160
                                            mem[_21587 + (4 * ceil32(return_data.size)) + 452] = 3
                                            idx = 0
                                            s = _21587 + (4 * ceil32(return_data.size)) + 484
                                            t = _21587 + (2 * ceil32(return_data.size)) + 192
                                            while idx < mem[_21587 + (2 * ceil32(return_data.size)) + 160]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_21587 + (4 * ceil32(return_data.size)) + 388] = this.address
                                            mem[_21587 + (4 * ceil32(return_data.size)) + 420] = block.timestamp
                                            require ext_code.size(uniswapV2RouterAddress)
                                            call uniswapV2RouterAddress.swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                 gas gas_remaining wei
                                                args balanceOf[this.address], 0, 160, address(this.address), block.timestamp, mem[_21587 + (4 * ceil32(return_data.size)) + 452 len (32 * mem[_21587 + (2 * ceil32(return_data.size)) + 160]) + 32]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            staticcall sub_4d7effddAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            require return_data.size >= 32
                                            mem[_21587 + (4 * ceil32(return_data.size)) + 292] = dividendTrackerAddress
                                            mem[_21587 + (4 * ceil32(return_data.size)) + 324] = ext_call.return_data[0]
                                            call sub_4d7effddAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args mem[_21587 + (4 * ceil32(return_data.size)) + 292 len (7 * ceil32(return_data.size)) + 64]
                                            mem[_21587 + (4 * ceil32(return_data.size)) + 288] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                            if ext_call.return_data[0]:
                                                require ext_code.size(dividendTrackerAddress)
                                                call dividendTrackerAddress.distributeDogeDividends(uint256 arg1) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                emit SendDividends(balanceOf[this.address], ext_call.return_data[0]);
                                            stor7 = 0
                                            if stor19[address(msg.sender)]:
                                                if not msg.sender:
                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 288] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 292] = 32
                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 324] = 37
                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 356] = 'ERC20: transfer from the zero ad'
                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 388] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                    revert with memory
                                                      from _21587 + (8 * ceil32(return_data.size)) + 288
                                                       len (13 * ceil32(return_data.size)) + 132
                                                if not address(cd[4]):
                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 288] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 292] = 32
                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 324] = 35
                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 356] = 'ERC20: transfer to the zero addr'
                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 388] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                    revert with memory
                                                      from _21587 + (8 * ceil32(return_data.size)) + 288
                                                       len (13 * ceil32(return_data.size)) + 132
                                                if cd[36] > balanceOf[address(msg.sender)]:
                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 384] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 388] = 32
                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 420] = 38
                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 452 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_21587 + (8 * ceil32(return_data.size)) + 358 len 26]
                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 490] = 0
                                                    revert with memory
                                                      from _21587 + (8 * ceil32(return_data.size)) + 384
                                                       len (13 * ceil32(return_data.size)) + 132
                                                if balanceOf[address(msg.sender)] < cd[36]:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= cd[36]
                                                if balanceOf[address(cd[4])] > !cd[36]:
                                                    revert with 0, 17
                                                if balanceOf[address(cd[4])] + cd[36] < balanceOf[address(cd[4])]:
                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 384] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 388] = 32
                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 420] = 27
                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 452] = 'SafeMath: addition overflow'
                                                    revert with memory
                                                      from _21587 + (8 * ceil32(return_data.size)) + 384
                                                       len (13 * ceil32(return_data.size)) + 100
                                                balanceOf[address(cd[4])] += cd[36]
                                                emit Transfer(cd[36], msg.sender, address(cd[4]));
                                                mem[_21587 + (8 * ceil32(return_data.size)) + 388] = msg.sender
                                                mem[_21587 + (8 * ceil32(return_data.size)) + 420] = balanceOf[address(msg.sender)]
                                                require ext_code.size(dividendTrackerAddress)
                                                call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args mem[_21587 + (8 * ceil32(return_data.size)) + 388 len (13 * ceil32(return_data.size)) + 64]
                                                mem[_21587 + (8 * ceil32(return_data.size)) + 388] = address(cd[4])
                                                mem[_21587 + (8 * ceil32(return_data.size)) + 420] = balanceOf[address(cd[4])]
                                                require ext_code.size(dividendTrackerAddress)
                                                call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args mem[_21587 + (8 * ceil32(return_data.size)) + 388 len (13 * ceil32(return_data.size)) + 64]
                                                if not stor7:
                                                    call dividendTrackerAddress.process(uint256 arg1) with:
                                                         gas gas_remaining wei
                                                        args gasForProcessing
                                                    if ext_call.success:
                                                        require return_data.size >= 96
                                                        emit ProcessedDividendTracker(uint256 arg1, uint256 arg2, uint256 arg3, bool arg4, uint256 arg5, address arg6):
                                                                                      ext_call.return_data[0],
                                                                                      ext_call.return_data[32],
                                                                                      ext_call.return_data[64],
                                                                                      gasForProcessing,
                                                                                      mem[_21587 + (9 * ceil32(return_data.size)) + 512 len 5 * ceil32(return_data.size)],
                                                                                      1,
                                                                                      tx.origin,
                                            else:
                                                if stor19[address(cd[4])]:
                                                    if not msg.sender:
                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 288] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 292] = 32
                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 324] = 37
                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 356] = 'ERC20: transfer from the zero ad'
                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 388] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                        revert with memory
                                                          from _21587 + (8 * ceil32(return_data.size)) + 288
                                                           len (13 * ceil32(return_data.size)) + 132
                                                    if not address(cd[4]):
                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 288] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 292] = 32
                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 324] = 35
                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 356] = 'ERC20: transfer to the zero addr'
                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 388] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                        revert with memory
                                                          from _21587 + (8 * ceil32(return_data.size)) + 288
                                                           len (13 * ceil32(return_data.size)) + 132
                                                    if cd[36] > balanceOf[address(msg.sender)]:
                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 384] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 388] = 32
                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 420] = 38
                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 452 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_21587 + (8 * ceil32(return_data.size)) + 358 len 26]
                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 490] = 0
                                                        revert with memory
                                                          from _21587 + (8 * ceil32(return_data.size)) + 384
                                                           len (13 * ceil32(return_data.size)) + 132
                                                    if balanceOf[address(msg.sender)] < cd[36]:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= cd[36]
                                                    if balanceOf[address(cd[4])] > !cd[36]:
                                                        revert with 0, 17
                                                    if balanceOf[address(cd[4])] + cd[36] < balanceOf[address(cd[4])]:
                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 384] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 388] = 32
                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 420] = 27
                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 452] = 'SafeMath: addition overflow'
                                                        revert with memory
                                                          from _21587 + (8 * ceil32(return_data.size)) + 384
                                                           len (13 * ceil32(return_data.size)) + 100
                                                    balanceOf[address(cd[4])] += cd[36]
                                                    emit Transfer(cd[36], msg.sender, address(cd[4]));
                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 388] = msg.sender
                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 420] = balanceOf[address(msg.sender)]
                                                    require ext_code.size(dividendTrackerAddress)
                                                    call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args mem[_21587 + (8 * ceil32(return_data.size)) + 388 len (13 * ceil32(return_data.size)) + 64]
                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 388] = address(cd[4])
                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 420] = balanceOf[address(cd[4])]
                                                    require ext_code.size(dividendTrackerAddress)
                                                    call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args mem[_21587 + (8 * ceil32(return_data.size)) + 388 len (13 * ceil32(return_data.size)) + 64]
                                                    if not stor7:
                                                        call dividendTrackerAddress.process(uint256 arg1) with:
                                                             gas gas_remaining wei
                                                            args gasForProcessing
                                                        if ext_call.success:
                                                            require return_data.size >= 96
                                                            emit ProcessedDividendTracker(uint256 arg1, uint256 arg2, uint256 arg3, bool arg4, uint256 arg5, address arg6):
                                                                                          ext_call.return_data[0],
                                                                                          ext_call.return_data[32],
                                                                                          ext_call.return_data[64],
                                                                                          gasForProcessing,
                                                                                          mem[_21587 + (9 * ceil32(return_data.size)) + 512 len 5 * ceil32(return_data.size)],
                                                                                          1,
                                                                                          tx.origin,
                                                else:
                                                    if stor7:
                                                        if not msg.sender:
                                                            mem[_21587 + (8 * ceil32(return_data.size)) + 288] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_21587 + (8 * ceil32(return_data.size)) + 292] = 32
                                                            mem[_21587 + (8 * ceil32(return_data.size)) + 324] = 37
                                                            mem[_21587 + (8 * ceil32(return_data.size)) + 356] = 'ERC20: transfer from the zero ad'
                                                            mem[_21587 + (8 * ceil32(return_data.size)) + 388] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                            revert with memory
                                                              from _21587 + (8 * ceil32(return_data.size)) + 288
                                                               len (13 * ceil32(return_data.size)) + 132
                                                        if not address(cd[4]):
                                                            mem[_21587 + (8 * ceil32(return_data.size)) + 288] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_21587 + (8 * ceil32(return_data.size)) + 292] = 32
                                                            mem[_21587 + (8 * ceil32(return_data.size)) + 324] = 35
                                                            mem[_21587 + (8 * ceil32(return_data.size)) + 356] = 'ERC20: transfer to the zero addr'
                                                            mem[_21587 + (8 * ceil32(return_data.size)) + 388] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                            revert with memory
                                                              from _21587 + (8 * ceil32(return_data.size)) + 288
                                                               len (13 * ceil32(return_data.size)) + 132
                                                        if cd[36] > balanceOf[address(msg.sender)]:
                                                            mem[_21587 + (8 * ceil32(return_data.size)) + 384] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_21587 + (8 * ceil32(return_data.size)) + 388] = 32
                                                            mem[_21587 + (8 * ceil32(return_data.size)) + 420] = 38
                                                            mem[_21587 + (8 * ceil32(return_data.size)) + 452 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_21587 + (8 * ceil32(return_data.size)) + 358 len 26]
                                                            mem[_21587 + (8 * ceil32(return_data.size)) + 490] = 0
                                                            revert with memory
                                                              from _21587 + (8 * ceil32(return_data.size)) + 384
                                                               len (13 * ceil32(return_data.size)) + 132
                                                        if balanceOf[address(msg.sender)] < cd[36]:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] -= cd[36]
                                                        if balanceOf[address(cd[4])] > !cd[36]:
                                                            revert with 0, 17
                                                        if balanceOf[address(cd[4])] + cd[36] < balanceOf[address(cd[4])]:
                                                            mem[_21587 + (8 * ceil32(return_data.size)) + 384] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_21587 + (8 * ceil32(return_data.size)) + 388] = 32
                                                            mem[_21587 + (8 * ceil32(return_data.size)) + 420] = 27
                                                            mem[_21587 + (8 * ceil32(return_data.size)) + 452] = 'SafeMath: addition overflow'
                                                            revert with memory
                                                              from _21587 + (8 * ceil32(return_data.size)) + 384
                                                               len (13 * ceil32(return_data.size)) + 100
                                                        balanceOf[address(cd[4])] += cd[36]
                                                        emit Transfer(cd[36], msg.sender, address(cd[4]));
                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 388] = msg.sender
                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 420] = balanceOf[address(msg.sender)]
                                                        require ext_code.size(dividendTrackerAddress)
                                                        call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args mem[_21587 + (8 * ceil32(return_data.size)) + 388 len (13 * ceil32(return_data.size)) + 64]
                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 388] = address(cd[4])
                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 420] = balanceOf[address(cd[4])]
                                                        require ext_code.size(dividendTrackerAddress)
                                                        call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args mem[_21587 + (8 * ceil32(return_data.size)) + 388 len (13 * ceil32(return_data.size)) + 64]
                                                        if not stor7:
                                                            call dividendTrackerAddress.process(uint256 arg1) with:
                                                                 gas gas_remaining wei
                                                                args gasForProcessing
                                                            if ext_call.success:
                                                                require return_data.size >= 96
                                                                emit ProcessedDividendTracker(uint256 arg1, uint256 arg2, uint256 arg3, bool arg4, uint256 arg5, address arg6):
                                                                                              ext_call.return_data[0],
                                                                                              ext_call.return_data[32],
                                                                                              ext_call.return_data[64],
                                                                                              gasForProcessing,
                                                                                              mem[_21587 + (9 * ceil32(return_data.size)) + 512 len 5 * ceil32(return_data.size)],
                                                                                              1,
                                                                                              tx.origin,
                                                    else:
                                                        if not cd[36]:
                                                            if not stor20[address(cd[4])]:
                                                                if 0 > cd[36]:
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 420] = 32
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 452] = 30
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 484] = 'SafeMath: subtraction overflow'
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 514] = 0
                                                                    revert with memory
                                                                      from _21587 + (8 * ceil32(return_data.size)) + 416
                                                                       len (13 * ceil32(return_data.size)) + 100
                                                                if cd[36] < 0:
                                                                    revert with 0, 17
                                                                if not msg.sender:
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 420] = 32
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 452] = 37
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 484] = 'ERC20: transfer from the zero ad'
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 516] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                                    revert with memory
                                                                      from _21587 + (8 * ceil32(return_data.size)) + 416
                                                                       len (13 * ceil32(return_data.size)) + 132
                                                                if not this.address:
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 420] = 32
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 452] = 35
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 484] = 'ERC20: transfer to the zero addr'
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 516] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                                    revert with memory
                                                                      from _21587 + (8 * ceil32(return_data.size)) + 416
                                                                       len (13 * ceil32(return_data.size)) + 132
                                                                if 0 > balanceOf[address(msg.sender)]:
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 512] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 516] = 32
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 548] = 38
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 580 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_21587 + (8 * ceil32(return_data.size)) + 486 len 26]
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 618] = 0
                                                                    revert with memory
                                                                      from _21587 + (8 * ceil32(return_data.size)) + 512
                                                                       len (13 * ceil32(return_data.size)) + 132
                                                                if balanceOf[address(msg.sender)] < 0:
                                                                    revert with 0, 17
                                                                if balanceOf[this.address] > -1:
                                                                    revert with 0, 17
                                                                if balanceOf[this.address] < balanceOf[this.address]:
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 512] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 516] = 32
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 548] = 27
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 580] = 'SafeMath: addition overflow'
                                                                    revert with memory
                                                                      from _21587 + (8 * ceil32(return_data.size)) + 512
                                                                       len (13 * ceil32(return_data.size)) + 100
                                                                balanceOf[address(this.address)] = balanceOf[this.address]
                                                                emit Transfer(0, msg.sender, this.address);
                                                                if not msg.sender:
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 512] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 516] = 32
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 548] = 37
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 580] = 'ERC20: transfer from the zero ad'
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 612] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                                    revert with memory
                                                                      from _21587 + (8 * ceil32(return_data.size)) + 512
                                                                       len (13 * ceil32(return_data.size)) + 132
                                                                if not address(cd[4]):
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 512] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 516] = 32
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 548] = 35
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 580] = 'ERC20: transfer to the zero addr'
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 612] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                                    revert with memory
                                                                      from _21587 + (8 * ceil32(return_data.size)) + 512
                                                                       len (13 * ceil32(return_data.size)) + 132
                                                                if cd[36] > balanceOf[address(msg.sender)]:
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 608] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 612] = 32
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 644] = 38
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 676 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_21587 + (8 * ceil32(return_data.size)) + 582 len 26]
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 714] = 0
                                                                    revert with memory
                                                                      from _21587 + (8 * ceil32(return_data.size)) + 608
                                                                       len (13 * ceil32(return_data.size)) + 132
                                                                if balanceOf[address(msg.sender)] < cd[36]:
                                                                    revert with 0, 17
                                                                balanceOf[address(msg.sender)] -= cd[36]
                                                                if balanceOf[address(cd[4])] > !cd[36]:
                                                                    revert with 0, 17
                                                                if balanceOf[address(cd[4])] + cd[36] < balanceOf[address(cd[4])]:
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 608] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 612] = 32
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 644] = 27
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 676] = 'SafeMath: addition overflow'
                                                                    revert with memory
                                                                      from _21587 + (8 * ceil32(return_data.size)) + 608
                                                                       len (13 * ceil32(return_data.size)) + 100
                                                                balanceOf[address(cd[4])] += cd[36]
                                                                emit Transfer(cd[36], msg.sender, address(cd[4]));
                                                                mem[_21587 + (8 * ceil32(return_data.size)) + 612] = msg.sender
                                                                mem[_21587 + (8 * ceil32(return_data.size)) + 644] = balanceOf[address(msg.sender)]
                                                                require ext_code.size(dividendTrackerAddress)
                                                                call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                                     gas gas_remaining wei
                                                                    args mem[_21587 + (8 * ceil32(return_data.size)) + 612 len (13 * ceil32(return_data.size)) + 64]
                                                                mem[_21587 + (8 * ceil32(return_data.size)) + 612] = address(cd[4])
                                                                mem[_21587 + (8 * ceil32(return_data.size)) + 644] = balanceOf[address(cd[4])]
                                                                require ext_code.size(dividendTrackerAddress)
                                                                call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                                     gas gas_remaining wei
                                                                    args mem[_21587 + (8 * ceil32(return_data.size)) + 612 len (13 * ceil32(return_data.size)) + 64]
                                                                if not stor7:
                                                                    call dividendTrackerAddress.process(uint256 arg1) with:
                                                                         gas gas_remaining wei
                                                                        args gasForProcessing
                                                                    if ext_call.success:
                                                                        require return_data.size >= 96
                                                                        emit ProcessedDividendTracker(uint256 arg1, uint256 arg2, uint256 arg3, bool arg4, uint256 arg5, address arg6):
                                                                                                      ext_call.return_data[0],
                                                                                                      ext_call.return_data[32],
                                                                                                      ext_call.return_data[64],
                                                                                                      gasForProcessing,
                                                                                                      mem[_21587 + (9 * ceil32(return_data.size)) + 736 len 5 * ceil32(return_data.size)],
                                                                                                      1,
                                                                                                      tx.origin,
                                                            else:
                                                                if not cd[36]:
                                                                    if 0 > cd[36]:
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 480] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 484] = 32
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 516] = 30
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 548] = 'SafeMath: subtraction overflow'
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 578] = 0
                                                                        revert with memory
                                                                          from _21587 + (8 * ceil32(return_data.size)) + 480
                                                                           len (13 * ceil32(return_data.size)) + 100
                                                                    if cd[36] < 0:
                                                                        revert with 0, 17
                                                                    if not msg.sender:
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 480] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 484] = 32
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 516] = 37
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 548] = 'ERC20: transfer from the zero ad'
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 580] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                                        revert with memory
                                                                          from _21587 + (8 * ceil32(return_data.size)) + 480
                                                                           len (13 * ceil32(return_data.size)) + 132
                                                                    if not this.address:
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 480] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 484] = 32
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 516] = 35
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 548] = 'ERC20: transfer to the zero addr'
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 580] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                                        revert with memory
                                                                          from _21587 + (8 * ceil32(return_data.size)) + 480
                                                                           len (13 * ceil32(return_data.size)) + 132
                                                                    if 0 > balanceOf[address(msg.sender)]:
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 576] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 580] = 32
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 612] = 38
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 644 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_21587 + (8 * ceil32(return_data.size)) + 550 len 26]
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 682] = 0
                                                                        revert with memory
                                                                          from _21587 + (8 * ceil32(return_data.size)) + 576
                                                                           len (13 * ceil32(return_data.size)) + 132
                                                                    if balanceOf[address(msg.sender)] < 0:
                                                                        revert with 0, 17
                                                                    if balanceOf[this.address] > -1:
                                                                        revert with 0, 17
                                                                    if balanceOf[this.address] < balanceOf[this.address]:
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 576] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 580] = 32
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 612] = 27
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 644] = 'SafeMath: addition overflow'
                                                                        revert with memory
                                                                          from _21587 + (8 * ceil32(return_data.size)) + 576
                                                                           len (13 * ceil32(return_data.size)) + 100
                                                                    balanceOf[address(this.address)] = balanceOf[this.address]
                                                                    emit Transfer(0, msg.sender, this.address);
                                                                    if not msg.sender:
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 576] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 580] = 32
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 612] = 37
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 644] = 'ERC20: transfer from the zero ad'
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 676] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                                        revert with memory
                                                                          from _21587 + (8 * ceil32(return_data.size)) + 576
                                                                           len (13 * ceil32(return_data.size)) + 132
                                                                    if not address(cd[4]):
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 576] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 580] = 32
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 612] = 35
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 644] = 'ERC20: transfer to the zero addr'
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 676] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                                        revert with memory
                                                                          from _21587 + (8 * ceil32(return_data.size)) + 576
                                                                           len (13 * ceil32(return_data.size)) + 132
                                                                    if cd[36] > balanceOf[address(msg.sender)]:
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 672] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 676] = 32
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 708] = 38
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 740 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_21587 + (8 * ceil32(return_data.size)) + 646 len 26]
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 778] = 0
                                                                        revert with memory
                                                                          from _21587 + (8 * ceil32(return_data.size)) + 672
                                                                           len (13 * ceil32(return_data.size)) + 132
                                                                    if balanceOf[address(msg.sender)] < cd[36]:
                                                                        revert with 0, 17
                                                                    balanceOf[address(msg.sender)] -= cd[36]
                                                                    if balanceOf[address(cd[4])] > !cd[36]:
                                                                        revert with 0, 17
                                                                    if balanceOf[address(cd[4])] + cd[36] < balanceOf[address(cd[4])]:
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 672] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 676] = 32
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 708] = 27
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 740] = 'SafeMath: addition overflow'
                                                                        revert with memory
                                                                          from _21587 + (8 * ceil32(return_data.size)) + 672
                                                                           len (13 * ceil32(return_data.size)) + 100
                                                                    balanceOf[address(cd[4])] += cd[36]
                                                                    emit Transfer(cd[36], msg.sender, address(cd[4]));
                                                                else:
                                                                    if cd[36] and 1 > -1 / cd[36]:
                                                                        revert with 0, 17
                                                                    if not cd[36]:
                                                                        revert with 0, 18
                                                                    if cd[36] / cd[36] != 1:
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 352] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 356] = 32
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 388] = 33
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 420] = 'SafeMath: multiplication overflo'
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 452] = 0x7700000000000000000000000000000000000000000000000000000000000000
                                                                        revert with memory
                                                                          from _21587 + (8 * ceil32(return_data.size)) + 352
                                                                           len (13 * ceil32(return_data.size)) + 132
                                                                    if 0 > !(cd[36] / 100):
                                                                        revert with 0, 17
                                                                    if cd[36] / 100 > cd[36]:
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 480] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 484] = 32
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 516] = 30
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 548] = 'SafeMath: subtraction overflow'
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 578] = 0
                                                                        revert with memory
                                                                          from _21587 + (8 * ceil32(return_data.size)) + 480
                                                                           len (13 * ceil32(return_data.size)) + 100
                                                                    if cd[36] < cd[36] / 100:
                                                                        revert with 0, 17
                                                                    if not msg.sender:
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 480] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 484] = 32
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 516] = 37
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 548] = 'ERC20: transfer from the zero ad'
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 580] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                                        revert with memory
                                                                          from _21587 + (8 * ceil32(return_data.size)) + 480
                                                                           len (13 * ceil32(return_data.size)) + 132
                                                                    if not this.address:
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 480] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 484] = 32
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 516] = 35
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 548] = 'ERC20: transfer to the zero addr'
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 580] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                                        revert with memory
                                                                          from _21587 + (8 * ceil32(return_data.size)) + 480
                                                                           len (13 * ceil32(return_data.size)) + 132
                                                                    if cd[36] / 100 > balanceOf[address(msg.sender)]:
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 576] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 580] = 32
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 612] = 38
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 644 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_21587 + (8 * ceil32(return_data.size)) + 550 len 26]
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 682] = 0
                                                                        revert with memory
                                                                          from _21587 + (8 * ceil32(return_data.size)) + 576
                                                                           len (13 * ceil32(return_data.size)) + 132
                                                                    if balanceOf[address(msg.sender)] < cd[36] / 100:
                                                                        revert with 0, 17
                                                                    balanceOf[address(msg.sender)] -= cd[36] / 100
                                                                    if balanceOf[this.address] > !(cd[36] / 100):
                                                                        revert with 0, 17
                                                                    if balanceOf[this.address] + (cd[36] / 100) < balanceOf[this.address]:
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 576] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 580] = 32
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 612] = 27
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 644] = 'SafeMath: addition overflow'
                                                                        revert with memory
                                                                          from _21587 + (8 * ceil32(return_data.size)) + 576
                                                                           len (13 * ceil32(return_data.size)) + 100
                                                                    balanceOf[address(this.address)] = balanceOf[this.address] + (cd[36] / 100)
                                                                    emit Transfer((cd[36] / 100), msg.sender, this.address);
                                                                    if not msg.sender:
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 576] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 580] = 32
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 612] = 37
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 644] = 'ERC20: transfer from the zero ad'
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 676] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                                        revert with memory
                                                                          from _21587 + (8 * ceil32(return_data.size)) + 576
                                                                           len (13 * ceil32(return_data.size)) + 132
                                                                    if not address(cd[4]):
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 576] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 580] = 32
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 612] = 35
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 644] = 'ERC20: transfer to the zero addr'
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 676] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                                        revert with memory
                                                                          from _21587 + (8 * ceil32(return_data.size)) + 576
                                                                           len (13 * ceil32(return_data.size)) + 132
                                                                    if cd[36] - (cd[36] / 100) > balanceOf[address(msg.sender)]:
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 672] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 676] = 32
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 708] = 38
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 740 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_21587 + (8 * ceil32(return_data.size)) + 646 len 26]
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 778] = 0
                                                                        revert with memory
                                                                          from _21587 + (8 * ceil32(return_data.size)) + 672
                                                                           len (13 * ceil32(return_data.size)) + 132
                                                                    if balanceOf[address(msg.sender)] < cd[36] - (cd[36] / 100):
                                                                        revert with 0, 17
                                                                    balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - cd[36] + (cd[36] / 100)
                                                                    if balanceOf[address(cd[4])] > !(cd[36] - (cd[36] / 100)):
                                                                        revert with 0, 17
                                                                    if balanceOf[address(cd[4])] + cd[36] - (cd[36] / 100) < balanceOf[address(cd[4])]:
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 672] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 676] = 32
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 708] = 27
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 740] = 'SafeMath: addition overflow'
                                                                        revert with memory
                                                                          from _21587 + (8 * ceil32(return_data.size)) + 672
                                                                           len (13 * ceil32(return_data.size)) + 100
                                                                    balanceOf[address(cd[4])] = balanceOf[address(cd[4])] + cd[36] - (cd[36] / 100)
                                                                    emit Transfer((cd[36] - (cd[36] / 100)), msg.sender, address(cd[4]));
                                                                mem[_21587 + (8 * ceil32(return_data.size)) + 676] = msg.sender
                                                                mem[_21587 + (8 * ceil32(return_data.size)) + 708] = balanceOf[address(msg.sender)]
                                                                require ext_code.size(dividendTrackerAddress)
                                                                call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                                     gas gas_remaining wei
                                                                    args mem[_21587 + (8 * ceil32(return_data.size)) + 676 len (13 * ceil32(return_data.size)) + 64]
                                                                mem[_21587 + (8 * ceil32(return_data.size)) + 676] = address(cd[4])
                                                                mem[_21587 + (8 * ceil32(return_data.size)) + 708] = balanceOf[address(cd[4])]
                                                                require ext_code.size(dividendTrackerAddress)
                                                                call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                                     gas gas_remaining wei
                                                                    args mem[_21587 + (8 * ceil32(return_data.size)) + 676 len (13 * ceil32(return_data.size)) + 64]
                                                                if not stor7:
                                                                    call dividendTrackerAddress.process(uint256 arg1) with:
                                                                         gas gas_remaining wei
                                                                        args gasForProcessing
                                                                    if ext_call.success:
                                                                        require return_data.size >= 96
                                                                        emit ProcessedDividendTracker(uint256 arg1, uint256 arg2, uint256 arg3, bool arg4, uint256 arg5, address arg6):
                                                                                                      ext_call.return_data[0],
                                                                                                      ext_call.return_data[32],
                                                                                                      ext_call.return_data[64],
                                                                                                      gasForProcessing,
                                                                                                      mem[_21587 + (9 * ceil32(return_data.size)) + 800 len 5 * ceil32(return_data.size)],
                                                                                                      1,
                                                                                                      tx.origin,
                                                        else:
                                                            if cd[36] and totalFees > -1 / cd[36]:
                                                                revert with 0, 17
                                                            if not cd[36]:
                                                                revert with 0, 18
                                                            if cd[36] * totalFees / cd[36] != totalFees:
                                                                mem[_21587 + (8 * ceil32(return_data.size)) + 288] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_21587 + (8 * ceil32(return_data.size)) + 292] = 32
                                                                mem[_21587 + (8 * ceil32(return_data.size)) + 324] = 33
                                                                mem[_21587 + (8 * ceil32(return_data.size)) + 356] = 'SafeMath: multiplication overflo'
                                                                mem[_21587 + (8 * ceil32(return_data.size)) + 388] = 0x7700000000000000000000000000000000000000000000000000000000000000
                                                                revert with memory
                                                                  from _21587 + (8 * ceil32(return_data.size)) + 288
                                                                   len (13 * ceil32(return_data.size)) + 132
                                                            if not stor20[address(cd[4])]:
                                                                if cd[36] * totalFees / 100 > cd[36]:
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 420] = 32
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 452] = 30
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 484] = 'SafeMath: subtraction overflow'
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 514] = 0
                                                                    revert with memory
                                                                      from _21587 + (8 * ceil32(return_data.size)) + 416
                                                                       len (13 * ceil32(return_data.size)) + 100
                                                                if cd[36] < cd[36] * totalFees / 100:
                                                                    revert with 0, 17
                                                                if not msg.sender:
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 420] = 32
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 452] = 37
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 484] = 'ERC20: transfer from the zero ad'
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 516] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                                    revert with memory
                                                                      from _21587 + (8 * ceil32(return_data.size)) + 416
                                                                       len (13 * ceil32(return_data.size)) + 132
                                                                if not this.address:
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 420] = 32
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 452] = 35
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 484] = 'ERC20: transfer to the zero addr'
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 516] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                                    revert with memory
                                                                      from _21587 + (8 * ceil32(return_data.size)) + 416
                                                                       len (13 * ceil32(return_data.size)) + 132
                                                                if cd[36] * totalFees / 100 > balanceOf[address(msg.sender)]:
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 512] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 516] = 32
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 548] = 38
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 580 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_21587 + (8 * ceil32(return_data.size)) + 486 len 26]
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 618] = 0
                                                                    revert with memory
                                                                      from _21587 + (8 * ceil32(return_data.size)) + 512
                                                                       len (13 * ceil32(return_data.size)) + 132
                                                                if balanceOf[address(msg.sender)] < cd[36] * totalFees / 100:
                                                                    revert with 0, 17
                                                                balanceOf[address(msg.sender)] -= cd[36] * totalFees / 100
                                                                if balanceOf[this.address] > !(cd[36] * totalFees / 100):
                                                                    revert with 0, 17
                                                                if balanceOf[this.address] + (cd[36] * totalFees / 100) < balanceOf[this.address]:
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 512] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 516] = 32
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 548] = 27
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 580] = 'SafeMath: addition overflow'
                                                                    revert with memory
                                                                      from _21587 + (8 * ceil32(return_data.size)) + 512
                                                                       len (13 * ceil32(return_data.size)) + 100
                                                                balanceOf[address(this.address)] = balanceOf[this.address] + (cd[36] * totalFees / 100)
                                                                emit Transfer((cd[36] * totalFees / 100), msg.sender, this.address);
                                                                if not msg.sender:
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 512] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 516] = 32
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 548] = 37
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 580] = 'ERC20: transfer from the zero ad'
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 612] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                                    revert with memory
                                                                      from _21587 + (8 * ceil32(return_data.size)) + 512
                                                                       len (13 * ceil32(return_data.size)) + 132
                                                                if not address(cd[4]):
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 512] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 516] = 32
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 548] = 35
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 580] = 'ERC20: transfer to the zero addr'
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 612] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                                    revert with memory
                                                                      from _21587 + (8 * ceil32(return_data.size)) + 512
                                                                       len (13 * ceil32(return_data.size)) + 132
                                                                if cd[36] - (cd[36] * totalFees / 100) > balanceOf[address(msg.sender)]:
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 608] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 612] = 32
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 644] = 38
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 676 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_21587 + (8 * ceil32(return_data.size)) + 582 len 26]
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 714] = 0
                                                                    revert with memory
                                                                      from _21587 + (8 * ceil32(return_data.size)) + 608
                                                                       len (13 * ceil32(return_data.size)) + 132
                                                                if balanceOf[address(msg.sender)] < cd[36] - (cd[36] * totalFees / 100):
                                                                    revert with 0, 17
                                                                balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - cd[36] + (cd[36] * totalFees / 100)
                                                                if balanceOf[address(cd[4])] > !(cd[36] - (cd[36] * totalFees / 100)):
                                                                    revert with 0, 17
                                                                if balanceOf[address(cd[4])] + cd[36] - (cd[36] * totalFees / 100) < balanceOf[address(cd[4])]:
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 608] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 612] = 32
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 644] = 27
                                                                    mem[_21587 + (8 * ceil32(return_data.size)) + 676] = 'SafeMath: addition overflow'
                                                                    revert with memory
                                                                      from _21587 + (8 * ceil32(return_data.size)) + 608
                                                                       len (13 * ceil32(return_data.size)) + 100
                                                                balanceOf[address(cd[4])] = balanceOf[address(cd[4])] + cd[36] - (cd[36] * totalFees / 100)
                                                                emit Transfer((cd[36] - (cd[36] * totalFees / 100)), msg.sender, address(cd[4]));
                                                                mem[_21587 + (8 * ceil32(return_data.size)) + 612] = msg.sender
                                                                mem[_21587 + (8 * ceil32(return_data.size)) + 644] = balanceOf[address(msg.sender)]
                                                                require ext_code.size(dividendTrackerAddress)
                                                                call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                                     gas gas_remaining wei
                                                                    args mem[_21587 + (8 * ceil32(return_data.size)) + 612 len (13 * ceil32(return_data.size)) + 64]
                                                                mem[_21587 + (8 * ceil32(return_data.size)) + 612] = address(cd[4])
                                                                mem[_21587 + (8 * ceil32(return_data.size)) + 644] = balanceOf[address(cd[4])]
                                                                require ext_code.size(dividendTrackerAddress)
                                                                call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                                     gas gas_remaining wei
                                                                    args mem[_21587 + (8 * ceil32(return_data.size)) + 612 len (13 * ceil32(return_data.size)) + 64]
                                                                if not stor7:
                                                                    call dividendTrackerAddress.process(uint256 arg1) with:
                                                                         gas gas_remaining wei
                                                                        args gasForProcessing
                                                                    if ext_call.success:
                                                                        require return_data.size >= 96
                                                                        emit ProcessedDividendTracker(uint256 arg1, uint256 arg2, uint256 arg3, bool arg4, uint256 arg5, address arg6):
                                                                                                      ext_call.return_data[0],
                                                                                                      ext_call.return_data[32],
                                                                                                      ext_call.return_data[64],
                                                                                                      gasForProcessing,
                                                                                                      mem[_21587 + (9 * ceil32(return_data.size)) + 736 len 5 * ceil32(return_data.size)],
                                                                                                      1,
                                                                                                      tx.origin,
                                                            else:
                                                                if not cd[36]:
                                                                    if cd[36] * totalFees / 100 > -1:
                                                                        revert with 0, 17
                                                                    if cd[36] * totalFees / 100 > cd[36]:
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 480] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 484] = 32
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 516] = 30
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 548] = 'SafeMath: subtraction overflow'
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 578] = 0
                                                                        revert with memory
                                                                          from _21587 + (8 * ceil32(return_data.size)) + 480
                                                                           len (13 * ceil32(return_data.size)) + 100
                                                                    if cd[36] < cd[36] * totalFees / 100:
                                                                        revert with 0, 17
                                                                    if not msg.sender:
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 480] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 484] = 32
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 516] = 37
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 548] = 'ERC20: transfer from the zero ad'
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 580] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                                        revert with memory
                                                                          from _21587 + (8 * ceil32(return_data.size)) + 480
                                                                           len (13 * ceil32(return_data.size)) + 132
                                                                    if not this.address:
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 480] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 484] = 32
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 516] = 35
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 548] = 'ERC20: transfer to the zero addr'
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 580] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                                        revert with memory
                                                                          from _21587 + (8 * ceil32(return_data.size)) + 480
                                                                           len (13 * ceil32(return_data.size)) + 132
                                                                    if cd[36] * totalFees / 100 > balanceOf[address(msg.sender)]:
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 576] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 580] = 32
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 612] = 38
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 644 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_21587 + (8 * ceil32(return_data.size)) + 550 len 26]
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 682] = 0
                                                                        revert with memory
                                                                          from _21587 + (8 * ceil32(return_data.size)) + 576
                                                                           len (13 * ceil32(return_data.size)) + 132
                                                                    if balanceOf[address(msg.sender)] < cd[36] * totalFees / 100:
                                                                        revert with 0, 17
                                                                    balanceOf[address(msg.sender)] -= cd[36] * totalFees / 100
                                                                    if balanceOf[this.address] > !(cd[36] * totalFees / 100):
                                                                        revert with 0, 17
                                                                    if balanceOf[this.address] + (cd[36] * totalFees / 100) < balanceOf[this.address]:
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 576] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 580] = 32
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 612] = 27
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 644] = 'SafeMath: addition overflow'
                                                                        revert with memory
                                                                          from _21587 + (8 * ceil32(return_data.size)) + 576
                                                                           len (13 * ceil32(return_data.size)) + 100
                                                                    balanceOf[address(this.address)] = balanceOf[this.address] + (cd[36] * totalFees / 100)
                                                                    emit Transfer((cd[36] * totalFees / 100), msg.sender, this.address);
                                                                    if not msg.sender:
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 576] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 580] = 32
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 612] = 37
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 644] = 'ERC20: transfer from the zero ad'
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 676] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                                        revert with memory
                                                                          from _21587 + (8 * ceil32(return_data.size)) + 576
                                                                           len (13 * ceil32(return_data.size)) + 132
                                                                    if not address(cd[4]):
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 576] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 580] = 32
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 612] = 35
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 644] = 'ERC20: transfer to the zero addr'
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 676] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                                        revert with memory
                                                                          from _21587 + (8 * ceil32(return_data.size)) + 576
                                                                           len (13 * ceil32(return_data.size)) + 132
                                                                    if cd[36] - (cd[36] * totalFees / 100) > balanceOf[address(msg.sender)]:
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 672] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 676] = 32
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 708] = 38
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 740 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_21587 + (8 * ceil32(return_data.size)) + 646 len 26]
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 778] = 0
                                                                        revert with memory
                                                                          from _21587 + (8 * ceil32(return_data.size)) + 672
                                                                           len (13 * ceil32(return_data.size)) + 132
                                                                    if balanceOf[address(msg.sender)] < cd[36] - (cd[36] * totalFees / 100):
                                                                        revert with 0, 17
                                                                    balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - cd[36] + (cd[36] * totalFees / 100)
                                                                    if balanceOf[address(cd[4])] > !(cd[36] - (cd[36] * totalFees / 100)):
                                                                        revert with 0, 17
                                                                    if balanceOf[address(cd[4])] + cd[36] - (cd[36] * totalFees / 100) < balanceOf[address(cd[4])]:
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 672] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 676] = 32
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 708] = 27
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 740] = 'SafeMath: addition overflow'
                                                                        revert with memory
                                                                          from _21587 + (8 * ceil32(return_data.size)) + 672
                                                                           len (13 * ceil32(return_data.size)) + 100
                                                                    balanceOf[address(cd[4])] = balanceOf[address(cd[4])] + cd[36] - (cd[36] * totalFees / 100)
                                                                    emit Transfer((cd[36] - (cd[36] * totalFees / 100)), msg.sender, address(cd[4]));
                                                                else:
                                                                    if cd[36] and 1 > -1 / cd[36]:
                                                                        revert with 0, 17
                                                                    if not cd[36]:
                                                                        revert with 0, 18
                                                                    if cd[36] / cd[36] != 1:
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 352] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 356] = 32
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 388] = 33
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 420] = 'SafeMath: multiplication overflo'
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 452] = 0x7700000000000000000000000000000000000000000000000000000000000000
                                                                        revert with memory
                                                                          from _21587 + (8 * ceil32(return_data.size)) + 352
                                                                           len (13 * ceil32(return_data.size)) + 132
                                                                    if cd[36] * totalFees / 100 > !(cd[36] / 100):
                                                                        revert with 0, 17
                                                                    if (cd[36] * totalFees / 100) + (cd[36] / 100) > cd[36]:
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 480] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 484] = 32
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 516] = 30
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 548] = 'SafeMath: subtraction overflow'
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 578] = 0
                                                                        revert with memory
                                                                          from _21587 + (8 * ceil32(return_data.size)) + 480
                                                                           len (13 * ceil32(return_data.size)) + 100
                                                                    if cd[36] < (cd[36] * totalFees / 100) + (cd[36] / 100):
                                                                        revert with 0, 17
                                                                    if not msg.sender:
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 480] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 484] = 32
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 516] = 37
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 548] = 'ERC20: transfer from the zero ad'
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 580] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                                        revert with memory
                                                                          from _21587 + (8 * ceil32(return_data.size)) + 480
                                                                           len (13 * ceil32(return_data.size)) + 132
                                                                    if not this.address:
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 480] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 484] = 32
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 516] = 35
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 548] = 'ERC20: transfer to the zero addr'
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 580] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                                        revert with memory
                                                                          from _21587 + (8 * ceil32(return_data.size)) + 480
                                                                           len (13 * ceil32(return_data.size)) + 132
                                                                    if (cd[36] * totalFees / 100) + (cd[36] / 100) > balanceOf[address(msg.sender)]:
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 576] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 580] = 32
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 612] = 38
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 644 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_21587 + (8 * ceil32(return_data.size)) + 550 len 26]
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 682] = 0
                                                                        revert with memory
                                                                          from _21587 + (8 * ceil32(return_data.size)) + 576
                                                                           len (13 * ceil32(return_data.size)) + 132
                                                                    if balanceOf[address(msg.sender)] < (cd[36] * totalFees / 100) + (cd[36] / 100):
                                                                        revert with 0, 17
                                                                    balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - (cd[36] * totalFees / 100) - (cd[36] / 100)
                                                                    if balanceOf[this.address] > !((cd[36] * totalFees / 100) + (cd[36] / 100)):
                                                                        revert with 0, 17
                                                                    if balanceOf[this.address] + (cd[36] * totalFees / 100) + (cd[36] / 100) < balanceOf[this.address]:
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 576] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 580] = 32
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 612] = 27
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 644] = 'SafeMath: addition overflow'
                                                                        revert with memory
                                                                          from _21587 + (8 * ceil32(return_data.size)) + 576
                                                                           len (13 * ceil32(return_data.size)) + 100
                                                                    balanceOf[address(this.address)] = balanceOf[this.address] + (cd[36] * totalFees / 100) + (cd[36] / 100)
                                                                    emit Transfer(((cd[36] * totalFees / 100) + (cd[36] / 100)), msg.sender, this.address);
                                                                    if not msg.sender:
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 576] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 580] = 32
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 612] = 37
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 644] = 'ERC20: transfer from the zero ad'
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 676] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                                        revert with memory
                                                                          from _21587 + (8 * ceil32(return_data.size)) + 576
                                                                           len (13 * ceil32(return_data.size)) + 132
                                                                    if not address(cd[4]):
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 576] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 580] = 32
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 612] = 35
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 644] = 'ERC20: transfer to the zero addr'
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 676] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                                        revert with memory
                                                                          from _21587 + (8 * ceil32(return_data.size)) + 576
                                                                           len (13 * ceil32(return_data.size)) + 132
                                                                    if cd[36] - (cd[36] * totalFees / 100) - (cd[36] / 100) > balanceOf[address(msg.sender)]:
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 672] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 676] = 32
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 708] = 38
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 740 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_21587 + (8 * ceil32(return_data.size)) + 646 len 26]
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 778] = 0
                                                                        revert with memory
                                                                          from _21587 + (8 * ceil32(return_data.size)) + 672
                                                                           len (13 * ceil32(return_data.size)) + 132
                                                                    if balanceOf[address(msg.sender)] < cd[36] - (cd[36] * totalFees / 100) - (cd[36] / 100):
                                                                        revert with 0, 17
                                                                    balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - cd[36] + (cd[36] * totalFees / 100) + (cd[36] / 100)
                                                                    if balanceOf[address(cd[4])] > !(cd[36] - (cd[36] * totalFees / 100) - (cd[36] / 100)):
                                                                        revert with 0, 17
                                                                    if balanceOf[address(cd[4])] + cd[36] - (cd[36] * totalFees / 100) - (cd[36] / 100) < balanceOf[address(cd[4])]:
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 672] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 676] = 32
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 708] = 27
                                                                        mem[_21587 + (8 * ceil32(return_data.size)) + 740] = 'SafeMath: addition overflow'
                                                                        revert with memory
                                                                          from _21587 + (8 * ceil32(return_data.size)) + 672
                                                                           len (13 * ceil32(return_data.size)) + 100
                                                                    balanceOf[address(cd[4])] = balanceOf[address(cd[4])] + cd[36] - (cd[36] * totalFees / 100) - (cd[36] / 100)
                                                                    emit Transfer((cd[36] - (cd[36] * totalFees / 100) - (cd[36] / 100)), msg.sender, address(cd[4]));
                                                                mem[_21587 + (8 * ceil32(return_data.size)) + 676] = msg.sender
                                                                mem[_21587 + (8 * ceil32(return_data.size)) + 708] = balanceOf[address(msg.sender)]
                                                                require ext_code.size(dividendTrackerAddress)
                                                                call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                                     gas gas_remaining wei
                                                                    args mem[_21587 + (8 * ceil32(return_data.size)) + 676 len (13 * ceil32(return_data.size)) + 64]
                                                                mem[_21587 + (8 * ceil32(return_data.size)) + 676] = address(cd[4])
                                                                mem[_21587 + (8 * ceil32(return_data.size)) + 708] = balanceOf[address(cd[4])]
                                                                require ext_code.size(dividendTrackerAddress)
                                                                call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                                     gas gas_remaining wei
                                                                    args mem[_21587 + (8 * ceil32(return_data.size)) + 676 len (13 * ceil32(return_data.size)) + 64]
                                                                if not stor7:
                                                                    call dividendTrackerAddress.process(uint256 arg1) with:
                                                                         gas gas_remaining wei
                                                                        args gasForProcessing
                                                                    if ext_call.success:
                                                                        require return_data.size >= 96
                                                                        emit ProcessedDividendTracker(uint256 arg1, uint256 arg2, uint256 arg3, bool arg4, uint256 arg5, address arg6):
                                                                                                      ext_call.return_data[0],
                                                                                                      ext_call.return_data[32],
                                                                                                      ext_call.return_data[64],
                                                                                                      gasForProcessing,
                                                                                                      mem[_21587 + (9 * ceil32(return_data.size)) + 800 len 5 * ceil32(return_data.size)],
                                                                                                      1,
                                                                                                      tx.origin,
                                    else:
                                        mem[128] = 26
                                        mem[160] = 'SafeMath: division by zero'
                                        if not totalFees:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        mem[196] = this.address
                                        staticcall sub_4d7effddAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[192] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        mem[ceil32(return_data.size) + 192] = 3
                                        mem[ceil32(return_data.size) + 224] = this.address
                                        staticcall uniswapV2RouterAddress.WETH() with:
                                                gas gas_remaining wei
                                        mem[ceil32(return_data.size) + 320] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = (2 * ceil32(return_data.size)) + 320
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                        mem[ceil32(return_data.size) + 256] = ext_call.return_data[12 len 20]
                                        mem[ceil32(return_data.size) + 288] = sub_4d7effddAddress
                                        if not this.address:
                                            mem[(2 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[(2 * ceil32(return_data.size)) + 324] = 32
                                            mem[(2 * ceil32(return_data.size)) + 356] = 36
                                            mem[(2 * ceil32(return_data.size)) + 388] = 'ERC20: approve from the zero add'
                                            mem[(2 * ceil32(return_data.size)) + 420] = 0x7265737300000000000000000000000000000000000000000000000000000000
                                            revert with memory
                                              from (2 * ceil32(return_data.size)) + 320
                                               len ceil32(return_data.size) + 132
                                        if not uniswapV2RouterAddress:
                                            mem[(2 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[(2 * ceil32(return_data.size)) + 324] = 32
                                            mem[(2 * ceil32(return_data.size)) + 356] = 34
                                            mem[(2 * ceil32(return_data.size)) + 388] = 'ERC20: approve to the zero addre'
                                            mem[(2 * ceil32(return_data.size)) + 420] = 0x7373000000000000000000000000000000000000000000000000000000000000
                                            revert with memory
                                              from (2 * ceil32(return_data.size)) + 320
                                               len ceil32(return_data.size) + 132
                                        mem[0] = uniswapV2RouterAddress
                                        mem[32] = sha3(address(this.address), 1)
                                        allowance[address(this.address)][stor6].field_0 = 0 / totalFees
                                        mem[(2 * ceil32(return_data.size)) + 320] = 0 / totalFees
                                        emit Approval(mem[(2 * ceil32(return_data.size)) + 320 len ceil32(return_data.size) + 32], this.address, uniswapV2RouterAddress);
                                        mem[(2 * ceil32(return_data.size)) + 320] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                        mem[(2 * ceil32(return_data.size)) + 324] = 0 / totalFees
                                        mem[(2 * ceil32(return_data.size)) + 356] = 0
                                        mem[(2 * ceil32(return_data.size)) + 388] = 160
                                        mem[(2 * ceil32(return_data.size)) + 484] = 3
                                        idx = 0
                                        s = (2 * ceil32(return_data.size)) + 516
                                        t = ceil32(return_data.size) + 224
                                        while idx < mem[ceil32(return_data.size) + 192]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[(2 * ceil32(return_data.size)) + 420] = this.address
                                        mem[(2 * ceil32(return_data.size)) + 452] = block.timestamp
                                        require ext_code.size(uniswapV2RouterAddress)
                                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 608]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[mem[64] + 4] = this.address
                                        staticcall sub_4d7effddAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[mem[64]] = ext_call.return_data[0]
                                        _21387 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _21399 = mem[_21387]
                                        _21412 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_21412] = 30
                                        mem[_21412 + 32] = 'SafeMath: subtraction overflow'
                                        if ext_call.return_data[0] > _21399:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if _21399 < ext_call.return_data[0]:
                                            revert with 0, 17
                                        mem[mem[64] + 4] = stor17
                                        mem[mem[64] + 36] = _21399 - ext_call.return_data[0]
                                        call sub_4d7effddAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args stor17, _21399 - ext_call.return_data[0]
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _21443 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_21443] == bool(mem[_21443])
                                        if not balanceOf[this.address]:
                                            _21452 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_21452] = 26
                                            mem[_21452 + 32] = 'SafeMath: division by zero'
                                            if not totalFees:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            _21496 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_21496] = 26
                                            mem[_21496 + 32] = 'SafeMath: division by zero'
                                            _21516 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_21516] = 30
                                            mem[_21516 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 / totalFees / 2 > 0 / totalFees:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if 0 / totalFees < 0 / totalFees / 2:
                                                revert with 0, 17
                                            _21550 = mem[64]
                                            mem[mem[64]] = 2
                                            mem[64] = mem[64] + 96
                                            mem[_21550 + 32 len 64] = call.data[calldata.size len 64]
                                            if 0 >= mem[_21550]:
                                                revert with 0, 50
                                            mem[_21550 + 32] = this.address
                                            staticcall uniswapV2RouterAddress.WETH() with:
                                                    gas gas_remaining wei
                                            mem[_21550 + 96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[64] = _21550 + ceil32(return_data.size) + 96
                                            require return_data.size >= 32
                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                            if 1 >= mem[_21550]:
                                                revert with 0, 50
                                            mem[_21550 + 64] = ext_call.return_data[12 len 20]
                                            if not this.address:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not uniswapV2RouterAddress:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            mem[0] = uniswapV2RouterAddress
                                            mem[32] = sha3(address(this.address), 1)
                                            allowance[address(this.address)][stor6].field_0 = 0 / totalFees / 2
                                            allowance[address(this.address)][stor6].field_255 = 0
                                            emit Approval((0 / totalFees / 2), this.address, uniswapV2RouterAddress);
                                            mem[_21550 + ceil32(return_data.size) + 96] = 0x791ac94700000000000000000000000000000000000000000000000000000000
                                            mem[_21550 + ceil32(return_data.size) + 100] = 0 / totalFees / 2
                                            mem[_21550 + ceil32(return_data.size) + 132] = 0
                                            mem[_21550 + ceil32(return_data.size) + 164] = 160
                                            mem[_21550 + ceil32(return_data.size) + 260] = mem[_21550]
                                            idx = 0
                                            s = _21550 + ceil32(return_data.size) + 292
                                            t = _21550 + 32
                                            while idx < mem[_21550]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            require ext_code.size(uniswapV2RouterAddress)
                                            call uniswapV2RouterAddress.swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                 gas gas_remaining wei
                                                args Mask(255, 1, 0 / totalFees), 0, 160, address(this.address), block.timestamp, mem[_21550 + ceil32(return_data.size) + 260 len (32 * mem[_21550]) + 32]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[_21550 + ceil32(return_data.size) + 96] = 30
                                            mem[_21550 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if eth.balance(this.address) < eth.balance(this.address):
                                                revert with 0, 17
                                            if not this.address:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not uniswapV2RouterAddress:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(this.address)][stor6].field_0 = (0 / totalFees) - (0 / totalFees / 2)
                                            emit Approval(((0 / totalFees) - (0 / totalFees / 2)), this.address, uniswapV2RouterAddress);
                                            mem[_21550 + ceil32(return_data.size) + 228] = 0
                                            mem[_21550 + ceil32(return_data.size) + 260] = 0
                                            mem[_21550 + ceil32(return_data.size) + 292] = stor17
                                            mem[_21550 + ceil32(return_data.size) + 324] = block.timestamp
                                            call uniswapV2RouterAddress.addLiquidityETH(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                 gas gas_remaining wei
                                                args this.address, (0 / totalFees) - (0 / totalFees / 2), 0, 0, stor17, block.timestamp
                                            mem[_21550 + ceil32(return_data.size) + 160 len 96] = ext_call.return_data[0 len 96]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 96
                                            emit SwapAndLiquify(Mask(255, 1, 0 / totalFees), 0, (0 / totalFees) - (0 / totalFees / 2));
                                            mem[_21550 + (2 * ceil32(return_data.size)) + 160] = 3
                                            mem[_21550 + (2 * ceil32(return_data.size)) + 192] = this.address
                                            staticcall uniswapV2RouterAddress.WETH() with:
                                                    gas gas_remaining wei
                                            mem[_21550 + (2 * ceil32(return_data.size)) + 288] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                            mem[_21550 + (2 * ceil32(return_data.size)) + 224] = ext_call.return_data[12 len 20]
                                            mem[_21550 + (2 * ceil32(return_data.size)) + 256] = sub_4d7effddAddress
                                            if not this.address:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not uniswapV2RouterAddress:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(this.address)][stor6].field_0 = balanceOf[this.address]
                                            emit Approval(balanceOf[this.address], this.address, uniswapV2RouterAddress);
                                            mem[_21550 + (4 * ceil32(return_data.size)) + 288] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                            mem[_21550 + (4 * ceil32(return_data.size)) + 292] = balanceOf[this.address]
                                            mem[_21550 + (4 * ceil32(return_data.size)) + 324] = 0
                                            mem[_21550 + (4 * ceil32(return_data.size)) + 356] = 160
                                            mem[_21550 + (4 * ceil32(return_data.size)) + 452] = 3
                                            idx = 0
                                            s = _21550 + (4 * ceil32(return_data.size)) + 484
                                            t = _21550 + (2 * ceil32(return_data.size)) + 192
                                            while idx < mem[_21550 + (2 * ceil32(return_data.size)) + 160]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_21550 + (4 * ceil32(return_data.size)) + 388] = this.address
                                            mem[_21550 + (4 * ceil32(return_data.size)) + 420] = block.timestamp
                                            require ext_code.size(uniswapV2RouterAddress)
                                            call uniswapV2RouterAddress.swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                 gas gas_remaining wei
                                                args balanceOf[this.address], 0, 160, address(this.address), block.timestamp, mem[_21550 + (4 * ceil32(return_data.size)) + 452 len (32 * mem[_21550 + (2 * ceil32(return_data.size)) + 160]) + 32]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            staticcall sub_4d7effddAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            require return_data.size >= 32
                                            mem[_21550 + (4 * ceil32(return_data.size)) + 292] = dividendTrackerAddress
                                            mem[_21550 + (4 * ceil32(return_data.size)) + 324] = ext_call.return_data[0]
                                            call sub_4d7effddAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args mem[_21550 + (4 * ceil32(return_data.size)) + 292 len (7 * ceil32(return_data.size)) + 64]
                                            mem[_21550 + (4 * ceil32(return_data.size)) + 288] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                            if ext_call.return_data[0]:
                                                require ext_code.size(dividendTrackerAddress)
                                                call dividendTrackerAddress.distributeDogeDividends(uint256 arg1) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                emit SendDividends(balanceOf[this.address], ext_call.return_data[0]);
                                            stor7 = 0
                                            if stor19[address(msg.sender)]:
                                                if not msg.sender:
                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 288] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 292] = 32
                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 324] = 37
                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 356] = 'ERC20: transfer from the zero ad'
                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 388] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                    revert with memory
                                                      from _21550 + (8 * ceil32(return_data.size)) + 288
                                                       len (13 * ceil32(return_data.size)) + 132
                                                if not address(cd[4]):
                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 288] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 292] = 32
                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 324] = 35
                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 356] = 'ERC20: transfer to the zero addr'
                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 388] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                    revert with memory
                                                      from _21550 + (8 * ceil32(return_data.size)) + 288
                                                       len (13 * ceil32(return_data.size)) + 132
                                                if cd[36] > balanceOf[address(msg.sender)]:
                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 384] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 388] = 32
                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 420] = 38
                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 452 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_21550 + (8 * ceil32(return_data.size)) + 358 len 26]
                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 490] = 0
                                                    revert with memory
                                                      from _21550 + (8 * ceil32(return_data.size)) + 384
                                                       len (13 * ceil32(return_data.size)) + 132
                                                if balanceOf[address(msg.sender)] < cd[36]:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= cd[36]
                                                if balanceOf[address(cd[4])] > !cd[36]:
                                                    revert with 0, 17
                                                if balanceOf[address(cd[4])] + cd[36] < balanceOf[address(cd[4])]:
                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 384] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 388] = 32
                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 420] = 27
                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 452] = 'SafeMath: addition overflow'
                                                    revert with memory
                                                      from _21550 + (8 * ceil32(return_data.size)) + 384
                                                       len (13 * ceil32(return_data.size)) + 100
                                                balanceOf[address(cd[4])] += cd[36]
                                                emit Transfer(cd[36], msg.sender, address(cd[4]));
                                                mem[_21550 + (8 * ceil32(return_data.size)) + 388] = msg.sender
                                                mem[_21550 + (8 * ceil32(return_data.size)) + 420] = balanceOf[address(msg.sender)]
                                                require ext_code.size(dividendTrackerAddress)
                                                call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args mem[_21550 + (8 * ceil32(return_data.size)) + 388 len (13 * ceil32(return_data.size)) + 64]
                                                mem[_21550 + (8 * ceil32(return_data.size)) + 388] = address(cd[4])
                                                mem[_21550 + (8 * ceil32(return_data.size)) + 420] = balanceOf[address(cd[4])]
                                                require ext_code.size(dividendTrackerAddress)
                                                call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args mem[_21550 + (8 * ceil32(return_data.size)) + 388 len (13 * ceil32(return_data.size)) + 64]
                                                if not stor7:
                                                    call dividendTrackerAddress.process(uint256 arg1) with:
                                                         gas gas_remaining wei
                                                        args gasForProcessing
                                                    if ext_call.success:
                                                        require return_data.size >= 96
                                                        emit ProcessedDividendTracker(uint256 arg1, uint256 arg2, uint256 arg3, bool arg4, uint256 arg5, address arg6):
                                                                                      ext_call.return_data[0],
                                                                                      ext_call.return_data[32],
                                                                                      ext_call.return_data[64],
                                                                                      gasForProcessing,
                                                                                      mem[_21550 + (9 * ceil32(return_data.size)) + 512 len 5 * ceil32(return_data.size)],
                                                                                      1,
                                                                                      tx.origin,
                                            else:
                                                if stor19[address(cd[4])]:
                                                    if not msg.sender:
                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 288] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 292] = 32
                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 324] = 37
                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 356] = 'ERC20: transfer from the zero ad'
                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 388] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                        revert with memory
                                                          from _21550 + (8 * ceil32(return_data.size)) + 288
                                                           len (13 * ceil32(return_data.size)) + 132
                                                    if not address(cd[4]):
                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 288] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 292] = 32
                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 324] = 35
                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 356] = 'ERC20: transfer to the zero addr'
                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 388] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                        revert with memory
                                                          from _21550 + (8 * ceil32(return_data.size)) + 288
                                                           len (13 * ceil32(return_data.size)) + 132
                                                    if cd[36] > balanceOf[address(msg.sender)]:
                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 384] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 388] = 32
                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 420] = 38
                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 452 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_21550 + (8 * ceil32(return_data.size)) + 358 len 26]
                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 490] = 0
                                                        revert with memory
                                                          from _21550 + (8 * ceil32(return_data.size)) + 384
                                                           len (13 * ceil32(return_data.size)) + 132
                                                    if balanceOf[address(msg.sender)] < cd[36]:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= cd[36]
                                                    if balanceOf[address(cd[4])] > !cd[36]:
                                                        revert with 0, 17
                                                    if balanceOf[address(cd[4])] + cd[36] < balanceOf[address(cd[4])]:
                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 384] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 388] = 32
                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 420] = 27
                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 452] = 'SafeMath: addition overflow'
                                                        revert with memory
                                                          from _21550 + (8 * ceil32(return_data.size)) + 384
                                                           len (13 * ceil32(return_data.size)) + 100
                                                    balanceOf[address(cd[4])] += cd[36]
                                                    emit Transfer(cd[36], msg.sender, address(cd[4]));
                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 388] = msg.sender
                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 420] = balanceOf[address(msg.sender)]
                                                    require ext_code.size(dividendTrackerAddress)
                                                    call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args mem[_21550 + (8 * ceil32(return_data.size)) + 388 len (13 * ceil32(return_data.size)) + 64]
                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 388] = address(cd[4])
                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 420] = balanceOf[address(cd[4])]
                                                    require ext_code.size(dividendTrackerAddress)
                                                    call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args mem[_21550 + (8 * ceil32(return_data.size)) + 388 len (13 * ceil32(return_data.size)) + 64]
                                                    if not stor7:
                                                        call dividendTrackerAddress.process(uint256 arg1) with:
                                                             gas gas_remaining wei
                                                            args gasForProcessing
                                                        if ext_call.success:
                                                            require return_data.size >= 96
                                                            emit ProcessedDividendTracker(uint256 arg1, uint256 arg2, uint256 arg3, bool arg4, uint256 arg5, address arg6):
                                                                                          ext_call.return_data[0],
                                                                                          ext_call.return_data[32],
                                                                                          ext_call.return_data[64],
                                                                                          gasForProcessing,
                                                                                          mem[_21550 + (9 * ceil32(return_data.size)) + 512 len 5 * ceil32(return_data.size)],
                                                                                          1,
                                                                                          tx.origin,
                                                else:
                                                    if stor7:
                                                        if not msg.sender:
                                                            mem[_21550 + (8 * ceil32(return_data.size)) + 288] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_21550 + (8 * ceil32(return_data.size)) + 292] = 32
                                                            mem[_21550 + (8 * ceil32(return_data.size)) + 324] = 37
                                                            mem[_21550 + (8 * ceil32(return_data.size)) + 356] = 'ERC20: transfer from the zero ad'
                                                            mem[_21550 + (8 * ceil32(return_data.size)) + 388] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                            revert with memory
                                                              from _21550 + (8 * ceil32(return_data.size)) + 288
                                                               len (13 * ceil32(return_data.size)) + 132
                                                        if not address(cd[4]):
                                                            mem[_21550 + (8 * ceil32(return_data.size)) + 288] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_21550 + (8 * ceil32(return_data.size)) + 292] = 32
                                                            mem[_21550 + (8 * ceil32(return_data.size)) + 324] = 35
                                                            mem[_21550 + (8 * ceil32(return_data.size)) + 356] = 'ERC20: transfer to the zero addr'
                                                            mem[_21550 + (8 * ceil32(return_data.size)) + 388] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                            revert with memory
                                                              from _21550 + (8 * ceil32(return_data.size)) + 288
                                                               len (13 * ceil32(return_data.size)) + 132
                                                        if cd[36] > balanceOf[address(msg.sender)]:
                                                            mem[_21550 + (8 * ceil32(return_data.size)) + 384] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_21550 + (8 * ceil32(return_data.size)) + 388] = 32
                                                            mem[_21550 + (8 * ceil32(return_data.size)) + 420] = 38
                                                            mem[_21550 + (8 * ceil32(return_data.size)) + 452 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_21550 + (8 * ceil32(return_data.size)) + 358 len 26]
                                                            mem[_21550 + (8 * ceil32(return_data.size)) + 490] = 0
                                                            revert with memory
                                                              from _21550 + (8 * ceil32(return_data.size)) + 384
                                                               len (13 * ceil32(return_data.size)) + 132
                                                        if balanceOf[address(msg.sender)] < cd[36]:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] -= cd[36]
                                                        if balanceOf[address(cd[4])] > !cd[36]:
                                                            revert with 0, 17
                                                        if balanceOf[address(cd[4])] + cd[36] < balanceOf[address(cd[4])]:
                                                            mem[_21550 + (8 * ceil32(return_data.size)) + 384] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[_21550 + (8 * ceil32(return_data.size)) + 388] = 32
                                                            mem[_21550 + (8 * ceil32(return_data.size)) + 420] = 27
                                                            mem[_21550 + (8 * ceil32(return_data.size)) + 452] = 'SafeMath: addition overflow'
                                                            revert with memory
                                                              from _21550 + (8 * ceil32(return_data.size)) + 384
                                                               len (13 * ceil32(return_data.size)) + 100
                                                        balanceOf[address(cd[4])] += cd[36]
                                                        emit Transfer(cd[36], msg.sender, address(cd[4]));
                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 388] = msg.sender
                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 420] = balanceOf[address(msg.sender)]
                                                        require ext_code.size(dividendTrackerAddress)
                                                        call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args mem[_21550 + (8 * ceil32(return_data.size)) + 388 len (13 * ceil32(return_data.size)) + 64]
                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 388] = address(cd[4])
                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 420] = balanceOf[address(cd[4])]
                                                        require ext_code.size(dividendTrackerAddress)
                                                        call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args mem[_21550 + (8 * ceil32(return_data.size)) + 388 len (13 * ceil32(return_data.size)) + 64]
                                                        if not stor7:
                                                            call dividendTrackerAddress.process(uint256 arg1) with:
                                                                 gas gas_remaining wei
                                                                args gasForProcessing
                                                            if ext_call.success:
                                                                require return_data.size >= 96
                                                                emit ProcessedDividendTracker(uint256 arg1, uint256 arg2, uint256 arg3, bool arg4, uint256 arg5, address arg6):
                                                                                              ext_call.return_data[0],
                                                                                              ext_call.return_data[32],
                                                                                              ext_call.return_data[64],
                                                                                              gasForProcessing,
                                                                                              mem[_21550 + (9 * ceil32(return_data.size)) + 512 len 5 * ceil32(return_data.size)],
                                                                                              1,
                                                                                              tx.origin,
                                                    else:
                                                        if not cd[36]:
                                                            if not stor20[address(cd[4])]:
                                                                if 0 > cd[36]:
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 420] = 32
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 452] = 30
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 484] = 'SafeMath: subtraction overflow'
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 514] = 0
                                                                    revert with memory
                                                                      from _21550 + (8 * ceil32(return_data.size)) + 416
                                                                       len (13 * ceil32(return_data.size)) + 100
                                                                if cd[36] < 0:
                                                                    revert with 0, 17
                                                                if not msg.sender:
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 420] = 32
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 452] = 37
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 484] = 'ERC20: transfer from the zero ad'
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 516] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                                    revert with memory
                                                                      from _21550 + (8 * ceil32(return_data.size)) + 416
                                                                       len (13 * ceil32(return_data.size)) + 132
                                                                if not this.address:
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 420] = 32
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 452] = 35
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 484] = 'ERC20: transfer to the zero addr'
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 516] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                                    revert with memory
                                                                      from _21550 + (8 * ceil32(return_data.size)) + 416
                                                                       len (13 * ceil32(return_data.size)) + 132
                                                                if 0 > balanceOf[address(msg.sender)]:
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 512] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 516] = 32
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 548] = 38
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 580 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_21550 + (8 * ceil32(return_data.size)) + 486 len 26]
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 618] = 0
                                                                    revert with memory
                                                                      from _21550 + (8 * ceil32(return_data.size)) + 512
                                                                       len (13 * ceil32(return_data.size)) + 132
                                                                if balanceOf[address(msg.sender)] < 0:
                                                                    revert with 0, 17
                                                                if balanceOf[this.address] > -1:
                                                                    revert with 0, 17
                                                                if balanceOf[this.address] < balanceOf[this.address]:
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 512] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 516] = 32
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 548] = 27
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 580] = 'SafeMath: addition overflow'
                                                                    revert with memory
                                                                      from _21550 + (8 * ceil32(return_data.size)) + 512
                                                                       len (13 * ceil32(return_data.size)) + 100
                                                                balanceOf[address(this.address)] = balanceOf[this.address]
                                                                emit Transfer(0, msg.sender, this.address);
                                                                if not msg.sender:
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 512] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 516] = 32
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 548] = 37
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 580] = 'ERC20: transfer from the zero ad'
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 612] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                                    revert with memory
                                                                      from _21550 + (8 * ceil32(return_data.size)) + 512
                                                                       len (13 * ceil32(return_data.size)) + 132
                                                                if not address(cd[4]):
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 512] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 516] = 32
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 548] = 35
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 580] = 'ERC20: transfer to the zero addr'
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 612] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                                    revert with memory
                                                                      from _21550 + (8 * ceil32(return_data.size)) + 512
                                                                       len (13 * ceil32(return_data.size)) + 132
                                                                if cd[36] > balanceOf[address(msg.sender)]:
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 608] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 612] = 32
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 644] = 38
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 676 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_21550 + (8 * ceil32(return_data.size)) + 582 len 26]
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 714] = 0
                                                                    revert with memory
                                                                      from _21550 + (8 * ceil32(return_data.size)) + 608
                                                                       len (13 * ceil32(return_data.size)) + 132
                                                                if balanceOf[address(msg.sender)] < cd[36]:
                                                                    revert with 0, 17
                                                                balanceOf[address(msg.sender)] -= cd[36]
                                                                if balanceOf[address(cd[4])] > !cd[36]:
                                                                    revert with 0, 17
                                                                if balanceOf[address(cd[4])] + cd[36] < balanceOf[address(cd[4])]:
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 608] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 612] = 32
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 644] = 27
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 676] = 'SafeMath: addition overflow'
                                                                    revert with memory
                                                                      from _21550 + (8 * ceil32(return_data.size)) + 608
                                                                       len (13 * ceil32(return_data.size)) + 100
                                                                balanceOf[address(cd[4])] += cd[36]
                                                                emit Transfer(cd[36], msg.sender, address(cd[4]));
                                                                mem[_21550 + (8 * ceil32(return_data.size)) + 612] = msg.sender
                                                                mem[_21550 + (8 * ceil32(return_data.size)) + 644] = balanceOf[address(msg.sender)]
                                                                require ext_code.size(dividendTrackerAddress)
                                                                call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                                     gas gas_remaining wei
                                                                    args mem[_21550 + (8 * ceil32(return_data.size)) + 612 len (13 * ceil32(return_data.size)) + 64]
                                                                mem[_21550 + (8 * ceil32(return_data.size)) + 612] = address(cd[4])
                                                                mem[_21550 + (8 * ceil32(return_data.size)) + 644] = balanceOf[address(cd[4])]
                                                                require ext_code.size(dividendTrackerAddress)
                                                                call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                                     gas gas_remaining wei
                                                                    args mem[_21550 + (8 * ceil32(return_data.size)) + 612 len (13 * ceil32(return_data.size)) + 64]
                                                                if not stor7:
                                                                    call dividendTrackerAddress.process(uint256 arg1) with:
                                                                         gas gas_remaining wei
                                                                        args gasForProcessing
                                                                    if ext_call.success:
                                                                        require return_data.size >= 96
                                                                        emit ProcessedDividendTracker(uint256 arg1, uint256 arg2, uint256 arg3, bool arg4, uint256 arg5, address arg6):
                                                                                                      ext_call.return_data[0],
                                                                                                      ext_call.return_data[32],
                                                                                                      ext_call.return_data[64],
                                                                                                      gasForProcessing,
                                                                                                      mem[_21550 + (9 * ceil32(return_data.size)) + 736 len 5 * ceil32(return_data.size)],
                                                                                                      1,
                                                                                                      tx.origin,
                                                            else:
                                                                if not cd[36]:
                                                                    if 0 > cd[36]:
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 480] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 484] = 32
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 516] = 30
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 548] = 'SafeMath: subtraction overflow'
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 578] = 0
                                                                        revert with memory
                                                                          from _21550 + (8 * ceil32(return_data.size)) + 480
                                                                           len (13 * ceil32(return_data.size)) + 100
                                                                    if cd[36] < 0:
                                                                        revert with 0, 17
                                                                    if not msg.sender:
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 480] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 484] = 32
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 516] = 37
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 548] = 'ERC20: transfer from the zero ad'
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 580] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                                        revert with memory
                                                                          from _21550 + (8 * ceil32(return_data.size)) + 480
                                                                           len (13 * ceil32(return_data.size)) + 132
                                                                    if not this.address:
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 480] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 484] = 32
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 516] = 35
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 548] = 'ERC20: transfer to the zero addr'
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 580] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                                        revert with memory
                                                                          from _21550 + (8 * ceil32(return_data.size)) + 480
                                                                           len (13 * ceil32(return_data.size)) + 132
                                                                    if 0 > balanceOf[address(msg.sender)]:
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 576] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 580] = 32
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 612] = 38
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 644 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_21550 + (8 * ceil32(return_data.size)) + 550 len 26]
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 682] = 0
                                                                        revert with memory
                                                                          from _21550 + (8 * ceil32(return_data.size)) + 576
                                                                           len (13 * ceil32(return_data.size)) + 132
                                                                    if balanceOf[address(msg.sender)] < 0:
                                                                        revert with 0, 17
                                                                    if balanceOf[this.address] > -1:
                                                                        revert with 0, 17
                                                                    if balanceOf[this.address] < balanceOf[this.address]:
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 576] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 580] = 32
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 612] = 27
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 644] = 'SafeMath: addition overflow'
                                                                        revert with memory
                                                                          from _21550 + (8 * ceil32(return_data.size)) + 576
                                                                           len (13 * ceil32(return_data.size)) + 100
                                                                    balanceOf[address(this.address)] = balanceOf[this.address]
                                                                    emit Transfer(0, msg.sender, this.address);
                                                                    if not msg.sender:
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 576] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 580] = 32
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 612] = 37
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 644] = 'ERC20: transfer from the zero ad'
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 676] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                                        revert with memory
                                                                          from _21550 + (8 * ceil32(return_data.size)) + 576
                                                                           len (13 * ceil32(return_data.size)) + 132
                                                                    if not address(cd[4]):
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 576] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 580] = 32
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 612] = 35
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 644] = 'ERC20: transfer to the zero addr'
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 676] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                                        revert with memory
                                                                          from _21550 + (8 * ceil32(return_data.size)) + 576
                                                                           len (13 * ceil32(return_data.size)) + 132
                                                                    if cd[36] > balanceOf[address(msg.sender)]:
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 672] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 676] = 32
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 708] = 38
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 740 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_21550 + (8 * ceil32(return_data.size)) + 646 len 26]
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 778] = 0
                                                                        revert with memory
                                                                          from _21550 + (8 * ceil32(return_data.size)) + 672
                                                                           len (13 * ceil32(return_data.size)) + 132
                                                                    if balanceOf[address(msg.sender)] < cd[36]:
                                                                        revert with 0, 17
                                                                    balanceOf[address(msg.sender)] -= cd[36]
                                                                    if balanceOf[address(cd[4])] > !cd[36]:
                                                                        revert with 0, 17
                                                                    if balanceOf[address(cd[4])] + cd[36] < balanceOf[address(cd[4])]:
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 672] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 676] = 32
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 708] = 27
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 740] = 'SafeMath: addition overflow'
                                                                        revert with memory
                                                                          from _21550 + (8 * ceil32(return_data.size)) + 672
                                                                           len (13 * ceil32(return_data.size)) + 100
                                                                    balanceOf[address(cd[4])] += cd[36]
                                                                    emit Transfer(cd[36], msg.sender, address(cd[4]));
                                                                else:
                                                                    if cd[36] and 1 > -1 / cd[36]:
                                                                        revert with 0, 17
                                                                    if not cd[36]:
                                                                        revert with 0, 18
                                                                    if cd[36] / cd[36] != 1:
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 352] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 356] = 32
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 388] = 33
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 420] = 'SafeMath: multiplication overflo'
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 452] = 0x7700000000000000000000000000000000000000000000000000000000000000
                                                                        revert with memory
                                                                          from _21550 + (8 * ceil32(return_data.size)) + 352
                                                                           len (13 * ceil32(return_data.size)) + 132
                                                                    if 0 > !(cd[36] / 100):
                                                                        revert with 0, 17
                                                                    if cd[36] / 100 > cd[36]:
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 480] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 484] = 32
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 516] = 30
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 548] = 'SafeMath: subtraction overflow'
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 578] = 0
                                                                        revert with memory
                                                                          from _21550 + (8 * ceil32(return_data.size)) + 480
                                                                           len (13 * ceil32(return_data.size)) + 100
                                                                    if cd[36] < cd[36] / 100:
                                                                        revert with 0, 17
                                                                    if not msg.sender:
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 480] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 484] = 32
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 516] = 37
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 548] = 'ERC20: transfer from the zero ad'
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 580] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                                        revert with memory
                                                                          from _21550 + (8 * ceil32(return_data.size)) + 480
                                                                           len (13 * ceil32(return_data.size)) + 132
                                                                    if not this.address:
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 480] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 484] = 32
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 516] = 35
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 548] = 'ERC20: transfer to the zero addr'
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 580] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                                        revert with memory
                                                                          from _21550 + (8 * ceil32(return_data.size)) + 480
                                                                           len (13 * ceil32(return_data.size)) + 132
                                                                    if cd[36] / 100 > balanceOf[address(msg.sender)]:
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 576] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 580] = 32
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 612] = 38
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 644 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_21550 + (8 * ceil32(return_data.size)) + 550 len 26]
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 682] = 0
                                                                        revert with memory
                                                                          from _21550 + (8 * ceil32(return_data.size)) + 576
                                                                           len (13 * ceil32(return_data.size)) + 132
                                                                    if balanceOf[address(msg.sender)] < cd[36] / 100:
                                                                        revert with 0, 17
                                                                    balanceOf[address(msg.sender)] -= cd[36] / 100
                                                                    if balanceOf[this.address] > !(cd[36] / 100):
                                                                        revert with 0, 17
                                                                    if balanceOf[this.address] + (cd[36] / 100) < balanceOf[this.address]:
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 576] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 580] = 32
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 612] = 27
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 644] = 'SafeMath: addition overflow'
                                                                        revert with memory
                                                                          from _21550 + (8 * ceil32(return_data.size)) + 576
                                                                           len (13 * ceil32(return_data.size)) + 100
                                                                    balanceOf[address(this.address)] = balanceOf[this.address] + (cd[36] / 100)
                                                                    emit Transfer((cd[36] / 100), msg.sender, this.address);
                                                                    if not msg.sender:
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 576] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 580] = 32
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 612] = 37
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 644] = 'ERC20: transfer from the zero ad'
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 676] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                                        revert with memory
                                                                          from _21550 + (8 * ceil32(return_data.size)) + 576
                                                                           len (13 * ceil32(return_data.size)) + 132
                                                                    if not address(cd[4]):
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 576] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 580] = 32
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 612] = 35
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 644] = 'ERC20: transfer to the zero addr'
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 676] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                                        revert with memory
                                                                          from _21550 + (8 * ceil32(return_data.size)) + 576
                                                                           len (13 * ceil32(return_data.size)) + 132
                                                                    if cd[36] - (cd[36] / 100) > balanceOf[address(msg.sender)]:
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 672] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 676] = 32
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 708] = 38
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 740 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_21550 + (8 * ceil32(return_data.size)) + 646 len 26]
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 778] = 0
                                                                        revert with memory
                                                                          from _21550 + (8 * ceil32(return_data.size)) + 672
                                                                           len (13 * ceil32(return_data.size)) + 132
                                                                    if balanceOf[address(msg.sender)] < cd[36] - (cd[36] / 100):
                                                                        revert with 0, 17
                                                                    balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - cd[36] + (cd[36] / 100)
                                                                    if balanceOf[address(cd[4])] > !(cd[36] - (cd[36] / 100)):
                                                                        revert with 0, 17
                                                                    if balanceOf[address(cd[4])] + cd[36] - (cd[36] / 100) < balanceOf[address(cd[4])]:
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 672] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 676] = 32
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 708] = 27
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 740] = 'SafeMath: addition overflow'
                                                                        revert with memory
                                                                          from _21550 + (8 * ceil32(return_data.size)) + 672
                                                                           len (13 * ceil32(return_data.size)) + 100
                                                                    balanceOf[address(cd[4])] = balanceOf[address(cd[4])] + cd[36] - (cd[36] / 100)
                                                                    emit Transfer((cd[36] - (cd[36] / 100)), msg.sender, address(cd[4]));
                                                                mem[_21550 + (8 * ceil32(return_data.size)) + 676] = msg.sender
                                                                mem[_21550 + (8 * ceil32(return_data.size)) + 708] = balanceOf[address(msg.sender)]
                                                                require ext_code.size(dividendTrackerAddress)
                                                                call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                                     gas gas_remaining wei
                                                                    args mem[_21550 + (8 * ceil32(return_data.size)) + 676 len (13 * ceil32(return_data.size)) + 64]
                                                                mem[_21550 + (8 * ceil32(return_data.size)) + 676] = address(cd[4])
                                                                mem[_21550 + (8 * ceil32(return_data.size)) + 708] = balanceOf[address(cd[4])]
                                                                require ext_code.size(dividendTrackerAddress)
                                                                call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                                     gas gas_remaining wei
                                                                    args mem[_21550 + (8 * ceil32(return_data.size)) + 676 len (13 * ceil32(return_data.size)) + 64]
                                                                if not stor7:
                                                                    call dividendTrackerAddress.process(uint256 arg1) with:
                                                                         gas gas_remaining wei
                                                                        args gasForProcessing
                                                                    if ext_call.success:
                                                                        require return_data.size >= 96
                                                                        emit ProcessedDividendTracker(uint256 arg1, uint256 arg2, uint256 arg3, bool arg4, uint256 arg5, address arg6):
                                                                                                      ext_call.return_data[0],
                                                                                                      ext_call.return_data[32],
                                                                                                      ext_call.return_data[64],
                                                                                                      gasForProcessing,
                                                                                                      mem[_21550 + (9 * ceil32(return_data.size)) + 800 len 5 * ceil32(return_data.size)],
                                                                                                      1,
                                                                                                      tx.origin,
                                                        else:
                                                            if cd[36] and totalFees > -1 / cd[36]:
                                                                revert with 0, 17
                                                            if not cd[36]:
                                                                revert with 0, 18
                                                            if cd[36] * totalFees / cd[36] != totalFees:
                                                                mem[_21550 + (8 * ceil32(return_data.size)) + 288] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[_21550 + (8 * ceil32(return_data.size)) + 292] = 32
                                                                mem[_21550 + (8 * ceil32(return_data.size)) + 324] = 33
                                                                mem[_21550 + (8 * ceil32(return_data.size)) + 356] = 'SafeMath: multiplication overflo'
                                                                mem[_21550 + (8 * ceil32(return_data.size)) + 388] = 0x7700000000000000000000000000000000000000000000000000000000000000
                                                                revert with memory
                                                                  from _21550 + (8 * ceil32(return_data.size)) + 288
                                                                   len (13 * ceil32(return_data.size)) + 132
                                                            if not stor20[address(cd[4])]:
                                                                if cd[36] * totalFees / 100 > cd[36]:
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 420] = 32
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 452] = 30
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 484] = 'SafeMath: subtraction overflow'
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 514] = 0
                                                                    revert with memory
                                                                      from _21550 + (8 * ceil32(return_data.size)) + 416
                                                                       len (13 * ceil32(return_data.size)) + 100
                                                                if cd[36] < cd[36] * totalFees / 100:
                                                                    revert with 0, 17
                                                                if not msg.sender:
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 420] = 32
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 452] = 37
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 484] = 'ERC20: transfer from the zero ad'
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 516] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                                    revert with memory
                                                                      from _21550 + (8 * ceil32(return_data.size)) + 416
                                                                       len (13 * ceil32(return_data.size)) + 132
                                                                if not this.address:
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 416] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 420] = 32
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 452] = 35
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 484] = 'ERC20: transfer to the zero addr'
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 516] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                                    revert with memory
                                                                      from _21550 + (8 * ceil32(return_data.size)) + 416
                                                                       len (13 * ceil32(return_data.size)) + 132
                                                                if cd[36] * totalFees / 100 > balanceOf[address(msg.sender)]:
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 512] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 516] = 32
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 548] = 38
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 580 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_21550 + (8 * ceil32(return_data.size)) + 486 len 26]
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 618] = 0
                                                                    revert with memory
                                                                      from _21550 + (8 * ceil32(return_data.size)) + 512
                                                                       len (13 * ceil32(return_data.size)) + 132
                                                                if balanceOf[address(msg.sender)] < cd[36] * totalFees / 100:
                                                                    revert with 0, 17
                                                                balanceOf[address(msg.sender)] -= cd[36] * totalFees / 100
                                                                if balanceOf[this.address] > !(cd[36] * totalFees / 100):
                                                                    revert with 0, 17
                                                                if balanceOf[this.address] + (cd[36] * totalFees / 100) < balanceOf[this.address]:
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 512] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 516] = 32
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 548] = 27
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 580] = 'SafeMath: addition overflow'
                                                                    revert with memory
                                                                      from _21550 + (8 * ceil32(return_data.size)) + 512
                                                                       len (13 * ceil32(return_data.size)) + 100
                                                                balanceOf[address(this.address)] = balanceOf[this.address] + (cd[36] * totalFees / 100)
                                                                emit Transfer((cd[36] * totalFees / 100), msg.sender, this.address);
                                                                if not msg.sender:
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 512] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 516] = 32
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 548] = 37
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 580] = 'ERC20: transfer from the zero ad'
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 612] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                                    revert with memory
                                                                      from _21550 + (8 * ceil32(return_data.size)) + 512
                                                                       len (13 * ceil32(return_data.size)) + 132
                                                                if not address(cd[4]):
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 512] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 516] = 32
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 548] = 35
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 580] = 'ERC20: transfer to the zero addr'
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 612] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                                    revert with memory
                                                                      from _21550 + (8 * ceil32(return_data.size)) + 512
                                                                       len (13 * ceil32(return_data.size)) + 132
                                                                if cd[36] - (cd[36] * totalFees / 100) > balanceOf[address(msg.sender)]:
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 608] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 612] = 32
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 644] = 38
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 676 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_21550 + (8 * ceil32(return_data.size)) + 582 len 26]
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 714] = 0
                                                                    revert with memory
                                                                      from _21550 + (8 * ceil32(return_data.size)) + 608
                                                                       len (13 * ceil32(return_data.size)) + 132
                                                                if balanceOf[address(msg.sender)] < cd[36] - (cd[36] * totalFees / 100):
                                                                    revert with 0, 17
                                                                balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - cd[36] + (cd[36] * totalFees / 100)
                                                                if balanceOf[address(cd[4])] > !(cd[36] - (cd[36] * totalFees / 100)):
                                                                    revert with 0, 17
                                                                if balanceOf[address(cd[4])] + cd[36] - (cd[36] * totalFees / 100) < balanceOf[address(cd[4])]:
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 608] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 612] = 32
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 644] = 27
                                                                    mem[_21550 + (8 * ceil32(return_data.size)) + 676] = 'SafeMath: addition overflow'
                                                                    revert with memory
                                                                      from _21550 + (8 * ceil32(return_data.size)) + 608
                                                                       len (13 * ceil32(return_data.size)) + 100
                                                                balanceOf[address(cd[4])] = balanceOf[address(cd[4])] + cd[36] - (cd[36] * totalFees / 100)
                                                                emit Transfer((cd[36] - (cd[36] * totalFees / 100)), msg.sender, address(cd[4]));
                                                                mem[_21550 + (8 * ceil32(return_data.size)) + 612] = msg.sender
                                                                mem[_21550 + (8 * ceil32(return_data.size)) + 644] = balanceOf[address(msg.sender)]
                                                                require ext_code.size(dividendTrackerAddress)
                                                                call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                                     gas gas_remaining wei
                                                                    args mem[_21550 + (8 * ceil32(return_data.size)) + 612 len (13 * ceil32(return_data.size)) + 64]
                                                                mem[_21550 + (8 * ceil32(return_data.size)) + 612] = address(cd[4])
                                                                mem[_21550 + (8 * ceil32(return_data.size)) + 644] = balanceOf[address(cd[4])]
                                                                require ext_code.size(dividendTrackerAddress)
                                                                call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                                     gas gas_remaining wei
                                                                    args mem[_21550 + (8 * ceil32(return_data.size)) + 612 len (13 * ceil32(return_data.size)) + 64]
                                                                if not stor7:
                                                                    call dividendTrackerAddress.process(uint256 arg1) with:
                                                                         gas gas_remaining wei
                                                                        args gasForProcessing
                                                                    if ext_call.success:
                                                                        require return_data.size >= 96
                                                                        emit ProcessedDividendTracker(uint256 arg1, uint256 arg2, uint256 arg3, bool arg4, uint256 arg5, address arg6):
                                                                                                      ext_call.return_data[0],
                                                                                                      ext_call.return_data[32],
                                                                                                      ext_call.return_data[64],
                                                                                                      gasForProcessing,
                                                                                                      mem[_21550 + (9 * ceil32(return_data.size)) + 736 len 5 * ceil32(return_data.size)],
                                                                                                      1,
                                                                                                      tx.origin,
                                                            else:
                                                                if not cd[36]:
                                                                    if cd[36] * totalFees / 100 > -1:
                                                                        revert with 0, 17
                                                                    if cd[36] * totalFees / 100 > cd[36]:
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 480] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 484] = 32
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 516] = 30
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 548] = 'SafeMath: subtraction overflow'
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 578] = 0
                                                                        revert with memory
                                                                          from _21550 + (8 * ceil32(return_data.size)) + 480
                                                                           len (13 * ceil32(return_data.size)) + 100
                                                                    if cd[36] < cd[36] * totalFees / 100:
                                                                        revert with 0, 17
                                                                    if not msg.sender:
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 480] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 484] = 32
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 516] = 37
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 548] = 'ERC20: transfer from the zero ad'
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 580] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                                        revert with memory
                                                                          from _21550 + (8 * ceil32(return_data.size)) + 480
                                                                           len (13 * ceil32(return_data.size)) + 132
                                                                    if not this.address:
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 480] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 484] = 32
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 516] = 35
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 548] = 'ERC20: transfer to the zero addr'
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 580] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                                        revert with memory
                                                                          from _21550 + (8 * ceil32(return_data.size)) + 480
                                                                           len (13 * ceil32(return_data.size)) + 132
                                                                    if cd[36] * totalFees / 100 > balanceOf[address(msg.sender)]:
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 576] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 580] = 32
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 612] = 38
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 644 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_21550 + (8 * ceil32(return_data.size)) + 550 len 26]
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 682] = 0
                                                                        revert with memory
                                                                          from _21550 + (8 * ceil32(return_data.size)) + 576
                                                                           len (13 * ceil32(return_data.size)) + 132
                                                                    if balanceOf[address(msg.sender)] < cd[36] * totalFees / 100:
                                                                        revert with 0, 17
                                                                    balanceOf[address(msg.sender)] -= cd[36] * totalFees / 100
                                                                    if balanceOf[this.address] > !(cd[36] * totalFees / 100):
                                                                        revert with 0, 17
                                                                    if balanceOf[this.address] + (cd[36] * totalFees / 100) < balanceOf[this.address]:
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 576] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 580] = 32
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 612] = 27
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 644] = 'SafeMath: addition overflow'
                                                                        revert with memory
                                                                          from _21550 + (8 * ceil32(return_data.size)) + 576
                                                                           len (13 * ceil32(return_data.size)) + 100
                                                                    balanceOf[address(this.address)] = balanceOf[this.address] + (cd[36] * totalFees / 100)
                                                                    emit Transfer((cd[36] * totalFees / 100), msg.sender, this.address);
                                                                    if not msg.sender:
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 576] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 580] = 32
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 612] = 37
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 644] = 'ERC20: transfer from the zero ad'
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 676] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                                        revert with memory
                                                                          from _21550 + (8 * ceil32(return_data.size)) + 576
                                                                           len (13 * ceil32(return_data.size)) + 132
                                                                    if not address(cd[4]):
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 576] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 580] = 32
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 612] = 35
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 644] = 'ERC20: transfer to the zero addr'
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 676] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                                        revert with memory
                                                                          from _21550 + (8 * ceil32(return_data.size)) + 576
                                                                           len (13 * ceil32(return_data.size)) + 132
                                                                    if cd[36] - (cd[36] * totalFees / 100) > balanceOf[address(msg.sender)]:
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 672] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 676] = 32
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 708] = 38
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 740 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_21550 + (8 * ceil32(return_data.size)) + 646 len 26]
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 778] = 0
                                                                        revert with memory
                                                                          from _21550 + (8 * ceil32(return_data.size)) + 672
                                                                           len (13 * ceil32(return_data.size)) + 132
                                                                    if balanceOf[address(msg.sender)] < cd[36] - (cd[36] * totalFees / 100):
                                                                        revert with 0, 17
                                                                    balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - cd[36] + (cd[36] * totalFees / 100)
                                                                    if balanceOf[address(cd[4])] > !(cd[36] - (cd[36] * totalFees / 100)):
                                                                        revert with 0, 17
                                                                    if balanceOf[address(cd[4])] + cd[36] - (cd[36] * totalFees / 100) < balanceOf[address(cd[4])]:
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 672] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 676] = 32
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 708] = 27
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 740] = 'SafeMath: addition overflow'
                                                                        revert with memory
                                                                          from _21550 + (8 * ceil32(return_data.size)) + 672
                                                                           len (13 * ceil32(return_data.size)) + 100
                                                                    balanceOf[address(cd[4])] = balanceOf[address(cd[4])] + cd[36] - (cd[36] * totalFees / 100)
                                                                    emit Transfer((cd[36] - (cd[36] * totalFees / 100)), msg.sender, address(cd[4]));
                                                                else:
                                                                    if cd[36] and 1 > -1 / cd[36]:
                                                                        revert with 0, 17
                                                                    if not cd[36]:
                                                                        revert with 0, 18
                                                                    if cd[36] / cd[36] != 1:
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 352] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 356] = 32
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 388] = 33
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 420] = 'SafeMath: multiplication overflo'
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 452] = 0x7700000000000000000000000000000000000000000000000000000000000000
                                                                        revert with memory
                                                                          from _21550 + (8 * ceil32(return_data.size)) + 352
                                                                           len (13 * ceil32(return_data.size)) + 132
                                                                    if cd[36] * totalFees / 100 > !(cd[36] / 100):
                                                                        revert with 0, 17
                                                                    if (cd[36] * totalFees / 100) + (cd[36] / 100) > cd[36]:
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 480] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 484] = 32
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 516] = 30
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 548] = 'SafeMath: subtraction overflow'
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 578] = 0
                                                                        revert with memory
                                                                          from _21550 + (8 * ceil32(return_data.size)) + 480
                                                                           len (13 * ceil32(return_data.size)) + 100
                                                                    if cd[36] < (cd[36] * totalFees / 100) + (cd[36] / 100):
                                                                        revert with 0, 17
                                                                    if not msg.sender:
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 480] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 484] = 32
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 516] = 37
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 548] = 'ERC20: transfer from the zero ad'
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 580] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                                        revert with memory
                                                                          from _21550 + (8 * ceil32(return_data.size)) + 480
                                                                           len (13 * ceil32(return_data.size)) + 132
                                                                    if not this.address:
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 480] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 484] = 32
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 516] = 35
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 548] = 'ERC20: transfer to the zero addr'
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 580] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                                        revert with memory
                                                                          from _21550 + (8 * ceil32(return_data.size)) + 480
                                                                           len (13 * ceil32(return_data.size)) + 132
                                                                    if (cd[36] * totalFees / 100) + (cd[36] / 100) > balanceOf[address(msg.sender)]:
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 576] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 580] = 32
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 612] = 38
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 644 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_21550 + (8 * ceil32(return_data.size)) + 550 len 26]
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 682] = 0
                                                                        revert with memory
                                                                          from _21550 + (8 * ceil32(return_data.size)) + 576
                                                                           len (13 * ceil32(return_data.size)) + 132
                                                                    if balanceOf[address(msg.sender)] < (cd[36] * totalFees / 100) + (cd[36] / 100):
                                                                        revert with 0, 17
                                                                    balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - (cd[36] * totalFees / 100) - (cd[36] / 100)
                                                                    if balanceOf[this.address] > !((cd[36] * totalFees / 100) + (cd[36] / 100)):
                                                                        revert with 0, 17
                                                                    if balanceOf[this.address] + (cd[36] * totalFees / 100) + (cd[36] / 100) < balanceOf[this.address]:
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 576] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 580] = 32
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 612] = 27
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 644] = 'SafeMath: addition overflow'
                                                                        revert with memory
                                                                          from _21550 + (8 * ceil32(return_data.size)) + 576
                                                                           len (13 * ceil32(return_data.size)) + 100
                                                                    balanceOf[address(this.address)] = balanceOf[this.address] + (cd[36] * totalFees / 100) + (cd[36] / 100)
                                                                    emit Transfer(((cd[36] * totalFees / 100) + (cd[36] / 100)), msg.sender, this.address);
                                                                    if not msg.sender:
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 576] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 580] = 32
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 612] = 37
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 644] = 'ERC20: transfer from the zero ad'
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 676] = 0x6472657373000000000000000000000000000000000000000000000000000000
                                                                        revert with memory
                                                                          from _21550 + (8 * ceil32(return_data.size)) + 576
                                                                           len (13 * ceil32(return_data.size)) + 132
                                                                    if not address(cd[4]):
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 576] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 580] = 32
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 612] = 35
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 644] = 'ERC20: transfer to the zero addr'
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 676] = 0x6573730000000000000000000000000000000000000000000000000000000000
                                                                        revert with memory
                                                                          from _21550 + (8 * ceil32(return_data.size)) + 576
                                                                           len (13 * ceil32(return_data.size)) + 132
                                                                    if cd[36] - (cd[36] * totalFees / 100) - (cd[36] / 100) > balanceOf[address(msg.sender)]:
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 672] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 676] = 32
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 708] = 38
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 740 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_21550 + (8 * ceil32(return_data.size)) + 646 len 26]
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 778] = 0
                                                                        revert with memory
                                                                          from _21550 + (8 * ceil32(return_data.size)) + 672
                                                                           len (13 * ceil32(return_data.size)) + 132
                                                                    if balanceOf[address(msg.sender)] < cd[36] - (cd[36] * totalFees / 100) - (cd[36] / 100):
                                                                        revert with 0, 17
                                                                    balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - cd[36] + (cd[36] * totalFees / 100) + (cd[36] / 100)
                                                                    if balanceOf[address(cd[4])] > !(cd[36] - (cd[36] * totalFees / 100) - (cd[36] / 100)):
                                                                        revert with 0, 17
                                                                    if balanceOf[address(cd[4])] + cd[36] - (cd[36] * totalFees / 100) - (cd[36] / 100) < balanceOf[address(cd[4])]:
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 672] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 676] = 32
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 708] = 27
                                                                        mem[_21550 + (8 * ceil32(return_data.size)) + 740] = 'SafeMath: addition overflow'
                                                                        revert with memory
                                                                          from _21550 + (8 * ceil32(return_data.size)) + 672
                                                                           len (13 * ceil32(return_data.size)) + 100
                                                                    balanceOf[address(cd[4])] = balanceOf[address(cd[4])] + cd[36] - (cd[36] * totalFees / 100) - (cd[36] / 100)
                                                                    emit Transfer((cd[36] - (cd[36] * totalFees / 100) - (cd[36] / 100)), msg.sender, address(cd[4]));
                                                                mem[_21550 + (8 * ceil32(return_data.size)) + 676] = msg.sender
                                                                mem[_21550 + (8 * ceil32(return_data.size)) + 708] = balanceOf[address(msg.sender)]
                                                                require ext_code.size(dividendTrackerAddress)
                                                                call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                                     gas gas_remaining wei
                                                                    args mem[_21550 + (8 * ceil32(return_data.size)) + 676 len (13 * ceil32(return_data.size)) + 64]
                                                                mem[_21550 + (8 * ceil32(return_data.size)) + 676] = address(cd[4])
                                                                mem[_21550 + (8 * ceil32(return_data.size)) + 708] = balanceOf[address(cd[4])]
                                                                require ext_code.size(dividendTrackerAddress)
                                                                call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                                     gas gas_remaining wei
                                                                    args mem[_21550 + (8 * ceil32(return_data.size)) + 676 len (13 * ceil32(return_data.size)) + 64]
                                                                if not stor7:
                                                                    call dividendTrackerAddress.process(uint256 arg1) with:
                                                                         gas gas_remaining wei
                                                                        args gasForProcessing
                                                                    if ext_call.success:
                                                                        require return_data.size >= 96
                                                                        emit ProcessedDividendTracker(uint256 arg1, uint256 arg2, uint256 arg3, bool arg4, uint256 arg5, address arg6):
                                                                                                      ext_call.return_data[0],
                                                                                                      ext_call.return_data[32],
                                                                                                      ext_call.return_data[64],
                                                                                                      gasForProcessing,
                                                                                                      mem[_21550 + (9 * ceil32(return_data.size)) + 800 len 5 * ceil32(return_data.size)],
                                                                                                      1,
                                                                                                      tx.origin,
                                        else:
                                            if balanceOf[this.address] and stor14 > -1 / balanceOf[this.address]:
                                                revert with 0, 17
                                            if not balanceOf[this.address]:
                                                revert with 0, 18
                                            if balanceOf[this.address] * stor14 / balanceOf[this.address] != stor14:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _21476 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_21476] = 26
                                            mem[_21476 + 32] = 'SafeMath: division by zero'
                                            if not totalFees:
                                                revert with 0, 'SafeMath: division by zero', 0
                                            _21512 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_21512] = 26
                                            mem[_21512 + 32] = 'SafeMath: division by zero'
                                            _21532 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_21532] = 30
                                            mem[_21532 + 32] = 'SafeMath: subtraction overflow'
                                            if balanceOf[this.address] * stor14 / totalFees / 2 > balanceOf[this.address] * stor14 / totalFees:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if balanceOf[this.address] * stor14 / totalFees < balanceOf[this.address] * stor14 / totalFees / 2:
                                                revert with 0, 17
                                            _21590 = mem[64]
                                            mem[mem[64]] = 2
                                            mem[64] = mem[64] + 96
                                            mem[_21590 + 32 len 64] = call.data[calldata.size len 64]
                                            if 0 >= mem[_21590]:
                                                revert with 0, 50
                                            mem[_21590 + 32] = this.address
                                            staticcall uniswapV2RouterAddress.WETH() with:
                                                    gas gas_remaining wei
                                            mem[_21590 + 96] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[64] = _21590 + ceil32(return_data.size) + 96
                                            require return_data.size >= 32
                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                            if 1 >= mem[_21590]:
                                                revert with 0, 50
                                            mem[_21590 + 64] = ext_call.return_data[12 len 20]
                                            if not this.address:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not uniswapV2RouterAddress:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            mem[0] = uniswapV2RouterAddress
                                            mem[32] = sha3(address(this.address), 1)
                                            allowance[address(this.address)][stor6].field_0 = balanceOf[this.address] * stor14 / totalFees / 2
                                            allowance[address(this.address)][stor6].field_255 = 0
                                            emit Approval((balanceOf[this.address] * stor14 / totalFees / 2), this.address, uniswapV2RouterAddress);
                                            mem[_21590 + ceil32(return_data.size) + 96] = 0x791ac94700000000000000000000000000000000000000000000000000000000
                                            mem[_21590 + ceil32(return_data.size) + 100] = balanceOf[this.address] * stor14 / totalFees / 2
                                            mem[_21590 + ceil32(return_data.size) + 132] = 0
                                            mem[_21590 + ceil32(return_data.size) + 164] = 160
                                            mem[_21590 + ceil32(return_data.size) + 260] = mem[_21590]
                                            idx = 0
                                            s = _21590 + ceil32(return_data.size) + 292
                                            t = _21590 + 32
                                            while idx < mem[_21590]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_21590 + ceil32(return_data.size) + 196] = this.address
                                            mem[_21590 + ceil32(return_data.size) + 228] = block.timestamp
                                            require ext_code.size(uniswapV2RouterAddress)
                                            call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                                 gas gas_remaining wei
                                                args mem[mem[64] + 4 len _21590 + ceil32(return_data.size) + (32 * mem[_21590]) + -mem[64] + 288]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _33728 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_33728] = 30
                                            mem[_33728 + 32] = 'SafeMath: subtraction overflow'
                                            if eth.balance(this.address) > eth.balance(this.address):
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if eth.balance(this.address) < eth.balance(this.address):
                                                revert with 0, 17
                                            if not this.address:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not uniswapV2RouterAddress:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            mem[0] = uniswapV2RouterAddress
                                            mem[32] = sha3(address(this.address), 1)
                                            allowance[address(this.address)][stor6].field_0 = (balanceOf[this.address] * stor14 / totalFees) - (balanceOf[this.address] * stor14 / totalFees / 2)
                                            emit Approval(((balanceOf[this.address] * stor14 / totalFees) - (balanceOf[this.address] * stor14 / totalFees / 2)), this.address, uniswapV2RouterAddress);
                                            mem[mem[64] + 68] = 0
                                            mem[mem[64] + 100] = 0
                                            mem[mem[64] + 132] = stor17
                                            mem[mem[64] + 164] = block.timestamp
                                            call uniswapV2RouterAddress.addLiquidityETH(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                                 gas gas_remaining wei
                                                args this.address, (balanceOf[this.address] * stor14 / totalFees) - (balanceOf[this.address] * stor14 / totalFees / 2), 0, 0, stor17, block.timestamp
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 96
                                            mem[mem[64] + 32] = 0
                                            mem[mem[64] + 64] = (balanceOf[this.address] * stor14 / totalFees) - (balanceOf[this.address] * stor14 / totalFees / 2)
                                            emit SwapAndLiquify(Mask(255, 1, balanceOf[this.address] * stor14 / totalFees), 0, (balanceOf[this.address] * stor14 / totalFees) - (balanceOf[this.address] * stor14 / totalFees / 2));
                                            mem[0] = this.address
                                            mem[32] = 0
                                            _33918 = mem[64]
                                            mem[mem[64]] = 3
                                            mem[64] = mem[64] + 128
                                            mem[_33918 + 32 len 96] = call.data[calldata.size len 96]
                                            if 0 >= mem[_33918]:
                                                revert with 0, 50
                                            mem[_33918 + 32] = this.address
                                            staticcall uniswapV2RouterAddress.WETH() with:
                                                    gas gas_remaining wei
                                            mem[_33918 + 128] = ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[64] = _33918 + ceil32(return_data.size) + 128
                                            require return_data.size >= 32
                                            require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                            if 1 >= mem[_33918]:
                                                revert with 0, 50
                                            mem[_33918 + 64] = ext_call.return_data[12 len 20]
                                            if 2 >= mem[_33918]:
                                                revert with 0, 50
                                            mem[_33918 + 96] = sub_4d7effddAddress
                                            if not this.address:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not uniswapV2RouterAddress:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            mem[0] = uniswapV2RouterAddress
                                            mem[32] = sha3(address(this.address), 1)
                                            allowance[address(this.address)][stor6].field_0 = balanceOf[this.address]
                                            emit Approval(balanceOf[this.address], this.address, uniswapV2RouterAddress);
                                            mem[_33918 + ceil32(return_data.size) + 128] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                            mem[_33918 + ceil32(return_data.size) + 132] = balanceOf[this.address]
                                            mem[_33918 + ceil32(return_data.size) + 164] = 0
                                            mem[_33918 + ceil32(return_data.size) + 196] = 160
                                            mem[_33918 + ceil32(return_data.size) + 292] = mem[_33918]
                                            idx = 0
                                            s = _33918 + ceil32(return_data.size) + 324
                                            t = _33918 + 32
                                            while idx < mem[_33918]:
                                                mem[s] = mem[t + 12 len 20]
                                                idx = idx + 1
                                                s = s + 32
                                                t = t + 32
                                                continue 
                                            mem[_33918 + ceil32(return_data.size) + 228] = this.address
                                            mem[_33918 + ceil32(return_data.size) + 260] = block.timestamp
                                            require ext_code.size(uniswapV2RouterAddress)
                                            call uniswapV2RouterAddress.swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                                 gas gas_remaining wei
                                                args balanceOf[this.address], 0, 160, address(this.address), block.timestamp, mem[_33918 + ceil32(return_data.size) + 292 len (32 * mem[_33918]) + 32]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            staticcall sub_4d7effddAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            require return_data.size >= 32
                                            call sub_4d7effddAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args dividendTrackerAddress, ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                            if ext_call.return_data[0]:
                                                require ext_code.size(dividendTrackerAddress)
                                                call dividendTrackerAddress.distributeDogeDividends(uint256 arg1) with:
                                                     gas gas_remaining wei
                                                    args ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                emit SendDividends(balanceOf[this.address], ext_call.return_data[0]);
                                            stor7 = 0
                                            if stor19[address(msg.sender)]:
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not address(cd[4]):
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                if cd[36] > balanceOf[address(msg.sender)]:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_33918 + (4 * ceil32(return_data.size)) + 198 len 26] >> 48,
                                                                0
                                                if balanceOf[address(msg.sender)] < cd[36]:
                                                    revert with 0, 17
                                                balanceOf[address(msg.sender)] -= cd[36]
                                                if balanceOf[address(cd[4])] > !cd[36]:
                                                    revert with 0, 17
                                                if balanceOf[address(cd[4])] + cd[36] < balanceOf[address(cd[4])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(cd[4])] += cd[36]
                                                emit Transfer(cd[36], msg.sender, address(cd[4]));
                                            else:
                                                if stor19[address(cd[4])]:
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not address(cd[4]):
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    if cd[36] > balanceOf[address(msg.sender)]:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_33918 + (4 * ceil32(return_data.size)) + 198 len 26] >> 48,
                                                                    0
                                                    if balanceOf[address(msg.sender)] < cd[36]:
                                                        revert with 0, 17
                                                    balanceOf[address(msg.sender)] -= cd[36]
                                                    if balanceOf[address(cd[4])] > !cd[36]:
                                                        revert with 0, 17
                                                    if balanceOf[address(cd[4])] + cd[36] < balanceOf[address(cd[4])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(cd[4])] += cd[36]
                                                    emit Transfer(cd[36], msg.sender, address(cd[4]));
                                                else:
                                                    if stor7:
                                                        if not msg.sender:
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not address(cd[4]):
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        if cd[36] > balanceOf[address(msg.sender)]:
                                                            revert with 0, 
                                                                        32,
                                                                        38,
                                                                        0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_33918 + (4 * ceil32(return_data.size)) + 198 len 26] >> 48,
                                                                        0
                                                        if balanceOf[address(msg.sender)] < cd[36]:
                                                            revert with 0, 17
                                                        balanceOf[address(msg.sender)] -= cd[36]
                                                        if balanceOf[address(cd[4])] > !cd[36]:
                                                            revert with 0, 17
                                                        if balanceOf[address(cd[4])] + cd[36] < balanceOf[address(cd[4])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(cd[4])] += cd[36]
                                                        emit Transfer(cd[36], msg.sender, address(cd[4]));
                                                    else:
                                                        if not cd[36]:
                                                            if not stor20[address(cd[4])]:
                                                                if 0 > cd[36]:
                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                if cd[36] < 0:
                                                                    revert with 0, 17
                                                                if not msg.sender:
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not this.address:
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                if 0 > balanceOf[address(msg.sender)]:
                                                                    revert with 0, 
                                                                                32,
                                                                                38,
                                                                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_33918 + (4 * ceil32(return_data.size)) + 326 len 26] >> 48,
                                                                                0
                                                                if balanceOf[address(msg.sender)] < 0:
                                                                    revert with 0, 17
                                                                if balanceOf[this.address] > -1:
                                                                    revert with 0, 17
                                                                if balanceOf[this.address] < balanceOf[this.address]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                balanceOf[address(this.address)] = balanceOf[this.address]
                                                                emit Transfer(0, msg.sender, this.address);
                                                                if not msg.sender:
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not address(cd[4]):
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                if cd[36] > balanceOf[address(msg.sender)]:
                                                                    revert with 0, 
                                                                                32,
                                                                                38,
                                                                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_33918 + (4 * ceil32(return_data.size)) + 422 len 26] >> 48,
                                                                                0
                                                                if balanceOf[address(msg.sender)] < cd[36]:
                                                                    revert with 0, 17
                                                                balanceOf[address(msg.sender)] -= cd[36]
                                                                if balanceOf[address(cd[4])] > !cd[36]:
                                                                    revert with 0, 17
                                                                if balanceOf[address(cd[4])] + cd[36] < balanceOf[address(cd[4])]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                balanceOf[address(cd[4])] += cd[36]
                                                                emit Transfer(cd[36], msg.sender, address(cd[4]));
                                                            else:
                                                                if not cd[36]:
                                                                    if 0 > cd[36]:
                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                    if cd[36] < 0:
                                                                        revert with 0, 17
                                                                    if not msg.sender:
                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                    if not this.address:
                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                    if 0 > balanceOf[address(msg.sender)]:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    38,
                                                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_33918 + (4 * ceil32(return_data.size)) + 390 len 26] >> 48,
                                                                                    0
                                                                    if balanceOf[address(msg.sender)] < 0:
                                                                        revert with 0, 17
                                                                    if balanceOf[this.address] > -1:
                                                                        revert with 0, 17
                                                                    if balanceOf[this.address] < balanceOf[this.address]:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    balanceOf[address(this.address)] = balanceOf[this.address]
                                                                    emit Transfer(0, msg.sender, this.address);
                                                                    if not msg.sender:
                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                    if not address(cd[4]):
                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                    if cd[36] > balanceOf[address(msg.sender)]:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    38,
                                                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_33918 + (4 * ceil32(return_data.size)) + 486 len 26] >> 48,
                                                                                    0
                                                                    if balanceOf[address(msg.sender)] < cd[36]:
                                                                        revert with 0, 17
                                                                    balanceOf[address(msg.sender)] -= cd[36]
                                                                    if balanceOf[address(cd[4])] > !cd[36]:
                                                                        revert with 0, 17
                                                                    if balanceOf[address(cd[4])] + cd[36] < balanceOf[address(cd[4])]:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    balanceOf[address(cd[4])] += cd[36]
                                                                    emit Transfer(cd[36], msg.sender, address(cd[4]));
                                                                else:
                                                                    if cd[36] and 1 > -1 / cd[36]:
                                                                        revert with 0, 17
                                                                    if not cd[36]:
                                                                        revert with 0, 18
                                                                    if cd[36] / cd[36] != 1:
                                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                                    if 0 > !(cd[36] / 100):
                                                                        revert with 0, 17
                                                                    if cd[36] / 100 > cd[36]:
                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                    if cd[36] < cd[36] / 100:
                                                                        revert with 0, 17
                                                                    if not msg.sender:
                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                    if not this.address:
                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                    if cd[36] / 100 > balanceOf[address(msg.sender)]:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    38,
                                                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_33918 + (4 * ceil32(return_data.size)) + 390 len 26] >> 48,
                                                                                    0
                                                                    if balanceOf[address(msg.sender)] < cd[36] / 100:
                                                                        revert with 0, 17
                                                                    balanceOf[address(msg.sender)] -= cd[36] / 100
                                                                    if balanceOf[this.address] > !(cd[36] / 100):
                                                                        revert with 0, 17
                                                                    if balanceOf[this.address] + (cd[36] / 100) < balanceOf[this.address]:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    balanceOf[address(this.address)] = balanceOf[this.address] + (cd[36] / 100)
                                                                    emit Transfer((cd[36] / 100), msg.sender, this.address);
                                                                    if not msg.sender:
                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                    if not address(cd[4]):
                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                    if cd[36] - (cd[36] / 100) > balanceOf[address(msg.sender)]:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    38,
                                                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_33918 + (4 * ceil32(return_data.size)) + 486 len 26] >> 48,
                                                                                    0
                                                                    if balanceOf[address(msg.sender)] < cd[36] - (cd[36] / 100):
                                                                        revert with 0, 17
                                                                    balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - cd[36] + (cd[36] / 100)
                                                                    if balanceOf[address(cd[4])] > !(cd[36] - (cd[36] / 100)):
                                                                        revert with 0, 17
                                                                    if balanceOf[address(cd[4])] + cd[36] - (cd[36] / 100) < balanceOf[address(cd[4])]:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    balanceOf[address(cd[4])] = balanceOf[address(cd[4])] + cd[36] - (cd[36] / 100)
                                                                    emit Transfer((cd[36] - (cd[36] / 100)), msg.sender, address(cd[4]));
                                                        else:
                                                            if cd[36] and totalFees > -1 / cd[36]:
                                                                revert with 0, 17
                                                            if not cd[36]:
                                                                revert with 0, 18
                                                            if cd[36] * totalFees / cd[36] != totalFees:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if not stor20[address(cd[4])]:
                                                                if cd[36] * totalFees / 100 > cd[36]:
                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                if cd[36] < cd[36] * totalFees / 100:
                                                                    revert with 0, 17
                                                                if not msg.sender:
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not this.address:
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                if cd[36] * totalFees / 100 > balanceOf[address(msg.sender)]:
                                                                    revert with 0, 
                                                                                32,
                                                                                38,
                                                                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_33918 + (4 * ceil32(return_data.size)) + 326 len 26] >> 48,
                                                                                0
                                                                if balanceOf[address(msg.sender)] < cd[36] * totalFees / 100:
                                                                    revert with 0, 17
                                                                balanceOf[address(msg.sender)] -= cd[36] * totalFees / 100
                                                                if balanceOf[this.address] > !(cd[36] * totalFees / 100):
                                                                    revert with 0, 17
                                                                if balanceOf[this.address] + (cd[36] * totalFees / 100) < balanceOf[this.address]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                balanceOf[address(this.address)] = balanceOf[this.address] + (cd[36] * totalFees / 100)
                                                                emit Transfer((cd[36] * totalFees / 100), msg.sender, this.address);
                                                                if not msg.sender:
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not address(cd[4]):
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                if cd[36] - (cd[36] * totalFees / 100) > balanceOf[address(msg.sender)]:
                                                                    revert with 0, 
                                                                                32,
                                                                                38,
                                                                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_33918 + (4 * ceil32(return_data.size)) + 422 len 26] >> 48,
                                                                                0
                                                                if balanceOf[address(msg.sender)] < cd[36] - (cd[36] * totalFees / 100):
                                                                    revert with 0, 17
                                                                balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - cd[36] + (cd[36] * totalFees / 100)
                                                                if balanceOf[address(cd[4])] > !(cd[36] - (cd[36] * totalFees / 100)):
                                                                    revert with 0, 17
                                                                if balanceOf[address(cd[4])] + cd[36] - (cd[36] * totalFees / 100) < balanceOf[address(cd[4])]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                balanceOf[address(cd[4])] = balanceOf[address(cd[4])] + cd[36] - (cd[36] * totalFees / 100)
                                                                emit Transfer((cd[36] - (cd[36] * totalFees / 100)), msg.sender, address(cd[4]));
                                                            else:
                                                                if not cd[36]:
                                                                    if cd[36] * totalFees / 100 > -1:
                                                                        revert with 0, 17
                                                                    if cd[36] * totalFees / 100 > cd[36]:
                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                    if cd[36] < cd[36] * totalFees / 100:
                                                                        revert with 0, 17
                                                                    if not msg.sender:
                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                    if not this.address:
                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                    if cd[36] * totalFees / 100 > balanceOf[address(msg.sender)]:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    38,
                                                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_33918 + (4 * ceil32(return_data.size)) + 390 len 26] >> 48,
                                                                                    0
                                                                    if balanceOf[address(msg.sender)] < cd[36] * totalFees / 100:
                                                                        revert with 0, 17
                                                                    balanceOf[address(msg.sender)] -= cd[36] * totalFees / 100
                                                                    if balanceOf[this.address] > !(cd[36] * totalFees / 100):
                                                                        revert with 0, 17
                                                                    if balanceOf[this.address] + (cd[36] * totalFees / 100) < balanceOf[this.address]:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    balanceOf[address(this.address)] = balanceOf[this.address] + (cd[36] * totalFees / 100)
                                                                    emit Transfer((cd[36] * totalFees / 100), msg.sender, this.address);
                                                                    if not msg.sender:
                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                    if not address(cd[4]):
                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                    if cd[36] - (cd[36] * totalFees / 100) > balanceOf[address(msg.sender)]:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    38,
                                                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_33918 + (4 * ceil32(return_data.size)) + 486 len 26] >> 48,
                                                                                    0
                                                                    if balanceOf[address(msg.sender)] < cd[36] - (cd[36] * totalFees / 100):
                                                                        revert with 0, 17
                                                                    balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - cd[36] + (cd[36] * totalFees / 100)
                                                                    if balanceOf[address(cd[4])] > !(cd[36] - (cd[36] * totalFees / 100)):
                                                                        revert with 0, 17
                                                                    if balanceOf[address(cd[4])] + cd[36] - (cd[36] * totalFees / 100) < balanceOf[address(cd[4])]:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    balanceOf[address(cd[4])] = balanceOf[address(cd[4])] + cd[36] - (cd[36] * totalFees / 100)
                                                                    emit Transfer((cd[36] - (cd[36] * totalFees / 100)), msg.sender, address(cd[4]));
                                                                else:
                                                                    if cd[36] and 1 > -1 / cd[36]:
                                                                        revert with 0, 17
                                                                    if not cd[36]:
                                                                        revert with 0, 18
                                                                    if cd[36] / cd[36] != 1:
                                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                                    if cd[36] * totalFees / 100 > !(cd[36] / 100):
                                                                        revert with 0, 17
                                                                    if (cd[36] * totalFees / 100) + (cd[36] / 100) > cd[36]:
                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                    if cd[36] < (cd[36] * totalFees / 100) + (cd[36] / 100):
                                                                        revert with 0, 17
                                                                    if not msg.sender:
                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                    if not this.address:
                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                    if (cd[36] * totalFees / 100) + (cd[36] / 100) > balanceOf[address(msg.sender)]:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    38,
                                                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_33918 + (4 * ceil32(return_data.size)) + 390 len 26] >> 48,
                                                                                    0
                                                                    if balanceOf[address(msg.sender)] < (cd[36] * totalFees / 100) + (cd[36] / 100):
                                                                        revert with 0, 17
                                                                    balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - (cd[36] * totalFees / 100) - (cd[36] / 100)
                                                                    if balanceOf[this.address] > !((cd[36] * totalFees / 100) + (cd[36] / 100)):
                                                                        revert with 0, 17
                                                                    if balanceOf[this.address] + (cd[36] * totalFees / 100) + (cd[36] / 100) < balanceOf[this.address]:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    balanceOf[address(this.address)] = balanceOf[this.address] + (cd[36] * totalFees / 100) + (cd[36] / 100)
                                                                    emit Transfer(((cd[36] * totalFees / 100) + (cd[36] / 100)), msg.sender, this.address);
                                                                    if not msg.sender:
                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                    if not address(cd[4]):
                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                    if cd[36] - (cd[36] * totalFees / 100) - (cd[36] / 100) > balanceOf[address(msg.sender)]:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    38,
                                                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_33918 + (4 * ceil32(return_data.size)) + 486 len 26] >> 48,
                                                                                    0
                                                                    if balanceOf[address(msg.sender)] < cd[36] - (cd[36] * totalFees / 100) - (cd[36] / 100):
                                                                        revert with 0, 17
                                                                    balanceOf[address(msg.sender)] = balanceOf[address(msg.sender)] - cd[36] + (cd[36] * totalFees / 100) + (cd[36] / 100)
                                                                    if balanceOf[address(cd[4])] > !(cd[36] - (cd[36] * totalFees / 100) - (cd[36] / 100)):
                                                                        revert with 0, 17
                                                                    if balanceOf[address(cd[4])] + cd[36] - (cd[36] * totalFees / 100) - (cd[36] / 100) < balanceOf[address(cd[4])]:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    balanceOf[address(cd[4])] = balanceOf[address(cd[4])] + cd[36] - (cd[36] * totalFees / 100) - (cd[36] / 100)
                                                                    emit Transfer((cd[36] - (cd[36] * totalFees / 100) - (cd[36] / 100)), msg.sender, address(cd[4]));
                                            require ext_code.size(dividendTrackerAddress)
                                            call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args msg.sender, balanceOf[address(msg.sender)]
                                            require ext_code.size(dividendTrackerAddress)
                                            call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args address(cd[4]), balanceOf[address(cd[4])]
                                            if not stor7:
                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                     gas gas_remaining wei
                                                    args gasForProcessing
                                                if ext_call.success:
                                                    require return_data.size >= 96
                                                    emit ProcessedDividendTracker(ext_call.return_data[0], ext_call.return_data[32], ext_call.return_data[64], gasForProcessing, 1, tx.origin);
    else:
        if unknown_0x39509351(?????) <= uint32(call.func_hash) >> 224:
            if unknown_0x52f34787(?????) > uint32(call.func_hash) >> 224:
                if unknown_0x39509351(?????) == uint32(call.func_hash) >> 224:
                    require not msg.value
                    require calldata.size - 4 >= 64
                    require cd[4] == address(cd[4])
                    if allowance[msg.sender][address(cd[4])].field_0 > !cd[36]:
                        revert with 0, 17
                    if allowance[msg.sender][address(cd[4])].field_0 + cd[36] < allowance[msg.sender][address(cd[4])].field_0:
                        revert with 0, 'SafeMath: addition overflow'
                    if not msg.sender:
                        revert with 0, 'ERC20: approve from the zero address'
                    if not address(cd[4]):
                        revert with 0, 'ERC20: approve to the zero address'
                    allowance[address(msg.sender)][address(cd[4])].field_0 = allowance[msg.sender][address(cd[4])].field_0 + cd[36]
                    emit Approval((allowance[msg.sender][address(cd[4])].field_0 + cd[36]), msg.sender, address(cd[4]));
                    return 1
                if unknown_0x455a4396(?????) == uint32(call.func_hash) >> 224:
                    require not msg.value
                    require calldata.size - 4 >= 64
                    require cd[4] == address(cd[4])
                    require cd[36] == bool(cd[36])
                    if owner != msg.sender:
                        revert with 0, 'Ownable: caller is not the owner'
                    stor12[address(cd[4])] = uint8(bool(cd[36]))
                else:
                    if unknown_0x49bd5a5e(?????) == uint32(call.func_hash) >> 224:
                        require not msg.value
                        return uniswapV2PairAddress
                    if unknown_0x4d7effdd(?????) == uint32(call.func_hash) >> 224:
                        require not msg.value
                        return sub_4d7effddAddress
                    if uint32(call.func_hash) >> 224 != unknown_0x4e71d92d(?????):
                        require unknown_0x4fbee193(?????) == uint32(call.func_hash) >> 224
                        require not msg.value
                        require calldata.size - 4 >= 32
                        require cd[4] == address(cd[4])
                        return bool(stor19[address(cd[4])])
                    require not msg.value
                    call dividendTrackerAddress.processAccount(address arg1, bool arg2) with:
                         gas gas_remaining wei
                        args msg.sender, 0
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_call.return_data[0] == bool(ext_call.return_data[0])
            else:
                if unknown_0x52f34787(?????) == uint32(call.func_hash) >> 224:
                    require not msg.value
                    require calldata.size - 4 >= 32
                    if owner != msg.sender:
                        revert with 0, 'Ownable: caller is not the owner'
                    stor13 = cd[4]
                    if cd[4] > !stor14:
                        revert with 0, 17
                    if cd[4] + stor14 < cd[4]:
                        revert with 0, 'SafeMath: addition overflow'
                    if cd[4] + stor14 > !stor15:
                        revert with 0, 17
                    if stor15 < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    totalFees = cd[4] + stor14 + stor15
                else:
                    if unknown_0x64b0f653(?????) == uint32(call.func_hash) >> 224:
                        require not msg.value
                        staticcall dividendTrackerAddress.getNumberOfTokenHolders() with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        return ext_call.return_data[0]
                    if uint32(call.func_hash) >> 224 != unknown_0x65b8dbc0(?????):
                        if unknown_0x6843cd84(?????) == uint32(call.func_hash) >> 224:
                            require not msg.value
                            require calldata.size - 4 >= 32
                            require cd[4] == address(cd[4])
                            staticcall dividendTrackerAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args address(cd[4])
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            return ext_call.return_data[0]
                        if uint32(call.func_hash) >> 224 != unknown_0x700bb191(?????):
                            require unknown_0x70a08231(?????) == uint32(call.func_hash) >> 224
                            require not msg.value
                            require calldata.size - 4 >= 32
                            require cd[4] == address(cd[4])
                            return balanceOf[address(cd[4])]
                        require not msg.value
                        require calldata.size - 4 >= 32
                        call dividendTrackerAddress.process(uint256 arg1) with:
                             gas gas_remaining wei
                            args cd[4]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 96
                        emit ProcessedDividendTracker(ext_call.return_data[0], ext_call.return_data[32], ext_call.return_data[64], cd[4], 0, tx.origin);
                    else:
                        require not msg.value
                        require calldata.size - 4 >= 32
                        require cd[4] == address(cd[4])
                        if owner != msg.sender:
                            revert with 0, 'Ownable: caller is not the owner'
                        if uniswapV2RouterAddress == address(cd[4]):
                            revert with 0, 'GreatDaneInu: The router already has that address'
                        emit UpdateUniswapV2Router(address(cd[4]), uniswapV2RouterAddress);
                        uniswapV2RouterAddress = address(cd[4])
                        staticcall address(cd[4]).factory() with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                        staticcall uniswapV2RouterAddress.WETH() with:
                                gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                        call address(ext_call.return_data[0]).createPair(address arg1, address arg2) with:
                             gas gas_remaining wei
                            args address(this.address), address(ext_call.return_data[0])
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                        uniswapV2PairAddress = ext_call.return_data[12 len 20]
        if unknown_0x23b872dd(?????) > uint32(call.func_hash) >> 224:
            if uint32(call.func_hash) >> 224 != name():
                if approve(address arg1, uint256 arg2) == uint32(call.func_hash) >> 224:
                    require not msg.value
                    require calldata.size - 4 >= 64
                    require cd[4] == address(cd[4])
                    if not msg.sender:
                        revert with 0, 'ERC20: approve from the zero address'
                    if not address(cd[4]):
                        revert with 0, 'ERC20: approve to the zero address'
                    allowance[address(msg.sender)][address(cd[4])].field_0 = cd[36]
                    emit Approval(cd[36], msg.sender, address(cd[4]));
                    return 1
                if unknown_0x13114a9d(?????) == uint32(call.func_hash) >> 224:
                    require not msg.value
                    return totalFees
                if unknown_0x1694505e(?????) == uint32(call.func_hash) >> 224:
                    require not msg.value
                    return uniswapV2RouterAddress
                if unknown_0x18160ddd(?????) == uint32(call.func_hash) >> 224:
                    require not msg.value
                    return totalSupply
                require unknown_0x1cdd3be3(?????) == uint32(call.func_hash) >> 224
                require not msg.value
                require calldata.size - 4 >= 32
                require cd[4] == address(cd[4])
                return bool(stor12[cd[4]])
            require not msg.value
            if bool(stor3.length):
                if bool(stor3.length) == uint255(stor3.length) * 0.5 < 32:
                    revert with 0, 34
                if bool(stor3.length):
                    if bool(stor3.length) == uint255(stor3.length) * 0.5 < 32:
                        revert with 0, 34
                    if Mask(256, -1, stor3.length):
                        if 31 < uint255(stor3.length) * 0.5:
                            mem[160] = uint256(stor3.field_0)
                            idx = 160
                            s = 0
                            while (uint255(stor3.length) * 0.5) + 128 > idx:
                                mem[idx + 32] = stor3[s].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            return Array(len=2 * Mask(256, -1, stor3.length), data=mem[160 len ceil32(uint255(stor3.length) * 0.5)])
                        mem[160] = 256 * stor3.length.field_8
                else:
                    if bool(stor3.length) == stor3.length.field_1 < 32:
                        revert with 0, 34
                    if stor3.length.field_1:
                        if 31 < stor3.length.field_1:
                            mem[160] = uint256(stor3.field_0)
                            idx = 160
                            s = 0
                            while stor3.length.field_1 + 128 > idx:
                                mem[idx + 32] = stor3[s].field_256
                                idx = idx + 32
                                s = s + 1
                                continue 
                            return Array(len=2 * Mask(256, -1, stor3.length), data=mem[160 len ceil32(uint255(stor3.length) * 0.5)])
                        mem[160] = 256 * stor3.length.field_8
                mem[ceil32(uint255(stor3.length) * 0.5) + 224 len ceil32(uint255(stor3.length) * 0.5)] = mem[160 len ceil32(uint255(stor3.length) * 0.5)]
                if ceil32(uint255(stor3.length) * 0.5) > uint255(stor3.length) * 0.5:
                    mem[ceil32(uint255(stor3.length) * 0.5) + (uint255(stor3.length) * 0.5) + 224] = 0
                return Array(len=2 * Mask(256, -1, stor3.length), data=mem[160 len ceil32(uint255(stor3.length) * 0.5)], mem[(2 * ceil32(uint255(stor3.length) * 0.5)) + 224 len 2 * ceil32(uint255(stor3.length) * 0.5)]), 
            if bool(stor3.length) == stor3.length.field_1 < 32:
                revert with 0, 34
            if bool(stor3.length):
                if bool(stor3.length) == uint255(stor3.length) * 0.5 < 32:
                    revert with 0, 34
                if Mask(256, -1, stor3.length):
                    if 31 < uint255(stor3.length) * 0.5:
                        mem[160] = uint256(stor3.field_0)
                        idx = 160
                        s = 0
                        while (uint255(stor3.length) * 0.5) + 128 > idx:
                            mem[idx + 32] = stor3[s].field_256
                            idx = idx + 32
                            s = s + 1
                            continue 
                        return Array(len=stor3.length % 128, data=mem[160 len ceil32(stor3.length.field_1)])
                    mem[160] = 256 * stor3.length.field_8
            else:
                if bool(stor3.length) == stor3.length.field_1 < 32:
                    revert with 0, 34
                if stor3.length.field_1:
                    if 31 < stor3.length.field_1:
                        mem[160] = uint256(stor3.field_0)
                        idx = 160
                        s = 0
                        while stor3.length.field_1 + 128 > idx:
                            mem[idx + 32] = stor3[s].field_256
                            idx = idx + 32
                            s = s + 1
                            continue 
                        return Array(len=stor3.length % 128, data=mem[160 len ceil32(stor3.length.field_1)])
                    mem[160] = 256 * stor3.length.field_8
            mem[ceil32(stor3.length.field_1) + 224 len ceil32(stor3.length.field_1)] = mem[160 len ceil32(stor3.length.field_1)]
            if ceil32(stor3.length.field_1) > stor3.length.field_1:
                mem[ceil32(stor3.length.field_1) + stor3.length.field_1 + 224] = 0
            return Array(len=stor3.length % 128, data=mem[160 len ceil32(stor3.length.field_1)], mem[(2 * ceil32(stor3.length.field_1)) + 224 len 2 * ceil32(stor3.length.field_1)]), 
        if uint32(call.func_hash) >> 224 != unknown_0x23b872dd(?????):
            if unknown_0x286ad7a2(?????) == uint32(call.func_hash) >> 224:
                require not msg.value
                require calldata.size - 4 >= 32
                if owner != msg.sender:
                    revert with 0, 'Ownable: caller is not the owner'
                stor15 = cd[4]
                if stor13 > !stor14:
                    revert with 0, 17
                if stor13 + stor14 < stor13:
                    revert with 0, 'SafeMath: addition overflow'
                if stor13 + stor14 > !cd[4]:
                    revert with 0, 17
                if cd[4] < 0:
                    revert with 0, 'SafeMath: addition overflow'
                totalFees = stor13 + stor14 + cd[4]
            else:
                if unknown_0x2c1f5216(?????) == uint32(call.func_hash) >> 224:
                    require not msg.value
                    return dividendTrackerAddress
                if unknown_0x30bb4cff(?????) == uint32(call.func_hash) >> 224:
                    require not msg.value
                    staticcall dividendTrackerAddress.totalDividendsDistributed() with:
                            gas gas_remaining wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    return ext_call.return_data[0]
                if unknown_0x313ce567(?????) == uint32(call.func_hash) >> 224:
                    require not msg.value
                    return 18
                require unknown_0x31e79db0(?????) == uint32(call.func_hash) >> 224
                require not msg.value
                require calldata.size - 4 >= 32
                require cd[4] == address(cd[4])
                if owner != msg.sender:
                    revert with 0, 'Ownable: caller is not the owner'
                require ext_code.size(dividendTrackerAddress)
                call dividendTrackerAddress.0x31e79db0 with:
                     gas gas_remaining wei
                    args address(cd[4])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
        require not msg.value
        require calldata.size - 4 >= 96
        require cd[4] == address(cd[4])
        require cd[36] == address(cd[36])
        if not address(cd[4]):
            revert with 0, 'ERC20: transfer from the zero address'
        if not address(cd[36]):
            revert with 0, 'ERC20: transfer to the zero address'
        if stor12[address(cd[4])]:
            revert with 0, 'Blacklisted address'
        if stor12[address(cd[36])]:
            revert with 0, 'Blacklisted address'
        if not cd[68]:
            if not address(cd[4]):
                revert with 0, 'ERC20: transfer from the zero address'
            if not address(cd[36]):
                revert with 0, 'ERC20: transfer to the zero address'
            if 0 > balanceOf[address(cd[4])]:
                revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
            if balanceOf[address(cd[4])] < 0:
                revert with 0, 17
            if balanceOf[address(cd[36])] > -1:
                revert with 0, 17
            if balanceOf[address(cd[36])] < balanceOf[address(cd[36])]:
                revert with 0, 'SafeMath: addition overflow'
            balanceOf[address(cd[36])] = balanceOf[address(cd[36])]
            emit Transfer(0, address(cd[4]), address(cd[36]));
            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                revert with 0, 32, 40, 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[296 len 24] >> 64, 0
        else:
            if balanceOf[this.address] < swapTokensAtAmount:
                if stor19[address(cd[4])]:
                    if not address(cd[4]):
                        revert with 0, 'ERC20: transfer from the zero address'
                    if not address(cd[36]):
                        revert with 0, 'ERC20: transfer to the zero address'
                    if cd[68] > balanceOf[address(cd[4])]:
                        revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                    if balanceOf[address(cd[4])] < cd[68]:
                        revert with 0, 17
                    balanceOf[address(cd[4])] -= cd[68]
                    if balanceOf[address(cd[36])] > !cd[68]:
                        revert with 0, 17
                    if balanceOf[address(cd[36])] + cd[68] < balanceOf[address(cd[36])]:
                        revert with 0, 'SafeMath: addition overflow'
                    balanceOf[address(cd[36])] += cd[68]
                    emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                    require ext_code.size(dividendTrackerAddress)
                    call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(cd[4]), balanceOf[address(cd[4])]
                    require ext_code.size(dividendTrackerAddress)
                    call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                         gas gas_remaining wei
                        args address(cd[36]), balanceOf[address(cd[36])]
                    if stor7:
                        if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                            revert with 0, 32, 40, 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[296 len 24] >> 64, 0
                    else:
                        call dividendTrackerAddress.process(uint256 arg1) with:
                             gas gas_remaining wei
                            args gasForProcessing
                        if not ext_call.success:
                            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                revert with 0, 
                                            32,
                                            40,
                                            0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, ext_call.return_data[72 len 24] >> 64,
                                            0
                        else:
                            require return_data.size >= 96
                            emit ProcessedDividendTracker(ext_call.return_data[0], ext_call.return_data[32], ext_call.return_data[64], gasForProcessing, 1, tx.origin);
                            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                revert with 0, 
                                            32,
                                            40,
                                            0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, Mask(192, 0, ext_call.return_data[64]) >> 64,
                                            0
                else:
                    if stor19[address(cd[36])]:
                        if not address(cd[4]):
                            revert with 0, 'ERC20: transfer from the zero address'
                        if not address(cd[36]):
                            revert with 0, 'ERC20: transfer to the zero address'
                        if cd[68] > balanceOf[address(cd[4])]:
                            revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                        if balanceOf[address(cd[4])] < cd[68]:
                            revert with 0, 17
                        balanceOf[address(cd[4])] -= cd[68]
                        if balanceOf[address(cd[36])] > !cd[68]:
                            revert with 0, 17
                        if balanceOf[address(cd[36])] + cd[68] < balanceOf[address(cd[36])]:
                            revert with 0, 'SafeMath: addition overflow'
                        balanceOf[address(cd[36])] += cd[68]
                        emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                        require ext_code.size(dividendTrackerAddress)
                        call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(cd[4]), balanceOf[address(cd[4])]
                        require ext_code.size(dividendTrackerAddress)
                        call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(cd[36]), balanceOf[address(cd[36])]
                        if stor7:
                            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                revert with 0, 32, 40, 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[296 len 24] >> 64, 0
                        else:
                            call dividendTrackerAddress.process(uint256 arg1) with:
                                 gas gas_remaining wei
                                args gasForProcessing
                            if not ext_call.success:
                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                    revert with 0, 
                                                32,
                                                40,
                                                0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, ext_call.return_data[72 len 24] >> 64,
                                                0
                            else:
                                require return_data.size >= 96
                                emit ProcessedDividendTracker(ext_call.return_data[0], ext_call.return_data[32], ext_call.return_data[64], gasForProcessing, 1, tx.origin);
                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                    revert with 0, 
                                                32,
                                                40,
                                                0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, Mask(192, 0, ext_call.return_data[64]) >> 64,
                                                0
                    else:
                        if stor7:
                            if not address(cd[4]):
                                revert with 0, 'ERC20: transfer from the zero address'
                            if not address(cd[36]):
                                revert with 0, 'ERC20: transfer to the zero address'
                            if cd[68] > balanceOf[address(cd[4])]:
                                revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                            if balanceOf[address(cd[4])] < cd[68]:
                                revert with 0, 17
                            balanceOf[address(cd[4])] -= cd[68]
                            if balanceOf[address(cd[36])] > !cd[68]:
                                revert with 0, 17
                            if balanceOf[address(cd[36])] + cd[68] < balanceOf[address(cd[36])]:
                                revert with 0, 'SafeMath: addition overflow'
                            balanceOf[address(cd[36])] += cd[68]
                            emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                            require ext_code.size(dividendTrackerAddress)
                            call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args address(cd[4]), balanceOf[address(cd[4])]
                            require ext_code.size(dividendTrackerAddress)
                            call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args address(cd[36]), balanceOf[address(cd[36])]
                            if stor7:
                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                    revert with 0, 32, 40, 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[296 len 24] >> 64, 0
                            else:
                                call dividendTrackerAddress.process(uint256 arg1) with:
                                     gas gas_remaining wei
                                    args gasForProcessing
                                if not ext_call.success:
                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                        revert with 0, 
                                                    32,
                                                    40,
                                                    0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, ext_call.return_data[72 len 24] >> 64,
                                                    0
                                else:
                                    require return_data.size >= 96
                                    emit ProcessedDividendTracker(ext_call.return_data[0], ext_call.return_data[32], ext_call.return_data[64], gasForProcessing, 1, tx.origin);
                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                        revert with 0, 
                                                    32,
                                                    40,
                                                    0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, Mask(192, 0, ext_call.return_data[64]) >> 64,
                                                    0
                        else:
                            if not cd[68]:
                                if not stor20[address(cd[36])]:
                                    if 0 > cd[68]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if cd[68] < 0:
                                        revert with 0, 17
                                    if not address(cd[4]):
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if not this.address:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    if 0 > balanceOf[address(cd[4])]:
                                        revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[326 len 26] >> 48, 0
                                    if balanceOf[address(cd[4])] < 0:
                                        revert with 0, 17
                                    if balanceOf[this.address] > -1:
                                        revert with 0, 17
                                    if balanceOf[this.address] < balanceOf[this.address]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(this.address)] = balanceOf[this.address]
                                    emit Transfer(0, address(cd[4]), this.address);
                                    if not address(cd[4]):
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if not address(cd[36]):
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    if cd[68] > balanceOf[address(cd[4])]:
                                        revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[422 len 26] >> 48, 0
                                    if balanceOf[address(cd[4])] < cd[68]:
                                        revert with 0, 17
                                    balanceOf[address(cd[4])] -= cd[68]
                                    if balanceOf[address(cd[36])] > !cd[68]:
                                        revert with 0, 17
                                    if balanceOf[address(cd[36])] + cd[68] < balanceOf[address(cd[36])]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(cd[36])] += cd[68]
                                    emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                                    require ext_code.size(dividendTrackerAddress)
                                    call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args address(cd[4]), balanceOf[address(cd[4])]
                                    require ext_code.size(dividendTrackerAddress)
                                    call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args address(cd[36]), balanceOf[address(cd[36])]
                                    if stor7:
                                        if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                            revert with 0, 32, 40, 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[520 len 24] >> 64, 0
                                    else:
                                        call dividendTrackerAddress.process(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args gasForProcessing
                                        if not ext_call.success:
                                            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                revert with 0, 
                                                            32,
                                                            40,
                                                            0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, ext_call.return_data[72 len 24] >> 64,
                                                            0
                                        else:
                                            require return_data.size >= 96
                                            emit ProcessedDividendTracker(ext_call.return_data[0], ext_call.return_data[32], ext_call.return_data[64], gasForProcessing, 1, tx.origin);
                                            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                revert with 0, 
                                                            32,
                                                            40,
                                                            0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, Mask(192, 0, ext_call.return_data[64]) >> 64,
                                                            0
                                else:
                                    if not cd[68]:
                                        if 0 > cd[68]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if cd[68] < 0:
                                            revert with 0, 17
                                        if not address(cd[4]):
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not this.address:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        if 0 > balanceOf[address(cd[4])]:
                                            revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[390 len 26] >> 48, 0
                                        if balanceOf[address(cd[4])] < 0:
                                            revert with 0, 17
                                        if balanceOf[this.address] > -1:
                                            revert with 0, 17
                                        if balanceOf[this.address] < balanceOf[this.address]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(this.address)] = balanceOf[this.address]
                                        emit Transfer(0, address(cd[4]), this.address);
                                        if not address(cd[4]):
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not address(cd[36]):
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        if cd[68] > balanceOf[address(cd[4])]:
                                            revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[486 len 26] >> 48, 0
                                        if balanceOf[address(cd[4])] < cd[68]:
                                            revert with 0, 17
                                        balanceOf[address(cd[4])] -= cd[68]
                                        if balanceOf[address(cd[36])] > !cd[68]:
                                            revert with 0, 17
                                        if balanceOf[address(cd[36])] + cd[68] < balanceOf[address(cd[36])]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(cd[36])] += cd[68]
                                        emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                                    else:
                                        if cd[68] and 1 > -1 / cd[68]:
                                            revert with 0, 17
                                        if not cd[68]:
                                            revert with 0, 18
                                        if cd[68] / cd[68] != 1:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if 0 > !(cd[68] / 100):
                                            revert with 0, 17
                                        if cd[68] / 100 > cd[68]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if cd[68] < cd[68] / 100:
                                            revert with 0, 17
                                        if not address(cd[4]):
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not this.address:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        if cd[68] / 100 > balanceOf[address(cd[4])]:
                                            revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[390 len 26] >> 48, 0
                                        if balanceOf[address(cd[4])] < cd[68] / 100:
                                            revert with 0, 17
                                        balanceOf[address(cd[4])] -= cd[68] / 100
                                        if balanceOf[this.address] > !(cd[68] / 100):
                                            revert with 0, 17
                                        if balanceOf[this.address] + (cd[68] / 100) < balanceOf[this.address]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(this.address)] = balanceOf[this.address] + (cd[68] / 100)
                                        emit Transfer((cd[68] / 100), address(cd[4]), this.address);
                                        if not address(cd[4]):
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not address(cd[36]):
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        if cd[68] - (cd[68] / 100) > balanceOf[address(cd[4])]:
                                            revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[486 len 26] >> 48, 0
                                        if balanceOf[address(cd[4])] < cd[68] - (cd[68] / 100):
                                            revert with 0, 17
                                        balanceOf[address(cd[4])] = balanceOf[address(cd[4])] - cd[68] + (cd[68] / 100)
                                        if balanceOf[address(cd[36])] > !(cd[68] - (cd[68] / 100)):
                                            revert with 0, 17
                                        if balanceOf[address(cd[36])] + cd[68] - (cd[68] / 100) < balanceOf[address(cd[36])]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(cd[36])] = balanceOf[address(cd[36])] + cd[68] - (cd[68] / 100)
                                        emit Transfer((cd[68] - (cd[68] / 100)), address(cd[4]), address(cd[36]));
                                    require ext_code.size(dividendTrackerAddress)
                                    call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args address(cd[4]), balanceOf[address(cd[4])]
                                    require ext_code.size(dividendTrackerAddress)
                                    call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args address(cd[36]), balanceOf[address(cd[36])]
                                    if stor7:
                                        if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                            revert with 0, 32, 40, 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[584 len 24] >> 64, 0
                                    else:
                                        call dividendTrackerAddress.process(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args gasForProcessing
                                        if not ext_call.success:
                                            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                revert with 0, 
                                                            32,
                                                            40,
                                                            0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, ext_call.return_data[72 len 24] >> 64,
                                                            0
                                        else:
                                            require return_data.size >= 96
                                            emit ProcessedDividendTracker(ext_call.return_data[0], ext_call.return_data[32], ext_call.return_data[64], gasForProcessing, 1, tx.origin);
                                            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                revert with 0, 
                                                            32,
                                                            40,
                                                            0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, Mask(192, 0, ext_call.return_data[64]) >> 64,
                                                            0
                            else:
                                if cd[68] and totalFees > -1 / cd[68]:
                                    revert with 0, 17
                                if not cd[68]:
                                    revert with 0, 18
                                if cd[68] * totalFees / cd[68] != totalFees:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not stor20[address(cd[36])]:
                                    if cd[68] * totalFees / 100 > cd[68]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if cd[68] < cd[68] * totalFees / 100:
                                        revert with 0, 17
                                    if not address(cd[4]):
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if not this.address:
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    if cd[68] * totalFees / 100 > balanceOf[address(cd[4])]:
                                        revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[326 len 26] >> 48, 0
                                    if balanceOf[address(cd[4])] < cd[68] * totalFees / 100:
                                        revert with 0, 17
                                    balanceOf[address(cd[4])] -= cd[68] * totalFees / 100
                                    if balanceOf[this.address] > !(cd[68] * totalFees / 100):
                                        revert with 0, 17
                                    if balanceOf[this.address] + (cd[68] * totalFees / 100) < balanceOf[this.address]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(this.address)] = balanceOf[this.address] + (cd[68] * totalFees / 100)
                                    emit Transfer((cd[68] * totalFees / 100), address(cd[4]), this.address);
                                    if not address(cd[4]):
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if not address(cd[36]):
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    if cd[68] - (cd[68] * totalFees / 100) > balanceOf[address(cd[4])]:
                                        revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[422 len 26] >> 48, 0
                                    if balanceOf[address(cd[4])] < cd[68] - (cd[68] * totalFees / 100):
                                        revert with 0, 17
                                    balanceOf[address(cd[4])] = balanceOf[address(cd[4])] - cd[68] + (cd[68] * totalFees / 100)
                                    if balanceOf[address(cd[36])] > !(cd[68] - (cd[68] * totalFees / 100)):
                                        revert with 0, 17
                                    if balanceOf[address(cd[36])] + cd[68] - (cd[68] * totalFees / 100) < balanceOf[address(cd[36])]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(cd[36])] = balanceOf[address(cd[36])] + cd[68] - (cd[68] * totalFees / 100)
                                    emit Transfer((cd[68] - (cd[68] * totalFees / 100)), address(cd[4]), address(cd[36]));
                                    require ext_code.size(dividendTrackerAddress)
                                    call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args address(cd[4]), balanceOf[address(cd[4])]
                                    require ext_code.size(dividendTrackerAddress)
                                    call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args address(cd[36]), balanceOf[address(cd[36])]
                                    if stor7:
                                        if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                            revert with 0, 32, 40, 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[520 len 24] >> 64, 0
                                    else:
                                        call dividendTrackerAddress.process(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args gasForProcessing
                                        if not ext_call.success:
                                            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                revert with 0, 
                                                            32,
                                                            40,
                                                            0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, ext_call.return_data[72 len 24] >> 64,
                                                            0
                                        else:
                                            require return_data.size >= 96
                                            emit ProcessedDividendTracker(ext_call.return_data[0], ext_call.return_data[32], ext_call.return_data[64], gasForProcessing, 1, tx.origin);
                                            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                revert with 0, 
                                                            32,
                                                            40,
                                                            0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, Mask(192, 0, ext_call.return_data[64]) >> 64,
                                                            0
                                else:
                                    if not cd[68]:
                                        if cd[68] * totalFees / 100 > -1:
                                            revert with 0, 17
                                        if cd[68] * totalFees / 100 > cd[68]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if cd[68] < cd[68] * totalFees / 100:
                                            revert with 0, 17
                                        if not address(cd[4]):
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not this.address:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        if cd[68] * totalFees / 100 > balanceOf[address(cd[4])]:
                                            revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[390 len 26] >> 48, 0
                                        if balanceOf[address(cd[4])] < cd[68] * totalFees / 100:
                                            revert with 0, 17
                                        balanceOf[address(cd[4])] -= cd[68] * totalFees / 100
                                        if balanceOf[this.address] > !(cd[68] * totalFees / 100):
                                            revert with 0, 17
                                        if balanceOf[this.address] + (cd[68] * totalFees / 100) < balanceOf[this.address]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(this.address)] = balanceOf[this.address] + (cd[68] * totalFees / 100)
                                        emit Transfer((cd[68] * totalFees / 100), address(cd[4]), this.address);
                                        if not address(cd[4]):
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not address(cd[36]):
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        if cd[68] - (cd[68] * totalFees / 100) > balanceOf[address(cd[4])]:
                                            revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[486 len 26] >> 48, 0
                                        if balanceOf[address(cd[4])] < cd[68] - (cd[68] * totalFees / 100):
                                            revert with 0, 17
                                        balanceOf[address(cd[4])] = balanceOf[address(cd[4])] - cd[68] + (cd[68] * totalFees / 100)
                                        if balanceOf[address(cd[36])] > !(cd[68] - (cd[68] * totalFees / 100)):
                                            revert with 0, 17
                                        if balanceOf[address(cd[36])] + cd[68] - (cd[68] * totalFees / 100) < balanceOf[address(cd[36])]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(cd[36])] = balanceOf[address(cd[36])] + cd[68] - (cd[68] * totalFees / 100)
                                        emit Transfer((cd[68] - (cd[68] * totalFees / 100)), address(cd[4]), address(cd[36]));
                                    else:
                                        if cd[68] and 1 > -1 / cd[68]:
                                            revert with 0, 17
                                        if not cd[68]:
                                            revert with 0, 18
                                        if cd[68] / cd[68] != 1:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if cd[68] * totalFees / 100 > !(cd[68] / 100):
                                            revert with 0, 17
                                        if (cd[68] * totalFees / 100) + (cd[68] / 100) > cd[68]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if cd[68] < (cd[68] * totalFees / 100) + (cd[68] / 100):
                                            revert with 0, 17
                                        if not address(cd[4]):
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not this.address:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        if (cd[68] * totalFees / 100) + (cd[68] / 100) > balanceOf[address(cd[4])]:
                                            revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[390 len 26] >> 48, 0
                                        if balanceOf[address(cd[4])] < (cd[68] * totalFees / 100) + (cd[68] / 100):
                                            revert with 0, 17
                                        balanceOf[address(cd[4])] = balanceOf[address(cd[4])] - (cd[68] * totalFees / 100) - (cd[68] / 100)
                                        if balanceOf[this.address] > !((cd[68] * totalFees / 100) + (cd[68] / 100)):
                                            revert with 0, 17
                                        if balanceOf[this.address] + (cd[68] * totalFees / 100) + (cd[68] / 100) < balanceOf[this.address]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(this.address)] = balanceOf[this.address] + (cd[68] * totalFees / 100) + (cd[68] / 100)
                                        emit Transfer(((cd[68] * totalFees / 100) + (cd[68] / 100)), address(cd[4]), this.address);
                                        if not address(cd[4]):
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not address(cd[36]):
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        if cd[68] - (cd[68] * totalFees / 100) - (cd[68] / 100) > balanceOf[address(cd[4])]:
                                            revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[486 len 26] >> 48, 0
                                        if balanceOf[address(cd[4])] < cd[68] - (cd[68] * totalFees / 100) - (cd[68] / 100):
                                            revert with 0, 17
                                        balanceOf[address(cd[4])] = balanceOf[address(cd[4])] - cd[68] + (cd[68] * totalFees / 100) + (cd[68] / 100)
                                        if balanceOf[address(cd[36])] > !(cd[68] - (cd[68] * totalFees / 100) - (cd[68] / 100)):
                                            revert with 0, 17
                                        if balanceOf[address(cd[36])] + cd[68] - (cd[68] * totalFees / 100) - (cd[68] / 100) < balanceOf[address(cd[36])]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(cd[36])] = balanceOf[address(cd[36])] + cd[68] - (cd[68] * totalFees / 100) - (cd[68] / 100)
                                        emit Transfer((cd[68] - (cd[68] * totalFees / 100) - (cd[68] / 100)), address(cd[4]), address(cd[36]));
                                    require ext_code.size(dividendTrackerAddress)
                                    call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args address(cd[4]), balanceOf[address(cd[4])]
                                    require ext_code.size(dividendTrackerAddress)
                                    call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args address(cd[36]), balanceOf[address(cd[36])]
                                    if stor7:
                                        if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                            revert with 0, 32, 40, 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[584 len 24] >> 64, 0
                                    else:
                                        call dividendTrackerAddress.process(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args gasForProcessing
                                        if not ext_call.success:
                                            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                revert with 0, 
                                                            32,
                                                            40,
                                                            0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, ext_call.return_data[72 len 24] >> 64,
                                                            0
                                        else:
                                            require return_data.size >= 96
                                            emit ProcessedDividendTracker(ext_call.return_data[0], ext_call.return_data[32], ext_call.return_data[64], gasForProcessing, 1, tx.origin);
                                            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                revert with 0, 
                                                            32,
                                                            40,
                                                            0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, Mask(192, 0, ext_call.return_data[64]) >> 64,
                                                            0
            else:
                if stor7:
                    if stor19[address(cd[4])]:
                        if not address(cd[4]):
                            revert with 0, 'ERC20: transfer from the zero address'
                        if not address(cd[36]):
                            revert with 0, 'ERC20: transfer to the zero address'
                        if cd[68] > balanceOf[address(cd[4])]:
                            revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                        if balanceOf[address(cd[4])] < cd[68]:
                            revert with 0, 17
                        balanceOf[address(cd[4])] -= cd[68]
                        if balanceOf[address(cd[36])] > !cd[68]:
                            revert with 0, 17
                        if balanceOf[address(cd[36])] + cd[68] < balanceOf[address(cd[36])]:
                            revert with 0, 'SafeMath: addition overflow'
                        balanceOf[address(cd[36])] += cd[68]
                        emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                        require ext_code.size(dividendTrackerAddress)
                        call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(cd[4]), balanceOf[address(cd[4])]
                        require ext_code.size(dividendTrackerAddress)
                        call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                             gas gas_remaining wei
                            args address(cd[36]), balanceOf[address(cd[36])]
                        if stor7:
                            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                revert with 0, 32, 40, 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[296 len 24] >> 64, 0
                        else:
                            call dividendTrackerAddress.process(uint256 arg1) with:
                                 gas gas_remaining wei
                                args gasForProcessing
                            if not ext_call.success:
                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                    revert with 0, 
                                                32,
                                                40,
                                                0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, ext_call.return_data[72 len 24] >> 64,
                                                0
                            else:
                                require return_data.size >= 96
                                emit ProcessedDividendTracker(ext_call.return_data[0], ext_call.return_data[32], ext_call.return_data[64], gasForProcessing, 1, tx.origin);
                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                    revert with 0, 
                                                32,
                                                40,
                                                0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, Mask(192, 0, ext_call.return_data[64]) >> 64,
                                                0
                    else:
                        if stor19[address(cd[36])]:
                            if not address(cd[4]):
                                revert with 0, 'ERC20: transfer from the zero address'
                            if not address(cd[36]):
                                revert with 0, 'ERC20: transfer to the zero address'
                            if cd[68] > balanceOf[address(cd[4])]:
                                revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                            if balanceOf[address(cd[4])] < cd[68]:
                                revert with 0, 17
                            balanceOf[address(cd[4])] -= cd[68]
                            if balanceOf[address(cd[36])] > !cd[68]:
                                revert with 0, 17
                            if balanceOf[address(cd[36])] + cd[68] < balanceOf[address(cd[36])]:
                                revert with 0, 'SafeMath: addition overflow'
                            balanceOf[address(cd[36])] += cd[68]
                            emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                            require ext_code.size(dividendTrackerAddress)
                            call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args address(cd[4]), balanceOf[address(cd[4])]
                            require ext_code.size(dividendTrackerAddress)
                            call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args address(cd[36]), balanceOf[address(cd[36])]
                            if stor7:
                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                    revert with 0, 32, 40, 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[296 len 24] >> 64, 0
                            else:
                                call dividendTrackerAddress.process(uint256 arg1) with:
                                     gas gas_remaining wei
                                    args gasForProcessing
                                if not ext_call.success:
                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                        revert with 0, 
                                                    32,
                                                    40,
                                                    0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, ext_call.return_data[72 len 24] >> 64,
                                                    0
                                else:
                                    require return_data.size >= 96
                                    emit ProcessedDividendTracker(ext_call.return_data[0], ext_call.return_data[32], ext_call.return_data[64], gasForProcessing, 1, tx.origin);
                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                        revert with 0, 
                                                    32,
                                                    40,
                                                    0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, Mask(192, 0, ext_call.return_data[64]) >> 64,
                                                    0
                        else:
                            if stor7:
                                if not address(cd[4]):
                                    revert with 0, 'ERC20: transfer from the zero address'
                                if not address(cd[36]):
                                    revert with 0, 'ERC20: transfer to the zero address'
                                if cd[68] > balanceOf[address(cd[4])]:
                                    revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                if balanceOf[address(cd[4])] < cd[68]:
                                    revert with 0, 17
                                balanceOf[address(cd[4])] -= cd[68]
                                if balanceOf[address(cd[36])] > !cd[68]:
                                    revert with 0, 17
                                if balanceOf[address(cd[36])] + cd[68] < balanceOf[address(cd[36])]:
                                    revert with 0, 'SafeMath: addition overflow'
                                balanceOf[address(cd[36])] += cd[68]
                                emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                                require ext_code.size(dividendTrackerAddress)
                                call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args address(cd[4]), balanceOf[address(cd[4])]
                                require ext_code.size(dividendTrackerAddress)
                                call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args address(cd[36]), balanceOf[address(cd[36])]
                                if stor7:
                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                        revert with 0, 32, 40, 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[296 len 24] >> 64, 0
                                else:
                                    call dividendTrackerAddress.process(uint256 arg1) with:
                                         gas gas_remaining wei
                                        args gasForProcessing
                                    if not ext_call.success:
                                        if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                            revert with 0, 
                                                        32,
                                                        40,
                                                        0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, ext_call.return_data[72 len 24] >> 64,
                                                        0
                                    else:
                                        require return_data.size >= 96
                                        emit ProcessedDividendTracker(ext_call.return_data[0], ext_call.return_data[32], ext_call.return_data[64], gasForProcessing, 1, tx.origin);
                                        if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                            revert with 0, 
                                                        32,
                                                        40,
                                                        0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, Mask(192, 0, ext_call.return_data[64]) >> 64,
                                                        0
                            else:
                                if not cd[68]:
                                    if not stor20[address(cd[36])]:
                                        if 0 > cd[68]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if cd[68] < 0:
                                            revert with 0, 17
                                        if not address(cd[4]):
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not this.address:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        if 0 > balanceOf[address(cd[4])]:
                                            revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[326 len 26] >> 48, 0
                                        if balanceOf[address(cd[4])] < 0:
                                            revert with 0, 17
                                        if balanceOf[this.address] > -1:
                                            revert with 0, 17
                                        if balanceOf[this.address] < balanceOf[this.address]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(this.address)] = balanceOf[this.address]
                                        emit Transfer(0, address(cd[4]), this.address);
                                        if not address(cd[4]):
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not address(cd[36]):
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        if cd[68] > balanceOf[address(cd[4])]:
                                            revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[422 len 26] >> 48, 0
                                        if balanceOf[address(cd[4])] < cd[68]:
                                            revert with 0, 17
                                        balanceOf[address(cd[4])] -= cd[68]
                                        if balanceOf[address(cd[36])] > !cd[68]:
                                            revert with 0, 17
                                        if balanceOf[address(cd[36])] + cd[68] < balanceOf[address(cd[36])]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(cd[36])] += cd[68]
                                        emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                                        require ext_code.size(dividendTrackerAddress)
                                        call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                             gas gas_remaining wei
                                            args address(cd[4]), balanceOf[address(cd[4])]
                                        require ext_code.size(dividendTrackerAddress)
                                        call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                             gas gas_remaining wei
                                            args address(cd[36]), balanceOf[address(cd[36])]
                                        if stor7:
                                            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                revert with 0, 32, 40, 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[520 len 24] >> 64, 0
                                        else:
                                            call dividendTrackerAddress.process(uint256 arg1) with:
                                                 gas gas_remaining wei
                                                args gasForProcessing
                                            if not ext_call.success:
                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, ext_call.return_data[72 len 24] >> 64,
                                                                0
                                            else:
                                                require return_data.size >= 96
                                                emit ProcessedDividendTracker(ext_call.return_data[0], ext_call.return_data[32], ext_call.return_data[64], gasForProcessing, 1, tx.origin);
                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, Mask(192, 0, ext_call.return_data[64]) >> 64,
                                                                0
                                    else:
                                        if not cd[68]:
                                            if 0 > cd[68]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if cd[68] < 0:
                                                revert with 0, 17
                                            if not address(cd[4]):
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not this.address:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            if 0 > balanceOf[address(cd[4])]:
                                                revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[390 len 26] >> 48, 0
                                            if balanceOf[address(cd[4])] < 0:
                                                revert with 0, 17
                                            if balanceOf[this.address] > -1:
                                                revert with 0, 17
                                            if balanceOf[this.address] < balanceOf[this.address]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(this.address)] = balanceOf[this.address]
                                            emit Transfer(0, address(cd[4]), this.address);
                                            if not address(cd[4]):
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not address(cd[36]):
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            if cd[68] > balanceOf[address(cd[4])]:
                                                revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[486 len 26] >> 48, 0
                                            if balanceOf[address(cd[4])] < cd[68]:
                                                revert with 0, 17
                                            balanceOf[address(cd[4])] -= cd[68]
                                            if balanceOf[address(cd[36])] > !cd[68]:
                                                revert with 0, 17
                                            if balanceOf[address(cd[36])] + cd[68] < balanceOf[address(cd[36])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(cd[36])] += cd[68]
                                            emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                                        else:
                                            if cd[68] and 1 > -1 / cd[68]:
                                                revert with 0, 17
                                            if not cd[68]:
                                                revert with 0, 18
                                            if cd[68] / cd[68] != 1:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if 0 > !(cd[68] / 100):
                                                revert with 0, 17
                                            if cd[68] / 100 > cd[68]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if cd[68] < cd[68] / 100:
                                                revert with 0, 17
                                            if not address(cd[4]):
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not this.address:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            if cd[68] / 100 > balanceOf[address(cd[4])]:
                                                revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[390 len 26] >> 48, 0
                                            if balanceOf[address(cd[4])] < cd[68] / 100:
                                                revert with 0, 17
                                            balanceOf[address(cd[4])] -= cd[68] / 100
                                            if balanceOf[this.address] > !(cd[68] / 100):
                                                revert with 0, 17
                                            if balanceOf[this.address] + (cd[68] / 100) < balanceOf[this.address]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(this.address)] = balanceOf[this.address] + (cd[68] / 100)
                                            emit Transfer((cd[68] / 100), address(cd[4]), this.address);
                                            if not address(cd[4]):
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not address(cd[36]):
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            if cd[68] - (cd[68] / 100) > balanceOf[address(cd[4])]:
                                                revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[486 len 26] >> 48, 0
                                            if balanceOf[address(cd[4])] < cd[68] - (cd[68] / 100):
                                                revert with 0, 17
                                            balanceOf[address(cd[4])] = balanceOf[address(cd[4])] - cd[68] + (cd[68] / 100)
                                            if balanceOf[address(cd[36])] > !(cd[68] - (cd[68] / 100)):
                                                revert with 0, 17
                                            if balanceOf[address(cd[36])] + cd[68] - (cd[68] / 100) < balanceOf[address(cd[36])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(cd[36])] = balanceOf[address(cd[36])] + cd[68] - (cd[68] / 100)
                                            emit Transfer((cd[68] - (cd[68] / 100)), address(cd[4]), address(cd[36]));
                                        require ext_code.size(dividendTrackerAddress)
                                        call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                             gas gas_remaining wei
                                            args address(cd[4]), balanceOf[address(cd[4])]
                                        require ext_code.size(dividendTrackerAddress)
                                        call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                             gas gas_remaining wei
                                            args address(cd[36]), balanceOf[address(cd[36])]
                                        if stor7:
                                            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                revert with 0, 32, 40, 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[584 len 24] >> 64, 0
                                        else:
                                            call dividendTrackerAddress.process(uint256 arg1) with:
                                                 gas gas_remaining wei
                                                args gasForProcessing
                                            if not ext_call.success:
                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, ext_call.return_data[72 len 24] >> 64,
                                                                0
                                            else:
                                                require return_data.size >= 96
                                                emit ProcessedDividendTracker(ext_call.return_data[0], ext_call.return_data[32], ext_call.return_data[64], gasForProcessing, 1, tx.origin);
                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, Mask(192, 0, ext_call.return_data[64]) >> 64,
                                                                0
                                else:
                                    if cd[68] and totalFees > -1 / cd[68]:
                                        revert with 0, 17
                                    if not cd[68]:
                                        revert with 0, 18
                                    if cd[68] * totalFees / cd[68] != totalFees:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not stor20[address(cd[36])]:
                                        if cd[68] * totalFees / 100 > cd[68]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if cd[68] < cd[68] * totalFees / 100:
                                            revert with 0, 17
                                        if not address(cd[4]):
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not this.address:
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        if cd[68] * totalFees / 100 > balanceOf[address(cd[4])]:
                                            revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[326 len 26] >> 48, 0
                                        if balanceOf[address(cd[4])] < cd[68] * totalFees / 100:
                                            revert with 0, 17
                                        balanceOf[address(cd[4])] -= cd[68] * totalFees / 100
                                        if balanceOf[this.address] > !(cd[68] * totalFees / 100):
                                            revert with 0, 17
                                        if balanceOf[this.address] + (cd[68] * totalFees / 100) < balanceOf[this.address]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(this.address)] = balanceOf[this.address] + (cd[68] * totalFees / 100)
                                        emit Transfer((cd[68] * totalFees / 100), address(cd[4]), this.address);
                                        if not address(cd[4]):
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not address(cd[36]):
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        if cd[68] - (cd[68] * totalFees / 100) > balanceOf[address(cd[4])]:
                                            revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[422 len 26] >> 48, 0
                                        if balanceOf[address(cd[4])] < cd[68] - (cd[68] * totalFees / 100):
                                            revert with 0, 17
                                        balanceOf[address(cd[4])] = balanceOf[address(cd[4])] - cd[68] + (cd[68] * totalFees / 100)
                                        if balanceOf[address(cd[36])] > !(cd[68] - (cd[68] * totalFees / 100)):
                                            revert with 0, 17
                                        if balanceOf[address(cd[36])] + cd[68] - (cd[68] * totalFees / 100) < balanceOf[address(cd[36])]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(cd[36])] = balanceOf[address(cd[36])] + cd[68] - (cd[68] * totalFees / 100)
                                        emit Transfer((cd[68] - (cd[68] * totalFees / 100)), address(cd[4]), address(cd[36]));
                                        require ext_code.size(dividendTrackerAddress)
                                        call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                             gas gas_remaining wei
                                            args address(cd[4]), balanceOf[address(cd[4])]
                                        require ext_code.size(dividendTrackerAddress)
                                        call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                             gas gas_remaining wei
                                            args address(cd[36]), balanceOf[address(cd[36])]
                                        if stor7:
                                            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                revert with 0, 32, 40, 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[520 len 24] >> 64, 0
                                        else:
                                            call dividendTrackerAddress.process(uint256 arg1) with:
                                                 gas gas_remaining wei
                                                args gasForProcessing
                                            if not ext_call.success:
                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, ext_call.return_data[72 len 24] >> 64,
                                                                0
                                            else:
                                                require return_data.size >= 96
                                                emit ProcessedDividendTracker(ext_call.return_data[0], ext_call.return_data[32], ext_call.return_data[64], gasForProcessing, 1, tx.origin);
                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, Mask(192, 0, ext_call.return_data[64]) >> 64,
                                                                0
                                    else:
                                        if not cd[68]:
                                            if cd[68] * totalFees / 100 > -1:
                                                revert with 0, 17
                                            if cd[68] * totalFees / 100 > cd[68]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if cd[68] < cd[68] * totalFees / 100:
                                                revert with 0, 17
                                            if not address(cd[4]):
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not this.address:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            if cd[68] * totalFees / 100 > balanceOf[address(cd[4])]:
                                                revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[390 len 26] >> 48, 0
                                            if balanceOf[address(cd[4])] < cd[68] * totalFees / 100:
                                                revert with 0, 17
                                            balanceOf[address(cd[4])] -= cd[68] * totalFees / 100
                                            if balanceOf[this.address] > !(cd[68] * totalFees / 100):
                                                revert with 0, 17
                                            if balanceOf[this.address] + (cd[68] * totalFees / 100) < balanceOf[this.address]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(this.address)] = balanceOf[this.address] + (cd[68] * totalFees / 100)
                                            emit Transfer((cd[68] * totalFees / 100), address(cd[4]), this.address);
                                            if not address(cd[4]):
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not address(cd[36]):
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            if cd[68] - (cd[68] * totalFees / 100) > balanceOf[address(cd[4])]:
                                                revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[486 len 26] >> 48, 0
                                            if balanceOf[address(cd[4])] < cd[68] - (cd[68] * totalFees / 100):
                                                revert with 0, 17
                                            balanceOf[address(cd[4])] = balanceOf[address(cd[4])] - cd[68] + (cd[68] * totalFees / 100)
                                            if balanceOf[address(cd[36])] > !(cd[68] - (cd[68] * totalFees / 100)):
                                                revert with 0, 17
                                            if balanceOf[address(cd[36])] + cd[68] - (cd[68] * totalFees / 100) < balanceOf[address(cd[36])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(cd[36])] = balanceOf[address(cd[36])] + cd[68] - (cd[68] * totalFees / 100)
                                            emit Transfer((cd[68] - (cd[68] * totalFees / 100)), address(cd[4]), address(cd[36]));
                                        else:
                                            if cd[68] and 1 > -1 / cd[68]:
                                                revert with 0, 17
                                            if not cd[68]:
                                                revert with 0, 18
                                            if cd[68] / cd[68] != 1:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if cd[68] * totalFees / 100 > !(cd[68] / 100):
                                                revert with 0, 17
                                            if (cd[68] * totalFees / 100) + (cd[68] / 100) > cd[68]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if cd[68] < (cd[68] * totalFees / 100) + (cd[68] / 100):
                                                revert with 0, 17
                                            if not address(cd[4]):
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not this.address:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            if (cd[68] * totalFees / 100) + (cd[68] / 100) > balanceOf[address(cd[4])]:
                                                revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[390 len 26] >> 48, 0
                                            if balanceOf[address(cd[4])] < (cd[68] * totalFees / 100) + (cd[68] / 100):
                                                revert with 0, 17
                                            balanceOf[address(cd[4])] = balanceOf[address(cd[4])] - (cd[68] * totalFees / 100) - (cd[68] / 100)
                                            if balanceOf[this.address] > !((cd[68] * totalFees / 100) + (cd[68] / 100)):
                                                revert with 0, 17
                                            if balanceOf[this.address] + (cd[68] * totalFees / 100) + (cd[68] / 100) < balanceOf[this.address]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(this.address)] = balanceOf[this.address] + (cd[68] * totalFees / 100) + (cd[68] / 100)
                                            emit Transfer(((cd[68] * totalFees / 100) + (cd[68] / 100)), address(cd[4]), this.address);
                                            if not address(cd[4]):
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not address(cd[36]):
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            if cd[68] - (cd[68] * totalFees / 100) - (cd[68] / 100) > balanceOf[address(cd[4])]:
                                                revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[486 len 26] >> 48, 0
                                            if balanceOf[address(cd[4])] < cd[68] - (cd[68] * totalFees / 100) - (cd[68] / 100):
                                                revert with 0, 17
                                            balanceOf[address(cd[4])] = balanceOf[address(cd[4])] - cd[68] + (cd[68] * totalFees / 100) + (cd[68] / 100)
                                            if balanceOf[address(cd[36])] > !(cd[68] - (cd[68] * totalFees / 100) - (cd[68] / 100)):
                                                revert with 0, 17
                                            if balanceOf[address(cd[36])] + cd[68] - (cd[68] * totalFees / 100) - (cd[68] / 100) < balanceOf[address(cd[36])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(cd[36])] = balanceOf[address(cd[36])] + cd[68] - (cd[68] * totalFees / 100) - (cd[68] / 100)
                                            emit Transfer((cd[68] - (cd[68] * totalFees / 100) - (cd[68] / 100)), address(cd[4]), address(cd[36]));
                                        require ext_code.size(dividendTrackerAddress)
                                        call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                             gas gas_remaining wei
                                            args address(cd[4]), balanceOf[address(cd[4])]
                                        require ext_code.size(dividendTrackerAddress)
                                        call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                             gas gas_remaining wei
                                            args address(cd[36]), balanceOf[address(cd[36])]
                                        if stor7:
                                            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                revert with 0, 32, 40, 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[584 len 24] >> 64, 0
                                        else:
                                            call dividendTrackerAddress.process(uint256 arg1) with:
                                                 gas gas_remaining wei
                                                args gasForProcessing
                                            if not ext_call.success:
                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, ext_call.return_data[72 len 24] >> 64,
                                                                0
                                            else:
                                                require return_data.size >= 96
                                                emit ProcessedDividendTracker(ext_call.return_data[0], ext_call.return_data[32], ext_call.return_data[64], gasForProcessing, 1, tx.origin);
                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, Mask(192, 0, ext_call.return_data[64]) >> 64,
                                                                0
                else:
                    if stor20[address(cd[4])]:
                        if stor19[address(cd[4])]:
                            if not address(cd[4]):
                                revert with 0, 'ERC20: transfer from the zero address'
                            if not address(cd[36]):
                                revert with 0, 'ERC20: transfer to the zero address'
                            if cd[68] > balanceOf[address(cd[4])]:
                                revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                            if balanceOf[address(cd[4])] < cd[68]:
                                revert with 0, 17
                            balanceOf[address(cd[4])] -= cd[68]
                            if balanceOf[address(cd[36])] > !cd[68]:
                                revert with 0, 17
                            if balanceOf[address(cd[36])] + cd[68] < balanceOf[address(cd[36])]:
                                revert with 0, 'SafeMath: addition overflow'
                            balanceOf[address(cd[36])] += cd[68]
                            emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                            require ext_code.size(dividendTrackerAddress)
                            call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args address(cd[4]), balanceOf[address(cd[4])]
                            require ext_code.size(dividendTrackerAddress)
                            call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                 gas gas_remaining wei
                                args address(cd[36]), balanceOf[address(cd[36])]
                            if stor7:
                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                    revert with 0, 32, 40, 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[296 len 24] >> 64, 0
                            else:
                                call dividendTrackerAddress.process(uint256 arg1) with:
                                     gas gas_remaining wei
                                    args gasForProcessing
                                if not ext_call.success:
                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                        revert with 0, 
                                                    32,
                                                    40,
                                                    0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, ext_call.return_data[72 len 24] >> 64,
                                                    0
                                else:
                                    require return_data.size >= 96
                                    emit ProcessedDividendTracker(ext_call.return_data[0], ext_call.return_data[32], ext_call.return_data[64], gasForProcessing, 1, tx.origin);
                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                        revert with 0, 
                                                    32,
                                                    40,
                                                    0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, Mask(192, 0, ext_call.return_data[64]) >> 64,
                                                    0
                        else:
                            if stor19[address(cd[36])]:
                                if not address(cd[4]):
                                    revert with 0, 'ERC20: transfer from the zero address'
                                if not address(cd[36]):
                                    revert with 0, 'ERC20: transfer to the zero address'
                                if cd[68] > balanceOf[address(cd[4])]:
                                    revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                if balanceOf[address(cd[4])] < cd[68]:
                                    revert with 0, 17
                                balanceOf[address(cd[4])] -= cd[68]
                                if balanceOf[address(cd[36])] > !cd[68]:
                                    revert with 0, 17
                                if balanceOf[address(cd[36])] + cd[68] < balanceOf[address(cd[36])]:
                                    revert with 0, 'SafeMath: addition overflow'
                                balanceOf[address(cd[36])] += cd[68]
                                emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                                require ext_code.size(dividendTrackerAddress)
                                call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args address(cd[4]), balanceOf[address(cd[4])]
                                require ext_code.size(dividendTrackerAddress)
                                call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args address(cd[36]), balanceOf[address(cd[36])]
                                if stor7:
                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                        revert with 0, 32, 40, 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[296 len 24] >> 64, 0
                                else:
                                    call dividendTrackerAddress.process(uint256 arg1) with:
                                         gas gas_remaining wei
                                        args gasForProcessing
                                    if not ext_call.success:
                                        if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                            revert with 0, 
                                                        32,
                                                        40,
                                                        0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, ext_call.return_data[72 len 24] >> 64,
                                                        0
                                    else:
                                        require return_data.size >= 96
                                        emit ProcessedDividendTracker(ext_call.return_data[0], ext_call.return_data[32], ext_call.return_data[64], gasForProcessing, 1, tx.origin);
                                        if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                            revert with 0, 
                                                        32,
                                                        40,
                                                        0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, Mask(192, 0, ext_call.return_data[64]) >> 64,
                                                        0
                            else:
                                if stor7:
                                    if not address(cd[4]):
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if not address(cd[36]):
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    if cd[68] > balanceOf[address(cd[4])]:
                                        revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                    if balanceOf[address(cd[4])] < cd[68]:
                                        revert with 0, 17
                                    balanceOf[address(cd[4])] -= cd[68]
                                    if balanceOf[address(cd[36])] > !cd[68]:
                                        revert with 0, 17
                                    if balanceOf[address(cd[36])] + cd[68] < balanceOf[address(cd[36])]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(cd[36])] += cd[68]
                                    emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                                    require ext_code.size(dividendTrackerAddress)
                                    call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args address(cd[4]), balanceOf[address(cd[4])]
                                    require ext_code.size(dividendTrackerAddress)
                                    call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args address(cd[36]), balanceOf[address(cd[36])]
                                    if stor7:
                                        if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                            revert with 0, 32, 40, 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[296 len 24] >> 64, 0
                                    else:
                                        call dividendTrackerAddress.process(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args gasForProcessing
                                        if not ext_call.success:
                                            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                revert with 0, 
                                                            32,
                                                            40,
                                                            0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, ext_call.return_data[72 len 24] >> 64,
                                                            0
                                        else:
                                            require return_data.size >= 96
                                            emit ProcessedDividendTracker(ext_call.return_data[0], ext_call.return_data[32], ext_call.return_data[64], gasForProcessing, 1, tx.origin);
                                            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                revert with 0, 
                                                            32,
                                                            40,
                                                            0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, Mask(192, 0, ext_call.return_data[64]) >> 64,
                                                            0
                                else:
                                    if not cd[68]:
                                        if not stor20[address(cd[36])]:
                                            if 0 > cd[68]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if cd[68] < 0:
                                                revert with 0, 17
                                            if not address(cd[4]):
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not this.address:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            if 0 > balanceOf[address(cd[4])]:
                                                revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[326 len 26] >> 48, 0
                                            if balanceOf[address(cd[4])] < 0:
                                                revert with 0, 17
                                            if balanceOf[this.address] > -1:
                                                revert with 0, 17
                                            if balanceOf[this.address] < balanceOf[this.address]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(this.address)] = balanceOf[this.address]
                                            emit Transfer(0, address(cd[4]), this.address);
                                            if not address(cd[4]):
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not address(cd[36]):
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            if cd[68] > balanceOf[address(cd[4])]:
                                                revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[422 len 26] >> 48, 0
                                            if balanceOf[address(cd[4])] < cd[68]:
                                                revert with 0, 17
                                            balanceOf[address(cd[4])] -= cd[68]
                                            if balanceOf[address(cd[36])] > !cd[68]:
                                                revert with 0, 17
                                            if balanceOf[address(cd[36])] + cd[68] < balanceOf[address(cd[36])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(cd[36])] += cd[68]
                                            emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                                            require ext_code.size(dividendTrackerAddress)
                                            call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args address(cd[4]), balanceOf[address(cd[4])]
                                            require ext_code.size(dividendTrackerAddress)
                                            call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args address(cd[36]), balanceOf[address(cd[36])]
                                            if stor7:
                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                    revert with 0, 32, 40, 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[520 len 24] >> 64, 0
                                            else:
                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                     gas gas_remaining wei
                                                    args gasForProcessing
                                                if not ext_call.success:
                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                        revert with 0, 
                                                                    32,
                                                                    40,
                                                                    0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, ext_call.return_data[72 len 24] >> 64,
                                                                    0
                                                else:
                                                    require return_data.size >= 96
                                                    emit ProcessedDividendTracker(ext_call.return_data[0], ext_call.return_data[32], ext_call.return_data[64], gasForProcessing, 1, tx.origin);
                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                        revert with 0, 
                                                                    32,
                                                                    40,
                                                                    0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, Mask(192, 0, ext_call.return_data[64]) >> 64,
                                                                    0
                                        else:
                                            if not cd[68]:
                                                if 0 > cd[68]:
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if cd[68] < 0:
                                                    revert with 0, 17
                                                if not address(cd[4]):
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not this.address:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                if 0 > balanceOf[address(cd[4])]:
                                                    revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[390 len 26] >> 48, 0
                                                if balanceOf[address(cd[4])] < 0:
                                                    revert with 0, 17
                                                if balanceOf[this.address] > -1:
                                                    revert with 0, 17
                                                if balanceOf[this.address] < balanceOf[this.address]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(this.address)] = balanceOf[this.address]
                                                emit Transfer(0, address(cd[4]), this.address);
                                                if not address(cd[4]):
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not address(cd[36]):
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                if cd[68] > balanceOf[address(cd[4])]:
                                                    revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[486 len 26] >> 48, 0
                                                if balanceOf[address(cd[4])] < cd[68]:
                                                    revert with 0, 17
                                                balanceOf[address(cd[4])] -= cd[68]
                                                if balanceOf[address(cd[36])] > !cd[68]:
                                                    revert with 0, 17
                                                if balanceOf[address(cd[36])] + cd[68] < balanceOf[address(cd[36])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(cd[36])] += cd[68]
                                                emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                                            else:
                                                if cd[68] and 1 > -1 / cd[68]:
                                                    revert with 0, 17
                                                if not cd[68]:
                                                    revert with 0, 18
                                                if cd[68] / cd[68] != 1:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if 0 > !(cd[68] / 100):
                                                    revert with 0, 17
                                                if cd[68] / 100 > cd[68]:
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if cd[68] < cd[68] / 100:
                                                    revert with 0, 17
                                                if not address(cd[4]):
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not this.address:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                if cd[68] / 100 > balanceOf[address(cd[4])]:
                                                    revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[390 len 26] >> 48, 0
                                                if balanceOf[address(cd[4])] < cd[68] / 100:
                                                    revert with 0, 17
                                                balanceOf[address(cd[4])] -= cd[68] / 100
                                                if balanceOf[this.address] > !(cd[68] / 100):
                                                    revert with 0, 17
                                                if balanceOf[this.address] + (cd[68] / 100) < balanceOf[this.address]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(this.address)] = balanceOf[this.address] + (cd[68] / 100)
                                                emit Transfer((cd[68] / 100), address(cd[4]), this.address);
                                                if not address(cd[4]):
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not address(cd[36]):
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                if cd[68] - (cd[68] / 100) > balanceOf[address(cd[4])]:
                                                    revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[486 len 26] >> 48, 0
                                                if balanceOf[address(cd[4])] < cd[68] - (cd[68] / 100):
                                                    revert with 0, 17
                                                balanceOf[address(cd[4])] = balanceOf[address(cd[4])] - cd[68] + (cd[68] / 100)
                                                if balanceOf[address(cd[36])] > !(cd[68] - (cd[68] / 100)):
                                                    revert with 0, 17
                                                if balanceOf[address(cd[36])] + cd[68] - (cd[68] / 100) < balanceOf[address(cd[36])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(cd[36])] = balanceOf[address(cd[36])] + cd[68] - (cd[68] / 100)
                                                emit Transfer((cd[68] - (cd[68] / 100)), address(cd[4]), address(cd[36]));
                                            require ext_code.size(dividendTrackerAddress)
                                            call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args address(cd[4]), balanceOf[address(cd[4])]
                                            require ext_code.size(dividendTrackerAddress)
                                            call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args address(cd[36]), balanceOf[address(cd[36])]
                                            if stor7:
                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                    revert with 0, 32, 40, 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[584 len 24] >> 64, 0
                                            else:
                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                     gas gas_remaining wei
                                                    args gasForProcessing
                                                if not ext_call.success:
                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                        revert with 0, 
                                                                    32,
                                                                    40,
                                                                    0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, ext_call.return_data[72 len 24] >> 64,
                                                                    0
                                                else:
                                                    require return_data.size >= 96
                                                    emit ProcessedDividendTracker(ext_call.return_data[0], ext_call.return_data[32], ext_call.return_data[64], gasForProcessing, 1, tx.origin);
                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                        revert with 0, 
                                                                    32,
                                                                    40,
                                                                    0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, Mask(192, 0, ext_call.return_data[64]) >> 64,
                                                                    0
                                    else:
                                        if cd[68] and totalFees > -1 / cd[68]:
                                            revert with 0, 17
                                        if not cd[68]:
                                            revert with 0, 18
                                        if cd[68] * totalFees / cd[68] != totalFees:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not stor20[address(cd[36])]:
                                            if cd[68] * totalFees / 100 > cd[68]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if cd[68] < cd[68] * totalFees / 100:
                                                revert with 0, 17
                                            if not address(cd[4]):
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not this.address:
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            if cd[68] * totalFees / 100 > balanceOf[address(cd[4])]:
                                                revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[326 len 26] >> 48, 0
                                            if balanceOf[address(cd[4])] < cd[68] * totalFees / 100:
                                                revert with 0, 17
                                            balanceOf[address(cd[4])] -= cd[68] * totalFees / 100
                                            if balanceOf[this.address] > !(cd[68] * totalFees / 100):
                                                revert with 0, 17
                                            if balanceOf[this.address] + (cd[68] * totalFees / 100) < balanceOf[this.address]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(this.address)] = balanceOf[this.address] + (cd[68] * totalFees / 100)
                                            emit Transfer((cd[68] * totalFees / 100), address(cd[4]), this.address);
                                            if not address(cd[4]):
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not address(cd[36]):
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            if cd[68] - (cd[68] * totalFees / 100) > balanceOf[address(cd[4])]:
                                                revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[422 len 26] >> 48, 0
                                            if balanceOf[address(cd[4])] < cd[68] - (cd[68] * totalFees / 100):
                                                revert with 0, 17
                                            balanceOf[address(cd[4])] = balanceOf[address(cd[4])] - cd[68] + (cd[68] * totalFees / 100)
                                            if balanceOf[address(cd[36])] > !(cd[68] - (cd[68] * totalFees / 100)):
                                                revert with 0, 17
                                            if balanceOf[address(cd[36])] + cd[68] - (cd[68] * totalFees / 100) < balanceOf[address(cd[36])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(cd[36])] = balanceOf[address(cd[36])] + cd[68] - (cd[68] * totalFees / 100)
                                            emit Transfer((cd[68] - (cd[68] * totalFees / 100)), address(cd[4]), address(cd[36]));
                                            require ext_code.size(dividendTrackerAddress)
                                            call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args address(cd[4]), balanceOf[address(cd[4])]
                                            require ext_code.size(dividendTrackerAddress)
                                            call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args address(cd[36]), balanceOf[address(cd[36])]
                                            if stor7:
                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                    revert with 0, 32, 40, 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[520 len 24] >> 64, 0
                                            else:
                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                     gas gas_remaining wei
                                                    args gasForProcessing
                                                if not ext_call.success:
                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                        revert with 0, 
                                                                    32,
                                                                    40,
                                                                    0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, ext_call.return_data[72 len 24] >> 64,
                                                                    0
                                                else:
                                                    require return_data.size >= 96
                                                    emit ProcessedDividendTracker(ext_call.return_data[0], ext_call.return_data[32], ext_call.return_data[64], gasForProcessing, 1, tx.origin);
                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                        revert with 0, 
                                                                    32,
                                                                    40,
                                                                    0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, Mask(192, 0, ext_call.return_data[64]) >> 64,
                                                                    0
                                        else:
                                            if not cd[68]:
                                                if cd[68] * totalFees / 100 > -1:
                                                    revert with 0, 17
                                                if cd[68] * totalFees / 100 > cd[68]:
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if cd[68] < cd[68] * totalFees / 100:
                                                    revert with 0, 17
                                                if not address(cd[4]):
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not this.address:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                if cd[68] * totalFees / 100 > balanceOf[address(cd[4])]:
                                                    revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[390 len 26] >> 48, 0
                                                if balanceOf[address(cd[4])] < cd[68] * totalFees / 100:
                                                    revert with 0, 17
                                                balanceOf[address(cd[4])] -= cd[68] * totalFees / 100
                                                if balanceOf[this.address] > !(cd[68] * totalFees / 100):
                                                    revert with 0, 17
                                                if balanceOf[this.address] + (cd[68] * totalFees / 100) < balanceOf[this.address]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(this.address)] = balanceOf[this.address] + (cd[68] * totalFees / 100)
                                                emit Transfer((cd[68] * totalFees / 100), address(cd[4]), this.address);
                                                if not address(cd[4]):
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not address(cd[36]):
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                if cd[68] - (cd[68] * totalFees / 100) > balanceOf[address(cd[4])]:
                                                    revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[486 len 26] >> 48, 0
                                                if balanceOf[address(cd[4])] < cd[68] - (cd[68] * totalFees / 100):
                                                    revert with 0, 17
                                                balanceOf[address(cd[4])] = balanceOf[address(cd[4])] - cd[68] + (cd[68] * totalFees / 100)
                                                if balanceOf[address(cd[36])] > !(cd[68] - (cd[68] * totalFees / 100)):
                                                    revert with 0, 17
                                                if balanceOf[address(cd[36])] + cd[68] - (cd[68] * totalFees / 100) < balanceOf[address(cd[36])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(cd[36])] = balanceOf[address(cd[36])] + cd[68] - (cd[68] * totalFees / 100)
                                                emit Transfer((cd[68] - (cd[68] * totalFees / 100)), address(cd[4]), address(cd[36]));
                                            else:
                                                if cd[68] and 1 > -1 / cd[68]:
                                                    revert with 0, 17
                                                if not cd[68]:
                                                    revert with 0, 18
                                                if cd[68] / cd[68] != 1:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if cd[68] * totalFees / 100 > !(cd[68] / 100):
                                                    revert with 0, 17
                                                if (cd[68] * totalFees / 100) + (cd[68] / 100) > cd[68]:
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if cd[68] < (cd[68] * totalFees / 100) + (cd[68] / 100):
                                                    revert with 0, 17
                                                if not address(cd[4]):
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not this.address:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                if (cd[68] * totalFees / 100) + (cd[68] / 100) > balanceOf[address(cd[4])]:
                                                    revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[390 len 26] >> 48, 0
                                                if balanceOf[address(cd[4])] < (cd[68] * totalFees / 100) + (cd[68] / 100):
                                                    revert with 0, 17
                                                balanceOf[address(cd[4])] = balanceOf[address(cd[4])] - (cd[68] * totalFees / 100) - (cd[68] / 100)
                                                if balanceOf[this.address] > !((cd[68] * totalFees / 100) + (cd[68] / 100)):
                                                    revert with 0, 17
                                                if balanceOf[this.address] + (cd[68] * totalFees / 100) + (cd[68] / 100) < balanceOf[this.address]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(this.address)] = balanceOf[this.address] + (cd[68] * totalFees / 100) + (cd[68] / 100)
                                                emit Transfer(((cd[68] * totalFees / 100) + (cd[68] / 100)), address(cd[4]), this.address);
                                                if not address(cd[4]):
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not address(cd[36]):
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                if cd[68] - (cd[68] * totalFees / 100) - (cd[68] / 100) > balanceOf[address(cd[4])]:
                                                    revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[486 len 26] >> 48, 0
                                                if balanceOf[address(cd[4])] < cd[68] - (cd[68] * totalFees / 100) - (cd[68] / 100):
                                                    revert with 0, 17
                                                balanceOf[address(cd[4])] = balanceOf[address(cd[4])] - cd[68] + (cd[68] * totalFees / 100) + (cd[68] / 100)
                                                if balanceOf[address(cd[36])] > !(cd[68] - (cd[68] * totalFees / 100) - (cd[68] / 100)):
                                                    revert with 0, 17
                                                if balanceOf[address(cd[36])] + cd[68] - (cd[68] * totalFees / 100) - (cd[68] / 100) < balanceOf[address(cd[36])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(cd[36])] = balanceOf[address(cd[36])] + cd[68] - (cd[68] * totalFees / 100) - (cd[68] / 100)
                                                emit Transfer((cd[68] - (cd[68] * totalFees / 100) - (cd[68] / 100)), address(cd[4]), address(cd[36]));
                                            require ext_code.size(dividendTrackerAddress)
                                            call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args address(cd[4]), balanceOf[address(cd[4])]
                                            require ext_code.size(dividendTrackerAddress)
                                            call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args address(cd[36]), balanceOf[address(cd[36])]
                                            if stor7:
                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                    revert with 0, 32, 40, 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[584 len 24] >> 64, 0
                                            else:
                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                     gas gas_remaining wei
                                                    args gasForProcessing
                                                if not ext_call.success:
                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                        revert with 0, 
                                                                    32,
                                                                    40,
                                                                    0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, ext_call.return_data[72 len 24] >> 64,
                                                                    0
                                                else:
                                                    require return_data.size >= 96
                                                    emit ProcessedDividendTracker(ext_call.return_data[0], ext_call.return_data[32], ext_call.return_data[64], gasForProcessing, 1, tx.origin);
                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                        revert with 0, 
                                                                    32,
                                                                    40,
                                                                    0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, Mask(192, 0, ext_call.return_data[64]) >> 64,
                                                                    0
                    else:
                        if owner == address(cd[4]):
                            if stor19[address(cd[4])]:
                                if not address(cd[4]):
                                    revert with 0, 'ERC20: transfer from the zero address'
                                if not address(cd[36]):
                                    revert with 0, 'ERC20: transfer to the zero address'
                                if cd[68] > balanceOf[address(cd[4])]:
                                    revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                if balanceOf[address(cd[4])] < cd[68]:
                                    revert with 0, 17
                                balanceOf[address(cd[4])] -= cd[68]
                                if balanceOf[address(cd[36])] > !cd[68]:
                                    revert with 0, 17
                                if balanceOf[address(cd[36])] + cd[68] < balanceOf[address(cd[36])]:
                                    revert with 0, 'SafeMath: addition overflow'
                                balanceOf[address(cd[36])] += cd[68]
                                emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                                require ext_code.size(dividendTrackerAddress)
                                call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args address(cd[4]), balanceOf[address(cd[4])]
                                require ext_code.size(dividendTrackerAddress)
                                call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                     gas gas_remaining wei
                                    args address(cd[36]), balanceOf[address(cd[36])]
                                if stor7:
                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                        revert with 0, 32, 40, 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[296 len 24] >> 64, 0
                                else:
                                    call dividendTrackerAddress.process(uint256 arg1) with:
                                         gas gas_remaining wei
                                        args gasForProcessing
                                    if not ext_call.success:
                                        if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                            revert with 0, 
                                                        32,
                                                        40,
                                                        0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, ext_call.return_data[72 len 24] >> 64,
                                                        0
                                    else:
                                        require return_data.size >= 96
                                        emit ProcessedDividendTracker(ext_call.return_data[0], ext_call.return_data[32], ext_call.return_data[64], gasForProcessing, 1, tx.origin);
                                        if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                            revert with 0, 
                                                        32,
                                                        40,
                                                        0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, Mask(192, 0, ext_call.return_data[64]) >> 64,
                                                        0
                            else:
                                if stor19[address(cd[36])]:
                                    if not address(cd[4]):
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if not address(cd[36]):
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    if cd[68] > balanceOf[address(cd[4])]:
                                        revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                    if balanceOf[address(cd[4])] < cd[68]:
                                        revert with 0, 17
                                    balanceOf[address(cd[4])] -= cd[68]
                                    if balanceOf[address(cd[36])] > !cd[68]:
                                        revert with 0, 17
                                    if balanceOf[address(cd[36])] + cd[68] < balanceOf[address(cd[36])]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(cd[36])] += cd[68]
                                    emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                                    require ext_code.size(dividendTrackerAddress)
                                    call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args address(cd[4]), balanceOf[address(cd[4])]
                                    require ext_code.size(dividendTrackerAddress)
                                    call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args address(cd[36]), balanceOf[address(cd[36])]
                                    if stor7:
                                        if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                            revert with 0, 32, 40, 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[296 len 24] >> 64, 0
                                    else:
                                        call dividendTrackerAddress.process(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args gasForProcessing
                                        if not ext_call.success:
                                            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                revert with 0, 
                                                            32,
                                                            40,
                                                            0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, ext_call.return_data[72 len 24] >> 64,
                                                            0
                                        else:
                                            require return_data.size >= 96
                                            emit ProcessedDividendTracker(ext_call.return_data[0], ext_call.return_data[32], ext_call.return_data[64], gasForProcessing, 1, tx.origin);
                                            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                revert with 0, 
                                                            32,
                                                            40,
                                                            0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, Mask(192, 0, ext_call.return_data[64]) >> 64,
                                                            0
                                else:
                                    if stor7:
                                        if not address(cd[4]):
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not address(cd[36]):
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        if cd[68] > balanceOf[address(cd[4])]:
                                            revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                        if balanceOf[address(cd[4])] < cd[68]:
                                            revert with 0, 17
                                        balanceOf[address(cd[4])] -= cd[68]
                                        if balanceOf[address(cd[36])] > !cd[68]:
                                            revert with 0, 17
                                        if balanceOf[address(cd[36])] + cd[68] < balanceOf[address(cd[36])]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(cd[36])] += cd[68]
                                        emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                                        require ext_code.size(dividendTrackerAddress)
                                        call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                             gas gas_remaining wei
                                            args address(cd[4]), balanceOf[address(cd[4])]
                                        require ext_code.size(dividendTrackerAddress)
                                        call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                             gas gas_remaining wei
                                            args address(cd[36]), balanceOf[address(cd[36])]
                                        if stor7:
                                            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                revert with 0, 32, 40, 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[296 len 24] >> 64, 0
                                        else:
                                            call dividendTrackerAddress.process(uint256 arg1) with:
                                                 gas gas_remaining wei
                                                args gasForProcessing
                                            if not ext_call.success:
                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, ext_call.return_data[72 len 24] >> 64,
                                                                0
                                            else:
                                                require return_data.size >= 96
                                                emit ProcessedDividendTracker(ext_call.return_data[0], ext_call.return_data[32], ext_call.return_data[64], gasForProcessing, 1, tx.origin);
                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, Mask(192, 0, ext_call.return_data[64]) >> 64,
                                                                0
                                    else:
                                        if not cd[68]:
                                            if not stor20[address(cd[36])]:
                                                if 0 > cd[68]:
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if cd[68] < 0:
                                                    revert with 0, 17
                                                if not address(cd[4]):
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not this.address:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                if 0 > balanceOf[address(cd[4])]:
                                                    revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[326 len 26] >> 48, 0
                                                if balanceOf[address(cd[4])] < 0:
                                                    revert with 0, 17
                                                if balanceOf[this.address] > -1:
                                                    revert with 0, 17
                                                if balanceOf[this.address] < balanceOf[this.address]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(this.address)] = balanceOf[this.address]
                                                emit Transfer(0, address(cd[4]), this.address);
                                                if not address(cd[4]):
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not address(cd[36]):
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                if cd[68] > balanceOf[address(cd[4])]:
                                                    revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[422 len 26] >> 48, 0
                                                if balanceOf[address(cd[4])] < cd[68]:
                                                    revert with 0, 17
                                                balanceOf[address(cd[4])] -= cd[68]
                                                if balanceOf[address(cd[36])] > !cd[68]:
                                                    revert with 0, 17
                                                if balanceOf[address(cd[36])] + cd[68] < balanceOf[address(cd[36])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(cd[36])] += cd[68]
                                                emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                                                require ext_code.size(dividendTrackerAddress)
                                                call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args address(cd[4]), balanceOf[address(cd[4])]
                                                require ext_code.size(dividendTrackerAddress)
                                                call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args address(cd[36]), balanceOf[address(cd[36])]
                                                if stor7:
                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                        revert with 0, 32, 40, 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[520 len 24] >> 64, 0
                                                else:
                                                    call dividendTrackerAddress.process(uint256 arg1) with:
                                                         gas gas_remaining wei
                                                        args gasForProcessing
                                                    if not ext_call.success:
                                                        if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                            revert with 0, 
                                                                        32,
                                                                        40,
                                                                        0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, ext_call.return_data[72 len 24] >> 64,
                                                                        0
                                                    else:
                                                        require return_data.size >= 96
                                                        emit ProcessedDividendTracker(ext_call.return_data[0], ext_call.return_data[32], ext_call.return_data[64], gasForProcessing, 1, tx.origin);
                                                        if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                            revert with 0, 
                                                                        32,
                                                                        40,
                                                                        0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, Mask(192, 0, ext_call.return_data[64]) >> 64,
                                                                        0
                                            else:
                                                if not cd[68]:
                                                    if 0 > cd[68]:
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if cd[68] < 0:
                                                        revert with 0, 17
                                                    if not address(cd[4]):
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not this.address:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    if 0 > balanceOf[address(cd[4])]:
                                                        revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[390 len 26] >> 48, 0
                                                    if balanceOf[address(cd[4])] < 0:
                                                        revert with 0, 17
                                                    if balanceOf[this.address] > -1:
                                                        revert with 0, 17
                                                    if balanceOf[this.address] < balanceOf[this.address]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(this.address)] = balanceOf[this.address]
                                                    emit Transfer(0, address(cd[4]), this.address);
                                                    if not address(cd[4]):
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not address(cd[36]):
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    if cd[68] > balanceOf[address(cd[4])]:
                                                        revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[486 len 26] >> 48, 0
                                                    if balanceOf[address(cd[4])] < cd[68]:
                                                        revert with 0, 17
                                                    balanceOf[address(cd[4])] -= cd[68]
                                                    if balanceOf[address(cd[36])] > !cd[68]:
                                                        revert with 0, 17
                                                    if balanceOf[address(cd[36])] + cd[68] < balanceOf[address(cd[36])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(cd[36])] += cd[68]
                                                    emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                                                else:
                                                    if cd[68] and 1 > -1 / cd[68]:
                                                        revert with 0, 17
                                                    if not cd[68]:
                                                        revert with 0, 18
                                                    if cd[68] / cd[68] != 1:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if 0 > !(cd[68] / 100):
                                                        revert with 0, 17
                                                    if cd[68] / 100 > cd[68]:
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if cd[68] < cd[68] / 100:
                                                        revert with 0, 17
                                                    if not address(cd[4]):
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not this.address:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    if cd[68] / 100 > balanceOf[address(cd[4])]:
                                                        revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[390 len 26] >> 48, 0
                                                    if balanceOf[address(cd[4])] < cd[68] / 100:
                                                        revert with 0, 17
                                                    balanceOf[address(cd[4])] -= cd[68] / 100
                                                    if balanceOf[this.address] > !(cd[68] / 100):
                                                        revert with 0, 17
                                                    if balanceOf[this.address] + (cd[68] / 100) < balanceOf[this.address]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(this.address)] = balanceOf[this.address] + (cd[68] / 100)
                                                    emit Transfer((cd[68] / 100), address(cd[4]), this.address);
                                                    if not address(cd[4]):
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not address(cd[36]):
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    if cd[68] - (cd[68] / 100) > balanceOf[address(cd[4])]:
                                                        revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[486 len 26] >> 48, 0
                                                    if balanceOf[address(cd[4])] < cd[68] - (cd[68] / 100):
                                                        revert with 0, 17
                                                    balanceOf[address(cd[4])] = balanceOf[address(cd[4])] - cd[68] + (cd[68] / 100)
                                                    if balanceOf[address(cd[36])] > !(cd[68] - (cd[68] / 100)):
                                                        revert with 0, 17
                                                    if balanceOf[address(cd[36])] + cd[68] - (cd[68] / 100) < balanceOf[address(cd[36])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(cd[36])] = balanceOf[address(cd[36])] + cd[68] - (cd[68] / 100)
                                                    emit Transfer((cd[68] - (cd[68] / 100)), address(cd[4]), address(cd[36]));
                                                require ext_code.size(dividendTrackerAddress)
                                                call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args address(cd[4]), balanceOf[address(cd[4])]
                                                require ext_code.size(dividendTrackerAddress)
                                                call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args address(cd[36]), balanceOf[address(cd[36])]
                                                if stor7:
                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                        revert with 0, 32, 40, 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[584 len 24] >> 64, 0
                                                else:
                                                    call dividendTrackerAddress.process(uint256 arg1) with:
                                                         gas gas_remaining wei
                                                        args gasForProcessing
                                                    if not ext_call.success:
                                                        if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                            revert with 0, 
                                                                        32,
                                                                        40,
                                                                        0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, ext_call.return_data[72 len 24] >> 64,
                                                                        0
                                                    else:
                                                        require return_data.size >= 96
                                                        emit ProcessedDividendTracker(ext_call.return_data[0], ext_call.return_data[32], ext_call.return_data[64], gasForProcessing, 1, tx.origin);
                                                        if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                            revert with 0, 
                                                                        32,
                                                                        40,
                                                                        0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, Mask(192, 0, ext_call.return_data[64]) >> 64,
                                                                        0
                                        else:
                                            if cd[68] and totalFees > -1 / cd[68]:
                                                revert with 0, 17
                                            if not cd[68]:
                                                revert with 0, 18
                                            if cd[68] * totalFees / cd[68] != totalFees:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not stor20[address(cd[36])]:
                                                if cd[68] * totalFees / 100 > cd[68]:
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if cd[68] < cd[68] * totalFees / 100:
                                                    revert with 0, 17
                                                if not address(cd[4]):
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not this.address:
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                if cd[68] * totalFees / 100 > balanceOf[address(cd[4])]:
                                                    revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[326 len 26] >> 48, 0
                                                if balanceOf[address(cd[4])] < cd[68] * totalFees / 100:
                                                    revert with 0, 17
                                                balanceOf[address(cd[4])] -= cd[68] * totalFees / 100
                                                if balanceOf[this.address] > !(cd[68] * totalFees / 100):
                                                    revert with 0, 17
                                                if balanceOf[this.address] + (cd[68] * totalFees / 100) < balanceOf[this.address]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(this.address)] = balanceOf[this.address] + (cd[68] * totalFees / 100)
                                                emit Transfer((cd[68] * totalFees / 100), address(cd[4]), this.address);
                                                if not address(cd[4]):
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not address(cd[36]):
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                if cd[68] - (cd[68] * totalFees / 100) > balanceOf[address(cd[4])]:
                                                    revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[422 len 26] >> 48, 0
                                                if balanceOf[address(cd[4])] < cd[68] - (cd[68] * totalFees / 100):
                                                    revert with 0, 17
                                                balanceOf[address(cd[4])] = balanceOf[address(cd[4])] - cd[68] + (cd[68] * totalFees / 100)
                                                if balanceOf[address(cd[36])] > !(cd[68] - (cd[68] * totalFees / 100)):
                                                    revert with 0, 17
                                                if balanceOf[address(cd[36])] + cd[68] - (cd[68] * totalFees / 100) < balanceOf[address(cd[36])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(cd[36])] = balanceOf[address(cd[36])] + cd[68] - (cd[68] * totalFees / 100)
                                                emit Transfer((cd[68] - (cd[68] * totalFees / 100)), address(cd[4]), address(cd[36]));
                                                require ext_code.size(dividendTrackerAddress)
                                                call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args address(cd[4]), balanceOf[address(cd[4])]
                                                require ext_code.size(dividendTrackerAddress)
                                                call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args address(cd[36]), balanceOf[address(cd[36])]
                                                if stor7:
                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                        revert with 0, 32, 40, 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[520 len 24] >> 64, 0
                                                else:
                                                    call dividendTrackerAddress.process(uint256 arg1) with:
                                                         gas gas_remaining wei
                                                        args gasForProcessing
                                                    if not ext_call.success:
                                                        if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                            revert with 0, 
                                                                        32,
                                                                        40,
                                                                        0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, ext_call.return_data[72 len 24] >> 64,
                                                                        0
                                                    else:
                                                        require return_data.size >= 96
                                                        emit ProcessedDividendTracker(ext_call.return_data[0], ext_call.return_data[32], ext_call.return_data[64], gasForProcessing, 1, tx.origin);
                                                        if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                            revert with 0, 
                                                                        32,
                                                                        40,
                                                                        0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, Mask(192, 0, ext_call.return_data[64]) >> 64,
                                                                        0
                                            else:
                                                if not cd[68]:
                                                    if cd[68] * totalFees / 100 > -1:
                                                        revert with 0, 17
                                                    if cd[68] * totalFees / 100 > cd[68]:
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if cd[68] < cd[68] * totalFees / 100:
                                                        revert with 0, 17
                                                    if not address(cd[4]):
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not this.address:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    if cd[68] * totalFees / 100 > balanceOf[address(cd[4])]:
                                                        revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[390 len 26] >> 48, 0
                                                    if balanceOf[address(cd[4])] < cd[68] * totalFees / 100:
                                                        revert with 0, 17
                                                    balanceOf[address(cd[4])] -= cd[68] * totalFees / 100
                                                    if balanceOf[this.address] > !(cd[68] * totalFees / 100):
                                                        revert with 0, 17
                                                    if balanceOf[this.address] + (cd[68] * totalFees / 100) < balanceOf[this.address]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(this.address)] = balanceOf[this.address] + (cd[68] * totalFees / 100)
                                                    emit Transfer((cd[68] * totalFees / 100), address(cd[4]), this.address);
                                                    if not address(cd[4]):
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not address(cd[36]):
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    if cd[68] - (cd[68] * totalFees / 100) > balanceOf[address(cd[4])]:
                                                        revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[486 len 26] >> 48, 0
                                                    if balanceOf[address(cd[4])] < cd[68] - (cd[68] * totalFees / 100):
                                                        revert with 0, 17
                                                    balanceOf[address(cd[4])] = balanceOf[address(cd[4])] - cd[68] + (cd[68] * totalFees / 100)
                                                    if balanceOf[address(cd[36])] > !(cd[68] - (cd[68] * totalFees / 100)):
                                                        revert with 0, 17
                                                    if balanceOf[address(cd[36])] + cd[68] - (cd[68] * totalFees / 100) < balanceOf[address(cd[36])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(cd[36])] = balanceOf[address(cd[36])] + cd[68] - (cd[68] * totalFees / 100)
                                                    emit Transfer((cd[68] - (cd[68] * totalFees / 100)), address(cd[4]), address(cd[36]));
                                                else:
                                                    if cd[68] and 1 > -1 / cd[68]:
                                                        revert with 0, 17
                                                    if not cd[68]:
                                                        revert with 0, 18
                                                    if cd[68] / cd[68] != 1:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if cd[68] * totalFees / 100 > !(cd[68] / 100):
                                                        revert with 0, 17
                                                    if (cd[68] * totalFees / 100) + (cd[68] / 100) > cd[68]:
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if cd[68] < (cd[68] * totalFees / 100) + (cd[68] / 100):
                                                        revert with 0, 17
                                                    if not address(cd[4]):
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not this.address:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    if (cd[68] * totalFees / 100) + (cd[68] / 100) > balanceOf[address(cd[4])]:
                                                        revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[390 len 26] >> 48, 0
                                                    if balanceOf[address(cd[4])] < (cd[68] * totalFees / 100) + (cd[68] / 100):
                                                        revert with 0, 17
                                                    balanceOf[address(cd[4])] = balanceOf[address(cd[4])] - (cd[68] * totalFees / 100) - (cd[68] / 100)
                                                    if balanceOf[this.address] > !((cd[68] * totalFees / 100) + (cd[68] / 100)):
                                                        revert with 0, 17
                                                    if balanceOf[this.address] + (cd[68] * totalFees / 100) + (cd[68] / 100) < balanceOf[this.address]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(this.address)] = balanceOf[this.address] + (cd[68] * totalFees / 100) + (cd[68] / 100)
                                                    emit Transfer(((cd[68] * totalFees / 100) + (cd[68] / 100)), address(cd[4]), this.address);
                                                    if not address(cd[4]):
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not address(cd[36]):
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    if cd[68] - (cd[68] * totalFees / 100) - (cd[68] / 100) > balanceOf[address(cd[4])]:
                                                        revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[486 len 26] >> 48, 0
                                                    if balanceOf[address(cd[4])] < cd[68] - (cd[68] * totalFees / 100) - (cd[68] / 100):
                                                        revert with 0, 17
                                                    balanceOf[address(cd[4])] = balanceOf[address(cd[4])] - cd[68] + (cd[68] * totalFees / 100) + (cd[68] / 100)
                                                    if balanceOf[address(cd[36])] > !(cd[68] - (cd[68] * totalFees / 100) - (cd[68] / 100)):
                                                        revert with 0, 17
                                                    if balanceOf[address(cd[36])] + cd[68] - (cd[68] * totalFees / 100) - (cd[68] / 100) < balanceOf[address(cd[36])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(cd[36])] = balanceOf[address(cd[36])] + cd[68] - (cd[68] * totalFees / 100) - (cd[68] / 100)
                                                    emit Transfer((cd[68] - (cd[68] * totalFees / 100) - (cd[68] / 100)), address(cd[4]), address(cd[36]));
                                                require ext_code.size(dividendTrackerAddress)
                                                call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args address(cd[4]), balanceOf[address(cd[4])]
                                                require ext_code.size(dividendTrackerAddress)
                                                call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args address(cd[36]), balanceOf[address(cd[36])]
                                                if stor7:
                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                        revert with 0, 32, 40, 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[584 len 24] >> 64, 0
                                                else:
                                                    call dividendTrackerAddress.process(uint256 arg1) with:
                                                         gas gas_remaining wei
                                                        args gasForProcessing
                                                    if not ext_call.success:
                                                        if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                            revert with 0, 
                                                                        32,
                                                                        40,
                                                                        0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, ext_call.return_data[72 len 24] >> 64,
                                                                        0
                                                    else:
                                                        require return_data.size >= 96
                                                        emit ProcessedDividendTracker(ext_call.return_data[0], ext_call.return_data[32], ext_call.return_data[64], gasForProcessing, 1, tx.origin);
                                                        if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                            revert with 0, 
                                                                        32,
                                                                        40,
                                                                        0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, Mask(192, 0, ext_call.return_data[64]) >> 64,
                                                                        0
                        else:
                            if owner == address(cd[36]):
                                if stor19[address(cd[4])]:
                                    if not address(cd[4]):
                                        revert with 0, 'ERC20: transfer from the zero address'
                                    if not address(cd[36]):
                                        revert with 0, 'ERC20: transfer to the zero address'
                                    if cd[68] > balanceOf[address(cd[4])]:
                                        revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                    if balanceOf[address(cd[4])] < cd[68]:
                                        revert with 0, 17
                                    balanceOf[address(cd[4])] -= cd[68]
                                    if balanceOf[address(cd[36])] > !cd[68]:
                                        revert with 0, 17
                                    if balanceOf[address(cd[36])] + cd[68] < balanceOf[address(cd[36])]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(cd[36])] += cd[68]
                                    emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                                    require ext_code.size(dividendTrackerAddress)
                                    call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args address(cd[4]), balanceOf[address(cd[4])]
                                    require ext_code.size(dividendTrackerAddress)
                                    call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                         gas gas_remaining wei
                                        args address(cd[36]), balanceOf[address(cd[36])]
                                    if stor7:
                                        if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                            revert with 0, 32, 40, 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[296 len 24] >> 64, 0
                                    else:
                                        call dividendTrackerAddress.process(uint256 arg1) with:
                                             gas gas_remaining wei
                                            args gasForProcessing
                                        if not ext_call.success:
                                            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                revert with 0, 
                                                            32,
                                                            40,
                                                            0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, ext_call.return_data[72 len 24] >> 64,
                                                            0
                                        else:
                                            require return_data.size >= 96
                                            emit ProcessedDividendTracker(ext_call.return_data[0], ext_call.return_data[32], ext_call.return_data[64], gasForProcessing, 1, tx.origin);
                                            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                revert with 0, 
                                                            32,
                                                            40,
                                                            0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, Mask(192, 0, ext_call.return_data[64]) >> 64,
                                                            0
                                else:
                                    if stor19[address(cd[36])]:
                                        if not address(cd[4]):
                                            revert with 0, 'ERC20: transfer from the zero address'
                                        if not address(cd[36]):
                                            revert with 0, 'ERC20: transfer to the zero address'
                                        if cd[68] > balanceOf[address(cd[4])]:
                                            revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                        if balanceOf[address(cd[4])] < cd[68]:
                                            revert with 0, 17
                                        balanceOf[address(cd[4])] -= cd[68]
                                        if balanceOf[address(cd[36])] > !cd[68]:
                                            revert with 0, 17
                                        if balanceOf[address(cd[36])] + cd[68] < balanceOf[address(cd[36])]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(cd[36])] += cd[68]
                                        emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                                        require ext_code.size(dividendTrackerAddress)
                                        call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                             gas gas_remaining wei
                                            args address(cd[4]), balanceOf[address(cd[4])]
                                        require ext_code.size(dividendTrackerAddress)
                                        call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                             gas gas_remaining wei
                                            args address(cd[36]), balanceOf[address(cd[36])]
                                        if stor7:
                                            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                revert with 0, 32, 40, 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[296 len 24] >> 64, 0
                                        else:
                                            call dividendTrackerAddress.process(uint256 arg1) with:
                                                 gas gas_remaining wei
                                                args gasForProcessing
                                            if not ext_call.success:
                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, ext_call.return_data[72 len 24] >> 64,
                                                                0
                                            else:
                                                require return_data.size >= 96
                                                emit ProcessedDividendTracker(ext_call.return_data[0], ext_call.return_data[32], ext_call.return_data[64], gasForProcessing, 1, tx.origin);
                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, Mask(192, 0, ext_call.return_data[64]) >> 64,
                                                                0
                                    else:
                                        if stor7:
                                            if not address(cd[4]):
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not address(cd[36]):
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            if cd[68] > balanceOf[address(cd[4])]:
                                                revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[198 len 26] >> 48, 0
                                            if balanceOf[address(cd[4])] < cd[68]:
                                                revert with 0, 17
                                            balanceOf[address(cd[4])] -= cd[68]
                                            if balanceOf[address(cd[36])] > !cd[68]:
                                                revert with 0, 17
                                            if balanceOf[address(cd[36])] + cd[68] < balanceOf[address(cd[36])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(cd[36])] += cd[68]
                                            emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                                            require ext_code.size(dividendTrackerAddress)
                                            call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args address(cd[4]), balanceOf[address(cd[4])]
                                            require ext_code.size(dividendTrackerAddress)
                                            call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args address(cd[36]), balanceOf[address(cd[36])]
                                            if stor7:
                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                    revert with 0, 32, 40, 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[296 len 24] >> 64, 0
                                            else:
                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                     gas gas_remaining wei
                                                    args gasForProcessing
                                                if not ext_call.success:
                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                        revert with 0, 
                                                                    32,
                                                                    40,
                                                                    0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, ext_call.return_data[72 len 24] >> 64,
                                                                    0
                                                else:
                                                    require return_data.size >= 96
                                                    emit ProcessedDividendTracker(ext_call.return_data[0], ext_call.return_data[32], ext_call.return_data[64], gasForProcessing, 1, tx.origin);
                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                        revert with 0, 
                                                                    32,
                                                                    40,
                                                                    0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, Mask(192, 0, ext_call.return_data[64]) >> 64,
                                                                    0
                                        else:
                                            if not cd[68]:
                                                if not stor20[address(cd[36])]:
                                                    if 0 > cd[68]:
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if cd[68] < 0:
                                                        revert with 0, 17
                                                    if not address(cd[4]):
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not this.address:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    if 0 > balanceOf[address(cd[4])]:
                                                        revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[326 len 26] >> 48, 0
                                                    if balanceOf[address(cd[4])] < 0:
                                                        revert with 0, 17
                                                    if balanceOf[this.address] > -1:
                                                        revert with 0, 17
                                                    if balanceOf[this.address] < balanceOf[this.address]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(this.address)] = balanceOf[this.address]
                                                    emit Transfer(0, address(cd[4]), this.address);
                                                    if not address(cd[4]):
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not address(cd[36]):
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    if cd[68] > balanceOf[address(cd[4])]:
                                                        revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[422 len 26] >> 48, 0
                                                    if balanceOf[address(cd[4])] < cd[68]:
                                                        revert with 0, 17
                                                    balanceOf[address(cd[4])] -= cd[68]
                                                    if balanceOf[address(cd[36])] > !cd[68]:
                                                        revert with 0, 17
                                                    if balanceOf[address(cd[36])] + cd[68] < balanceOf[address(cd[36])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(cd[36])] += cd[68]
                                                    emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                                                    require ext_code.size(dividendTrackerAddress)
                                                    call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args address(cd[4]), balanceOf[address(cd[4])]
                                                    require ext_code.size(dividendTrackerAddress)
                                                    call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args address(cd[36]), balanceOf[address(cd[36])]
                                                    if stor7:
                                                        if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                            revert with 0, 32, 40, 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[520 len 24] >> 64, 0
                                                    else:
                                                        call dividendTrackerAddress.process(uint256 arg1) with:
                                                             gas gas_remaining wei
                                                            args gasForProcessing
                                                        if not ext_call.success:
                                                            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                revert with 0, 
                                                                            32,
                                                                            40,
                                                                            0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, ext_call.return_data[72 len 24] >> 64,
                                                                            0
                                                        else:
                                                            require return_data.size >= 96
                                                            emit ProcessedDividendTracker(ext_call.return_data[0], ext_call.return_data[32], ext_call.return_data[64], gasForProcessing, 1, tx.origin);
                                                            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                revert with 0, 
                                                                            32,
                                                                            40,
                                                                            0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, Mask(192, 0, ext_call.return_data[64]) >> 64,
                                                                            0
                                                else:
                                                    if not cd[68]:
                                                        if 0 > cd[68]:
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if cd[68] < 0:
                                                            revert with 0, 17
                                                        if not address(cd[4]):
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not this.address:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        if 0 > balanceOf[address(cd[4])]:
                                                            revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[390 len 26] >> 48, 0
                                                        if balanceOf[address(cd[4])] < 0:
                                                            revert with 0, 17
                                                        if balanceOf[this.address] > -1:
                                                            revert with 0, 17
                                                        if balanceOf[this.address] < balanceOf[this.address]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(this.address)] = balanceOf[this.address]
                                                        emit Transfer(0, address(cd[4]), this.address);
                                                        if not address(cd[4]):
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not address(cd[36]):
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        if cd[68] > balanceOf[address(cd[4])]:
                                                            revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[486 len 26] >> 48, 0
                                                        if balanceOf[address(cd[4])] < cd[68]:
                                                            revert with 0, 17
                                                        balanceOf[address(cd[4])] -= cd[68]
                                                        if balanceOf[address(cd[36])] > !cd[68]:
                                                            revert with 0, 17
                                                        if balanceOf[address(cd[36])] + cd[68] < balanceOf[address(cd[36])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(cd[36])] += cd[68]
                                                        emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                                                    else:
                                                        if cd[68] and 1 > -1 / cd[68]:
                                                            revert with 0, 17
                                                        if not cd[68]:
                                                            revert with 0, 18
                                                        if cd[68] / cd[68] != 1:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if 0 > !(cd[68] / 100):
                                                            revert with 0, 17
                                                        if cd[68] / 100 > cd[68]:
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if cd[68] < cd[68] / 100:
                                                            revert with 0, 17
                                                        if not address(cd[4]):
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not this.address:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        if cd[68] / 100 > balanceOf[address(cd[4])]:
                                                            revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[390 len 26] >> 48, 0
                                                        if balanceOf[address(cd[4])] < cd[68] / 100:
                                                            revert with 0, 17
                                                        balanceOf[address(cd[4])] -= cd[68] / 100
                                                        if balanceOf[this.address] > !(cd[68] / 100):
                                                            revert with 0, 17
                                                        if balanceOf[this.address] + (cd[68] / 100) < balanceOf[this.address]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(this.address)] = balanceOf[this.address] + (cd[68] / 100)
                                                        emit Transfer((cd[68] / 100), address(cd[4]), this.address);
                                                        if not address(cd[4]):
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not address(cd[36]):
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        if cd[68] - (cd[68] / 100) > balanceOf[address(cd[4])]:
                                                            revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[486 len 26] >> 48, 0
                                                        if balanceOf[address(cd[4])] < cd[68] - (cd[68] / 100):
                                                            revert with 0, 17
                                                        balanceOf[address(cd[4])] = balanceOf[address(cd[4])] - cd[68] + (cd[68] / 100)
                                                        if balanceOf[address(cd[36])] > !(cd[68] - (cd[68] / 100)):
                                                            revert with 0, 17
                                                        if balanceOf[address(cd[36])] + cd[68] - (cd[68] / 100) < balanceOf[address(cd[36])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(cd[36])] = balanceOf[address(cd[36])] + cd[68] - (cd[68] / 100)
                                                        emit Transfer((cd[68] - (cd[68] / 100)), address(cd[4]), address(cd[36]));
                                                    require ext_code.size(dividendTrackerAddress)
                                                    call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args address(cd[4]), balanceOf[address(cd[4])]
                                                    require ext_code.size(dividendTrackerAddress)
                                                    call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args address(cd[36]), balanceOf[address(cd[36])]
                                                    if stor7:
                                                        if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                            revert with 0, 32, 40, 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[584 len 24] >> 64, 0
                                                    else:
                                                        call dividendTrackerAddress.process(uint256 arg1) with:
                                                             gas gas_remaining wei
                                                            args gasForProcessing
                                                        if not ext_call.success:
                                                            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                revert with 0, 
                                                                            32,
                                                                            40,
                                                                            0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, ext_call.return_data[72 len 24] >> 64,
                                                                            0
                                                        else:
                                                            require return_data.size >= 96
                                                            emit ProcessedDividendTracker(ext_call.return_data[0], ext_call.return_data[32], ext_call.return_data[64], gasForProcessing, 1, tx.origin);
                                                            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                revert with 0, 
                                                                            32,
                                                                            40,
                                                                            0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, Mask(192, 0, ext_call.return_data[64]) >> 64,
                                                                            0
                                            else:
                                                if cd[68] and totalFees > -1 / cd[68]:
                                                    revert with 0, 17
                                                if not cd[68]:
                                                    revert with 0, 18
                                                if cd[68] * totalFees / cd[68] != totalFees:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not stor20[address(cd[36])]:
                                                    if cd[68] * totalFees / 100 > cd[68]:
                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                    if cd[68] < cd[68] * totalFees / 100:
                                                        revert with 0, 17
                                                    if not address(cd[4]):
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not this.address:
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    if cd[68] * totalFees / 100 > balanceOf[address(cd[4])]:
                                                        revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[326 len 26] >> 48, 0
                                                    if balanceOf[address(cd[4])] < cd[68] * totalFees / 100:
                                                        revert with 0, 17
                                                    balanceOf[address(cd[4])] -= cd[68] * totalFees / 100
                                                    if balanceOf[this.address] > !(cd[68] * totalFees / 100):
                                                        revert with 0, 17
                                                    if balanceOf[this.address] + (cd[68] * totalFees / 100) < balanceOf[this.address]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(this.address)] = balanceOf[this.address] + (cd[68] * totalFees / 100)
                                                    emit Transfer((cd[68] * totalFees / 100), address(cd[4]), this.address);
                                                    if not address(cd[4]):
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not address(cd[36]):
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    if cd[68] - (cd[68] * totalFees / 100) > balanceOf[address(cd[4])]:
                                                        revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[422 len 26] >> 48, 0
                                                    if balanceOf[address(cd[4])] < cd[68] - (cd[68] * totalFees / 100):
                                                        revert with 0, 17
                                                    balanceOf[address(cd[4])] = balanceOf[address(cd[4])] - cd[68] + (cd[68] * totalFees / 100)
                                                    if balanceOf[address(cd[36])] > !(cd[68] - (cd[68] * totalFees / 100)):
                                                        revert with 0, 17
                                                    if balanceOf[address(cd[36])] + cd[68] - (cd[68] * totalFees / 100) < balanceOf[address(cd[36])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(cd[36])] = balanceOf[address(cd[36])] + cd[68] - (cd[68] * totalFees / 100)
                                                    emit Transfer((cd[68] - (cd[68] * totalFees / 100)), address(cd[4]), address(cd[36]));
                                                    require ext_code.size(dividendTrackerAddress)
                                                    call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args address(cd[4]), balanceOf[address(cd[4])]
                                                    require ext_code.size(dividendTrackerAddress)
                                                    call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args address(cd[36]), balanceOf[address(cd[36])]
                                                    if stor7:
                                                        if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                            revert with 0, 32, 40, 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[520 len 24] >> 64, 0
                                                    else:
                                                        call dividendTrackerAddress.process(uint256 arg1) with:
                                                             gas gas_remaining wei
                                                            args gasForProcessing
                                                        if not ext_call.success:
                                                            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                revert with 0, 
                                                                            32,
                                                                            40,
                                                                            0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, ext_call.return_data[72 len 24] >> 64,
                                                                            0
                                                        else:
                                                            require return_data.size >= 96
                                                            emit ProcessedDividendTracker(ext_call.return_data[0], ext_call.return_data[32], ext_call.return_data[64], gasForProcessing, 1, tx.origin);
                                                            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                revert with 0, 
                                                                            32,
                                                                            40,
                                                                            0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, Mask(192, 0, ext_call.return_data[64]) >> 64,
                                                                            0
                                                else:
                                                    if not cd[68]:
                                                        if cd[68] * totalFees / 100 > -1:
                                                            revert with 0, 17
                                                        if cd[68] * totalFees / 100 > cd[68]:
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if cd[68] < cd[68] * totalFees / 100:
                                                            revert with 0, 17
                                                        if not address(cd[4]):
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not this.address:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        if cd[68] * totalFees / 100 > balanceOf[address(cd[4])]:
                                                            revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[390 len 26] >> 48, 0
                                                        if balanceOf[address(cd[4])] < cd[68] * totalFees / 100:
                                                            revert with 0, 17
                                                        balanceOf[address(cd[4])] -= cd[68] * totalFees / 100
                                                        if balanceOf[this.address] > !(cd[68] * totalFees / 100):
                                                            revert with 0, 17
                                                        if balanceOf[this.address] + (cd[68] * totalFees / 100) < balanceOf[this.address]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(this.address)] = balanceOf[this.address] + (cd[68] * totalFees / 100)
                                                        emit Transfer((cd[68] * totalFees / 100), address(cd[4]), this.address);
                                                        if not address(cd[4]):
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not address(cd[36]):
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        if cd[68] - (cd[68] * totalFees / 100) > balanceOf[address(cd[4])]:
                                                            revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[486 len 26] >> 48, 0
                                                        if balanceOf[address(cd[4])] < cd[68] - (cd[68] * totalFees / 100):
                                                            revert with 0, 17
                                                        balanceOf[address(cd[4])] = balanceOf[address(cd[4])] - cd[68] + (cd[68] * totalFees / 100)
                                                        if balanceOf[address(cd[36])] > !(cd[68] - (cd[68] * totalFees / 100)):
                                                            revert with 0, 17
                                                        if balanceOf[address(cd[36])] + cd[68] - (cd[68] * totalFees / 100) < balanceOf[address(cd[36])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(cd[36])] = balanceOf[address(cd[36])] + cd[68] - (cd[68] * totalFees / 100)
                                                        emit Transfer((cd[68] - (cd[68] * totalFees / 100)), address(cd[4]), address(cd[36]));
                                                    else:
                                                        if cd[68] and 1 > -1 / cd[68]:
                                                            revert with 0, 17
                                                        if not cd[68]:
                                                            revert with 0, 18
                                                        if cd[68] / cd[68] != 1:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if cd[68] * totalFees / 100 > !(cd[68] / 100):
                                                            revert with 0, 17
                                                        if (cd[68] * totalFees / 100) + (cd[68] / 100) > cd[68]:
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if cd[68] < (cd[68] * totalFees / 100) + (cd[68] / 100):
                                                            revert with 0, 17
                                                        if not address(cd[4]):
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not this.address:
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        if (cd[68] * totalFees / 100) + (cd[68] / 100) > balanceOf[address(cd[4])]:
                                                            revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[390 len 26] >> 48, 0
                                                        if balanceOf[address(cd[4])] < (cd[68] * totalFees / 100) + (cd[68] / 100):
                                                            revert with 0, 17
                                                        balanceOf[address(cd[4])] = balanceOf[address(cd[4])] - (cd[68] * totalFees / 100) - (cd[68] / 100)
                                                        if balanceOf[this.address] > !((cd[68] * totalFees / 100) + (cd[68] / 100)):
                                                            revert with 0, 17
                                                        if balanceOf[this.address] + (cd[68] * totalFees / 100) + (cd[68] / 100) < balanceOf[this.address]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(this.address)] = balanceOf[this.address] + (cd[68] * totalFees / 100) + (cd[68] / 100)
                                                        emit Transfer(((cd[68] * totalFees / 100) + (cd[68] / 100)), address(cd[4]), this.address);
                                                        if not address(cd[4]):
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not address(cd[36]):
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        if cd[68] - (cd[68] * totalFees / 100) - (cd[68] / 100) > balanceOf[address(cd[4])]:
                                                            revert with 0, 32, 38, 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[486 len 26] >> 48, 0
                                                        if balanceOf[address(cd[4])] < cd[68] - (cd[68] * totalFees / 100) - (cd[68] / 100):
                                                            revert with 0, 17
                                                        balanceOf[address(cd[4])] = balanceOf[address(cd[4])] - cd[68] + (cd[68] * totalFees / 100) + (cd[68] / 100)
                                                        if balanceOf[address(cd[36])] > !(cd[68] - (cd[68] * totalFees / 100) - (cd[68] / 100)):
                                                            revert with 0, 17
                                                        if balanceOf[address(cd[36])] + cd[68] - (cd[68] * totalFees / 100) - (cd[68] / 100) < balanceOf[address(cd[36])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(cd[36])] = balanceOf[address(cd[36])] + cd[68] - (cd[68] * totalFees / 100) - (cd[68] / 100)
                                                        emit Transfer((cd[68] - (cd[68] * totalFees / 100) - (cd[68] / 100)), address(cd[4]), address(cd[36]));
                                                    require ext_code.size(dividendTrackerAddress)
                                                    call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args address(cd[4]), balanceOf[address(cd[4])]
                                                    require ext_code.size(dividendTrackerAddress)
                                                    call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args address(cd[36]), balanceOf[address(cd[36])]
                                                    if stor7:
                                                        if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                            revert with 0, 32, 40, 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[584 len 24] >> 64, 0
                                                    else:
                                                        call dividendTrackerAddress.process(uint256 arg1) with:
                                                             gas gas_remaining wei
                                                            args gasForProcessing
                                                        if not ext_call.success:
                                                            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                revert with 0, 
                                                                            32,
                                                                            40,
                                                                            0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, ext_call.return_data[72 len 24] >> 64,
                                                                            0
                                                        else:
                                                            require return_data.size >= 96
                                                            emit ProcessedDividendTracker(ext_call.return_data[0], ext_call.return_data[32], ext_call.return_data[64], gasForProcessing, 1, tx.origin);
                                                            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                revert with 0, 
                                                                            32,
                                                                            40,
                                                                            0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, Mask(192, 0, ext_call.return_data[64]) >> 64,
                                                                            0
                            else:
                                stor7 = 1
                                if not balanceOf[this.address]:
                                    mem[128] = 26
                                    mem[160] = 'SafeMath: division by zero'
                                    if not totalFees:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    mem[196] = this.address
                                    staticcall sub_4d7effddAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[192] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[ceil32(return_data.size) + 192] = 3
                                    mem[ceil32(return_data.size) + 224] = this.address
                                    staticcall uniswapV2RouterAddress.WETH() with:
                                            gas gas_remaining wei
                                    mem[ceil32(return_data.size) + 320] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = (2 * ceil32(return_data.size)) + 320
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    mem[ceil32(return_data.size) + 256] = ext_call.return_data[12 len 20]
                                    mem[ceil32(return_data.size) + 288] = sub_4d7effddAddress
                                    if not this.address:
                                        mem[(2 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[(2 * ceil32(return_data.size)) + 324] = 32
                                        mem[(2 * ceil32(return_data.size)) + 356] = 36
                                        mem[(2 * ceil32(return_data.size)) + 388] = 'ERC20: approve from the zero add'
                                        mem[(2 * ceil32(return_data.size)) + 420] = 0x7265737300000000000000000000000000000000000000000000000000000000
                                        revert with memory
                                          from (2 * ceil32(return_data.size)) + 320
                                           len ceil32(return_data.size) + 132
                                    if not uniswapV2RouterAddress:
                                        mem[(2 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[(2 * ceil32(return_data.size)) + 324] = 32
                                        mem[(2 * ceil32(return_data.size)) + 356] = 34
                                        mem[(2 * ceil32(return_data.size)) + 388] = 'ERC20: approve to the zero addre'
                                        mem[(2 * ceil32(return_data.size)) + 420] = 0x7373000000000000000000000000000000000000000000000000000000000000
                                        revert with memory
                                          from (2 * ceil32(return_data.size)) + 320
                                           len ceil32(return_data.size) + 132
                                    mem[0] = uniswapV2RouterAddress
                                    mem[32] = sha3(address(this.address), 1)
                                    allowance[address(this.address)][stor6].field_0 = 0 / totalFees
                                    mem[(2 * ceil32(return_data.size)) + 320] = 0 / totalFees
                                    emit Approval(mem[(2 * ceil32(return_data.size)) + 320 len ceil32(return_data.size) + 32], this.address, uniswapV2RouterAddress);
                                    mem[(2 * ceil32(return_data.size)) + 320] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                    mem[(2 * ceil32(return_data.size)) + 324] = 0 / totalFees
                                    mem[(2 * ceil32(return_data.size)) + 356] = 0
                                    mem[(2 * ceil32(return_data.size)) + 388] = 160
                                    mem[(2 * ceil32(return_data.size)) + 484] = 3
                                    idx = 0
                                    s = (2 * ceil32(return_data.size)) + 516
                                    t = ceil32(return_data.size) + 224
                                    while idx < mem[ceil32(return_data.size) + 192]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[(2 * ceil32(return_data.size)) + 420] = this.address
                                    mem[(2 * ceil32(return_data.size)) + 452] = block.timestamp
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 608]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[mem[64] + 4] = this.address
                                    staticcall sub_4d7effddAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    _21381 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _21393 = mem[_21381]
                                    _21410 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21410] = 30
                                    mem[_21410 + 32] = 'SafeMath: subtraction overflow'
                                    if ext_call.return_data[0] > _21393:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if _21393 < ext_call.return_data[0]:
                                        revert with 0, 17
                                    mem[mem[64] + 4] = stor17
                                    mem[mem[64] + 36] = _21393 - ext_call.return_data[0]
                                    call sub_4d7effddAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args stor17, _21393 - ext_call.return_data[0]
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _21439 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_21439] == bool(mem[_21439])
                                    if not balanceOf[this.address]:
                                        _21450 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_21450] = 26
                                        mem[_21450 + 32] = 'SafeMath: division by zero'
                                        if not totalFees:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        _21492 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_21492] = 26
                                        mem[_21492 + 32] = 'SafeMath: division by zero'
                                        _21514 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_21514] = 30
                                        mem[_21514 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 / totalFees / 2 > 0 / totalFees:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if 0 / totalFees < 0 / totalFees / 2:
                                            revert with 0, 17
                                        _21542 = mem[64]
                                        mem[mem[64]] = 2
                                        mem[64] = mem[64] + 96
                                        mem[_21542 + 32 len 64] = call.data[calldata.size len 64]
                                        if 0 >= mem[_21542]:
                                            revert with 0, 50
                                        mem[_21542 + 32] = this.address
                                        staticcall uniswapV2RouterAddress.WETH() with:
                                                gas gas_remaining wei
                                        mem[_21542 + 96] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = _21542 + ceil32(return_data.size) + 96
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                        if 1 >= mem[_21542]:
                                            revert with 0, 50
                                        mem[_21542 + 64] = ext_call.return_data[12 len 20]
                                        if not this.address:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not uniswapV2RouterAddress:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        mem[0] = uniswapV2RouterAddress
                                        mem[32] = sha3(address(this.address), 1)
                                        allowance[address(this.address)][stor6].field_0 = 0 / totalFees / 2
                                        allowance[address(this.address)][stor6].field_255 = 0
                                        emit Approval((0 / totalFees / 2), this.address, uniswapV2RouterAddress);
                                        mem[_21542 + ceil32(return_data.size) + 96] = 0x791ac94700000000000000000000000000000000000000000000000000000000
                                        mem[_21542 + ceil32(return_data.size) + 100] = 0 / totalFees / 2
                                        mem[_21542 + ceil32(return_data.size) + 132] = 0
                                        mem[_21542 + ceil32(return_data.size) + 164] = 160
                                        mem[_21542 + ceil32(return_data.size) + 260] = mem[_21542]
                                        idx = 0
                                        s = _21542 + ceil32(return_data.size) + 292
                                        t = _21542 + 32
                                        while idx < mem[_21542]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        require ext_code.size(uniswapV2RouterAddress)
                                        call uniswapV2RouterAddress.swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args Mask(255, 1, 0 / totalFees), 0, 160, address(this.address), block.timestamp, mem[_21542 + ceil32(return_data.size) + 260 len (32 * mem[_21542]) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[_21542 + ceil32(return_data.size) + 96] = 30
                                        mem[_21542 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                        if eth.balance(this.address) > eth.balance(this.address):
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if eth.balance(this.address) < eth.balance(this.address):
                                            revert with 0, 17
                                        if not this.address:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not uniswapV2RouterAddress:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(this.address)][stor6].field_0 = (0 / totalFees) - (0 / totalFees / 2)
                                        emit Approval(((0 / totalFees) - (0 / totalFees / 2)), this.address, uniswapV2RouterAddress);
                                        mem[_21542 + ceil32(return_data.size) + 228] = 0
                                        mem[_21542 + ceil32(return_data.size) + 260] = 0
                                        mem[_21542 + ceil32(return_data.size) + 292] = stor17
                                        mem[_21542 + ceil32(return_data.size) + 324] = block.timestamp
                                        call uniswapV2RouterAddress.addLiquidityETH(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                             gas gas_remaining wei
                                            args this.address, (0 / totalFees) - (0 / totalFees / 2), 0, 0, stor17, block.timestamp
                                        mem[_21542 + ceil32(return_data.size) + 160 len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 96
                                        emit SwapAndLiquify(Mask(255, 1, 0 / totalFees), 0, (0 / totalFees) - (0 / totalFees / 2));
                                        mem[_21542 + (2 * ceil32(return_data.size)) + 160] = 3
                                        mem[_21542 + (2 * ceil32(return_data.size)) + 192] = this.address
                                        staticcall uniswapV2RouterAddress.WETH() with:
                                                gas gas_remaining wei
                                        mem[_21542 + (2 * ceil32(return_data.size)) + 288] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                        mem[_21542 + (2 * ceil32(return_data.size)) + 224] = ext_call.return_data[12 len 20]
                                        mem[_21542 + (2 * ceil32(return_data.size)) + 256] = sub_4d7effddAddress
                                        if not this.address:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not uniswapV2RouterAddress:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(this.address)][stor6].field_0 = balanceOf[this.address]
                                        emit Approval(balanceOf[this.address], this.address, uniswapV2RouterAddress);
                                        mem[_21542 + (4 * ceil32(return_data.size)) + 288] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                        mem[_21542 + (4 * ceil32(return_data.size)) + 292] = balanceOf[this.address]
                                        mem[_21542 + (4 * ceil32(return_data.size)) + 324] = 0
                                        mem[_21542 + (4 * ceil32(return_data.size)) + 356] = 160
                                        mem[_21542 + (4 * ceil32(return_data.size)) + 452] = 3
                                        idx = 0
                                        s = _21542 + (4 * ceil32(return_data.size)) + 484
                                        t = _21542 + (2 * ceil32(return_data.size)) + 192
                                        while idx < mem[_21542 + (2 * ceil32(return_data.size)) + 160]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_21542 + (4 * ceil32(return_data.size)) + 388] = this.address
                                        mem[_21542 + (4 * ceil32(return_data.size)) + 420] = block.timestamp
                                        require ext_code.size(uniswapV2RouterAddress)
                                        call uniswapV2RouterAddress.swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args balanceOf[this.address], 0, 160, address(this.address), block.timestamp, mem[_21542 + (4 * ceil32(return_data.size)) + 452 len (32 * mem[_21542 + (2 * ceil32(return_data.size)) + 160]) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        staticcall sub_4d7effddAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        require return_data.size >= 32
                                        call sub_4d7effddAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args dividendTrackerAddress, ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                        if ext_call.return_data[0]:
                                            require ext_code.size(dividendTrackerAddress)
                                            call dividendTrackerAddress.distributeDogeDividends(uint256 arg1) with:
                                                 gas gas_remaining wei
                                                args ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            emit SendDividends(balanceOf[this.address], ext_call.return_data[0]);
                                        stor7 = 0
                                        if stor19[address(cd[4])]:
                                            if not address(cd[4]):
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not address(cd[36]):
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            if cd[68] > balanceOf[address(cd[4])]:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_21542 + (7 * ceil32(return_data.size)) + 358 len 26] >> 48,
                                                            0
                                            if balanceOf[address(cd[4])] < cd[68]:
                                                revert with 0, 17
                                            balanceOf[address(cd[4])] -= cd[68]
                                            if balanceOf[address(cd[36])] > !cd[68]:
                                                revert with 0, 17
                                            if balanceOf[address(cd[36])] + cd[68] < balanceOf[address(cd[36])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(cd[36])] += cd[68]
                                            emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                                            require ext_code.size(dividendTrackerAddress)
                                            call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args address(cd[4]), balanceOf[address(cd[4])]
                                            require ext_code.size(dividendTrackerAddress)
                                            call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args address(cd[36]), balanceOf[address(cd[36])]
                                            if stor7:
                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_21542 + (7 * ceil32(return_data.size)) + 456 len 24] >> 64,
                                                                0
                                            else:
                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                     gas gas_remaining wei
                                                    args gasForProcessing
                                                if not ext_call.success:
                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                        revert with 0, 
                                                                    32,
                                                                    40,
                                                                    0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, ext_call.return_data[72 len 24] >> 64,
                                                                    0
                                                else:
                                                    require return_data.size >= 96
                                                    emit ProcessedDividendTracker(ext_call.return_data[0], ext_call.return_data[32], ext_call.return_data[64], gasForProcessing, 1, tx.origin);
                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                        revert with 0, 
                                                                    32,
                                                                    40,
                                                                    0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, Mask(192, 0, ext_call.return_data[64]) >> 64,
                                                                    0
                                        else:
                                            if stor19[address(cd[36])]:
                                                if not address(cd[4]):
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not address(cd[36]):
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                if cd[68] > balanceOf[address(cd[4])]:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_21542 + (7 * ceil32(return_data.size)) + 358 len 26] >> 48,
                                                                0
                                                if balanceOf[address(cd[4])] < cd[68]:
                                                    revert with 0, 17
                                                balanceOf[address(cd[4])] -= cd[68]
                                                if balanceOf[address(cd[36])] > !cd[68]:
                                                    revert with 0, 17
                                                if balanceOf[address(cd[36])] + cd[68] < balanceOf[address(cd[36])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(cd[36])] += cd[68]
                                                emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                                                require ext_code.size(dividendTrackerAddress)
                                                call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args address(cd[4]), balanceOf[address(cd[4])]
                                                require ext_code.size(dividendTrackerAddress)
                                                call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args address(cd[36]), balanceOf[address(cd[36])]
                                                if stor7:
                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                        revert with 0, 
                                                                    32,
                                                                    40,
                                                                    0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_21542 + (7 * ceil32(return_data.size)) + 456 len 24] >> 64,
                                                                    0
                                                else:
                                                    call dividendTrackerAddress.process(uint256 arg1) with:
                                                         gas gas_remaining wei
                                                        args gasForProcessing
                                                    if not ext_call.success:
                                                        if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                            revert with 0, 
                                                                        32,
                                                                        40,
                                                                        0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, ext_call.return_data[72 len 24] >> 64,
                                                                        0
                                                    else:
                                                        require return_data.size >= 96
                                                        emit ProcessedDividendTracker(ext_call.return_data[0], ext_call.return_data[32], ext_call.return_data[64], gasForProcessing, 1, tx.origin);
                                                        if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                            revert with 0, 
                                                                        32,
                                                                        40,
                                                                        0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, Mask(192, 0, ext_call.return_data[64]) >> 64,
                                                                        0
                                            else:
                                                if stor7:
                                                    if not address(cd[4]):
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not address(cd[36]):
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    if cd[68] > balanceOf[address(cd[4])]:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_21542 + (7 * ceil32(return_data.size)) + 358 len 26] >> 48,
                                                                    0
                                                    if balanceOf[address(cd[4])] < cd[68]:
                                                        revert with 0, 17
                                                    balanceOf[address(cd[4])] -= cd[68]
                                                    if balanceOf[address(cd[36])] > !cd[68]:
                                                        revert with 0, 17
                                                    if balanceOf[address(cd[36])] + cd[68] < balanceOf[address(cd[36])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(cd[36])] += cd[68]
                                                    emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                                                    require ext_code.size(dividendTrackerAddress)
                                                    call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args address(cd[4]), balanceOf[address(cd[4])]
                                                    require ext_code.size(dividendTrackerAddress)
                                                    call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args address(cd[36]), balanceOf[address(cd[36])]
                                                    if stor7:
                                                        if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                            revert with 0, 
                                                                        32,
                                                                        40,
                                                                        0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_21542 + (7 * ceil32(return_data.size)) + 456 len 24] >> 64,
                                                                        0
                                                    else:
                                                        call dividendTrackerAddress.process(uint256 arg1) with:
                                                             gas gas_remaining wei
                                                            args gasForProcessing
                                                        if not ext_call.success:
                                                            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                revert with 0, 
                                                                            32,
                                                                            40,
                                                                            0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, ext_call.return_data[72 len 24] >> 64,
                                                                            0
                                                        else:
                                                            require return_data.size >= 96
                                                            emit ProcessedDividendTracker(ext_call.return_data[0], ext_call.return_data[32], ext_call.return_data[64], gasForProcessing, 1, tx.origin);
                                                            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                revert with 0, 
                                                                            32,
                                                                            40,
                                                                            0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, Mask(192, 0, ext_call.return_data[64]) >> 64,
                                                                            0
                                                else:
                                                    if not cd[68]:
                                                        if not stor20[address(cd[36])]:
                                                            if 0 > cd[68]:
                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                            if cd[68] < 0:
                                                                revert with 0, 17
                                                            if not address(cd[4]):
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not this.address:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            if 0 > balanceOf[address(cd[4])]:
                                                                revert with 0, 
                                                                            32,
                                                                            38,
                                                                            0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_21542 + (7 * ceil32(return_data.size)) + 486 len 26] >> 48,
                                                                            0
                                                            if balanceOf[address(cd[4])] < 0:
                                                                revert with 0, 17
                                                            if balanceOf[this.address] > -1:
                                                                revert with 0, 17
                                                            if balanceOf[this.address] < balanceOf[this.address]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            balanceOf[address(this.address)] = balanceOf[this.address]
                                                            emit Transfer(0, address(cd[4]), this.address);
                                                            if not address(cd[4]):
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not address(cd[36]):
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            if cd[68] > balanceOf[address(cd[4])]:
                                                                revert with 0, 
                                                                            32,
                                                                            38,
                                                                            0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_21542 + (7 * ceil32(return_data.size)) + 582 len 26] >> 48,
                                                                            0
                                                            if balanceOf[address(cd[4])] < cd[68]:
                                                                revert with 0, 17
                                                            balanceOf[address(cd[4])] -= cd[68]
                                                            if balanceOf[address(cd[36])] > !cd[68]:
                                                                revert with 0, 17
                                                            if balanceOf[address(cd[36])] + cd[68] < balanceOf[address(cd[36])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            balanceOf[address(cd[36])] += cd[68]
                                                            emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                                                            require ext_code.size(dividendTrackerAddress)
                                                            call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                                 gas gas_remaining wei
                                                                args address(cd[4]), balanceOf[address(cd[4])]
                                                            require ext_code.size(dividendTrackerAddress)
                                                            call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                                 gas gas_remaining wei
                                                                args address(cd[36]), balanceOf[address(cd[36])]
                                                            if stor7:
                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                    revert with 0, 
                                                                                32,
                                                                                40,
                                                                                0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_21542 + (7 * ceil32(return_data.size)) + 680 len 24] >> 64,
                                                                                0
                                                            else:
                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                     gas gas_remaining wei
                                                                    args gasForProcessing
                                                                if not ext_call.success:
                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    40,
                                                                                    0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, ext_call.return_data[72 len 24] >> 64,
                                                                                    0
                                                                else:
                                                                    require return_data.size >= 96
                                                                    emit ProcessedDividendTracker(ext_call.return_data[0], ext_call.return_data[32], ext_call.return_data[64], gasForProcessing, 1, tx.origin);
                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    40,
                                                                                    0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, Mask(192, 0, ext_call.return_data[64]) >> 64,
                                                                                    0
                                                        else:
                                                            if not cd[68]:
                                                                if 0 > cd[68]:
                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                if cd[68] < 0:
                                                                    revert with 0, 17
                                                                if not address(cd[4]):
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not this.address:
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                if 0 > balanceOf[address(cd[4])]:
                                                                    revert with 0, 
                                                                                32,
                                                                                38,
                                                                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_21542 + (7 * ceil32(return_data.size)) + 550 len 26] >> 48,
                                                                                0
                                                                if balanceOf[address(cd[4])] < 0:
                                                                    revert with 0, 17
                                                                if balanceOf[this.address] > -1:
                                                                    revert with 0, 17
                                                                if balanceOf[this.address] < balanceOf[this.address]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                balanceOf[address(this.address)] = balanceOf[this.address]
                                                                emit Transfer(0, address(cd[4]), this.address);
                                                                if not address(cd[4]):
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not address(cd[36]):
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                if cd[68] > balanceOf[address(cd[4])]:
                                                                    revert with 0, 
                                                                                32,
                                                                                38,
                                                                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_21542 + (7 * ceil32(return_data.size)) + 646 len 26] >> 48,
                                                                                0
                                                                if balanceOf[address(cd[4])] < cd[68]:
                                                                    revert with 0, 17
                                                                balanceOf[address(cd[4])] -= cd[68]
                                                                if balanceOf[address(cd[36])] > !cd[68]:
                                                                    revert with 0, 17
                                                                if balanceOf[address(cd[36])] + cd[68] < balanceOf[address(cd[36])]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                balanceOf[address(cd[36])] += cd[68]
                                                                emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                                                            else:
                                                                if cd[68] and 1 > -1 / cd[68]:
                                                                    revert with 0, 17
                                                                if not cd[68]:
                                                                    revert with 0, 18
                                                                if cd[68] / cd[68] != 1:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if 0 > !(cd[68] / 100):
                                                                    revert with 0, 17
                                                                if cd[68] / 100 > cd[68]:
                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                if cd[68] < cd[68] / 100:
                                                                    revert with 0, 17
                                                                if not address(cd[4]):
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not this.address:
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                if cd[68] / 100 > balanceOf[address(cd[4])]:
                                                                    revert with 0, 
                                                                                32,
                                                                                38,
                                                                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_21542 + (7 * ceil32(return_data.size)) + 550 len 26] >> 48,
                                                                                0
                                                                if balanceOf[address(cd[4])] < cd[68] / 100:
                                                                    revert with 0, 17
                                                                balanceOf[address(cd[4])] -= cd[68] / 100
                                                                if balanceOf[this.address] > !(cd[68] / 100):
                                                                    revert with 0, 17
                                                                if balanceOf[this.address] + (cd[68] / 100) < balanceOf[this.address]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                balanceOf[address(this.address)] = balanceOf[this.address] + (cd[68] / 100)
                                                                emit Transfer((cd[68] / 100), address(cd[4]), this.address);
                                                                if not address(cd[4]):
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not address(cd[36]):
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                if cd[68] - (cd[68] / 100) > balanceOf[address(cd[4])]:
                                                                    revert with 0, 
                                                                                32,
                                                                                38,
                                                                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_21542 + (7 * ceil32(return_data.size)) + 646 len 26] >> 48,
                                                                                0
                                                                if balanceOf[address(cd[4])] < cd[68] - (cd[68] / 100):
                                                                    revert with 0, 17
                                                                balanceOf[address(cd[4])] = balanceOf[address(cd[4])] - cd[68] + (cd[68] / 100)
                                                                if balanceOf[address(cd[36])] > !(cd[68] - (cd[68] / 100)):
                                                                    revert with 0, 17
                                                                if balanceOf[address(cd[36])] + cd[68] - (cd[68] / 100) < balanceOf[address(cd[36])]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                balanceOf[address(cd[36])] = balanceOf[address(cd[36])] + cd[68] - (cd[68] / 100)
                                                                emit Transfer((cd[68] - (cd[68] / 100)), address(cd[4]), address(cd[36]));
                                                            require ext_code.size(dividendTrackerAddress)
                                                            call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                                 gas gas_remaining wei
                                                                args address(cd[4]), balanceOf[address(cd[4])]
                                                            require ext_code.size(dividendTrackerAddress)
                                                            call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                                 gas gas_remaining wei
                                                                args address(cd[36]), balanceOf[address(cd[36])]
                                                            if stor7:
                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                    revert with 0, 
                                                                                32,
                                                                                40,
                                                                                0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_21542 + (7 * ceil32(return_data.size)) + 744 len 24] >> 64,
                                                                                0
                                                            else:
                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                     gas gas_remaining wei
                                                                    args gasForProcessing
                                                                if not ext_call.success:
                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    40,
                                                                                    0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, ext_call.return_data[72 len 24] >> 64,
                                                                                    0
                                                                else:
                                                                    require return_data.size >= 96
                                                                    emit ProcessedDividendTracker(ext_call.return_data[0], ext_call.return_data[32], ext_call.return_data[64], gasForProcessing, 1, tx.origin);
                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    40,
                                                                                    0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, Mask(192, 0, ext_call.return_data[64]) >> 64,
                                                                                    0
                                                    else:
                                                        if cd[68] and totalFees > -1 / cd[68]:
                                                            revert with 0, 17
                                                        if not cd[68]:
                                                            revert with 0, 18
                                                        if cd[68] * totalFees / cd[68] != totalFees:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not stor20[address(cd[36])]:
                                                            if cd[68] * totalFees / 100 > cd[68]:
                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                            if cd[68] < cd[68] * totalFees / 100:
                                                                revert with 0, 17
                                                            if not address(cd[4]):
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not this.address:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            if cd[68] * totalFees / 100 > balanceOf[address(cd[4])]:
                                                                revert with 0, 
                                                                            32,
                                                                            38,
                                                                            0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_21542 + (7 * ceil32(return_data.size)) + 486 len 26] >> 48,
                                                                            0
                                                            if balanceOf[address(cd[4])] < cd[68] * totalFees / 100:
                                                                revert with 0, 17
                                                            balanceOf[address(cd[4])] -= cd[68] * totalFees / 100
                                                            if balanceOf[this.address] > !(cd[68] * totalFees / 100):
                                                                revert with 0, 17
                                                            if balanceOf[this.address] + (cd[68] * totalFees / 100) < balanceOf[this.address]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            balanceOf[address(this.address)] = balanceOf[this.address] + (cd[68] * totalFees / 100)
                                                            emit Transfer((cd[68] * totalFees / 100), address(cd[4]), this.address);
                                                            if not address(cd[4]):
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not address(cd[36]):
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            if cd[68] - (cd[68] * totalFees / 100) > balanceOf[address(cd[4])]:
                                                                revert with 0, 
                                                                            32,
                                                                            38,
                                                                            0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_21542 + (7 * ceil32(return_data.size)) + 582 len 26] >> 48,
                                                                            0
                                                            if balanceOf[address(cd[4])] < cd[68] - (cd[68] * totalFees / 100):
                                                                revert with 0, 17
                                                            balanceOf[address(cd[4])] = balanceOf[address(cd[4])] - cd[68] + (cd[68] * totalFees / 100)
                                                            if balanceOf[address(cd[36])] > !(cd[68] - (cd[68] * totalFees / 100)):
                                                                revert with 0, 17
                                                            if balanceOf[address(cd[36])] + cd[68] - (cd[68] * totalFees / 100) < balanceOf[address(cd[36])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            balanceOf[address(cd[36])] = balanceOf[address(cd[36])] + cd[68] - (cd[68] * totalFees / 100)
                                                            emit Transfer((cd[68] - (cd[68] * totalFees / 100)), address(cd[4]), address(cd[36]));
                                                            require ext_code.size(dividendTrackerAddress)
                                                            call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                                 gas gas_remaining wei
                                                                args address(cd[4]), balanceOf[address(cd[4])]
                                                            require ext_code.size(dividendTrackerAddress)
                                                            call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                                 gas gas_remaining wei
                                                                args address(cd[36]), balanceOf[address(cd[36])]
                                                            if stor7:
                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                    revert with 0, 
                                                                                32,
                                                                                40,
                                                                                0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_21542 + (7 * ceil32(return_data.size)) + 680 len 24] >> 64,
                                                                                0
                                                            else:
                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                     gas gas_remaining wei
                                                                    args gasForProcessing
                                                                if not ext_call.success:
                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    40,
                                                                                    0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, ext_call.return_data[72 len 24] >> 64,
                                                                                    0
                                                                else:
                                                                    require return_data.size >= 96
                                                                    emit ProcessedDividendTracker(ext_call.return_data[0], ext_call.return_data[32], ext_call.return_data[64], gasForProcessing, 1, tx.origin);
                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    40,
                                                                                    0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, Mask(192, 0, ext_call.return_data[64]) >> 64,
                                                                                    0
                                                        else:
                                                            if not cd[68]:
                                                                if cd[68] * totalFees / 100 > -1:
                                                                    revert with 0, 17
                                                                if cd[68] * totalFees / 100 > cd[68]:
                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                if cd[68] < cd[68] * totalFees / 100:
                                                                    revert with 0, 17
                                                                if not address(cd[4]):
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not this.address:
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                if cd[68] * totalFees / 100 > balanceOf[address(cd[4])]:
                                                                    revert with 0, 
                                                                                32,
                                                                                38,
                                                                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_21542 + (7 * ceil32(return_data.size)) + 550 len 26] >> 48,
                                                                                0
                                                                if balanceOf[address(cd[4])] < cd[68] * totalFees / 100:
                                                                    revert with 0, 17
                                                                balanceOf[address(cd[4])] -= cd[68] * totalFees / 100
                                                                if balanceOf[this.address] > !(cd[68] * totalFees / 100):
                                                                    revert with 0, 17
                                                                if balanceOf[this.address] + (cd[68] * totalFees / 100) < balanceOf[this.address]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                balanceOf[address(this.address)] = balanceOf[this.address] + (cd[68] * totalFees / 100)
                                                                emit Transfer((cd[68] * totalFees / 100), address(cd[4]), this.address);
                                                                if not address(cd[4]):
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not address(cd[36]):
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                if cd[68] - (cd[68] * totalFees / 100) > balanceOf[address(cd[4])]:
                                                                    revert with 0, 
                                                                                32,
                                                                                38,
                                                                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_21542 + (7 * ceil32(return_data.size)) + 646 len 26] >> 48,
                                                                                0
                                                                if balanceOf[address(cd[4])] < cd[68] - (cd[68] * totalFees / 100):
                                                                    revert with 0, 17
                                                                balanceOf[address(cd[4])] = balanceOf[address(cd[4])] - cd[68] + (cd[68] * totalFees / 100)
                                                                if balanceOf[address(cd[36])] > !(cd[68] - (cd[68] * totalFees / 100)):
                                                                    revert with 0, 17
                                                                if balanceOf[address(cd[36])] + cd[68] - (cd[68] * totalFees / 100) < balanceOf[address(cd[36])]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                balanceOf[address(cd[36])] = balanceOf[address(cd[36])] + cd[68] - (cd[68] * totalFees / 100)
                                                                emit Transfer((cd[68] - (cd[68] * totalFees / 100)), address(cd[4]), address(cd[36]));
                                                            else:
                                                                if cd[68] and 1 > -1 / cd[68]:
                                                                    revert with 0, 17
                                                                if not cd[68]:
                                                                    revert with 0, 18
                                                                if cd[68] / cd[68] != 1:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if cd[68] * totalFees / 100 > !(cd[68] / 100):
                                                                    revert with 0, 17
                                                                if (cd[68] * totalFees / 100) + (cd[68] / 100) > cd[68]:
                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                if cd[68] < (cd[68] * totalFees / 100) + (cd[68] / 100):
                                                                    revert with 0, 17
                                                                if not address(cd[4]):
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not this.address:
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                if (cd[68] * totalFees / 100) + (cd[68] / 100) > balanceOf[address(cd[4])]:
                                                                    revert with 0, 
                                                                                32,
                                                                                38,
                                                                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_21542 + (7 * ceil32(return_data.size)) + 550 len 26] >> 48,
                                                                                0
                                                                if balanceOf[address(cd[4])] < (cd[68] * totalFees / 100) + (cd[68] / 100):
                                                                    revert with 0, 17
                                                                balanceOf[address(cd[4])] = balanceOf[address(cd[4])] - (cd[68] * totalFees / 100) - (cd[68] / 100)
                                                                if balanceOf[this.address] > !((cd[68] * totalFees / 100) + (cd[68] / 100)):
                                                                    revert with 0, 17
                                                                if balanceOf[this.address] + (cd[68] * totalFees / 100) + (cd[68] / 100) < balanceOf[this.address]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                balanceOf[address(this.address)] = balanceOf[this.address] + (cd[68] * totalFees / 100) + (cd[68] / 100)
                                                                emit Transfer(((cd[68] * totalFees / 100) + (cd[68] / 100)), address(cd[4]), this.address);
                                                                if not address(cd[4]):
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not address(cd[36]):
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                if cd[68] - (cd[68] * totalFees / 100) - (cd[68] / 100) > balanceOf[address(cd[4])]:
                                                                    revert with 0, 
                                                                                32,
                                                                                38,
                                                                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_21542 + (7 * ceil32(return_data.size)) + 646 len 26] >> 48,
                                                                                0
                                                                if balanceOf[address(cd[4])] < cd[68] - (cd[68] * totalFees / 100) - (cd[68] / 100):
                                                                    revert with 0, 17
                                                                balanceOf[address(cd[4])] = balanceOf[address(cd[4])] - cd[68] + (cd[68] * totalFees / 100) + (cd[68] / 100)
                                                                if balanceOf[address(cd[36])] > !(cd[68] - (cd[68] * totalFees / 100) - (cd[68] / 100)):
                                                                    revert with 0, 17
                                                                if balanceOf[address(cd[36])] + cd[68] - (cd[68] * totalFees / 100) - (cd[68] / 100) < balanceOf[address(cd[36])]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                balanceOf[address(cd[36])] = balanceOf[address(cd[36])] + cd[68] - (cd[68] * totalFees / 100) - (cd[68] / 100)
                                                                emit Transfer((cd[68] - (cd[68] * totalFees / 100) - (cd[68] / 100)), address(cd[4]), address(cd[36]));
                                                            require ext_code.size(dividendTrackerAddress)
                                                            call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                                 gas gas_remaining wei
                                                                args address(cd[4]), balanceOf[address(cd[4])]
                                                            require ext_code.size(dividendTrackerAddress)
                                                            call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                                 gas gas_remaining wei
                                                                args address(cd[36]), balanceOf[address(cd[36])]
                                                            if stor7:
                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                    revert with 0, 
                                                                                32,
                                                                                40,
                                                                                0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_21542 + (7 * ceil32(return_data.size)) + 744 len 24] >> 64,
                                                                                0
                                                            else:
                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                     gas gas_remaining wei
                                                                    args gasForProcessing
                                                                if not ext_call.success:
                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    40,
                                                                                    0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, ext_call.return_data[72 len 24] >> 64,
                                                                                    0
                                                                else:
                                                                    require return_data.size >= 96
                                                                    emit ProcessedDividendTracker(ext_call.return_data[0], ext_call.return_data[32], ext_call.return_data[64], gasForProcessing, 1, tx.origin);
                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    40,
                                                                                    0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, Mask(192, 0, ext_call.return_data[64]) >> 64,
                                                                                    0
                                    else:
                                        if balanceOf[this.address] and stor14 > -1 / balanceOf[this.address]:
                                            revert with 0, 17
                                        if not balanceOf[this.address]:
                                            revert with 0, 18
                                        if balanceOf[this.address] * stor14 / balanceOf[this.address] != stor14:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _21474 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_21474] = 26
                                        mem[_21474 + 32] = 'SafeMath: division by zero'
                                        if not totalFees:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        _21510 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_21510] = 26
                                        mem[_21510 + 32] = 'SafeMath: division by zero'
                                        _21530 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_21530] = 30
                                        mem[_21530 + 32] = 'SafeMath: subtraction overflow'
                                        if balanceOf[this.address] * stor14 / totalFees / 2 > balanceOf[this.address] * stor14 / totalFees:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if balanceOf[this.address] * stor14 / totalFees < balanceOf[this.address] * stor14 / totalFees / 2:
                                            revert with 0, 17
                                        _21584 = mem[64]
                                        mem[mem[64]] = 2
                                        mem[64] = mem[64] + 96
                                        mem[_21584 + 32 len 64] = call.data[calldata.size len 64]
                                        if 0 >= mem[_21584]:
                                            revert with 0, 50
                                        mem[_21584 + 32] = this.address
                                        staticcall uniswapV2RouterAddress.WETH() with:
                                                gas gas_remaining wei
                                        mem[_21584 + 96] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = _21584 + ceil32(return_data.size) + 96
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                        if 1 >= mem[_21584]:
                                            revert with 0, 50
                                        mem[_21584 + 64] = ext_call.return_data[12 len 20]
                                        if not this.address:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not uniswapV2RouterAddress:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        mem[0] = uniswapV2RouterAddress
                                        mem[32] = sha3(address(this.address), 1)
                                        allowance[address(this.address)][stor6].field_0 = balanceOf[this.address] * stor14 / totalFees / 2
                                        allowance[address(this.address)][stor6].field_255 = 0
                                        emit Approval((balanceOf[this.address] * stor14 / totalFees / 2), this.address, uniswapV2RouterAddress);
                                        mem[_21584 + ceil32(return_data.size) + 96] = 0x791ac94700000000000000000000000000000000000000000000000000000000
                                        mem[_21584 + ceil32(return_data.size) + 100] = balanceOf[this.address] * stor14 / totalFees / 2
                                        mem[_21584 + ceil32(return_data.size) + 132] = 0
                                        mem[_21584 + ceil32(return_data.size) + 164] = 160
                                        mem[_21584 + ceil32(return_data.size) + 260] = mem[_21584]
                                        idx = 0
                                        s = _21584 + ceil32(return_data.size) + 292
                                        t = _21584 + 32
                                        while idx < mem[_21584]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_21584 + ceil32(return_data.size) + 196] = this.address
                                        mem[_21584 + ceil32(return_data.size) + 228] = block.timestamp
                                        require ext_code.size(uniswapV2RouterAddress)
                                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _21584 + ceil32(return_data.size) + (32 * mem[_21584]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _33724 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33724] = 30
                                        mem[_33724 + 32] = 'SafeMath: subtraction overflow'
                                        if eth.balance(this.address) > eth.balance(this.address):
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if eth.balance(this.address) < eth.balance(this.address):
                                            revert with 0, 17
                                        if not this.address:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not uniswapV2RouterAddress:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        mem[0] = uniswapV2RouterAddress
                                        mem[32] = sha3(address(this.address), 1)
                                        allowance[address(this.address)][stor6].field_0 = (balanceOf[this.address] * stor14 / totalFees) - (balanceOf[this.address] * stor14 / totalFees / 2)
                                        emit Approval(((balanceOf[this.address] * stor14 / totalFees) - (balanceOf[this.address] * stor14 / totalFees / 2)), this.address, uniswapV2RouterAddress);
                                        mem[mem[64] + 68] = 0
                                        mem[mem[64] + 100] = 0
                                        mem[mem[64] + 132] = stor17
                                        mem[mem[64] + 164] = block.timestamp
                                        call uniswapV2RouterAddress.addLiquidityETH(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                             gas gas_remaining wei
                                            args this.address, (balanceOf[this.address] * stor14 / totalFees) - (balanceOf[this.address] * stor14 / totalFees / 2), 0, 0, stor17, block.timestamp
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        mem[mem[64] + 32] = 0
                                        mem[mem[64] + 64] = (balanceOf[this.address] * stor14 / totalFees) - (balanceOf[this.address] * stor14 / totalFees / 2)
                                        emit SwapAndLiquify(Mask(255, 1, balanceOf[this.address] * stor14 / totalFees), 0, (balanceOf[this.address] * stor14 / totalFees) - (balanceOf[this.address] * stor14 / totalFees / 2));
                                        mem[0] = this.address
                                        mem[32] = 0
                                        _33910 = mem[64]
                                        mem[mem[64]] = 3
                                        mem[64] = mem[64] + 128
                                        mem[_33910 + 32 len 96] = call.data[calldata.size len 96]
                                        if 0 >= mem[_33910]:
                                            revert with 0, 50
                                        mem[_33910 + 32] = this.address
                                        staticcall uniswapV2RouterAddress.WETH() with:
                                                gas gas_remaining wei
                                        mem[_33910 + 128] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = _33910 + ceil32(return_data.size) + 128
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                        if 1 >= mem[_33910]:
                                            revert with 0, 50
                                        mem[_33910 + 64] = ext_call.return_data[12 len 20]
                                        if 2 >= mem[_33910]:
                                            revert with 0, 50
                                        mem[_33910 + 96] = sub_4d7effddAddress
                                        if not this.address:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not uniswapV2RouterAddress:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        mem[0] = uniswapV2RouterAddress
                                        mem[32] = sha3(address(this.address), 1)
                                        allowance[address(this.address)][stor6].field_0 = balanceOf[this.address]
                                        emit Approval(balanceOf[this.address], this.address, uniswapV2RouterAddress);
                                        mem[_33910 + ceil32(return_data.size) + 128] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                        mem[_33910 + ceil32(return_data.size) + 132] = balanceOf[this.address]
                                        mem[_33910 + ceil32(return_data.size) + 164] = 0
                                        mem[_33910 + ceil32(return_data.size) + 196] = 160
                                        mem[_33910 + ceil32(return_data.size) + 292] = mem[_33910]
                                        idx = 0
                                        s = _33910 + ceil32(return_data.size) + 324
                                        t = _33910 + 32
                                        while idx < mem[_33910]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_33910 + ceil32(return_data.size) + 228] = this.address
                                        mem[_33910 + ceil32(return_data.size) + 260] = block.timestamp
                                        require ext_code.size(uniswapV2RouterAddress)
                                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _33910 + ceil32(return_data.size) + (32 * mem[_33910]) + -mem[64] + 320]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[mem[64] + 4] = this.address
                                        staticcall sub_4d7effddAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[mem[64]] = ext_call.return_data[0]
                                        _62556 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _62564 = mem[_62556]
                                        mem[mem[64] + 4] = dividendTrackerAddress
                                        mem[mem[64] + 36] = _62564
                                        call sub_4d7effddAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args dividendTrackerAddress, _62564
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _62588 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_62588] == bool(mem[_62588])
                                        if not mem[_62588]:
                                            stor7 = 0
                                            mem[0] = address(cd[4])
                                            mem[32] = 19
                                            if stor19[address(cd[4])]:
                                                if not address(cd[4]):
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not address(cd[36]):
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _62696 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_62696] = 38
                                                mem[_62696 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if cd[68] > balanceOf[address(cd[4])]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_62696 + 70 len 26]
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(cd[4])] < cd[68]:
                                                    revert with 0, 17
                                                balanceOf[address(cd[4])] -= cd[68]
                                                if balanceOf[address(cd[36])] > !cd[68]:
                                                    revert with 0, 17
                                                if balanceOf[address(cd[36])] + cd[68] < balanceOf[address(cd[36])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(cd[36])] += cd[68]
                                                emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                                                require ext_code.size(dividendTrackerAddress)
                                                call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args address(cd[4]), balanceOf[address(cd[4])]
                                                mem[0] = address(cd[36])
                                                mem[32] = 0
                                                require ext_code.size(dividendTrackerAddress)
                                                call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args address(cd[36]), balanceOf[address(cd[36])]
                                                if not ext_call.success:
                                                    if not ext_call.success:
                                                        if stor7:
                                                            _64278 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_64278] = 40
                                                            mem[_64278 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 40
                                                                mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_64278 + 72 len 24]
                                                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                        else:
                                                            call dividendTrackerAddress.process(uint256 arg1) with:
                                                                 gas gas_remaining wei
                                                                args gasForProcessing
                                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                            if not ext_call.success:
                                                                _65370 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_65370] = 40
                                                                mem[_65370 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 40
                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_65370 + 72 len 24]
                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                            else:
                                                                _64281 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 96
                                                                _64730 = mem[_64281 + 32]
                                                                _64731 = mem[_64281 + 64]
                                                                mem[mem[64]] = mem[_64281]
                                                                mem[mem[64] + 64] = _64731
                                                                mem[mem[64] + 96] = gasForProcessing
                                                                emit ProcessedDividendTracker(mem[mem[64]], _64730, _64731, gasForProcessing, 1, tx.origin);
                                                                _66978 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_66978] = 40
                                                                mem[_66978 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 40
                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_66978 + 72 len 24]
                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                    else:
                                                        if stor7:
                                                            _64504 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_64504] = 40
                                                            mem[_64504 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 40
                                                                mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_64504 + 72 len 24]
                                                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                        else:
                                                            call dividendTrackerAddress.process(uint256 arg1) with:
                                                                 gas gas_remaining wei
                                                                args gasForProcessing
                                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                            if not ext_call.success:
                                                                _65777 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_65777] = 40
                                                                mem[_65777 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 40
                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_65777 + 72 len 24]
                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                            else:
                                                                _64507 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 96
                                                                _65001 = mem[_64507 + 32]
                                                                _65002 = mem[_64507 + 64]
                                                                mem[mem[64]] = mem[_64507]
                                                                mem[mem[64] + 64] = _65002
                                                                mem[mem[64] + 96] = gasForProcessing
                                                                emit ProcessedDividendTracker(mem[mem[64]], _65001, _65002, gasForProcessing, 1, tx.origin);
                                                                _67398 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_67398] = 40
                                                                mem[_67398 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 40
                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_67398 + 72 len 24]
                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                else:
                                                    if not ext_call.success:
                                                        if stor7:
                                                            _64508 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_64508] = 40
                                                            mem[_64508 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 40
                                                                mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_64508 + 72 len 24]
                                                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                        else:
                                                            call dividendTrackerAddress.process(uint256 arg1) with:
                                                                 gas gas_remaining wei
                                                                args gasForProcessing
                                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                            if not ext_call.success:
                                                                _65780 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_65780] = 40
                                                                mem[_65780 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 40
                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_65780 + 72 len 24]
                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                            else:
                                                                _64511 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 96
                                                                _65005 = mem[_64511 + 32]
                                                                _65006 = mem[_64511 + 64]
                                                                mem[mem[64]] = mem[_64511]
                                                                mem[mem[64] + 64] = _65006
                                                                mem[mem[64] + 96] = gasForProcessing
                                                                emit ProcessedDividendTracker(mem[mem[64]], _65005, _65006, gasForProcessing, 1, tx.origin);
                                                                _67403 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_67403] = 40
                                                                mem[_67403 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 40
                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_67403 + 72 len 24]
                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                    else:
                                                        if stor7:
                                                            _64732 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_64732] = 40
                                                            mem[_64732 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 40
                                                                mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_64732 + 72 len 24]
                                                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                        else:
                                                            call dividendTrackerAddress.process(uint256 arg1) with:
                                                                 gas gas_remaining wei
                                                                args gasForProcessing
                                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                            if not ext_call.success:
                                                                _66169 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_66169] = 40
                                                                mem[_66169 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 40
                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_66169 + 72 len 24]
                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                            else:
                                                                _64735 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 96
                                                                _65377 = mem[_64735 + 32]
                                                                _65378 = mem[_64735 + 64]
                                                                mem[mem[64]] = mem[_64735]
                                                                mem[mem[64] + 64] = _65378
                                                                mem[mem[64] + 96] = gasForProcessing
                                                                emit ProcessedDividendTracker(mem[mem[64]], _65377, _65378, gasForProcessing, 1, tx.origin);
                                                                _67821 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_67821] = 40
                                                                mem[_67821 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 40
                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_67821 + 72 len 24]
                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                            else:
                                                mem[0] = address(cd[36])
                                                mem[32] = 19
                                                if stor19[address(cd[36])]:
                                                    if not address(cd[4]):
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not address(cd[36]):
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _62750 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_62750] = 38
                                                    mem[_62750 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if cd[68] > balanceOf[address(cd[4])]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_62750 + 70 len 26]
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(cd[4])] < cd[68]:
                                                        revert with 0, 17
                                                    balanceOf[address(cd[4])] -= cd[68]
                                                    if balanceOf[address(cd[36])] > !cd[68]:
                                                        revert with 0, 17
                                                    if balanceOf[address(cd[36])] + cd[68] < balanceOf[address(cd[36])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(cd[36])] += cd[68]
                                                    emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                                                    require ext_code.size(dividendTrackerAddress)
                                                    call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args address(cd[4]), balanceOf[address(cd[4])]
                                                    mem[0] = address(cd[36])
                                                    mem[32] = 0
                                                    require ext_code.size(dividendTrackerAddress)
                                                    call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args address(cd[36]), balanceOf[address(cd[36])]
                                                    if not ext_call.success:
                                                        if not ext_call.success:
                                                            if stor7:
                                                                _64526 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_64526] = 40
                                                                mem[_64526 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 40
                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_64526 + 72 len 24]
                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                            else:
                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                     gas gas_remaining wei
                                                                    args gasForProcessing
                                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                if not ext_call.success:
                                                                    _65801 = mem[64]
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_65801] = 40
                                                                    mem[_65801 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[mem[64] + 4] = 32
                                                                        mem[mem[64] + 36] = 40
                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_65801 + 72 len 24]
                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                else:
                                                                    _64529 = mem[64]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 96
                                                                    _65020 = mem[_64529 + 32]
                                                                    _65021 = mem[_64529 + 64]
                                                                    mem[mem[64]] = mem[_64529]
                                                                    mem[mem[64] + 64] = _65021
                                                                    mem[mem[64] + 96] = gasForProcessing
                                                                    emit ProcessedDividendTracker(mem[mem[64]], _65020, _65021, gasForProcessing, 1, tx.origin);
                                                                    _67428 = mem[64]
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_67428] = 40
                                                                    mem[_67428 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[mem[64] + 4] = 32
                                                                        mem[mem[64] + 36] = 40
                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_67428 + 72 len 24]
                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                        else:
                                                            if stor7:
                                                                _64746 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_64746] = 40
                                                                mem[_64746 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 40
                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_64746 + 72 len 24]
                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                            else:
                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                     gas gas_remaining wei
                                                                    args gasForProcessing
                                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                if not ext_call.success:
                                                                    _66187 = mem[64]
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_66187] = 40
                                                                    mem[_66187 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[mem[64] + 4] = 32
                                                                        mem[mem[64] + 36] = 40
                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_66187 + 72 len 24]
                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                else:
                                                                    _64749 = mem[64]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 96
                                                                    _65394 = mem[_64749 + 32]
                                                                    _65395 = mem[_64749 + 64]
                                                                    mem[mem[64]] = mem[_64749]
                                                                    mem[mem[64] + 64] = _65395
                                                                    mem[mem[64] + 96] = gasForProcessing
                                                                    emit ProcessedDividendTracker(mem[mem[64]], _65394, _65395, gasForProcessing, 1, tx.origin);
                                                                    _67855 = mem[64]
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_67855] = 40
                                                                    mem[_67855 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[mem[64] + 4] = 32
                                                                        mem[mem[64] + 36] = 40
                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_67855 + 72 len 24]
                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                    else:
                                                        if not ext_call.success:
                                                            if stor7:
                                                                _64750 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_64750] = 40
                                                                mem[_64750 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 40
                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_64750 + 72 len 24]
                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                            else:
                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                     gas gas_remaining wei
                                                                    args gasForProcessing
                                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                if not ext_call.success:
                                                                    _66190 = mem[64]
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_66190] = 40
                                                                    mem[_66190 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[mem[64] + 4] = 32
                                                                        mem[mem[64] + 36] = 40
                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_66190 + 72 len 24]
                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                else:
                                                                    _64753 = mem[64]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 96
                                                                    _65398 = mem[_64753 + 32]
                                                                    _65399 = mem[_64753 + 64]
                                                                    mem[mem[64]] = mem[_64753]
                                                                    mem[mem[64] + 64] = _65399
                                                                    mem[mem[64] + 96] = gasForProcessing
                                                                    emit ProcessedDividendTracker(mem[mem[64]], _65398, _65399, gasForProcessing, 1, tx.origin);
                                                                    _67860 = mem[64]
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_67860] = 40
                                                                    mem[_67860 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[mem[64] + 4] = 32
                                                                        mem[mem[64] + 36] = 40
                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_67860 + 72 len 24]
                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                        else:
                                                            if stor7:
                                                                _65022 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_65022] = 40
                                                                mem[_65022 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 40
                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_65022 + 72 len 24]
                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                            else:
                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                     gas gas_remaining wei
                                                                    args gasForProcessing
                                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                if not ext_call.success:
                                                                    _66583 = mem[64]
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_66583] = 40
                                                                    mem[_66583 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[mem[64] + 4] = 32
                                                                        mem[mem[64] + 36] = 40
                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_66583 + 72 len 24]
                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                else:
                                                                    _65025 = mem[64]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 96
                                                                    _65808 = mem[_65025 + 32]
                                                                    _65809 = mem[_65025 + 64]
                                                                    mem[mem[64]] = mem[_65025]
                                                                    mem[mem[64] + 64] = _65809
                                                                    mem[mem[64] + 96] = gasForProcessing
                                                                    emit ProcessedDividendTracker(mem[mem[64]], _65808, _65809, gasForProcessing, 1, tx.origin);
                                                                    _68302 = mem[64]
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_68302] = 40
                                                                    mem[_68302 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[mem[64] + 4] = 32
                                                                        mem[mem[64] + 36] = 40
                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_68302 + 72 len 24]
                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                else:
                                                    if stor7:
                                                        if not address(cd[4]):
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not address(cd[36]):
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        _62699 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_62699] = 38
                                                        mem[_62699 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if cd[68] > balanceOf[address(cd[4])]:
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 38
                                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_62699 + 70 len 26]
                                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                        if balanceOf[address(cd[4])] < cd[68]:
                                                            revert with 0, 17
                                                        balanceOf[address(cd[4])] -= cd[68]
                                                        if balanceOf[address(cd[36])] > !cd[68]:
                                                            revert with 0, 17
                                                        if balanceOf[address(cd[36])] + cd[68] < balanceOf[address(cd[36])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(cd[36])] += cd[68]
                                                        emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                                                        require ext_code.size(dividendTrackerAddress)
                                                        call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args address(cd[4]), balanceOf[address(cd[4])]
                                                        mem[0] = address(cd[36])
                                                        mem[32] = 0
                                                        require ext_code.size(dividendTrackerAddress)
                                                        call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args address(cd[36]), balanceOf[address(cd[36])]
                                                        if not ext_call.success:
                                                            if not ext_call.success:
                                                                if stor7:
                                                                    _64286 = mem[64]
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_64286] = 40
                                                                    mem[_64286 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[mem[64] + 4] = 32
                                                                        mem[mem[64] + 36] = 40
                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_64286 + 72 len 24]
                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                else:
                                                                    call dividendTrackerAddress.process(uint256 arg1) with:
                                                                         gas gas_remaining wei
                                                                        args gasForProcessing
                                                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                    if not ext_call.success:
                                                                        _65379 = mem[64]
                                                                        mem[64] = mem[64] + 96
                                                                        mem[_65379] = 40
                                                                        mem[_65379 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                        if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                            mem[mem[64] + 4] = 32
                                                                            mem[mem[64] + 36] = 40
                                                                            mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_65379 + 72 len 24]
                                                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                    else:
                                                                        _64289 = mem[64]
                                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                                        require return_data.size >= 96
                                                                        _64738 = mem[_64289 + 32]
                                                                        _64739 = mem[_64289 + 64]
                                                                        mem[mem[64]] = mem[_64289]
                                                                        mem[mem[64] + 64] = _64739
                                                                        mem[mem[64] + 96] = gasForProcessing
                                                                        emit ProcessedDividendTracker(mem[mem[64]], _64738, _64739, gasForProcessing, 1, tx.origin);
                                                                        _66988 = mem[64]
                                                                        mem[64] = mem[64] + 96
                                                                        mem[_66988] = 40
                                                                        mem[_66988 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                        if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                            mem[mem[64] + 4] = 32
                                                                            mem[mem[64] + 36] = 40
                                                                            mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_66988 + 72 len 24]
                                                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                            else:
                                                                if stor7:
                                                                    _64514 = mem[64]
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_64514] = 40
                                                                    mem[_64514 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[mem[64] + 4] = 32
                                                                        mem[mem[64] + 36] = 40
                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_64514 + 72 len 24]
                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                else:
                                                                    call dividendTrackerAddress.process(uint256 arg1) with:
                                                                         gas gas_remaining wei
                                                                        args gasForProcessing
                                                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                    if not ext_call.success:
                                                                        _65787 = mem[64]
                                                                        mem[64] = mem[64] + 96
                                                                        mem[_65787] = 40
                                                                        mem[_65787 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                        if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                            mem[mem[64] + 4] = 32
                                                                            mem[mem[64] + 36] = 40
                                                                            mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_65787 + 72 len 24]
                                                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                    else:
                                                                        _64517 = mem[64]
                                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                                        require return_data.size >= 96
                                                                        _65010 = mem[_64517 + 32]
                                                                        _65011 = mem[_64517 + 64]
                                                                        mem[mem[64]] = mem[_64517]
                                                                        mem[mem[64] + 64] = _65011
                                                                        mem[mem[64] + 96] = gasForProcessing
                                                                        emit ProcessedDividendTracker(mem[mem[64]], _65010, _65011, gasForProcessing, 1, tx.origin);
                                                                        _67416 = mem[64]
                                                                        mem[64] = mem[64] + 96
                                                                        mem[_67416] = 40
                                                                        mem[_67416 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                        if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                            mem[mem[64] + 4] = 32
                                                                            mem[mem[64] + 36] = 40
                                                                            mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_67416 + 72 len 24]
                                                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                        else:
                                                            if not ext_call.success:
                                                                if stor7:
                                                                    _64518 = mem[64]
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_64518] = 40
                                                                    mem[_64518 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[mem[64] + 4] = 32
                                                                        mem[mem[64] + 36] = 40
                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_64518 + 72 len 24]
                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                else:
                                                                    call dividendTrackerAddress.process(uint256 arg1) with:
                                                                         gas gas_remaining wei
                                                                        args gasForProcessing
                                                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                    if not ext_call.success:
                                                                        _65790 = mem[64]
                                                                        mem[64] = mem[64] + 96
                                                                        mem[_65790] = 40
                                                                        mem[_65790 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                        if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                            mem[mem[64] + 4] = 32
                                                                            mem[mem[64] + 36] = 40
                                                                            mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_65790 + 72 len 24]
                                                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                    else:
                                                                        _64521 = mem[64]
                                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                                        require return_data.size >= 96
                                                                        _65014 = mem[_64521 + 32]
                                                                        _65015 = mem[_64521 + 64]
                                                                        mem[mem[64]] = mem[_64521]
                                                                        mem[mem[64] + 64] = _65015
                                                                        mem[mem[64] + 96] = gasForProcessing
                                                                        emit ProcessedDividendTracker(mem[mem[64]], _65014, _65015, gasForProcessing, 1, tx.origin);
                                                                        _67421 = mem[64]
                                                                        mem[64] = mem[64] + 96
                                                                        mem[_67421] = 40
                                                                        mem[_67421 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                        if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                            mem[mem[64] + 4] = 32
                                                                            mem[mem[64] + 36] = 40
                                                                            mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_67421 + 72 len 24]
                                                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                            else:
                                                                if stor7:
                                                                    _64740 = mem[64]
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_64740] = 40
                                                                    mem[_64740 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[mem[64] + 4] = 32
                                                                        mem[mem[64] + 36] = 40
                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_64740 + 72 len 24]
                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                else:
                                                                    call dividendTrackerAddress.process(uint256 arg1) with:
                                                                         gas gas_remaining wei
                                                                        args gasForProcessing
                                                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                    if not ext_call.success:
                                                                        _66179 = mem[64]
                                                                        mem[64] = mem[64] + 96
                                                                        mem[_66179] = 40
                                                                        mem[_66179 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                        if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                            mem[mem[64] + 4] = 32
                                                                            mem[mem[64] + 36] = 40
                                                                            mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_66179 + 72 len 24]
                                                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                    else:
                                                                        _64743 = mem[64]
                                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                                        require return_data.size >= 96
                                                                        _65386 = mem[_64743 + 32]
                                                                        _65387 = mem[_64743 + 64]
                                                                        mem[mem[64]] = mem[_64743]
                                                                        mem[mem[64] + 64] = _65387
                                                                        mem[mem[64] + 96] = gasForProcessing
                                                                        emit ProcessedDividendTracker(mem[mem[64]], _65386, _65387, gasForProcessing, 1, tx.origin);
                                                                        _67841 = mem[64]
                                                                        mem[64] = mem[64] + 96
                                                                        mem[_67841] = 40
                                                                        mem[_67841 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                        if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                            mem[mem[64] + 4] = 32
                                                                            mem[mem[64] + 36] = 40
                                                                            mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_67841 + 72 len 24]
                                                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                    else:
                                                        if not cd[68]:
                                                            _62798 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_62798] = 26
                                                            mem[_62798 + 32] = 'SafeMath: division by zero'
                                                            mem[0] = address(cd[36])
                                                            mem[32] = 20
                                                            if not stor20[address(cd[36])]:
                                                                _63338 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_63338] = 30
                                                                mem[_63338 + 32] = 'SafeMath: subtraction overflow'
                                                                if 0 > cd[68]:
                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                if cd[68] < 0:
                                                                    revert with 0, 17
                                                                if not address(cd[4]):
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not this.address:
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                _64121 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_64121] = 38
                                                                mem[_64121 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                if 0 > balanceOf[address(cd[4])]:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 38
                                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_64121 + 70 len 26]
                                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                if balanceOf[address(cd[4])] < 0:
                                                                    revert with 0, 17
                                                                if balanceOf[this.address] > -1:
                                                                    revert with 0, 17
                                                                if balanceOf[this.address] < balanceOf[this.address]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[0] = this.address
                                                                mem[32] = 0
                                                                balanceOf[address(this.address)] = balanceOf[this.address]
                                                                emit Transfer(0, address(cd[4]), this.address);
                                                                if not address(cd[4]):
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not address(cd[36]):
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                _70896 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_70896] = 38
                                                                mem[_70896 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                if cd[68] > balanceOf[address(cd[4])]:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 38
                                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_70896 + 70 len 26]
                                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                if balanceOf[address(cd[4])] < cd[68]:
                                                                    revert with 0, 17
                                                                balanceOf[address(cd[4])] -= cd[68]
                                                                if balanceOf[address(cd[36])] > !cd[68]:
                                                                    revert with 0, 17
                                                                if balanceOf[address(cd[36])] + cd[68] < balanceOf[address(cd[36])]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                balanceOf[address(cd[36])] += cd[68]
                                                                emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                                                                require ext_code.size(dividendTrackerAddress)
                                                                call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                                     gas gas_remaining wei
                                                                    args address(cd[4]), balanceOf[address(cd[4])]
                                                                mem[0] = address(cd[36])
                                                                mem[32] = 0
                                                                require ext_code.size(dividendTrackerAddress)
                                                                call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                                     gas gas_remaining wei
                                                                    args address(cd[36]), balanceOf[address(cd[36])]
                                                                if not ext_call.success:
                                                                    if not ext_call.success:
                                                                        if stor7:
                                                                            _74646 = mem[64]
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_74646] = 40
                                                                            mem[_74646 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[mem[64] + 4] = 32
                                                                                mem[mem[64] + 36] = 40
                                                                                mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_74646 + 72 len 24]
                                                                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                        else:
                                                                            call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                 gas gas_remaining wei
                                                                                args gasForProcessing
                                                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                            if not ext_call.success:
                                                                                _75342 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_75342] = 40
                                                                                mem[_75342 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_75342 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                _74649 = mem[64]
                                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                                require return_data.size >= 96
                                                                                _74925 = mem[_74649 + 32]
                                                                                _74926 = mem[_74649 + 64]
                                                                                mem[mem[64]] = mem[_74649]
                                                                                mem[mem[64] + 64] = _74926
                                                                                mem[mem[64] + 96] = gasForProcessing
                                                                                emit ProcessedDividendTracker(mem[mem[64]], _74925, _74926, gasForProcessing, 1, tx.origin);
                                                                                _76249 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_76249] = 40
                                                                                mem[_76249 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_76249 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                    else:
                                                                        if stor7:
                                                                            _74801 = mem[64]
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_74801] = 40
                                                                            mem[_74801 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[mem[64] + 4] = 32
                                                                                mem[mem[64] + 36] = 40
                                                                                mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_74801 + 72 len 24]
                                                                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                        else:
                                                                            call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                 gas gas_remaining wei
                                                                                args gasForProcessing
                                                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                            if not ext_call.success:
                                                                                _75521 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_75521] = 40
                                                                                mem[_75521 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_75521 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                _74804 = mem[64]
                                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                                require return_data.size >= 96
                                                                                _75120 = mem[_74804 + 32]
                                                                                _75121 = mem[_74804 + 64]
                                                                                mem[mem[64]] = mem[_74804]
                                                                                mem[mem[64] + 64] = _75121
                                                                                mem[mem[64] + 96] = gasForProcessing
                                                                                emit ProcessedDividendTracker(mem[mem[64]], _75120, _75121, gasForProcessing, 1, tx.origin);
                                                                                _76536 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_76536] = 40
                                                                                mem[_76536 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_76536 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                else:
                                                                    if not ext_call.success:
                                                                        if stor7:
                                                                            _74805 = mem[64]
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_74805] = 40
                                                                            mem[_74805 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[mem[64] + 4] = 32
                                                                                mem[mem[64] + 36] = 40
                                                                                mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_74805 + 72 len 24]
                                                                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                        else:
                                                                            call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                 gas gas_remaining wei
                                                                                args gasForProcessing
                                                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                            if not ext_call.success:
                                                                                _75524 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_75524] = 40
                                                                                mem[_75524 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_75524 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                _74808 = mem[64]
                                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                                require return_data.size >= 96
                                                                                _75124 = mem[_74808 + 32]
                                                                                _75125 = mem[_74808 + 64]
                                                                                mem[mem[64]] = mem[_74808]
                                                                                mem[mem[64] + 64] = _75125
                                                                                mem[mem[64] + 96] = gasForProcessing
                                                                                emit ProcessedDividendTracker(mem[mem[64]], _75124, _75125, gasForProcessing, 1, tx.origin);
                                                                                _76541 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_76541] = 40
                                                                                mem[_76541 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_76541 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                    else:
                                                                        if stor7:
                                                                            _74927 = mem[64]
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_74927] = 40
                                                                            mem[_74927 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[mem[64] + 4] = 32
                                                                                mem[mem[64] + 36] = 40
                                                                                mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_74927 + 72 len 24]
                                                                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                        else:
                                                                            call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                 gas gas_remaining wei
                                                                                args gasForProcessing
                                                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                            if not ext_call.success:
                                                                                _75768 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_75768] = 40
                                                                                mem[_75768 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_75768 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                _74930 = mem[64]
                                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                                require return_data.size >= 96
                                                                                _75349 = mem[_74930 + 32]
                                                                                _75350 = mem[_74930 + 64]
                                                                                mem[mem[64]] = mem[_74930]
                                                                                mem[mem[64] + 64] = _75350
                                                                                mem[mem[64] + 96] = gasForProcessing
                                                                                emit ProcessedDividendTracker(mem[mem[64]], _75349, _75350, gasForProcessing, 1, tx.origin);
                                                                                _76892 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_76892] = 40
                                                                                mem[_76892 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_76892 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                            else:
                                                                if not cd[68]:
                                                                    _63587 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_63587] = 26
                                                                    mem[_63587 + 32] = 'SafeMath: division by zero'
                                                                    _65800 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_65800] = 30
                                                                    mem[_65800 + 32] = 'SafeMath: subtraction overflow'
                                                                    if 0 > cd[68]:
                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                    if cd[68] < 0:
                                                                        revert with 0, 17
                                                                    if not address(cd[4]):
                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                    if not this.address:
                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                    _70112 = mem[64]
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_70112] = 38
                                                                    mem[_70112 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                    if 0 > balanceOf[address(cd[4])]:
                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[mem[64] + 4] = 32
                                                                        mem[mem[64] + 36] = 38
                                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_70112 + 70 len 26]
                                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                    if balanceOf[address(cd[4])] < 0:
                                                                        revert with 0, 17
                                                                    if balanceOf[this.address] > -1:
                                                                        revert with 0, 17
                                                                    if balanceOf[this.address] < balanceOf[this.address]:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    mem[0] = this.address
                                                                    mem[32] = 0
                                                                    balanceOf[address(this.address)] = balanceOf[this.address]
                                                                    emit Transfer(0, address(cd[4]), this.address);
                                                                    if not address(cd[4]):
                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                    if not address(cd[36]):
                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                    _74022 = mem[64]
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_74022] = 38
                                                                    mem[_74022 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                    if cd[68] > balanceOf[address(cd[4])]:
                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[mem[64] + 4] = 32
                                                                        mem[mem[64] + 36] = 38
                                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_74022 + 70 len 26]
                                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                    if balanceOf[address(cd[4])] < cd[68]:
                                                                        revert with 0, 17
                                                                    balanceOf[address(cd[4])] -= cd[68]
                                                                    if balanceOf[address(cd[36])] > !cd[68]:
                                                                        revert with 0, 17
                                                                    if balanceOf[address(cd[36])] + cd[68] < balanceOf[address(cd[36])]:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    balanceOf[address(cd[36])] += cd[68]
                                                                    emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                                                                    require ext_code.size(dividendTrackerAddress)
                                                                    call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                                         gas gas_remaining wei
                                                                        args address(cd[4]), balanceOf[address(cd[4])]
                                                                    mem[0] = address(cd[36])
                                                                    mem[32] = 0
                                                                    require ext_code.size(dividendTrackerAddress)
                                                                    call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                                         gas gas_remaining wei
                                                                        args address(cd[36]), balanceOf[address(cd[36])]
                                                                    if not ext_call.success:
                                                                        if not ext_call.success:
                                                                            if stor7:
                                                                                _78837 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_78837] = 40
                                                                                mem[_78837 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_78837 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                     gas gas_remaining wei
                                                                                    args gasForProcessing
                                                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                                if not ext_call.success:
                                                                                    _80317 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_80317] = 40
                                                                                    mem[_80317 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_80317 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                                else:
                                                                                    _78840 = mem[64]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 96
                                                                                    _79552 = mem[_78840 + 32]
                                                                                    _79553 = mem[_78840 + 64]
                                                                                    mem[mem[64]] = mem[_78840]
                                                                                    mem[mem[64] + 64] = _79553
                                                                                    mem[mem[64] + 96] = gasForProcessing
                                                                                    emit ProcessedDividendTracker(mem[mem[64]], _79552, _79553, gasForProcessing, 1, tx.origin);
                                                                                    _81902 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_81902] = 40
                                                                                    mem[_81902 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_81902 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                        else:
                                                                            if stor7:
                                                                                _79176 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_79176] = 40
                                                                                mem[_79176 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_79176 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                     gas gas_remaining wei
                                                                                    args gasForProcessing
                                                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                                if not ext_call.success:
                                                                                    _80680 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_80680] = 40
                                                                                    mem[_80680 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_80680 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                                else:
                                                                                    _79179 = mem[64]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 96
                                                                                    _79951 = mem[_79179 + 32]
                                                                                    _79952 = mem[_79179 + 64]
                                                                                    mem[mem[64]] = mem[_79179]
                                                                                    mem[mem[64] + 64] = _79952
                                                                                    mem[mem[64] + 96] = gasForProcessing
                                                                                    emit ProcessedDividendTracker(mem[mem[64]], _79951, _79952, gasForProcessing, 1, tx.origin);
                                                                                    _82324 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_82324] = 40
                                                                                    mem[_82324 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_82324 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                    else:
                                                                        if not ext_call.success:
                                                                            if stor7:
                                                                                _79180 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_79180] = 40
                                                                                mem[_79180 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_79180 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                     gas gas_remaining wei
                                                                                    args gasForProcessing
                                                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                                if not ext_call.success:
                                                                                    _80683 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_80683] = 40
                                                                                    mem[_80683 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_80683 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                                else:
                                                                                    _79183 = mem[64]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 96
                                                                                    _79955 = mem[_79183 + 32]
                                                                                    _79956 = mem[_79183 + 64]
                                                                                    mem[mem[64]] = mem[_79183]
                                                                                    mem[mem[64] + 64] = _79956
                                                                                    mem[mem[64] + 96] = gasForProcessing
                                                                                    emit ProcessedDividendTracker(mem[mem[64]], _79955, _79956, gasForProcessing, 1, tx.origin);
                                                                                    _82329 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_82329] = 40
                                                                                    mem[_82329 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_82329 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                        else:
                                                                            if stor7:
                                                                                _79554 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_79554] = 40
                                                                                mem[_79554 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_79554 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                     gas gas_remaining wei
                                                                                    args gasForProcessing
                                                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                                if not ext_call.success:
                                                                                    _81093 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_81093] = 40
                                                                                    mem[_81093 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_81093 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                                else:
                                                                                    _79557 = mem[64]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 96
                                                                                    _80324 = mem[_79557 + 32]
                                                                                    _80325 = mem[_79557 + 64]
                                                                                    mem[mem[64]] = mem[_79557]
                                                                                    mem[mem[64] + 64] = _80325
                                                                                    mem[mem[64] + 96] = gasForProcessing
                                                                                    emit ProcessedDividendTracker(mem[mem[64]], _80324, _80325, gasForProcessing, 1, tx.origin);
                                                                                    _82802 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_82802] = 40
                                                                                    mem[_82802 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_82802 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                else:
                                                                    if cd[68] and 1 > -1 / cd[68]:
                                                                        revert with 0, 17
                                                                    if not cd[68]:
                                                                        revert with 0, 18
                                                                    if cd[68] / cd[68] != 1:
                                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                                    _64124 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_64124] = 26
                                                                    mem[_64124 + 32] = 'SafeMath: division by zero'
                                                                    if 0 > !(cd[68] / 100):
                                                                        revert with 0, 17
                                                                    _68284 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_68284] = 30
                                                                    mem[_68284 + 32] = 'SafeMath: subtraction overflow'
                                                                    if cd[68] / 100 > cd[68]:
                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                    if cd[68] < cd[68] / 100:
                                                                        revert with 0, 17
                                                                    if not address(cd[4]):
                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                    if not this.address:
                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                    _72325 = mem[64]
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_72325] = 38
                                                                    mem[_72325 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                    if cd[68] / 100 > balanceOf[address(cd[4])]:
                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[mem[64] + 4] = 32
                                                                        mem[mem[64] + 36] = 38
                                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_72325 + 70 len 26]
                                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                    if balanceOf[address(cd[4])] < cd[68] / 100:
                                                                        revert with 0, 17
                                                                    balanceOf[address(cd[4])] -= cd[68] / 100
                                                                    if balanceOf[this.address] > !(cd[68] / 100):
                                                                        revert with 0, 17
                                                                    if balanceOf[this.address] + (cd[68] / 100) < balanceOf[this.address]:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    mem[0] = this.address
                                                                    mem[32] = 0
                                                                    balanceOf[address(this.address)] = balanceOf[this.address] + (cd[68] / 100)
                                                                    emit Transfer((cd[68] / 100), address(cd[4]), this.address);
                                                                    if not address(cd[4]):
                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                    if not address(cd[36]):
                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                    _74654 = mem[64]
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_74654] = 38
                                                                    mem[_74654 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                    if cd[68] - (cd[68] / 100) > balanceOf[address(cd[4])]:
                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[mem[64] + 4] = 32
                                                                        mem[mem[64] + 36] = 38
                                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_74654 + 70 len 26]
                                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                    if balanceOf[address(cd[4])] < cd[68] - (cd[68] / 100):
                                                                        revert with 0, 17
                                                                    balanceOf[address(cd[4])] = balanceOf[address(cd[4])] - cd[68] + (cd[68] / 100)
                                                                    if balanceOf[address(cd[36])] > !(cd[68] - (cd[68] / 100)):
                                                                        revert with 0, 17
                                                                    if balanceOf[address(cd[36])] + cd[68] - (cd[68] / 100) < balanceOf[address(cd[36])]:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    balanceOf[address(cd[36])] = balanceOf[address(cd[36])] + cd[68] - (cd[68] / 100)
                                                                    emit Transfer((cd[68] - (cd[68] / 100)), address(cd[4]), address(cd[36]));
                                                                    require ext_code.size(dividendTrackerAddress)
                                                                    call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                                         gas gas_remaining wei
                                                                        args address(cd[4]), balanceOf[address(cd[4])]
                                                                    mem[0] = address(cd[36])
                                                                    mem[32] = 0
                                                                    require ext_code.size(dividendTrackerAddress)
                                                                    call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                                         gas gas_remaining wei
                                                                        args address(cd[36]), balanceOf[address(cd[36])]
                                                                    if not ext_call.success:
                                                                        if not ext_call.success:
                                                                            if stor7:
                                                                                _81078 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_81078] = 40
                                                                                mem[_81078 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_81078 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                     gas gas_remaining wei
                                                                                    args gasForProcessing
                                                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                                if not ext_call.success:
                                                                                    _82776 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_82776] = 40
                                                                                    mem[_82776 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_82776 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                                else:
                                                                                    _81081 = mem[64]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 96
                                                                                    _81894 = mem[_81081 + 32]
                                                                                    _81895 = mem[_81081 + 64]
                                                                                    mem[mem[64]] = mem[_81081]
                                                                                    mem[mem[64] + 64] = _81895
                                                                                    mem[mem[64] + 96] = gasForProcessing
                                                                                    emit ProcessedDividendTracker(mem[mem[64]], _81894, _81895, gasForProcessing, 1, tx.origin);
                                                                                    _84626 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_84626] = 40
                                                                                    mem[_84626 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_84626 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                        else:
                                                                            if stor7:
                                                                                _81503 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_81503] = 40
                                                                                mem[_81503 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_81503 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                     gas gas_remaining wei
                                                                                    args gasForProcessing
                                                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                                if not ext_call.success:
                                                                                    _83226 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_83226] = 40
                                                                                    mem[_83226 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_83226 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                                else:
                                                                                    _81506 = mem[64]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 96
                                                                                    _82310 = mem[_81506 + 32]
                                                                                    _82311 = mem[_81506 + 64]
                                                                                    mem[mem[64]] = mem[_81506]
                                                                                    mem[mem[64] + 64] = _82311
                                                                                    mem[mem[64] + 96] = gasForProcessing
                                                                                    emit ProcessedDividendTracker(mem[mem[64]], _82310, _82311, gasForProcessing, 1, tx.origin);
                                                                                    _85097 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_85097] = 40
                                                                                    mem[_85097 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_85097 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                    else:
                                                                        if not ext_call.success:
                                                                            if stor7:
                                                                                _81507 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_81507] = 40
                                                                                mem[_81507 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_81507 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                     gas gas_remaining wei
                                                                                    args gasForProcessing
                                                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                                if not ext_call.success:
                                                                                    _83229 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_83229] = 40
                                                                                    mem[_83229 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_83229 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                                else:
                                                                                    _81510 = mem[64]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 96
                                                                                    _82314 = mem[_81510 + 32]
                                                                                    _82315 = mem[_81510 + 64]
                                                                                    mem[mem[64]] = mem[_81510]
                                                                                    mem[mem[64] + 64] = _82315
                                                                                    mem[mem[64] + 96] = gasForProcessing
                                                                                    emit ProcessedDividendTracker(mem[mem[64]], _82314, _82315, gasForProcessing, 1, tx.origin);
                                                                                    _85102 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_85102] = 40
                                                                                    mem[_85102 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_85102 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                        else:
                                                                            if stor7:
                                                                                _81896 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_81896] = 40
                                                                                mem[_81896 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_81896 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                     gas gas_remaining wei
                                                                                    args gasForProcessing
                                                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                                if not ext_call.success:
                                                                                    _83692 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_83692] = 40
                                                                                    mem[_83692 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_83692 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                                else:
                                                                                    _81899 = mem[64]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 96
                                                                                    _82783 = mem[_81899 + 32]
                                                                                    _82784 = mem[_81899 + 64]
                                                                                    mem[mem[64]] = mem[_81899]
                                                                                    mem[mem[64] + 64] = _82784
                                                                                    mem[mem[64] + 96] = gasForProcessing
                                                                                    emit ProcessedDividendTracker(mem[mem[64]], _82783, _82784, gasForProcessing, 1, tx.origin);
                                                                                    _85612 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_85612] = 40
                                                                                    mem[_85612 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_85612 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                        else:
                                                            if cd[68] and totalFees > -1 / cd[68]:
                                                                revert with 0, 17
                                                            if not cd[68]:
                                                                revert with 0, 18
                                                            if cd[68] * totalFees / cd[68] != totalFees:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _63184 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_63184] = 26
                                                            mem[_63184 + 32] = 'SafeMath: division by zero'
                                                            mem[0] = address(cd[36])
                                                            mem[32] = 20
                                                            if not stor20[address(cd[36])]:
                                                                _63754 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_63754] = 30
                                                                mem[_63754 + 32] = 'SafeMath: subtraction overflow'
                                                                if cd[68] * totalFees / 100 > cd[68]:
                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                if cd[68] < cd[68] * totalFees / 100:
                                                                    revert with 0, 17
                                                                if not address(cd[4]):
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not this.address:
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                _65794 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_65794] = 38
                                                                mem[_65794 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                if cd[68] * totalFees / 100 > balanceOf[address(cd[4])]:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 38
                                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_65794 + 70 len 26]
                                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                if balanceOf[address(cd[4])] < cd[68] * totalFees / 100:
                                                                    revert with 0, 17
                                                                balanceOf[address(cd[4])] -= cd[68] * totalFees / 100
                                                                if balanceOf[this.address] > !(cd[68] * totalFees / 100):
                                                                    revert with 0, 17
                                                                if balanceOf[this.address] + (cd[68] * totalFees / 100) < balanceOf[this.address]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[0] = this.address
                                                                mem[32] = 0
                                                                balanceOf[address(this.address)] = balanceOf[this.address] + (cd[68] * totalFees / 100)
                                                                emit Transfer((cd[68] * totalFees / 100), address(cd[4]), this.address);
                                                                if not address(cd[4]):
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not address(cd[36]):
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                _72852 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_72852] = 38
                                                                mem[_72852 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                if cd[68] - (cd[68] * totalFees / 100) > balanceOf[address(cd[4])]:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 38
                                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_72852 + 70 len 26]
                                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                if balanceOf[address(cd[4])] < cd[68] - (cd[68] * totalFees / 100):
                                                                    revert with 0, 17
                                                                balanceOf[address(cd[4])] = balanceOf[address(cd[4])] - cd[68] + (cd[68] * totalFees / 100)
                                                                if balanceOf[address(cd[36])] > !(cd[68] - (cd[68] * totalFees / 100)):
                                                                    revert with 0, 17
                                                                if balanceOf[address(cd[36])] + cd[68] - (cd[68] * totalFees / 100) < balanceOf[address(cd[36])]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                balanceOf[address(cd[36])] = balanceOf[address(cd[36])] + cd[68] - (cd[68] * totalFees / 100)
                                                                emit Transfer((cd[68] - (cd[68] * totalFees / 100)), address(cd[4]), address(cd[36]));
                                                                require ext_code.size(dividendTrackerAddress)
                                                                call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                                     gas gas_remaining wei
                                                                    args address(cd[4]), balanceOf[address(cd[4])]
                                                                mem[0] = address(cd[36])
                                                                mem[32] = 0
                                                                require ext_code.size(dividendTrackerAddress)
                                                                call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                                     gas gas_remaining wei
                                                                    args address(cd[36]), balanceOf[address(cd[36])]
                                                                if not ext_call.success:
                                                                    if not ext_call.success:
                                                                        if stor7:
                                                                            _75748 = mem[64]
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_75748] = 40
                                                                            mem[_75748 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[mem[64] + 4] = 32
                                                                                mem[mem[64] + 36] = 40
                                                                                mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_75748 + 72 len 24]
                                                                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                        else:
                                                                            call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                 gas gas_remaining wei
                                                                                args gasForProcessing
                                                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                            if not ext_call.success:
                                                                                _76866 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_76866] = 40
                                                                                mem[_76866 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_76866 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                _75751 = mem[64]
                                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                                require return_data.size >= 96
                                                                                _76238 = mem[_75751 + 32]
                                                                                _76239 = mem[_75751 + 64]
                                                                                mem[mem[64]] = mem[_75751]
                                                                                mem[mem[64] + 64] = _76239
                                                                                mem[mem[64] + 96] = gasForProcessing
                                                                                emit ProcessedDividendTracker(mem[mem[64]], _76238, _76239, gasForProcessing, 1, tx.origin);
                                                                                _78132 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_78132] = 40
                                                                                mem[_78132 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_78132 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                    else:
                                                                        if stor7:
                                                                            _76022 = mem[64]
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_76022] = 40
                                                                            mem[_76022 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[mem[64] + 4] = 32
                                                                                mem[mem[64] + 36] = 40
                                                                                mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_76022 + 72 len 24]
                                                                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                        else:
                                                                            call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                 gas gas_remaining wei
                                                                                args gasForProcessing
                                                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                            if not ext_call.success:
                                                                                _77151 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_77151] = 40
                                                                                mem[_77151 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_77151 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                _76025 = mem[64]
                                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                                require return_data.size >= 96
                                                                                _76521 = mem[_76025 + 32]
                                                                                _76522 = mem[_76025 + 64]
                                                                                mem[mem[64]] = mem[_76025]
                                                                                mem[mem[64] + 64] = _76522
                                                                                mem[mem[64] + 96] = gasForProcessing
                                                                                emit ProcessedDividendTracker(mem[mem[64]], _76521, _76522, gasForProcessing, 1, tx.origin);
                                                                                _78456 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_78456] = 40
                                                                                mem[_78456 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_78456 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                else:
                                                                    if not ext_call.success:
                                                                        if stor7:
                                                                            _76026 = mem[64]
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_76026] = 40
                                                                            mem[_76026 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[mem[64] + 4] = 32
                                                                                mem[mem[64] + 36] = 40
                                                                                mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_76026 + 72 len 24]
                                                                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                        else:
                                                                            call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                 gas gas_remaining wei
                                                                                args gasForProcessing
                                                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                            if not ext_call.success:
                                                                                _77154 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_77154] = 40
                                                                                mem[_77154 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_77154 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                _76029 = mem[64]
                                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                                require return_data.size >= 96
                                                                                _76525 = mem[_76029 + 32]
                                                                                _76526 = mem[_76029 + 64]
                                                                                mem[mem[64]] = mem[_76029]
                                                                                mem[mem[64] + 64] = _76526
                                                                                mem[mem[64] + 96] = gasForProcessing
                                                                                emit ProcessedDividendTracker(mem[mem[64]], _76525, _76526, gasForProcessing, 1, tx.origin);
                                                                                _78461 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_78461] = 40
                                                                                mem[_78461 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_78461 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                    else:
                                                                        if stor7:
                                                                            _76240 = mem[64]
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_76240] = 40
                                                                            mem[_76240 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[mem[64] + 4] = 32
                                                                                mem[mem[64] + 36] = 40
                                                                                mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_76240 + 72 len 24]
                                                                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                        else:
                                                                            call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                 gas gas_remaining wei
                                                                                args gasForProcessing
                                                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                            if not ext_call.success:
                                                                                _77471 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_77471] = 40
                                                                                mem[_77471 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_77471 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                _76243 = mem[64]
                                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                                require return_data.size >= 96
                                                                                _76873 = mem[_76243 + 32]
                                                                                _76874 = mem[_76243 + 64]
                                                                                mem[mem[64]] = mem[_76243]
                                                                                mem[mem[64] + 64] = _76874
                                                                                mem[mem[64] + 96] = gasForProcessing
                                                                                emit ProcessedDividendTracker(mem[mem[64]], _76873, _76874, gasForProcessing, 1, tx.origin);
                                                                                _78827 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_78827] = 40
                                                                                mem[_78827 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_78827 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                            else:
                                                                if not cd[68]:
                                                                    _64120 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_64120] = 26
                                                                    mem[_64120 + 32] = 'SafeMath: division by zero'
                                                                    if cd[68] * totalFees / 100 > -1:
                                                                        revert with 0, 17
                                                                    _68280 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_68280] = 30
                                                                    mem[_68280 + 32] = 'SafeMath: subtraction overflow'
                                                                    if cd[68] * totalFees / 100 > cd[68]:
                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                    if cd[68] < cd[68] * totalFees / 100:
                                                                        revert with 0, 17
                                                                    if not address(cd[4]):
                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                    if not this.address:
                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                    _72322 = mem[64]
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_72322] = 38
                                                                    mem[_72322 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                    if cd[68] * totalFees / 100 > balanceOf[address(cd[4])]:
                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[mem[64] + 4] = 32
                                                                        mem[mem[64] + 36] = 38
                                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_72322 + 70 len 26]
                                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                    if balanceOf[address(cd[4])] < cd[68] * totalFees / 100:
                                                                        revert with 0, 17
                                                                    balanceOf[address(cd[4])] -= cd[68] * totalFees / 100
                                                                    if balanceOf[this.address] > !(cd[68] * totalFees / 100):
                                                                        revert with 0, 17
                                                                    if balanceOf[this.address] + (cd[68] * totalFees / 100) < balanceOf[this.address]:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    mem[0] = this.address
                                                                    mem[32] = 0
                                                                    balanceOf[address(this.address)] = balanceOf[this.address] + (cd[68] * totalFees / 100)
                                                                    emit Transfer((cd[68] * totalFees / 100), address(cd[4]), this.address);
                                                                    if not address(cd[4]):
                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                    if not address(cd[36]):
                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                    _74643 = mem[64]
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_74643] = 38
                                                                    mem[_74643 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                    if cd[68] - (cd[68] * totalFees / 100) > balanceOf[address(cd[4])]:
                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[mem[64] + 4] = 32
                                                                        mem[mem[64] + 36] = 38
                                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_74643 + 70 len 26]
                                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                    if balanceOf[address(cd[4])] < cd[68] - (cd[68] * totalFees / 100):
                                                                        revert with 0, 17
                                                                    balanceOf[address(cd[4])] = balanceOf[address(cd[4])] - cd[68] + (cd[68] * totalFees / 100)
                                                                    if balanceOf[address(cd[36])] > !(cd[68] - (cd[68] * totalFees / 100)):
                                                                        revert with 0, 17
                                                                    if balanceOf[address(cd[36])] + cd[68] - (cd[68] * totalFees / 100) < balanceOf[address(cd[36])]:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    balanceOf[address(cd[36])] = balanceOf[address(cd[36])] + cd[68] - (cd[68] * totalFees / 100)
                                                                    emit Transfer((cd[68] - (cd[68] * totalFees / 100)), address(cd[4]), address(cd[36]));
                                                                    require ext_code.size(dividendTrackerAddress)
                                                                    call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                                         gas gas_remaining wei
                                                                        args address(cd[4]), balanceOf[address(cd[4])]
                                                                    mem[0] = address(cd[36])
                                                                    mem[32] = 0
                                                                    require ext_code.size(dividendTrackerAddress)
                                                                    call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                                         gas gas_remaining wei
                                                                        args address(cd[36]), balanceOf[address(cd[36])]
                                                                    if not ext_call.success:
                                                                        if not ext_call.success:
                                                                            if stor7:
                                                                                _81067 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_81067] = 40
                                                                                mem[_81067 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_81067 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                     gas gas_remaining wei
                                                                                    args gasForProcessing
                                                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                                if not ext_call.success:
                                                                                    _82767 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_82767] = 40
                                                                                    mem[_82767 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_82767 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                                else:
                                                                                    _81070 = mem[64]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 96
                                                                                    _81886 = mem[_81070 + 32]
                                                                                    _81887 = mem[_81070 + 64]
                                                                                    mem[mem[64]] = mem[_81070]
                                                                                    mem[mem[64] + 64] = _81887
                                                                                    mem[mem[64] + 96] = gasForProcessing
                                                                                    emit ProcessedDividendTracker(mem[mem[64]], _81886, _81887, gasForProcessing, 1, tx.origin);
                                                                                    _84616 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_84616] = 40
                                                                                    mem[_84616 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_84616 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                        else:
                                                                            if stor7:
                                                                                _81492 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_81492] = 40
                                                                                mem[_81492 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_81492 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                     gas gas_remaining wei
                                                                                    args gasForProcessing
                                                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                                if not ext_call.success:
                                                                                    _83216 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_83216] = 40
                                                                                    mem[_83216 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_83216 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                                else:
                                                                                    _81495 = mem[64]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 96
                                                                                    _82301 = mem[_81495 + 32]
                                                                                    _82302 = mem[_81495 + 64]
                                                                                    mem[mem[64]] = mem[_81495]
                                                                                    mem[mem[64] + 64] = _82302
                                                                                    mem[mem[64] + 96] = gasForProcessing
                                                                                    emit ProcessedDividendTracker(mem[mem[64]], _82301, _82302, gasForProcessing, 1, tx.origin);
                                                                                    _85079 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_85079] = 40
                                                                                    mem[_85079 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_85079 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                    else:
                                                                        if not ext_call.success:
                                                                            if stor7:
                                                                                _81496 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_81496] = 40
                                                                                mem[_81496 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_81496 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                     gas gas_remaining wei
                                                                                    args gasForProcessing
                                                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                                if not ext_call.success:
                                                                                    _83219 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_83219] = 40
                                                                                    mem[_83219 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_83219 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                                else:
                                                                                    _81499 = mem[64]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 96
                                                                                    _82305 = mem[_81499 + 32]
                                                                                    _82306 = mem[_81499 + 64]
                                                                                    mem[mem[64]] = mem[_81499]
                                                                                    mem[mem[64] + 64] = _82306
                                                                                    mem[mem[64] + 96] = gasForProcessing
                                                                                    emit ProcessedDividendTracker(mem[mem[64]], _82305, _82306, gasForProcessing, 1, tx.origin);
                                                                                    _85084 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_85084] = 40
                                                                                    mem[_85084 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_85084 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                        else:
                                                                            if stor7:
                                                                                _81888 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_81888] = 40
                                                                                mem[_81888 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_81888 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                     gas gas_remaining wei
                                                                                    args gasForProcessing
                                                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                                if not ext_call.success:
                                                                                    _83682 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_83682] = 40
                                                                                    mem[_83682 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_83682 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                                else:
                                                                                    _81891 = mem[64]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 96
                                                                                    _82774 = mem[_81891 + 32]
                                                                                    _82775 = mem[_81891 + 64]
                                                                                    mem[mem[64]] = mem[_81891]
                                                                                    mem[mem[64] + 64] = _82775
                                                                                    mem[mem[64] + 96] = gasForProcessing
                                                                                    emit ProcessedDividendTracker(mem[mem[64]], _82774, _82775, gasForProcessing, 1, tx.origin);
                                                                                    _85592 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_85592] = 40
                                                                                    mem[_85592 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_85592 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                else:
                                                                    if cd[68] and 1 > -1 / cd[68]:
                                                                        revert with 0, 17
                                                                    if not cd[68]:
                                                                        revert with 0, 18
                                                                    if cd[68] / cd[68] != 1:
                                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                                    _65797 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_65797] = 26
                                                                    mem[_65797 + 32] = 'SafeMath: division by zero'
                                                                    if cd[68] * totalFees / 100 > !(cd[68] / 100):
                                                                        revert with 0, 17
                                                                    _70895 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_70895] = 30
                                                                    mem[_70895 + 32] = 'SafeMath: subtraction overflow'
                                                                    if (cd[68] * totalFees / 100) + (cd[68] / 100) > cd[68]:
                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                    if cd[68] < (cd[68] * totalFees / 100) + (cd[68] / 100):
                                                                        revert with 0, 17
                                                                    if not address(cd[4]):
                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                    if not this.address:
                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                    _73414 = mem[64]
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_73414] = 38
                                                                    mem[_73414 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                    if (cd[68] * totalFees / 100) + (cd[68] / 100) > balanceOf[address(cd[4])]:
                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[mem[64] + 4] = 32
                                                                        mem[mem[64] + 36] = 38
                                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_73414 + 70 len 26]
                                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                    if balanceOf[address(cd[4])] < (cd[68] * totalFees / 100) + (cd[68] / 100):
                                                                        revert with 0, 17
                                                                    balanceOf[address(cd[4])] = balanceOf[address(cd[4])] - (cd[68] * totalFees / 100) - (cd[68] / 100)
                                                                    if balanceOf[this.address] > !((cd[68] * totalFees / 100) + (cd[68] / 100)):
                                                                        revert with 0, 17
                                                                    if balanceOf[this.address] + (cd[68] * totalFees / 100) + (cd[68] / 100) < balanceOf[this.address]:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    mem[0] = this.address
                                                                    mem[32] = 0
                                                                    balanceOf[address(this.address)] = balanceOf[this.address] + (cd[68] * totalFees / 100) + (cd[68] / 100)
                                                                    emit Transfer(((cd[68] * totalFees / 100) + (cd[68] / 100)), address(cd[4]), this.address);
                                                                    if not address(cd[4]):
                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                    if not address(cd[36]):
                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                    _75756 = mem[64]
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_75756] = 38
                                                                    mem[_75756 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                    if cd[68] - (cd[68] * totalFees / 100) - (cd[68] / 100) > balanceOf[address(cd[4])]:
                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[mem[64] + 4] = 32
                                                                        mem[mem[64] + 36] = 38
                                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_75756 + 70 len 26]
                                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                    if balanceOf[address(cd[4])] < cd[68] - (cd[68] * totalFees / 100) - (cd[68] / 100):
                                                                        revert with 0, 17
                                                                    balanceOf[address(cd[4])] = balanceOf[address(cd[4])] - cd[68] + (cd[68] * totalFees / 100) + (cd[68] / 100)
                                                                    if balanceOf[address(cd[36])] > !(cd[68] - (cd[68] * totalFees / 100) - (cd[68] / 100)):
                                                                        revert with 0, 17
                                                                    if balanceOf[address(cd[36])] + cd[68] - (cd[68] * totalFees / 100) - (cd[68] / 100) < balanceOf[address(cd[36])]:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    balanceOf[address(cd[36])] = balanceOf[address(cd[36])] + cd[68] - (cd[68] * totalFees / 100) - (cd[68] / 100)
                                                                    emit Transfer((cd[68] - (cd[68] * totalFees / 100) - (cd[68] / 100)), address(cd[4]), address(cd[36]));
                                                                    require ext_code.size(dividendTrackerAddress)
                                                                    call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                                         gas gas_remaining wei
                                                                        args address(cd[4]), balanceOf[address(cd[4])]
                                                                    mem[0] = address(cd[36])
                                                                    mem[32] = 0
                                                                    require ext_code.size(dividendTrackerAddress)
                                                                    call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                                         gas gas_remaining wei
                                                                        args address(cd[36]), balanceOf[address(cd[36])]
                                                                    if not ext_call.success:
                                                                        if not ext_call.success:
                                                                            if stor7:
                                                                                _83667 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_83667] = 40
                                                                                mem[_83667 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_83667 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                     gas gas_remaining wei
                                                                                    args gasForProcessing
                                                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                                if not ext_call.success:
                                                                                    _85566 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_85566] = 40
                                                                                    mem[_85566 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_85566 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                                else:
                                                                                    _83670 = mem[64]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 96
                                                                                    _84608 = mem[_83670 + 32]
                                                                                    _84609 = mem[_83670 + 64]
                                                                                    mem[mem[64]] = mem[_83670]
                                                                                    mem[mem[64] + 64] = _84609
                                                                                    mem[mem[64] + 96] = gasForProcessing
                                                                                    emit ProcessedDividendTracker(mem[mem[64]], _84608, _84609, gasForProcessing, 1, tx.origin);
                                                                                    _87504 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_87504] = 40
                                                                                    mem[_87504 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_87504 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                        else:
                                                                            if stor7:
                                                                                _84161 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_84161] = 40
                                                                                mem[_84161 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_84161 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                     gas gas_remaining wei
                                                                                    args gasForProcessing
                                                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                                if not ext_call.success:
                                                                                    _86049 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_86049] = 40
                                                                                    mem[_86049 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_86049 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                                else:
                                                                                    _84164 = mem[64]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 96
                                                                                    _85065 = mem[_84164 + 32]
                                                                                    _85066 = mem[_84164 + 64]
                                                                                    mem[mem[64]] = mem[_84164]
                                                                                    mem[mem[64] + 64] = _85066
                                                                                    mem[mem[64] + 96] = gasForProcessing
                                                                                    emit ProcessedDividendTracker(mem[mem[64]], _85065, _85066, gasForProcessing, 1, tx.origin);
                                                                                    _87946 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_87946] = 40
                                                                                    mem[_87946 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_87946 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                    else:
                                                                        if not ext_call.success:
                                                                            if stor7:
                                                                                _84165 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_84165] = 40
                                                                                mem[_84165 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_84165 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                     gas gas_remaining wei
                                                                                    args gasForProcessing
                                                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                                if not ext_call.success:
                                                                                    _86052 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_86052] = 40
                                                                                    mem[_86052 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_86052 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                                else:
                                                                                    _84168 = mem[64]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 96
                                                                                    _85069 = mem[_84168 + 32]
                                                                                    _85070 = mem[_84168 + 64]
                                                                                    mem[mem[64]] = mem[_84168]
                                                                                    mem[mem[64] + 64] = _85070
                                                                                    mem[mem[64] + 96] = gasForProcessing
                                                                                    emit ProcessedDividendTracker(mem[mem[64]], _85069, _85070, gasForProcessing, 1, tx.origin);
                                                                                    _87951 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_87951] = 40
                                                                                    mem[_87951 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_87951 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                        else:
                                                                            if stor7:
                                                                                _84610 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_84610] = 40
                                                                                mem[_84610 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_84610 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                     gas gas_remaining wei
                                                                                    args gasForProcessing
                                                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                                if not ext_call.success:
                                                                                    _86537 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_86537] = 40
                                                                                    mem[_86537 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_86537 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                                else:
                                                                                    _84613 = mem[64]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 96
                                                                                    _85573 = mem[_84613 + 32]
                                                                                    _85574 = mem[_84613 + 64]
                                                                                    mem[mem[64]] = mem[_84613]
                                                                                    mem[mem[64] + 64] = _85574
                                                                                    mem[mem[64] + 96] = gasForProcessing
                                                                                    emit ProcessedDividendTracker(mem[mem[64]], _85573, _85574, gasForProcessing, 1, tx.origin);
                                                                                    _88355 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_88355] = 40
                                                                                    mem[_88355 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_88355 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                        else:
                                            require ext_code.size(dividendTrackerAddress)
                                            call dividendTrackerAddress.distributeDogeDividends(uint256 arg1) with:
                                                 gas gas_remaining wei
                                                args _62564
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[mem[64] + 32] = _62564
                                            emit SendDividends(balanceOf[this.address], _62564);
                                            stor7 = 0
                                            mem[0] = address(cd[4])
                                            mem[32] = 19
                                            if stor19[address(cd[4])]:
                                                if not address(cd[4]):
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not address(cd[36]):
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _62868 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_62868] = 38
                                                mem[_62868 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if cd[68] > balanceOf[address(cd[4])]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_62868 + 70 len 26]
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(cd[4])] < cd[68]:
                                                    revert with 0, 17
                                                balanceOf[address(cd[4])] -= cd[68]
                                                if balanceOf[address(cd[36])] > !cd[68]:
                                                    revert with 0, 17
                                                if balanceOf[address(cd[36])] + cd[68] < balanceOf[address(cd[36])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(cd[36])] += cd[68]
                                                emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                                                require ext_code.size(dividendTrackerAddress)
                                                call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args address(cd[4]), balanceOf[address(cd[4])]
                                                mem[0] = address(cd[36])
                                                mem[32] = 0
                                                require ext_code.size(dividendTrackerAddress)
                                                call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args address(cd[36]), balanceOf[address(cd[36])]
                                                if not ext_call.success:
                                                    if not ext_call.success:
                                                        if stor7:
                                                            _65026 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_65026] = 40
                                                            mem[_65026 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 40
                                                                mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_65026 + 72 len 24]
                                                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                        else:
                                                            call dividendTrackerAddress.process(uint256 arg1) with:
                                                                 gas gas_remaining wei
                                                                args gasForProcessing
                                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                            if not ext_call.success:
                                                                _66586 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_66586] = 40
                                                                mem[_66586 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 40
                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_66586 + 72 len 24]
                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                            else:
                                                                _65029 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 96
                                                                _65812 = mem[_65029 + 32]
                                                                _65813 = mem[_65029 + 64]
                                                                mem[mem[64]] = mem[_65029]
                                                                mem[mem[64] + 64] = _65813
                                                                mem[mem[64] + 96] = gasForProcessing
                                                                emit ProcessedDividendTracker(mem[mem[64]], _65812, _65813, gasForProcessing, 1, tx.origin);
                                                                _68307 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_68307] = 40
                                                                mem[_68307 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 40
                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_68307 + 72 len 24]
                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                    else:
                                                        if stor7:
                                                            _65400 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_65400] = 40
                                                            mem[_65400 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 40
                                                                mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_65400 + 72 len 24]
                                                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                        else:
                                                            call dividendTrackerAddress.process(uint256 arg1) with:
                                                                 gas gas_remaining wei
                                                                args gasForProcessing
                                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                            if not ext_call.success:
                                                                _67008 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_67008] = 40
                                                                mem[_67008 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 40
                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_67008 + 72 len 24]
                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                            else:
                                                                _65403 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 96
                                                                _66197 = mem[_65403 + 32]
                                                                _66198 = mem[_65403 + 64]
                                                                mem[mem[64]] = mem[_65403]
                                                                mem[mem[64] + 64] = _66198
                                                                mem[mem[64] + 96] = gasForProcessing
                                                                emit ProcessedDividendTracker(mem[mem[64]], _66197, _66198, gasForProcessing, 1, tx.origin);
                                                                _68737 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_68737] = 40
                                                                mem[_68737 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 40
                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_68737 + 72 len 24]
                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                else:
                                                    if not ext_call.success:
                                                        if stor7:
                                                            _65404 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_65404] = 40
                                                            mem[_65404 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 40
                                                                mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_65404 + 72 len 24]
                                                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                        else:
                                                            call dividendTrackerAddress.process(uint256 arg1) with:
                                                                 gas gas_remaining wei
                                                                args gasForProcessing
                                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                            if not ext_call.success:
                                                                _67011 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_67011] = 40
                                                                mem[_67011 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 40
                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_67011 + 72 len 24]
                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                            else:
                                                                _65407 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 96
                                                                _66201 = mem[_65407 + 32]
                                                                _66202 = mem[_65407 + 64]
                                                                mem[mem[64]] = mem[_65407]
                                                                mem[mem[64] + 64] = _66202
                                                                mem[mem[64] + 96] = gasForProcessing
                                                                emit ProcessedDividendTracker(mem[mem[64]], _66201, _66202, gasForProcessing, 1, tx.origin);
                                                                _68742 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_68742] = 40
                                                                mem[_68742 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 40
                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_68742 + 72 len 24]
                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                    else:
                                                        if stor7:
                                                            _65814 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_65814] = 40
                                                            mem[_65814 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 40
                                                                mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_65814 + 72 len 24]
                                                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                        else:
                                                            call dividendTrackerAddress.process(uint256 arg1) with:
                                                                 gas gas_remaining wei
                                                                args gasForProcessing
                                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                            if not ext_call.success:
                                                                _67443 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_67443] = 40
                                                                mem[_67443 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 40
                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_67443 + 72 len 24]
                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                            else:
                                                                _65817 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 96
                                                                _66593 = mem[_65817 + 32]
                                                                _66594 = mem[_65817 + 64]
                                                                mem[mem[64]] = mem[_65817]
                                                                mem[mem[64] + 64] = _66594
                                                                mem[mem[64] + 96] = gasForProcessing
                                                                emit ProcessedDividendTracker(mem[mem[64]], _66593, _66594, gasForProcessing, 1, tx.origin);
                                                                _69197 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_69197] = 40
                                                                mem[_69197 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 40
                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_69197 + 72 len 24]
                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                            else:
                                                mem[0] = address(cd[36])
                                                mem[32] = 19
                                                if stor19[address(cd[36])]:
                                                    if not address(cd[4]):
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not address(cd[36]):
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _62945 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_62945] = 38
                                                    mem[_62945 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if cd[68] > balanceOf[address(cd[4])]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_62945 + 70 len 26]
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(cd[4])] < cd[68]:
                                                        revert with 0, 17
                                                    balanceOf[address(cd[4])] -= cd[68]
                                                    if balanceOf[address(cd[36])] > !cd[68]:
                                                        revert with 0, 17
                                                    if balanceOf[address(cd[36])] + cd[68] < balanceOf[address(cd[36])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(cd[36])] += cd[68]
                                                    emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                                                    require ext_code.size(dividendTrackerAddress)
                                                    call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args address(cd[4]), balanceOf[address(cd[4])]
                                                    mem[0] = address(cd[36])
                                                    mem[32] = 0
                                                    require ext_code.size(dividendTrackerAddress)
                                                    call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args address(cd[36]), balanceOf[address(cd[36])]
                                                    if not ext_call.success:
                                                        if not ext_call.success:
                                                            if stor7:
                                                                _65422 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_65422] = 40
                                                                mem[_65422 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 40
                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_65422 + 72 len 24]
                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                            else:
                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                     gas gas_remaining wei
                                                                    args gasForProcessing
                                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                if not ext_call.success:
                                                                    _67032 = mem[64]
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_67032] = 40
                                                                    mem[_67032 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[mem[64] + 4] = 32
                                                                        mem[mem[64] + 36] = 40
                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_67032 + 72 len 24]
                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                else:
                                                                    _65425 = mem[64]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 96
                                                                    _66216 = mem[_65425 + 32]
                                                                    _66217 = mem[_65425 + 64]
                                                                    mem[mem[64]] = mem[_65425]
                                                                    mem[mem[64] + 64] = _66217
                                                                    mem[mem[64] + 96] = gasForProcessing
                                                                    emit ProcessedDividendTracker(mem[mem[64]], _66216, _66217, gasForProcessing, 1, tx.origin);
                                                                    _68767 = mem[64]
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_68767] = 40
                                                                    mem[_68767 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[mem[64] + 4] = 32
                                                                        mem[mem[64] + 36] = 40
                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_68767 + 72 len 24]
                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                        else:
                                                            if stor7:
                                                                _65828 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_65828] = 40
                                                                mem[_65828 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 40
                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_65828 + 72 len 24]
                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                            else:
                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                     gas gas_remaining wei
                                                                    args gasForProcessing
                                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                if not ext_call.success:
                                                                    _67461 = mem[64]
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_67461] = 40
                                                                    mem[_67461 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[mem[64] + 4] = 32
                                                                        mem[mem[64] + 36] = 40
                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_67461 + 72 len 24]
                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                else:
                                                                    _65831 = mem[64]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 96
                                                                    _66610 = mem[_65831 + 32]
                                                                    _66611 = mem[_65831 + 64]
                                                                    mem[mem[64]] = mem[_65831]
                                                                    mem[mem[64] + 64] = _66611
                                                                    mem[mem[64] + 96] = gasForProcessing
                                                                    emit ProcessedDividendTracker(mem[mem[64]], _66610, _66611, gasForProcessing, 1, tx.origin);
                                                                    _69231 = mem[64]
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_69231] = 40
                                                                    mem[_69231 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[mem[64] + 4] = 32
                                                                        mem[mem[64] + 36] = 40
                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_69231 + 72 len 24]
                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                    else:
                                                        if not ext_call.success:
                                                            if stor7:
                                                                _65832 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_65832] = 40
                                                                mem[_65832 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 40
                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_65832 + 72 len 24]
                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                            else:
                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                     gas gas_remaining wei
                                                                    args gasForProcessing
                                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                if not ext_call.success:
                                                                    _67464 = mem[64]
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_67464] = 40
                                                                    mem[_67464 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[mem[64] + 4] = 32
                                                                        mem[mem[64] + 36] = 40
                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_67464 + 72 len 24]
                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                else:
                                                                    _65835 = mem[64]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 96
                                                                    _66614 = mem[_65835 + 32]
                                                                    _66615 = mem[_65835 + 64]
                                                                    mem[mem[64]] = mem[_65835]
                                                                    mem[mem[64] + 64] = _66615
                                                                    mem[mem[64] + 96] = gasForProcessing
                                                                    emit ProcessedDividendTracker(mem[mem[64]], _66614, _66615, gasForProcessing, 1, tx.origin);
                                                                    _69236 = mem[64]
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_69236] = 40
                                                                    mem[_69236 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[mem[64] + 4] = 32
                                                                        mem[mem[64] + 36] = 40
                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_69236 + 72 len 24]
                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                        else:
                                                            if stor7:
                                                                _66218 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_66218] = 40
                                                                mem[_66218 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 40
                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_66218 + 72 len 24]
                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                            else:
                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                     gas gas_remaining wei
                                                                    args gasForProcessing
                                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                if not ext_call.success:
                                                                    _67890 = mem[64]
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_67890] = 40
                                                                    mem[_67890 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[mem[64] + 4] = 32
                                                                        mem[mem[64] + 36] = 40
                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_67890 + 72 len 24]
                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                else:
                                                                    _66221 = mem[64]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 96
                                                                    _67039 = mem[_66221 + 32]
                                                                    _67040 = mem[_66221 + 64]
                                                                    mem[mem[64]] = mem[_66221]
                                                                    mem[mem[64] + 64] = _67040
                                                                    mem[mem[64] + 96] = gasForProcessing
                                                                    emit ProcessedDividendTracker(mem[mem[64]], _67039, _67040, gasForProcessing, 1, tx.origin);
                                                                    _69736 = mem[64]
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_69736] = 40
                                                                    mem[_69736 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[mem[64] + 4] = 32
                                                                        mem[mem[64] + 36] = 40
                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_69736 + 72 len 24]
                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                else:
                                                    if stor7:
                                                        if not address(cd[4]):
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not address(cd[36]):
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        _62871 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_62871] = 38
                                                        mem[_62871 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if cd[68] > balanceOf[address(cd[4])]:
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 38
                                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_62871 + 70 len 26]
                                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                        if balanceOf[address(cd[4])] < cd[68]:
                                                            revert with 0, 17
                                                        balanceOf[address(cd[4])] -= cd[68]
                                                        if balanceOf[address(cd[36])] > !cd[68]:
                                                            revert with 0, 17
                                                        if balanceOf[address(cd[36])] + cd[68] < balanceOf[address(cd[36])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(cd[36])] += cd[68]
                                                        emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                                                        require ext_code.size(dividendTrackerAddress)
                                                        call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args address(cd[4]), balanceOf[address(cd[4])]
                                                        mem[0] = address(cd[36])
                                                        mem[32] = 0
                                                        require ext_code.size(dividendTrackerAddress)
                                                        call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args address(cd[36]), balanceOf[address(cd[36])]
                                                        if not ext_call.success:
                                                            if not ext_call.success:
                                                                if stor7:
                                                                    _65034 = mem[64]
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_65034] = 40
                                                                    mem[_65034 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[mem[64] + 4] = 32
                                                                        mem[mem[64] + 36] = 40
                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_65034 + 72 len 24]
                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                else:
                                                                    call dividendTrackerAddress.process(uint256 arg1) with:
                                                                         gas gas_remaining wei
                                                                        args gasForProcessing
                                                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                    if not ext_call.success:
                                                                        _66595 = mem[64]
                                                                        mem[64] = mem[64] + 96
                                                                        mem[_66595] = 40
                                                                        mem[_66595 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                        if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                            mem[mem[64] + 4] = 32
                                                                            mem[mem[64] + 36] = 40
                                                                            mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_66595 + 72 len 24]
                                                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                    else:
                                                                        _65037 = mem[64]
                                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                                        require return_data.size >= 96
                                                                        _65820 = mem[_65037 + 32]
                                                                        _65821 = mem[_65037 + 64]
                                                                        mem[mem[64]] = mem[_65037]
                                                                        mem[mem[64] + 64] = _65821
                                                                        mem[mem[64] + 96] = gasForProcessing
                                                                        emit ProcessedDividendTracker(mem[mem[64]], _65820, _65821, gasForProcessing, 1, tx.origin);
                                                                        _68317 = mem[64]
                                                                        mem[64] = mem[64] + 96
                                                                        mem[_68317] = 40
                                                                        mem[_68317 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                        if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                            mem[mem[64] + 4] = 32
                                                                            mem[mem[64] + 36] = 40
                                                                            mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_68317 + 72 len 24]
                                                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                            else:
                                                                if stor7:
                                                                    _65410 = mem[64]
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_65410] = 40
                                                                    mem[_65410 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[mem[64] + 4] = 32
                                                                        mem[mem[64] + 36] = 40
                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_65410 + 72 len 24]
                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                else:
                                                                    call dividendTrackerAddress.process(uint256 arg1) with:
                                                                         gas gas_remaining wei
                                                                        args gasForProcessing
                                                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                    if not ext_call.success:
                                                                        _67018 = mem[64]
                                                                        mem[64] = mem[64] + 96
                                                                        mem[_67018] = 40
                                                                        mem[_67018 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                        if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                            mem[mem[64] + 4] = 32
                                                                            mem[mem[64] + 36] = 40
                                                                            mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_67018 + 72 len 24]
                                                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                    else:
                                                                        _65413 = mem[64]
                                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                                        require return_data.size >= 96
                                                                        _66206 = mem[_65413 + 32]
                                                                        _66207 = mem[_65413 + 64]
                                                                        mem[mem[64]] = mem[_65413]
                                                                        mem[mem[64] + 64] = _66207
                                                                        mem[mem[64] + 96] = gasForProcessing
                                                                        emit ProcessedDividendTracker(mem[mem[64]], _66206, _66207, gasForProcessing, 1, tx.origin);
                                                                        _68755 = mem[64]
                                                                        mem[64] = mem[64] + 96
                                                                        mem[_68755] = 40
                                                                        mem[_68755 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                        if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                            mem[mem[64] + 4] = 32
                                                                            mem[mem[64] + 36] = 40
                                                                            mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_68755 + 72 len 24]
                                                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                        else:
                                                            if not ext_call.success:
                                                                if stor7:
                                                                    _65414 = mem[64]
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_65414] = 40
                                                                    mem[_65414 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[mem[64] + 4] = 32
                                                                        mem[mem[64] + 36] = 40
                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_65414 + 72 len 24]
                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                else:
                                                                    call dividendTrackerAddress.process(uint256 arg1) with:
                                                                         gas gas_remaining wei
                                                                        args gasForProcessing
                                                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                    if not ext_call.success:
                                                                        _67021 = mem[64]
                                                                        mem[64] = mem[64] + 96
                                                                        mem[_67021] = 40
                                                                        mem[_67021 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                        if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                            mem[mem[64] + 4] = 32
                                                                            mem[mem[64] + 36] = 40
                                                                            mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_67021 + 72 len 24]
                                                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                    else:
                                                                        _65417 = mem[64]
                                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                                        require return_data.size >= 96
                                                                        _66210 = mem[_65417 + 32]
                                                                        _66211 = mem[_65417 + 64]
                                                                        mem[mem[64]] = mem[_65417]
                                                                        mem[mem[64] + 64] = _66211
                                                                        mem[mem[64] + 96] = gasForProcessing
                                                                        emit ProcessedDividendTracker(mem[mem[64]], _66210, _66211, gasForProcessing, 1, tx.origin);
                                                                        _68760 = mem[64]
                                                                        mem[64] = mem[64] + 96
                                                                        mem[_68760] = 40
                                                                        mem[_68760 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                        if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                            mem[mem[64] + 4] = 32
                                                                            mem[mem[64] + 36] = 40
                                                                            mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_68760 + 72 len 24]
                                                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                            else:
                                                                if stor7:
                                                                    _65822 = mem[64]
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_65822] = 40
                                                                    mem[_65822 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[mem[64] + 4] = 32
                                                                        mem[mem[64] + 36] = 40
                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_65822 + 72 len 24]
                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                else:
                                                                    call dividendTrackerAddress.process(uint256 arg1) with:
                                                                         gas gas_remaining wei
                                                                        args gasForProcessing
                                                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                    if not ext_call.success:
                                                                        _67453 = mem[64]
                                                                        mem[64] = mem[64] + 96
                                                                        mem[_67453] = 40
                                                                        mem[_67453 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                        if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                            mem[mem[64] + 4] = 32
                                                                            mem[mem[64] + 36] = 40
                                                                            mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_67453 + 72 len 24]
                                                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                    else:
                                                                        _65825 = mem[64]
                                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                                        require return_data.size >= 96
                                                                        _66602 = mem[_65825 + 32]
                                                                        _66603 = mem[_65825 + 64]
                                                                        mem[mem[64]] = mem[_65825]
                                                                        mem[mem[64] + 64] = _66603
                                                                        mem[mem[64] + 96] = gasForProcessing
                                                                        emit ProcessedDividendTracker(mem[mem[64]], _66602, _66603, gasForProcessing, 1, tx.origin);
                                                                        _69217 = mem[64]
                                                                        mem[64] = mem[64] + 96
                                                                        mem[_69217] = 40
                                                                        mem[_69217 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                        if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                            mem[mem[64] + 4] = 32
                                                                            mem[mem[64] + 36] = 40
                                                                            mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_69217 + 72 len 24]
                                                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                    else:
                                                        if not cd[68]:
                                                            _63000 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_63000] = 26
                                                            mem[_63000 + 32] = 'SafeMath: division by zero'
                                                            mem[0] = address(cd[36])
                                                            mem[32] = 20
                                                            if not stor20[address(cd[36])]:
                                                                _63518 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_63518] = 30
                                                                mem[_63518 + 32] = 'SafeMath: subtraction overflow'
                                                                if 0 > cd[68]:
                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                if cd[68] < 0:
                                                                    revert with 0, 17
                                                                if not address(cd[4]):
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not this.address:
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                _64761 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_64761] = 38
                                                                mem[_64761 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                if 0 > balanceOf[address(cd[4])]:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 38
                                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_64761 + 70 len 26]
                                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                if balanceOf[address(cd[4])] < 0:
                                                                    revert with 0, 17
                                                                if balanceOf[this.address] > -1:
                                                                    revert with 0, 17
                                                                if balanceOf[this.address] < balanceOf[this.address]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[0] = this.address
                                                                mem[32] = 0
                                                                balanceOf[address(this.address)] = balanceOf[this.address]
                                                                emit Transfer(0, address(cd[4]), this.address);
                                                                if not address(cd[4]):
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not address(cd[36]):
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                _72047 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_72047] = 38
                                                                mem[_72047 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                if cd[68] > balanceOf[address(cd[4])]:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 38
                                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_72047 + 70 len 26]
                                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                if balanceOf[address(cd[4])] < cd[68]:
                                                                    revert with 0, 17
                                                                balanceOf[address(cd[4])] -= cd[68]
                                                                if balanceOf[address(cd[36])] > !cd[68]:
                                                                    revert with 0, 17
                                                                if balanceOf[address(cd[36])] + cd[68] < balanceOf[address(cd[36])]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                balanceOf[address(cd[36])] += cd[68]
                                                                emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                                                                require ext_code.size(dividendTrackerAddress)
                                                                call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                                     gas gas_remaining wei
                                                                    args address(cd[4]), balanceOf[address(cd[4])]
                                                                mem[0] = address(cd[36])
                                                                mem[32] = 0
                                                                require ext_code.size(dividendTrackerAddress)
                                                                call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                                     gas gas_remaining wei
                                                                    args address(cd[36]), balanceOf[address(cd[36])]
                                                                if not ext_call.success:
                                                                    if not ext_call.success:
                                                                        if stor7:
                                                                            _75133 = mem[64]
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_75133] = 40
                                                                            mem[_75133 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[mem[64] + 4] = 32
                                                                                mem[mem[64] + 36] = 40
                                                                                mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_75133 + 72 len 24]
                                                                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                        else:
                                                                            call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                 gas gas_remaining wei
                                                                                args gasForProcessing
                                                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                            if not ext_call.success:
                                                                                _76043 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_76043] = 40
                                                                                mem[_76043 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_76043 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                _75136 = mem[64]
                                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                                require return_data.size >= 96
                                                                                _75537 = mem[_75136 + 32]
                                                                                _75538 = mem[_75136 + 64]
                                                                                mem[mem[64]] = mem[_75136]
                                                                                mem[mem[64] + 64] = _75538
                                                                                mem[mem[64] + 96] = gasForProcessing
                                                                                emit ProcessedDividendTracker(mem[mem[64]], _75537, _75538, gasForProcessing, 1, tx.origin);
                                                                                _77189 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_77189] = 40
                                                                                mem[_77189 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_77189 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                    else:
                                                                        if stor7:
                                                                            _75354 = mem[64]
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_75354] = 40
                                                                            mem[_75354 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[mem[64] + 4] = 32
                                                                                mem[mem[64] + 36] = 40
                                                                                mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_75354 + 72 len 24]
                                                                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                        else:
                                                                            call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                 gas gas_remaining wei
                                                                                args gasForProcessing
                                                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                            if not ext_call.success:
                                                                                _76266 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_76266] = 40
                                                                                mem[_76266 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_76266 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                _75357 = mem[64]
                                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                                require return_data.size >= 96
                                                                                _75782 = mem[_75357 + 32]
                                                                                _75783 = mem[_75357 + 64]
                                                                                mem[mem[64]] = mem[_75357]
                                                                                mem[mem[64] + 64] = _75783
                                                                                mem[mem[64] + 96] = gasForProcessing
                                                                                emit ProcessedDividendTracker(mem[mem[64]], _75782, _75783, gasForProcessing, 1, tx.origin);
                                                                                _77513 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_77513] = 40
                                                                                mem[_77513 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_77513 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                else:
                                                                    if not ext_call.success:
                                                                        if stor7:
                                                                            _75358 = mem[64]
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_75358] = 40
                                                                            mem[_75358 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[mem[64] + 4] = 32
                                                                                mem[mem[64] + 36] = 40
                                                                                mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_75358 + 72 len 24]
                                                                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                        else:
                                                                            call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                 gas gas_remaining wei
                                                                                args gasForProcessing
                                                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                            if not ext_call.success:
                                                                                _76269 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_76269] = 40
                                                                                mem[_76269 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_76269 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                _75361 = mem[64]
                                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                                require return_data.size >= 96
                                                                                _75786 = mem[_75361 + 32]
                                                                                _75787 = mem[_75361 + 64]
                                                                                mem[mem[64]] = mem[_75361]
                                                                                mem[mem[64] + 64] = _75787
                                                                                mem[mem[64] + 96] = gasForProcessing
                                                                                emit ProcessedDividendTracker(mem[mem[64]], _75786, _75787, gasForProcessing, 1, tx.origin);
                                                                                _77518 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_77518] = 40
                                                                                mem[_77518 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_77518 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                    else:
                                                                        if stor7:
                                                                            _75539 = mem[64]
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_75539] = 40
                                                                            mem[_75539 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[mem[64] + 4] = 32
                                                                                mem[mem[64] + 36] = 40
                                                                                mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_75539 + 72 len 24]
                                                                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                        else:
                                                                            call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                 gas gas_remaining wei
                                                                                args gasForProcessing
                                                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                            if not ext_call.success:
                                                                                _76568 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_76568] = 40
                                                                                mem[_76568 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_76568 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                _75542 = mem[64]
                                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                                require return_data.size >= 96
                                                                                _76050 = mem[_75542 + 32]
                                                                                _76051 = mem[_75542 + 64]
                                                                                mem[mem[64]] = mem[_75542]
                                                                                mem[mem[64] + 64] = _76051
                                                                                mem[mem[64] + 96] = gasForProcessing
                                                                                emit ProcessedDividendTracker(mem[mem[64]], _76050, _76051, gasForProcessing, 1, tx.origin);
                                                                                _77879 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_77879] = 40
                                                                                mem[_77879 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_77879 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                            else:
                                                                if not cd[68]:
                                                                    _63837 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_63837] = 26
                                                                    mem[_63837 + 32] = 'SafeMath: division by zero'
                                                                    _67031 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_67031] = 30
                                                                    mem[_67031 + 32] = 'SafeMath: subtraction overflow'
                                                                    if 0 > cd[68]:
                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                    if cd[68] < 0:
                                                                        revert with 0, 17
                                                                    if not address(cd[4]):
                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                    if not this.address:
                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                    _71386 = mem[64]
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_71386] = 38
                                                                    mem[_71386 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                    if 0 > balanceOf[address(cd[4])]:
                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[mem[64] + 4] = 32
                                                                        mem[mem[64] + 36] = 38
                                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_71386 + 70 len 26]
                                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                    if balanceOf[address(cd[4])] < 0:
                                                                        revert with 0, 17
                                                                    if balanceOf[this.address] > -1:
                                                                        revert with 0, 17
                                                                    if balanceOf[this.address] < balanceOf[this.address]:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    mem[0] = this.address
                                                                    mem[32] = 0
                                                                    balanceOf[address(this.address)] = balanceOf[this.address]
                                                                    emit Transfer(0, address(cd[4]), this.address);
                                                                    if not address(cd[4]):
                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                    if not address(cd[36]):
                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                    _74324 = mem[64]
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_74324] = 38
                                                                    mem[_74324 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                    if cd[68] > balanceOf[address(cd[4])]:
                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[mem[64] + 4] = 32
                                                                        mem[mem[64] + 36] = 38
                                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_74324 + 70 len 26]
                                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                    if balanceOf[address(cd[4])] < cd[68]:
                                                                        revert with 0, 17
                                                                    balanceOf[address(cd[4])] -= cd[68]
                                                                    if balanceOf[address(cd[36])] > !cd[68]:
                                                                        revert with 0, 17
                                                                    if balanceOf[address(cd[36])] + cd[68] < balanceOf[address(cd[36])]:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    balanceOf[address(cd[36])] += cd[68]
                                                                    emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                                                                    require ext_code.size(dividendTrackerAddress)
                                                                    call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                                         gas gas_remaining wei
                                                                        args address(cd[4]), balanceOf[address(cd[4])]
                                                                    mem[0] = address(cd[36])
                                                                    mem[32] = 0
                                                                    require ext_code.size(dividendTrackerAddress)
                                                                    call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                                         gas gas_remaining wei
                                                                        args address(cd[36]), balanceOf[address(cd[36])]
                                                                    if not ext_call.success:
                                                                        if not ext_call.success:
                                                                            if stor7:
                                                                                _79984 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_79984] = 40
                                                                                mem[_79984 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_79984 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                     gas gas_remaining wei
                                                                                    args gasForProcessing
                                                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                                if not ext_call.success:
                                                                                    _81543 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_81543] = 40
                                                                                    mem[_81543 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_81543 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                                else:
                                                                                    _79987 = mem[64]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 96
                                                                                    _80725 = mem[_79987 + 32]
                                                                                    _80726 = mem[_79987 + 64]
                                                                                    mem[mem[64]] = mem[_79987]
                                                                                    mem[mem[64] + 64] = _80726
                                                                                    mem[mem[64] + 96] = gasForProcessing
                                                                                    emit ProcessedDividendTracker(mem[mem[64]], _80725, _80726, gasForProcessing, 1, tx.origin);
                                                                                    _83285 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_83285] = 40
                                                                                    mem[_83285 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_83285 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                        else:
                                                                            if stor7:
                                                                                _80356 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_80356] = 40
                                                                                mem[_80356 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_80356 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                     gas gas_remaining wei
                                                                                    args gasForProcessing
                                                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                                if not ext_call.success:
                                                                                    _81934 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_81934] = 40
                                                                                    mem[_81934 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_81934 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                                else:
                                                                                    _80359 = mem[64]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 96
                                                                                    _81129 = mem[_80359 + 32]
                                                                                    _81130 = mem[_80359 + 64]
                                                                                    mem[mem[64]] = mem[_80359]
                                                                                    mem[mem[64] + 64] = _81130
                                                                                    mem[mem[64] + 96] = gasForProcessing
                                                                                    emit ProcessedDividendTracker(mem[mem[64]], _81129, _81130, gasForProcessing, 1, tx.origin);
                                                                                    _83743 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_83743] = 40
                                                                                    mem[_83743 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_83743 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                    else:
                                                                        if not ext_call.success:
                                                                            if stor7:
                                                                                _80360 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_80360] = 40
                                                                                mem[_80360 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_80360 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                     gas gas_remaining wei
                                                                                    args gasForProcessing
                                                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                                if not ext_call.success:
                                                                                    _81937 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_81937] = 40
                                                                                    mem[_81937 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_81937 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                                else:
                                                                                    _80363 = mem[64]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 96
                                                                                    _81133 = mem[_80363 + 32]
                                                                                    _81134 = mem[_80363 + 64]
                                                                                    mem[mem[64]] = mem[_80363]
                                                                                    mem[mem[64] + 64] = _81134
                                                                                    mem[mem[64] + 96] = gasForProcessing
                                                                                    emit ProcessedDividendTracker(mem[mem[64]], _81133, _81134, gasForProcessing, 1, tx.origin);
                                                                                    _83748 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_83748] = 40
                                                                                    mem[_83748 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_83748 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                        else:
                                                                            if stor7:
                                                                                _80727 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_80727] = 40
                                                                                mem[_80727 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_80727 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                     gas gas_remaining wei
                                                                                    args gasForProcessing
                                                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                                if not ext_call.success:
                                                                                    _82367 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_82367] = 40
                                                                                    mem[_82367 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_82367 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                                else:
                                                                                    _80730 = mem[64]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 96
                                                                                    _81550 = mem[_80730 + 32]
                                                                                    _81551 = mem[_80730 + 64]
                                                                                    mem[mem[64]] = mem[_80730]
                                                                                    mem[mem[64] + 64] = _81551
                                                                                    mem[mem[64] + 96] = gasForProcessing
                                                                                    emit ProcessedDividendTracker(mem[mem[64]], _81550, _81551, gasForProcessing, 1, tx.origin);
                                                                                    _84238 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_84238] = 40
                                                                                    mem[_84238 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_84238 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                else:
                                                                    if cd[68] and 1 > -1 / cd[68]:
                                                                        revert with 0, 17
                                                                    if not cd[68]:
                                                                        revert with 0, 18
                                                                    if cd[68] / cd[68] != 1:
                                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                                    _64764 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_64764] = 26
                                                                    mem[_64764 + 32] = 'SafeMath: division by zero'
                                                                    if 0 > !(cd[68] / 100):
                                                                        revert with 0, 17
                                                                    _69718 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_69718] = 30
                                                                    mem[_69718 + 32] = 'SafeMath: subtraction overflow'
                                                                    if cd[68] / 100 > cd[68]:
                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                    if cd[68] < cd[68] / 100:
                                                                        revert with 0, 17
                                                                    if not address(cd[4]):
                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                    if not this.address:
                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                    _73043 = mem[64]
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_73043] = 38
                                                                    mem[_73043 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                    if cd[68] / 100 > balanceOf[address(cd[4])]:
                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[mem[64] + 4] = 32
                                                                        mem[mem[64] + 36] = 38
                                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_73043 + 70 len 26]
                                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                    if balanceOf[address(cd[4])] < cd[68] / 100:
                                                                        revert with 0, 17
                                                                    balanceOf[address(cd[4])] -= cd[68] / 100
                                                                    if balanceOf[this.address] > !(cd[68] / 100):
                                                                        revert with 0, 17
                                                                    if balanceOf[this.address] + (cd[68] / 100) < balanceOf[this.address]:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    mem[0] = this.address
                                                                    mem[32] = 0
                                                                    balanceOf[address(this.address)] = balanceOf[this.address] + (cd[68] / 100)
                                                                    emit Transfer((cd[68] / 100), address(cd[4]), this.address);
                                                                    if not address(cd[4]):
                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                    if not address(cd[36]):
                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                    _75141 = mem[64]
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_75141] = 38
                                                                    mem[_75141 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                    if cd[68] - (cd[68] / 100) > balanceOf[address(cd[4])]:
                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[mem[64] + 4] = 32
                                                                        mem[mem[64] + 36] = 38
                                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_75141 + 70 len 26]
                                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                    if balanceOf[address(cd[4])] < cd[68] - (cd[68] / 100):
                                                                        revert with 0, 17
                                                                    balanceOf[address(cd[4])] = balanceOf[address(cd[4])] - cd[68] + (cd[68] / 100)
                                                                    if balanceOf[address(cd[36])] > !(cd[68] - (cd[68] / 100)):
                                                                        revert with 0, 17
                                                                    if balanceOf[address(cd[36])] + cd[68] - (cd[68] / 100) < balanceOf[address(cd[36])]:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    balanceOf[address(cd[36])] = balanceOf[address(cd[36])] + cd[68] - (cd[68] / 100)
                                                                    emit Transfer((cd[68] - (cd[68] / 100)), address(cd[4]), address(cd[36]));
                                                                    require ext_code.size(dividendTrackerAddress)
                                                                    call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                                         gas gas_remaining wei
                                                                        args address(cd[4]), balanceOf[address(cd[4])]
                                                                    mem[0] = address(cd[36])
                                                                    mem[32] = 0
                                                                    require ext_code.size(dividendTrackerAddress)
                                                                    call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                                         gas gas_remaining wei
                                                                        args address(cd[36]), balanceOf[address(cd[36])]
                                                                    if not ext_call.success:
                                                                        if not ext_call.success:
                                                                            if stor7:
                                                                                _82352 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_82352] = 40
                                                                                mem[_82352 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_82352 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                     gas gas_remaining wei
                                                                                    args gasForProcessing
                                                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                                if not ext_call.success:
                                                                                    _84212 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_84212] = 40
                                                                                    mem[_84212 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_84212 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                                else:
                                                                                    _82355 = mem[64]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 96
                                                                                    _83277 = mem[_82355 + 32]
                                                                                    _83278 = mem[_82355 + 64]
                                                                                    mem[mem[64]] = mem[_82355]
                                                                                    mem[mem[64] + 64] = _83278
                                                                                    mem[mem[64] + 96] = gasForProcessing
                                                                                    emit ProcessedDividendTracker(mem[mem[64]], _83277, _83278, gasForProcessing, 1, tx.origin);
                                                                                    _86117 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_86117] = 40
                                                                                    mem[_86117 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_86117 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                        else:
                                                                            if stor7:
                                                                                _82830 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_82830] = 40
                                                                                mem[_82830 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_82830 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                     gas gas_remaining wei
                                                                                    args gasForProcessing
                                                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                                if not ext_call.success:
                                                                                    _84671 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_84671] = 40
                                                                                    mem[_84671 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_84671 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                                else:
                                                                                    _82833 = mem[64]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 96
                                                                                    _83729 = mem[_82833 + 32]
                                                                                    _83730 = mem[_82833 + 64]
                                                                                    mem[mem[64]] = mem[_82833]
                                                                                    mem[mem[64] + 64] = _83730
                                                                                    mem[mem[64] + 96] = gasForProcessing
                                                                                    emit ProcessedDividendTracker(mem[mem[64]], _83729, _83730, gasForProcessing, 1, tx.origin);
                                                                                    _86612 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_86612] = 40
                                                                                    mem[_86612 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_86612 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                    else:
                                                                        if not ext_call.success:
                                                                            if stor7:
                                                                                _82834 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_82834] = 40
                                                                                mem[_82834 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_82834 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                     gas gas_remaining wei
                                                                                    args gasForProcessing
                                                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                                if not ext_call.success:
                                                                                    _84674 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_84674] = 40
                                                                                    mem[_84674 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_84674 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                                else:
                                                                                    _82837 = mem[64]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 96
                                                                                    _83733 = mem[_82837 + 32]
                                                                                    _83734 = mem[_82837 + 64]
                                                                                    mem[mem[64]] = mem[_82837]
                                                                                    mem[mem[64] + 64] = _83734
                                                                                    mem[mem[64] + 96] = gasForProcessing
                                                                                    emit ProcessedDividendTracker(mem[mem[64]], _83733, _83734, gasForProcessing, 1, tx.origin);
                                                                                    _86617 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_86617] = 40
                                                                                    mem[_86617 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_86617 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                        else:
                                                                            if stor7:
                                                                                _83279 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_83279] = 40
                                                                                mem[_83279 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_83279 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                     gas gas_remaining wei
                                                                                    args gasForProcessing
                                                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                                if not ext_call.success:
                                                                                    _85147 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_85147] = 40
                                                                                    mem[_85147 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_85147 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                                else:
                                                                                    _83282 = mem[64]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 96
                                                                                    _84219 = mem[_83282 + 32]
                                                                                    _84220 = mem[_83282 + 64]
                                                                                    mem[mem[64]] = mem[_83282]
                                                                                    mem[mem[64] + 64] = _84220
                                                                                    mem[mem[64] + 96] = gasForProcessing
                                                                                    emit ProcessedDividendTracker(mem[mem[64]], _84219, _84220, gasForProcessing, 1, tx.origin);
                                                                                    _87125 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_87125] = 40
                                                                                    mem[_87125 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_87125 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                        else:
                                                            if cd[68] and totalFees > -1 / cd[68]:
                                                                revert with 0, 17
                                                            if not cd[68]:
                                                                revert with 0, 18
                                                            if cd[68] * totalFees / cd[68] != totalFees:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _63341 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_63341] = 26
                                                            mem[_63341 + 32] = 'SafeMath: division by zero'
                                                            mem[0] = address(cd[36])
                                                            mem[32] = 20
                                                            if not stor20[address(cd[36])]:
                                                                _64041 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_64041] = 30
                                                                mem[_64041 + 32] = 'SafeMath: subtraction overflow'
                                                                if cd[68] * totalFees / 100 > cd[68]:
                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                if cd[68] < cd[68] * totalFees / 100:
                                                                    revert with 0, 17
                                                                if not address(cd[4]):
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not this.address:
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                _67025 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_67025] = 38
                                                                mem[_67025 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                if cd[68] * totalFees / 100 > balanceOf[address(cd[4])]:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 38
                                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_67025 + 70 len 26]
                                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                if balanceOf[address(cd[4])] < cd[68] * totalFees / 100:
                                                                    revert with 0, 17
                                                                balanceOf[address(cd[4])] -= cd[68] * totalFees / 100
                                                                if balanceOf[this.address] > !(cd[68] * totalFees / 100):
                                                                    revert with 0, 17
                                                                if balanceOf[this.address] + (cd[68] * totalFees / 100) < balanceOf[this.address]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[0] = this.address
                                                                mem[32] = 0
                                                                balanceOf[address(this.address)] = balanceOf[this.address] + (cd[68] * totalFees / 100)
                                                                emit Transfer((cd[68] * totalFees / 100), address(cd[4]), this.address);
                                                                if not address(cd[4]):
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not address(cd[36]):
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                _73289 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_73289] = 38
                                                                mem[_73289 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                if cd[68] - (cd[68] * totalFees / 100) > balanceOf[address(cd[4])]:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 38
                                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_73289 + 70 len 26]
                                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                if balanceOf[address(cd[4])] < cd[68] - (cd[68] * totalFees / 100):
                                                                    revert with 0, 17
                                                                balanceOf[address(cd[4])] = balanceOf[address(cd[4])] - cd[68] + (cd[68] * totalFees / 100)
                                                                if balanceOf[address(cd[36])] > !(cd[68] - (cd[68] * totalFees / 100)):
                                                                    revert with 0, 17
                                                                if balanceOf[address(cd[36])] + cd[68] - (cd[68] * totalFees / 100) < balanceOf[address(cd[36])]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                balanceOf[address(cd[36])] = balanceOf[address(cd[36])] + cd[68] - (cd[68] * totalFees / 100)
                                                                emit Transfer((cd[68] - (cd[68] * totalFees / 100)), address(cd[4]), address(cd[36]));
                                                                require ext_code.size(dividendTrackerAddress)
                                                                call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                                     gas gas_remaining wei
                                                                    args address(cd[4]), balanceOf[address(cd[4])]
                                                                mem[0] = address(cd[36])
                                                                mem[32] = 0
                                                                require ext_code.size(dividendTrackerAddress)
                                                                call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                                     gas gas_remaining wei
                                                                    args address(cd[36]), balanceOf[address(cd[36])]
                                                                if not ext_call.success:
                                                                    if not ext_call.success:
                                                                        if stor7:
                                                                            _76548 = mem[64]
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_76548] = 40
                                                                            mem[_76548 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[mem[64] + 4] = 32
                                                                                mem[mem[64] + 36] = 40
                                                                                mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_76548 + 72 len 24]
                                                                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                        else:
                                                                            call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                 gas gas_remaining wei
                                                                                args gasForProcessing
                                                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                            if not ext_call.success:
                                                                                _77853 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_77853] = 40
                                                                                mem[_77853 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_77853 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                _76551 = mem[64]
                                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                                require return_data.size >= 96
                                                                                _77178 = mem[_76551 + 32]
                                                                                _77179 = mem[_76551 + 64]
                                                                                mem[mem[64]] = mem[_76551]
                                                                                mem[mem[64] + 64] = _77179
                                                                                mem[mem[64] + 96] = gasForProcessing
                                                                                emit ProcessedDividendTracker(mem[mem[64]], _77178, _77179, gasForProcessing, 1, tx.origin);
                                                                                _79188 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_79188] = 40
                                                                                mem[_79188 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_79188 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                    else:
                                                                        if stor7:
                                                                            _76895 = mem[64]
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_76895] = 40
                                                                            mem[_76895 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[mem[64] + 4] = 32
                                                                                mem[mem[64] + 36] = 40
                                                                                mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_76895 + 72 len 24]
                                                                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                        else:
                                                                            call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                 gas gas_remaining wei
                                                                                args gasForProcessing
                                                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                            if not ext_call.success:
                                                                                _78165 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_78165] = 40
                                                                                mem[_78165 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_78165 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                _76898 = mem[64]
                                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                                require return_data.size >= 96
                                                                                _77498 = mem[_76898 + 32]
                                                                                _77499 = mem[_76898 + 64]
                                                                                mem[mem[64]] = mem[_76898]
                                                                                mem[mem[64] + 64] = _77499
                                                                                mem[mem[64] + 96] = gasForProcessing
                                                                                emit ProcessedDividendTracker(mem[mem[64]], _77498, _77499, gasForProcessing, 1, tx.origin);
                                                                                _79566 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_79566] = 40
                                                                                mem[_79566 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_79566 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                else:
                                                                    if not ext_call.success:
                                                                        if stor7:
                                                                            _76899 = mem[64]
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_76899] = 40
                                                                            mem[_76899 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[mem[64] + 4] = 32
                                                                                mem[mem[64] + 36] = 40
                                                                                mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_76899 + 72 len 24]
                                                                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                        else:
                                                                            call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                 gas gas_remaining wei
                                                                                args gasForProcessing
                                                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                            if not ext_call.success:
                                                                                _78168 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_78168] = 40
                                                                                mem[_78168 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_78168 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                _76902 = mem[64]
                                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                                require return_data.size >= 96
                                                                                _77502 = mem[_76902 + 32]
                                                                                _77503 = mem[_76902 + 64]
                                                                                mem[mem[64]] = mem[_76902]
                                                                                mem[mem[64] + 64] = _77503
                                                                                mem[mem[64] + 96] = gasForProcessing
                                                                                emit ProcessedDividendTracker(mem[mem[64]], _77502, _77503, gasForProcessing, 1, tx.origin);
                                                                                _79571 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_79571] = 40
                                                                                mem[_79571 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_79571 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                    else:
                                                                        if stor7:
                                                                            _77180 = mem[64]
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_77180] = 40
                                                                            mem[_77180 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[mem[64] + 4] = 32
                                                                                mem[mem[64] + 36] = 40
                                                                                mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_77180 + 72 len 24]
                                                                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                        else:
                                                                            call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                 gas gas_remaining wei
                                                                                args gasForProcessing
                                                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                            if not ext_call.success:
                                                                                _78491 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_78491] = 40
                                                                                mem[_78491 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_78491 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                _77183 = mem[64]
                                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                                require return_data.size >= 96
                                                                                _77860 = mem[_77183 + 32]
                                                                                _77861 = mem[_77183 + 64]
                                                                                mem[mem[64]] = mem[_77183]
                                                                                mem[mem[64] + 64] = _77861
                                                                                mem[mem[64] + 96] = gasForProcessing
                                                                                emit ProcessedDividendTracker(mem[mem[64]], _77860, _77861, gasForProcessing, 1, tx.origin);
                                                                                _79974 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_79974] = 40
                                                                                mem[_79974 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_79974 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                            else:
                                                                if not cd[68]:
                                                                    _64760 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_64760] = 26
                                                                    mem[_64760 + 32] = 'SafeMath: division by zero'
                                                                    if cd[68] * totalFees / 100 > -1:
                                                                        revert with 0, 17
                                                                    _69714 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_69714] = 30
                                                                    mem[_69714 + 32] = 'SafeMath: subtraction overflow'
                                                                    if cd[68] * totalFees / 100 > cd[68]:
                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                    if cd[68] < cd[68] * totalFees / 100:
                                                                        revert with 0, 17
                                                                    if not address(cd[4]):
                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                    if not this.address:
                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                    _73040 = mem[64]
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_73040] = 38
                                                                    mem[_73040 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                    if cd[68] * totalFees / 100 > balanceOf[address(cd[4])]:
                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[mem[64] + 4] = 32
                                                                        mem[mem[64] + 36] = 38
                                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_73040 + 70 len 26]
                                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                    if balanceOf[address(cd[4])] < cd[68] * totalFees / 100:
                                                                        revert with 0, 17
                                                                    balanceOf[address(cd[4])] -= cd[68] * totalFees / 100
                                                                    if balanceOf[this.address] > !(cd[68] * totalFees / 100):
                                                                        revert with 0, 17
                                                                    if balanceOf[this.address] + (cd[68] * totalFees / 100) < balanceOf[this.address]:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    mem[0] = this.address
                                                                    mem[32] = 0
                                                                    balanceOf[address(this.address)] = balanceOf[this.address] + (cd[68] * totalFees / 100)
                                                                    emit Transfer((cd[68] * totalFees / 100), address(cd[4]), this.address);
                                                                    if not address(cd[4]):
                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                    if not address(cd[36]):
                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                    _75130 = mem[64]
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_75130] = 38
                                                                    mem[_75130 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                    if cd[68] - (cd[68] * totalFees / 100) > balanceOf[address(cd[4])]:
                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[mem[64] + 4] = 32
                                                                        mem[mem[64] + 36] = 38
                                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_75130 + 70 len 26]
                                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                    if balanceOf[address(cd[4])] < cd[68] - (cd[68] * totalFees / 100):
                                                                        revert with 0, 17
                                                                    balanceOf[address(cd[4])] = balanceOf[address(cd[4])] - cd[68] + (cd[68] * totalFees / 100)
                                                                    if balanceOf[address(cd[36])] > !(cd[68] - (cd[68] * totalFees / 100)):
                                                                        revert with 0, 17
                                                                    if balanceOf[address(cd[36])] + cd[68] - (cd[68] * totalFees / 100) < balanceOf[address(cd[36])]:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    balanceOf[address(cd[36])] = balanceOf[address(cd[36])] + cd[68] - (cd[68] * totalFees / 100)
                                                                    emit Transfer((cd[68] - (cd[68] * totalFees / 100)), address(cd[4]), address(cd[36]));
                                                                    require ext_code.size(dividendTrackerAddress)
                                                                    call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                                         gas gas_remaining wei
                                                                        args address(cd[4]), balanceOf[address(cd[4])]
                                                                    mem[0] = address(cd[36])
                                                                    mem[32] = 0
                                                                    require ext_code.size(dividendTrackerAddress)
                                                                    call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                                         gas gas_remaining wei
                                                                        args address(cd[36]), balanceOf[address(cd[36])]
                                                                    if not ext_call.success:
                                                                        if not ext_call.success:
                                                                            if stor7:
                                                                                _82341 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_82341] = 40
                                                                                mem[_82341 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_82341 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                     gas gas_remaining wei
                                                                                    args gasForProcessing
                                                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                                if not ext_call.success:
                                                                                    _84203 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_84203] = 40
                                                                                    mem[_84203 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_84203 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                                else:
                                                                                    _82344 = mem[64]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 96
                                                                                    _83269 = mem[_82344 + 32]
                                                                                    _83270 = mem[_82344 + 64]
                                                                                    mem[mem[64]] = mem[_82344]
                                                                                    mem[mem[64] + 64] = _83270
                                                                                    mem[mem[64] + 96] = gasForProcessing
                                                                                    emit ProcessedDividendTracker(mem[mem[64]], _83269, _83270, gasForProcessing, 1, tx.origin);
                                                                                    _86107 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_86107] = 40
                                                                                    mem[_86107 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_86107 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                        else:
                                                                            if stor7:
                                                                                _82819 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_82819] = 40
                                                                                mem[_82819 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_82819 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                     gas gas_remaining wei
                                                                                    args gasForProcessing
                                                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                                if not ext_call.success:
                                                                                    _84661 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_84661] = 40
                                                                                    mem[_84661 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_84661 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                                else:
                                                                                    _82822 = mem[64]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 96
                                                                                    _83720 = mem[_82822 + 32]
                                                                                    _83721 = mem[_82822 + 64]
                                                                                    mem[mem[64]] = mem[_82822]
                                                                                    mem[mem[64] + 64] = _83721
                                                                                    mem[mem[64] + 96] = gasForProcessing
                                                                                    emit ProcessedDividendTracker(mem[mem[64]], _83720, _83721, gasForProcessing, 1, tx.origin);
                                                                                    _86594 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_86594] = 40
                                                                                    mem[_86594 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_86594 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                    else:
                                                                        if not ext_call.success:
                                                                            if stor7:
                                                                                _82823 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_82823] = 40
                                                                                mem[_82823 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_82823 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                     gas gas_remaining wei
                                                                                    args gasForProcessing
                                                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                                if not ext_call.success:
                                                                                    _84664 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_84664] = 40
                                                                                    mem[_84664 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_84664 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                                else:
                                                                                    _82826 = mem[64]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 96
                                                                                    _83724 = mem[_82826 + 32]
                                                                                    _83725 = mem[_82826 + 64]
                                                                                    mem[mem[64]] = mem[_82826]
                                                                                    mem[mem[64] + 64] = _83725
                                                                                    mem[mem[64] + 96] = gasForProcessing
                                                                                    emit ProcessedDividendTracker(mem[mem[64]], _83724, _83725, gasForProcessing, 1, tx.origin);
                                                                                    _86599 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_86599] = 40
                                                                                    mem[_86599 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_86599 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                        else:
                                                                            if stor7:
                                                                                _83271 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_83271] = 40
                                                                                mem[_83271 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_83271 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                     gas gas_remaining wei
                                                                                    args gasForProcessing
                                                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                                if not ext_call.success:
                                                                                    _85137 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_85137] = 40
                                                                                    mem[_85137 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_85137 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                                else:
                                                                                    _83274 = mem[64]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 96
                                                                                    _84210 = mem[_83274 + 32]
                                                                                    _84211 = mem[_83274 + 64]
                                                                                    mem[mem[64]] = mem[_83274]
                                                                                    mem[mem[64] + 64] = _84211
                                                                                    mem[mem[64] + 96] = gasForProcessing
                                                                                    emit ProcessedDividendTracker(mem[mem[64]], _84210, _84211, gasForProcessing, 1, tx.origin);
                                                                                    _87105 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_87105] = 40
                                                                                    mem[_87105 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_87105 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                else:
                                                                    if cd[68] and 1 > -1 / cd[68]:
                                                                        revert with 0, 17
                                                                    if not cd[68]:
                                                                        revert with 0, 18
                                                                    if cd[68] / cd[68] != 1:
                                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                                    _67028 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_67028] = 26
                                                                    mem[_67028 + 32] = 'SafeMath: division by zero'
                                                                    if cd[68] * totalFees / 100 > !(cd[68] / 100):
                                                                        revert with 0, 17
                                                                    _72046 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_72046] = 30
                                                                    mem[_72046 + 32] = 'SafeMath: subtraction overflow'
                                                                    if (cd[68] * totalFees / 100) + (cd[68] / 100) > cd[68]:
                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                    if cd[68] < (cd[68] * totalFees / 100) + (cd[68] / 100):
                                                                        revert with 0, 17
                                                                    if not address(cd[4]):
                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                    if not this.address:
                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                    _73727 = mem[64]
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_73727] = 38
                                                                    mem[_73727 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                    if (cd[68] * totalFees / 100) + (cd[68] / 100) > balanceOf[address(cd[4])]:
                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[mem[64] + 4] = 32
                                                                        mem[mem[64] + 36] = 38
                                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_73727 + 70 len 26]
                                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                    if balanceOf[address(cd[4])] < (cd[68] * totalFees / 100) + (cd[68] / 100):
                                                                        revert with 0, 17
                                                                    balanceOf[address(cd[4])] = balanceOf[address(cd[4])] - (cd[68] * totalFees / 100) - (cd[68] / 100)
                                                                    if balanceOf[this.address] > !((cd[68] * totalFees / 100) + (cd[68] / 100)):
                                                                        revert with 0, 17
                                                                    if balanceOf[this.address] + (cd[68] * totalFees / 100) + (cd[68] / 100) < balanceOf[this.address]:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    mem[0] = this.address
                                                                    mem[32] = 0
                                                                    balanceOf[address(this.address)] = balanceOf[this.address] + (cd[68] * totalFees / 100) + (cd[68] / 100)
                                                                    emit Transfer(((cd[68] * totalFees / 100) + (cd[68] / 100)), address(cd[4]), this.address);
                                                                    if not address(cd[4]):
                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                    if not address(cd[36]):
                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                    _76556 = mem[64]
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_76556] = 38
                                                                    mem[_76556 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                    if cd[68] - (cd[68] * totalFees / 100) - (cd[68] / 100) > balanceOf[address(cd[4])]:
                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[mem[64] + 4] = 32
                                                                        mem[mem[64] + 36] = 38
                                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_76556 + 70 len 26]
                                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                    if balanceOf[address(cd[4])] < cd[68] - (cd[68] * totalFees / 100) - (cd[68] / 100):
                                                                        revert with 0, 17
                                                                    balanceOf[address(cd[4])] = balanceOf[address(cd[4])] - cd[68] + (cd[68] * totalFees / 100) + (cd[68] / 100)
                                                                    if balanceOf[address(cd[36])] > !(cd[68] - (cd[68] * totalFees / 100) - (cd[68] / 100)):
                                                                        revert with 0, 17
                                                                    if balanceOf[address(cd[36])] + cd[68] - (cd[68] * totalFees / 100) - (cd[68] / 100) < balanceOf[address(cd[36])]:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    balanceOf[address(cd[36])] = balanceOf[address(cd[36])] + cd[68] - (cd[68] * totalFees / 100) - (cd[68] / 100)
                                                                    emit Transfer((cd[68] - (cd[68] * totalFees / 100) - (cd[68] / 100)), address(cd[4]), address(cd[36]));
                                                                    require ext_code.size(dividendTrackerAddress)
                                                                    call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                                         gas gas_remaining wei
                                                                        args address(cd[4]), balanceOf[address(cd[4])]
                                                                    mem[0] = address(cd[36])
                                                                    mem[32] = 0
                                                                    require ext_code.size(dividendTrackerAddress)
                                                                    call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                                         gas gas_remaining wei
                                                                        args address(cd[36]), balanceOf[address(cd[36])]
                                                                    if not ext_call.success:
                                                                        if not ext_call.success:
                                                                            if stor7:
                                                                                _85122 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_85122] = 40
                                                                                mem[_85122 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_85122 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                     gas gas_remaining wei
                                                                                    args gasForProcessing
                                                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                                if not ext_call.success:
                                                                                    _87079 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_87079] = 40
                                                                                    mem[_87079 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_87079 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                                else:
                                                                                    _85125 = mem[64]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 96
                                                                                    _86099 = mem[_85125 + 32]
                                                                                    _86100 = mem[_85125 + 64]
                                                                                    mem[mem[64]] = mem[_85125]
                                                                                    mem[mem[64] + 64] = _86100
                                                                                    mem[mem[64] + 96] = gasForProcessing
                                                                                    emit ProcessedDividendTracker(mem[mem[64]], _86099, _86100, gasForProcessing, 1, tx.origin);
                                                                                    _88765 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_88765] = 40
                                                                                    mem[_88765 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_88765 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                        else:
                                                                            if stor7:
                                                                                _85623 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_85623] = 40
                                                                                mem[_85623 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_85623 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                     gas gas_remaining wei
                                                                                    args gasForProcessing
                                                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                                if not ext_call.success:
                                                                                    _87556 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_87556] = 40
                                                                                    mem[_87556 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_87556 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                                else:
                                                                                    _85626 = mem[64]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 96
                                                                                    _86580 = mem[_85626 + 32]
                                                                                    _86581 = mem[_85626 + 64]
                                                                                    mem[mem[64]] = mem[_85626]
                                                                                    mem[mem[64] + 64] = _86581
                                                                                    mem[mem[64] + 96] = gasForProcessing
                                                                                    emit ProcessedDividendTracker(mem[mem[64]], _86580, _86581, gasForProcessing, 1, tx.origin);
                                                                                    _89160 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_89160] = 40
                                                                                    mem[_89160 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_89160 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                    else:
                                                                        if not ext_call.success:
                                                                            if stor7:
                                                                                _85627 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_85627] = 40
                                                                                mem[_85627 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_85627 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                     gas gas_remaining wei
                                                                                    args gasForProcessing
                                                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                                if not ext_call.success:
                                                                                    _87559 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_87559] = 40
                                                                                    mem[_87559 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_87559 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                                else:
                                                                                    _85630 = mem[64]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 96
                                                                                    _86584 = mem[_85630 + 32]
                                                                                    _86585 = mem[_85630 + 64]
                                                                                    mem[mem[64]] = mem[_85630]
                                                                                    mem[mem[64] + 64] = _86585
                                                                                    mem[mem[64] + 96] = gasForProcessing
                                                                                    emit ProcessedDividendTracker(mem[mem[64]], _86584, _86585, gasForProcessing, 1, tx.origin);
                                                                                    _89165 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_89165] = 40
                                                                                    mem[_89165 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_89165 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                        else:
                                                                            if stor7:
                                                                                _86101 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_86101] = 40
                                                                                mem[_86101 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_86101 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                     gas gas_remaining wei
                                                                                    args gasForProcessing
                                                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                                if not ext_call.success:
                                                                                    _87990 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_87990] = 40
                                                                                    mem[_87990 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_87990 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                                else:
                                                                                    _86104 = mem[64]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 96
                                                                                    _87086 = mem[_86104 + 32]
                                                                                    _87087 = mem[_86104 + 64]
                                                                                    mem[mem[64]] = mem[_86104]
                                                                                    mem[mem[64] + 64] = _87087
                                                                                    mem[mem[64] + 96] = gasForProcessing
                                                                                    emit ProcessedDividendTracker(mem[mem[64]], _87086, _87087, gasForProcessing, 1, tx.origin);
                                                                                    _89498 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_89498] = 40
                                                                                    mem[_89498 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_89498 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    if balanceOf[this.address] and stor15 > -1 / balanceOf[this.address]:
                                        revert with 0, 17
                                    if not balanceOf[this.address]:
                                        revert with 0, 18
                                    if balanceOf[this.address] * stor15 / balanceOf[this.address] != stor15:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    mem[128] = 26
                                    mem[160] = 'SafeMath: division by zero'
                                    if not totalFees:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    mem[196] = this.address
                                    staticcall sub_4d7effddAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[192] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    mem[ceil32(return_data.size) + 192] = 3
                                    mem[ceil32(return_data.size) + 224] = this.address
                                    staticcall uniswapV2RouterAddress.WETH() with:
                                            gas gas_remaining wei
                                    mem[ceil32(return_data.size) + 320] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[64] = (2 * ceil32(return_data.size)) + 320
                                    require return_data.size >= 32
                                    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                    mem[ceil32(return_data.size) + 256] = ext_call.return_data[12 len 20]
                                    mem[ceil32(return_data.size) + 288] = sub_4d7effddAddress
                                    if not this.address:
                                        mem[(2 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[(2 * ceil32(return_data.size)) + 324] = 32
                                        mem[(2 * ceil32(return_data.size)) + 356] = 36
                                        mem[(2 * ceil32(return_data.size)) + 388] = 'ERC20: approve from the zero add'
                                        mem[(2 * ceil32(return_data.size)) + 420] = 0x7265737300000000000000000000000000000000000000000000000000000000
                                        revert with memory
                                          from (2 * ceil32(return_data.size)) + 320
                                           len ceil32(return_data.size) + 132
                                    if not uniswapV2RouterAddress:
                                        mem[(2 * ceil32(return_data.size)) + 320] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[(2 * ceil32(return_data.size)) + 324] = 32
                                        mem[(2 * ceil32(return_data.size)) + 356] = 34
                                        mem[(2 * ceil32(return_data.size)) + 388] = 'ERC20: approve to the zero addre'
                                        mem[(2 * ceil32(return_data.size)) + 420] = 0x7373000000000000000000000000000000000000000000000000000000000000
                                        revert with memory
                                          from (2 * ceil32(return_data.size)) + 320
                                           len ceil32(return_data.size) + 132
                                    mem[0] = uniswapV2RouterAddress
                                    mem[32] = sha3(address(this.address), 1)
                                    allowance[address(this.address)][stor6].field_0 = balanceOf[this.address] * stor15 / totalFees
                                    mem[(2 * ceil32(return_data.size)) + 320] = balanceOf[this.address] * stor15 / totalFees
                                    emit Approval(mem[(2 * ceil32(return_data.size)) + 320 len ceil32(return_data.size) + 32], this.address, uniswapV2RouterAddress);
                                    mem[(2 * ceil32(return_data.size)) + 320] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                    mem[(2 * ceil32(return_data.size)) + 324] = balanceOf[this.address] * stor15 / totalFees
                                    mem[(2 * ceil32(return_data.size)) + 356] = 0
                                    mem[(2 * ceil32(return_data.size)) + 388] = 160
                                    mem[(2 * ceil32(return_data.size)) + 484] = 3
                                    idx = 0
                                    s = (2 * ceil32(return_data.size)) + 516
                                    t = ceil32(return_data.size) + 224
                                    while idx < mem[ceil32(return_data.size) + 192]:
                                        mem[s] = mem[t + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[(2 * ceil32(return_data.size)) + 420] = this.address
                                    mem[(2 * ceil32(return_data.size)) + 452] = block.timestamp
                                    require ext_code.size(uniswapV2RouterAddress)
                                    call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                         gas gas_remaining wei
                                        args mem[mem[64] + 4 len (2 * ceil32(return_data.size)) + -mem[64] + 608]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[mem[64] + 4] = this.address
                                    staticcall sub_4d7effddAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    mem[mem[64]] = ext_call.return_data[0]
                                    _21380 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    _21392 = mem[_21380]
                                    _21409 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21409] = 30
                                    mem[_21409 + 32] = 'SafeMath: subtraction overflow'
                                    if ext_call.return_data[0] > _21392:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if _21392 < ext_call.return_data[0]:
                                        revert with 0, 17
                                    mem[mem[64] + 4] = stor17
                                    mem[mem[64] + 36] = _21392 - ext_call.return_data[0]
                                    call sub_4d7effddAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args stor17, _21392 - ext_call.return_data[0]
                                    mem[mem[64]] = ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _21437 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 32
                                    require mem[_21437] == bool(mem[_21437])
                                    if not balanceOf[this.address]:
                                        _21449 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_21449] = 26
                                        mem[_21449 + 32] = 'SafeMath: division by zero'
                                        if not totalFees:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        _21490 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_21490] = 26
                                        mem[_21490 + 32] = 'SafeMath: division by zero'
                                        _21513 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_21513] = 30
                                        mem[_21513 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 / totalFees / 2 > 0 / totalFees:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if 0 / totalFees < 0 / totalFees / 2:
                                            revert with 0, 17
                                        _21538 = mem[64]
                                        mem[mem[64]] = 2
                                        mem[64] = mem[64] + 96
                                        mem[_21538 + 32 len 64] = call.data[calldata.size len 64]
                                        if 0 >= mem[_21538]:
                                            revert with 0, 50
                                        mem[_21538 + 32] = this.address
                                        staticcall uniswapV2RouterAddress.WETH() with:
                                                gas gas_remaining wei
                                        mem[_21538 + 96] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = _21538 + ceil32(return_data.size) + 96
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                        if 1 >= mem[_21538]:
                                            revert with 0, 50
                                        mem[_21538 + 64] = ext_call.return_data[12 len 20]
                                        if not this.address:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not uniswapV2RouterAddress:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        mem[0] = uniswapV2RouterAddress
                                        mem[32] = sha3(address(this.address), 1)
                                        allowance[address(this.address)][stor6].field_0 = 0 / totalFees / 2
                                        allowance[address(this.address)][stor6].field_255 = 0
                                        emit Approval((0 / totalFees / 2), this.address, uniswapV2RouterAddress);
                                        mem[_21538 + ceil32(return_data.size) + 96] = 0x791ac94700000000000000000000000000000000000000000000000000000000
                                        mem[_21538 + ceil32(return_data.size) + 100] = 0 / totalFees / 2
                                        mem[_21538 + ceil32(return_data.size) + 132] = 0
                                        mem[_21538 + ceil32(return_data.size) + 164] = 160
                                        mem[_21538 + ceil32(return_data.size) + 260] = mem[_21538]
                                        idx = 0
                                        s = _21538 + ceil32(return_data.size) + 292
                                        t = _21538 + 32
                                        while idx < mem[_21538]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        require ext_code.size(uniswapV2RouterAddress)
                                        call uniswapV2RouterAddress.swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args Mask(255, 1, 0 / totalFees), 0, 160, address(this.address), block.timestamp, mem[_21538 + ceil32(return_data.size) + 260 len (32 * mem[_21538]) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[_21538 + ceil32(return_data.size) + 96] = 30
                                        mem[_21538 + ceil32(return_data.size) + 128] = 'SafeMath: subtraction overflow'
                                        if eth.balance(this.address) > eth.balance(this.address):
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if eth.balance(this.address) < eth.balance(this.address):
                                            revert with 0, 17
                                        if not this.address:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not uniswapV2RouterAddress:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(this.address)][stor6].field_0 = (0 / totalFees) - (0 / totalFees / 2)
                                        emit Approval(((0 / totalFees) - (0 / totalFees / 2)), this.address, uniswapV2RouterAddress);
                                        mem[_21538 + ceil32(return_data.size) + 228] = 0
                                        mem[_21538 + ceil32(return_data.size) + 260] = 0
                                        mem[_21538 + ceil32(return_data.size) + 292] = stor17
                                        mem[_21538 + ceil32(return_data.size) + 324] = block.timestamp
                                        call uniswapV2RouterAddress.addLiquidityETH(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                             gas gas_remaining wei
                                            args this.address, (0 / totalFees) - (0 / totalFees / 2), 0, 0, stor17, block.timestamp
                                        mem[_21538 + ceil32(return_data.size) + 160 len 96] = ext_call.return_data[0 len 96]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 96
                                        emit SwapAndLiquify(Mask(255, 1, 0 / totalFees), 0, (0 / totalFees) - (0 / totalFees / 2));
                                        mem[_21538 + (2 * ceil32(return_data.size)) + 160] = 3
                                        mem[_21538 + (2 * ceil32(return_data.size)) + 192] = this.address
                                        staticcall uniswapV2RouterAddress.WETH() with:
                                                gas gas_remaining wei
                                        mem[_21538 + (2 * ceil32(return_data.size)) + 288] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                        mem[_21538 + (2 * ceil32(return_data.size)) + 224] = ext_call.return_data[12 len 20]
                                        mem[_21538 + (2 * ceil32(return_data.size)) + 256] = sub_4d7effddAddress
                                        if not this.address:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not uniswapV2RouterAddress:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(this.address)][stor6].field_0 = balanceOf[this.address]
                                        emit Approval(balanceOf[this.address], this.address, uniswapV2RouterAddress);
                                        mem[_21538 + (4 * ceil32(return_data.size)) + 288] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                        mem[_21538 + (4 * ceil32(return_data.size)) + 292] = balanceOf[this.address]
                                        mem[_21538 + (4 * ceil32(return_data.size)) + 324] = 0
                                        mem[_21538 + (4 * ceil32(return_data.size)) + 356] = 160
                                        mem[_21538 + (4 * ceil32(return_data.size)) + 452] = 3
                                        idx = 0
                                        s = _21538 + (4 * ceil32(return_data.size)) + 484
                                        t = _21538 + (2 * ceil32(return_data.size)) + 192
                                        while idx < mem[_21538 + (2 * ceil32(return_data.size)) + 160]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_21538 + (4 * ceil32(return_data.size)) + 388] = this.address
                                        mem[_21538 + (4 * ceil32(return_data.size)) + 420] = block.timestamp
                                        require ext_code.size(uniswapV2RouterAddress)
                                        call uniswapV2RouterAddress.swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 arg1, uint256 arg2, address[] arg3, address arg4, uint256 arg5) with:
                                             gas gas_remaining wei
                                            args balanceOf[this.address], 0, 160, address(this.address), block.timestamp, mem[_21538 + (4 * ceil32(return_data.size)) + 452 len (32 * mem[_21538 + (2 * ceil32(return_data.size)) + 160]) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        staticcall sub_4d7effddAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        require return_data.size >= 32
                                        call sub_4d7effddAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args dividendTrackerAddress, ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == bool(ext_call.return_data[0])
                                        if ext_call.return_data[0]:
                                            require ext_code.size(dividendTrackerAddress)
                                            call dividendTrackerAddress.distributeDogeDividends(uint256 arg1) with:
                                                 gas gas_remaining wei
                                                args ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            emit SendDividends(balanceOf[this.address], ext_call.return_data[0]);
                                        stor7 = 0
                                        if stor19[address(cd[4])]:
                                            if not address(cd[4]):
                                                revert with 0, 'ERC20: transfer from the zero address'
                                            if not address(cd[36]):
                                                revert with 0, 'ERC20: transfer to the zero address'
                                            if cd[68] > balanceOf[address(cd[4])]:
                                                revert with 0, 
                                                            32,
                                                            38,
                                                            0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_21538 + (7 * ceil32(return_data.size)) + 358 len 26] >> 48,
                                                            0
                                            if balanceOf[address(cd[4])] < cd[68]:
                                                revert with 0, 17
                                            balanceOf[address(cd[4])] -= cd[68]
                                            if balanceOf[address(cd[36])] > !cd[68]:
                                                revert with 0, 17
                                            if balanceOf[address(cd[36])] + cd[68] < balanceOf[address(cd[36])]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(cd[36])] += cd[68]
                                            emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                                            require ext_code.size(dividendTrackerAddress)
                                            call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args address(cd[4]), balanceOf[address(cd[4])]
                                            require ext_code.size(dividendTrackerAddress)
                                            call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                 gas gas_remaining wei
                                                args address(cd[36]), balanceOf[address(cd[36])]
                                            if stor7:
                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                    revert with 0, 
                                                                32,
                                                                40,
                                                                0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_21538 + (7 * ceil32(return_data.size)) + 456 len 24] >> 64,
                                                                0
                                            else:
                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                     gas gas_remaining wei
                                                    args gasForProcessing
                                                if not ext_call.success:
                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                        revert with 0, 
                                                                    32,
                                                                    40,
                                                                    0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, ext_call.return_data[72 len 24] >> 64,
                                                                    0
                                                else:
                                                    require return_data.size >= 96
                                                    emit ProcessedDividendTracker(ext_call.return_data[0], ext_call.return_data[32], ext_call.return_data[64], gasForProcessing, 1, tx.origin);
                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                        revert with 0, 
                                                                    32,
                                                                    40,
                                                                    0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, Mask(192, 0, ext_call.return_data[64]) >> 64,
                                                                    0
                                        else:
                                            if stor19[address(cd[36])]:
                                                if not address(cd[4]):
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not address(cd[36]):
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                if cd[68] > balanceOf[address(cd[4])]:
                                                    revert with 0, 
                                                                32,
                                                                38,
                                                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_21538 + (7 * ceil32(return_data.size)) + 358 len 26] >> 48,
                                                                0
                                                if balanceOf[address(cd[4])] < cd[68]:
                                                    revert with 0, 17
                                                balanceOf[address(cd[4])] -= cd[68]
                                                if balanceOf[address(cd[36])] > !cd[68]:
                                                    revert with 0, 17
                                                if balanceOf[address(cd[36])] + cd[68] < balanceOf[address(cd[36])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(cd[36])] += cd[68]
                                                emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                                                require ext_code.size(dividendTrackerAddress)
                                                call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args address(cd[4]), balanceOf[address(cd[4])]
                                                require ext_code.size(dividendTrackerAddress)
                                                call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args address(cd[36]), balanceOf[address(cd[36])]
                                                if stor7:
                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                        revert with 0, 
                                                                    32,
                                                                    40,
                                                                    0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_21538 + (7 * ceil32(return_data.size)) + 456 len 24] >> 64,
                                                                    0
                                                else:
                                                    call dividendTrackerAddress.process(uint256 arg1) with:
                                                         gas gas_remaining wei
                                                        args gasForProcessing
                                                    if not ext_call.success:
                                                        if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                            revert with 0, 
                                                                        32,
                                                                        40,
                                                                        0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, ext_call.return_data[72 len 24] >> 64,
                                                                        0
                                                    else:
                                                        require return_data.size >= 96
                                                        emit ProcessedDividendTracker(ext_call.return_data[0], ext_call.return_data[32], ext_call.return_data[64], gasForProcessing, 1, tx.origin);
                                                        if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                            revert with 0, 
                                                                        32,
                                                                        40,
                                                                        0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, Mask(192, 0, ext_call.return_data[64]) >> 64,
                                                                        0
                                            else:
                                                if stor7:
                                                    if not address(cd[4]):
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not address(cd[36]):
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    if cd[68] > balanceOf[address(cd[4])]:
                                                        revert with 0, 
                                                                    32,
                                                                    38,
                                                                    0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_21538 + (7 * ceil32(return_data.size)) + 358 len 26] >> 48,
                                                                    0
                                                    if balanceOf[address(cd[4])] < cd[68]:
                                                        revert with 0, 17
                                                    balanceOf[address(cd[4])] -= cd[68]
                                                    if balanceOf[address(cd[36])] > !cd[68]:
                                                        revert with 0, 17
                                                    if balanceOf[address(cd[36])] + cd[68] < balanceOf[address(cd[36])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(cd[36])] += cd[68]
                                                    emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                                                    require ext_code.size(dividendTrackerAddress)
                                                    call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args address(cd[4]), balanceOf[address(cd[4])]
                                                    require ext_code.size(dividendTrackerAddress)
                                                    call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args address(cd[36]), balanceOf[address(cd[36])]
                                                    if stor7:
                                                        if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                            revert with 0, 
                                                                        32,
                                                                        40,
                                                                        0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_21538 + (7 * ceil32(return_data.size)) + 456 len 24] >> 64,
                                                                        0
                                                    else:
                                                        call dividendTrackerAddress.process(uint256 arg1) with:
                                                             gas gas_remaining wei
                                                            args gasForProcessing
                                                        if not ext_call.success:
                                                            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                revert with 0, 
                                                                            32,
                                                                            40,
                                                                            0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, ext_call.return_data[72 len 24] >> 64,
                                                                            0
                                                        else:
                                                            require return_data.size >= 96
                                                            emit ProcessedDividendTracker(ext_call.return_data[0], ext_call.return_data[32], ext_call.return_data[64], gasForProcessing, 1, tx.origin);
                                                            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                revert with 0, 
                                                                            32,
                                                                            40,
                                                                            0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, Mask(192, 0, ext_call.return_data[64]) >> 64,
                                                                            0
                                                else:
                                                    if not cd[68]:
                                                        if not stor20[address(cd[36])]:
                                                            if 0 > cd[68]:
                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                            if cd[68] < 0:
                                                                revert with 0, 17
                                                            if not address(cd[4]):
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not this.address:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            if 0 > balanceOf[address(cd[4])]:
                                                                revert with 0, 
                                                                            32,
                                                                            38,
                                                                            0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_21538 + (7 * ceil32(return_data.size)) + 486 len 26] >> 48,
                                                                            0
                                                            if balanceOf[address(cd[4])] < 0:
                                                                revert with 0, 17
                                                            if balanceOf[this.address] > -1:
                                                                revert with 0, 17
                                                            if balanceOf[this.address] < balanceOf[this.address]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            balanceOf[address(this.address)] = balanceOf[this.address]
                                                            emit Transfer(0, address(cd[4]), this.address);
                                                            if not address(cd[4]):
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not address(cd[36]):
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            if cd[68] > balanceOf[address(cd[4])]:
                                                                revert with 0, 
                                                                            32,
                                                                            38,
                                                                            0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_21538 + (7 * ceil32(return_data.size)) + 582 len 26] >> 48,
                                                                            0
                                                            if balanceOf[address(cd[4])] < cd[68]:
                                                                revert with 0, 17
                                                            balanceOf[address(cd[4])] -= cd[68]
                                                            if balanceOf[address(cd[36])] > !cd[68]:
                                                                revert with 0, 17
                                                            if balanceOf[address(cd[36])] + cd[68] < balanceOf[address(cd[36])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            balanceOf[address(cd[36])] += cd[68]
                                                            emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                                                            require ext_code.size(dividendTrackerAddress)
                                                            call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                                 gas gas_remaining wei
                                                                args address(cd[4]), balanceOf[address(cd[4])]
                                                            require ext_code.size(dividendTrackerAddress)
                                                            call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                                 gas gas_remaining wei
                                                                args address(cd[36]), balanceOf[address(cd[36])]
                                                            if stor7:
                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                    revert with 0, 
                                                                                32,
                                                                                40,
                                                                                0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_21538 + (7 * ceil32(return_data.size)) + 680 len 24] >> 64,
                                                                                0
                                                            else:
                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                     gas gas_remaining wei
                                                                    args gasForProcessing
                                                                if not ext_call.success:
                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    40,
                                                                                    0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, ext_call.return_data[72 len 24] >> 64,
                                                                                    0
                                                                else:
                                                                    require return_data.size >= 96
                                                                    emit ProcessedDividendTracker(ext_call.return_data[0], ext_call.return_data[32], ext_call.return_data[64], gasForProcessing, 1, tx.origin);
                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    40,
                                                                                    0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, Mask(192, 0, ext_call.return_data[64]) >> 64,
                                                                                    0
                                                        else:
                                                            if not cd[68]:
                                                                if 0 > cd[68]:
                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                if cd[68] < 0:
                                                                    revert with 0, 17
                                                                if not address(cd[4]):
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not this.address:
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                if 0 > balanceOf[address(cd[4])]:
                                                                    revert with 0, 
                                                                                32,
                                                                                38,
                                                                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_21538 + (7 * ceil32(return_data.size)) + 550 len 26] >> 48,
                                                                                0
                                                                if balanceOf[address(cd[4])] < 0:
                                                                    revert with 0, 17
                                                                if balanceOf[this.address] > -1:
                                                                    revert with 0, 17
                                                                if balanceOf[this.address] < balanceOf[this.address]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                balanceOf[address(this.address)] = balanceOf[this.address]
                                                                emit Transfer(0, address(cd[4]), this.address);
                                                                if not address(cd[4]):
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not address(cd[36]):
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                if cd[68] > balanceOf[address(cd[4])]:
                                                                    revert with 0, 
                                                                                32,
                                                                                38,
                                                                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_21538 + (7 * ceil32(return_data.size)) + 646 len 26] >> 48,
                                                                                0
                                                                if balanceOf[address(cd[4])] < cd[68]:
                                                                    revert with 0, 17
                                                                balanceOf[address(cd[4])] -= cd[68]
                                                                if balanceOf[address(cd[36])] > !cd[68]:
                                                                    revert with 0, 17
                                                                if balanceOf[address(cd[36])] + cd[68] < balanceOf[address(cd[36])]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                balanceOf[address(cd[36])] += cd[68]
                                                                emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                                                            else:
                                                                if cd[68] and 1 > -1 / cd[68]:
                                                                    revert with 0, 17
                                                                if not cd[68]:
                                                                    revert with 0, 18
                                                                if cd[68] / cd[68] != 1:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if 0 > !(cd[68] / 100):
                                                                    revert with 0, 17
                                                                if cd[68] / 100 > cd[68]:
                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                if cd[68] < cd[68] / 100:
                                                                    revert with 0, 17
                                                                if not address(cd[4]):
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not this.address:
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                if cd[68] / 100 > balanceOf[address(cd[4])]:
                                                                    revert with 0, 
                                                                                32,
                                                                                38,
                                                                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_21538 + (7 * ceil32(return_data.size)) + 550 len 26] >> 48,
                                                                                0
                                                                if balanceOf[address(cd[4])] < cd[68] / 100:
                                                                    revert with 0, 17
                                                                balanceOf[address(cd[4])] -= cd[68] / 100
                                                                if balanceOf[this.address] > !(cd[68] / 100):
                                                                    revert with 0, 17
                                                                if balanceOf[this.address] + (cd[68] / 100) < balanceOf[this.address]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                balanceOf[address(this.address)] = balanceOf[this.address] + (cd[68] / 100)
                                                                emit Transfer((cd[68] / 100), address(cd[4]), this.address);
                                                                if not address(cd[4]):
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not address(cd[36]):
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                if cd[68] - (cd[68] / 100) > balanceOf[address(cd[4])]:
                                                                    revert with 0, 
                                                                                32,
                                                                                38,
                                                                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_21538 + (7 * ceil32(return_data.size)) + 646 len 26] >> 48,
                                                                                0
                                                                if balanceOf[address(cd[4])] < cd[68] - (cd[68] / 100):
                                                                    revert with 0, 17
                                                                balanceOf[address(cd[4])] = balanceOf[address(cd[4])] - cd[68] + (cd[68] / 100)
                                                                if balanceOf[address(cd[36])] > !(cd[68] - (cd[68] / 100)):
                                                                    revert with 0, 17
                                                                if balanceOf[address(cd[36])] + cd[68] - (cd[68] / 100) < balanceOf[address(cd[36])]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                balanceOf[address(cd[36])] = balanceOf[address(cd[36])] + cd[68] - (cd[68] / 100)
                                                                emit Transfer((cd[68] - (cd[68] / 100)), address(cd[4]), address(cd[36]));
                                                            require ext_code.size(dividendTrackerAddress)
                                                            call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                                 gas gas_remaining wei
                                                                args address(cd[4]), balanceOf[address(cd[4])]
                                                            require ext_code.size(dividendTrackerAddress)
                                                            call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                                 gas gas_remaining wei
                                                                args address(cd[36]), balanceOf[address(cd[36])]
                                                            if stor7:
                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                    revert with 0, 
                                                                                32,
                                                                                40,
                                                                                0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_21538 + (7 * ceil32(return_data.size)) + 744 len 24] >> 64,
                                                                                0
                                                            else:
                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                     gas gas_remaining wei
                                                                    args gasForProcessing
                                                                if not ext_call.success:
                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    40,
                                                                                    0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, ext_call.return_data[72 len 24] >> 64,
                                                                                    0
                                                                else:
                                                                    require return_data.size >= 96
                                                                    emit ProcessedDividendTracker(ext_call.return_data[0], ext_call.return_data[32], ext_call.return_data[64], gasForProcessing, 1, tx.origin);
                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    40,
                                                                                    0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, Mask(192, 0, ext_call.return_data[64]) >> 64,
                                                                                    0
                                                    else:
                                                        if cd[68] and totalFees > -1 / cd[68]:
                                                            revert with 0, 17
                                                        if not cd[68]:
                                                            revert with 0, 18
                                                        if cd[68] * totalFees / cd[68] != totalFees:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not stor20[address(cd[36])]:
                                                            if cd[68] * totalFees / 100 > cd[68]:
                                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                                            if cd[68] < cd[68] * totalFees / 100:
                                                                revert with 0, 17
                                                            if not address(cd[4]):
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not this.address:
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            if cd[68] * totalFees / 100 > balanceOf[address(cd[4])]:
                                                                revert with 0, 
                                                                            32,
                                                                            38,
                                                                            0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_21538 + (7 * ceil32(return_data.size)) + 486 len 26] >> 48,
                                                                            0
                                                            if balanceOf[address(cd[4])] < cd[68] * totalFees / 100:
                                                                revert with 0, 17
                                                            balanceOf[address(cd[4])] -= cd[68] * totalFees / 100
                                                            if balanceOf[this.address] > !(cd[68] * totalFees / 100):
                                                                revert with 0, 17
                                                            if balanceOf[this.address] + (cd[68] * totalFees / 100) < balanceOf[this.address]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            balanceOf[address(this.address)] = balanceOf[this.address] + (cd[68] * totalFees / 100)
                                                            emit Transfer((cd[68] * totalFees / 100), address(cd[4]), this.address);
                                                            if not address(cd[4]):
                                                                revert with 0, 'ERC20: transfer from the zero address'
                                                            if not address(cd[36]):
                                                                revert with 0, 'ERC20: transfer to the zero address'
                                                            if cd[68] - (cd[68] * totalFees / 100) > balanceOf[address(cd[4])]:
                                                                revert with 0, 
                                                                            32,
                                                                            38,
                                                                            0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_21538 + (7 * ceil32(return_data.size)) + 582 len 26] >> 48,
                                                                            0
                                                            if balanceOf[address(cd[4])] < cd[68] - (cd[68] * totalFees / 100):
                                                                revert with 0, 17
                                                            balanceOf[address(cd[4])] = balanceOf[address(cd[4])] - cd[68] + (cd[68] * totalFees / 100)
                                                            if balanceOf[address(cd[36])] > !(cd[68] - (cd[68] * totalFees / 100)):
                                                                revert with 0, 17
                                                            if balanceOf[address(cd[36])] + cd[68] - (cd[68] * totalFees / 100) < balanceOf[address(cd[36])]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            balanceOf[address(cd[36])] = balanceOf[address(cd[36])] + cd[68] - (cd[68] * totalFees / 100)
                                                            emit Transfer((cd[68] - (cd[68] * totalFees / 100)), address(cd[4]), address(cd[36]));
                                                            require ext_code.size(dividendTrackerAddress)
                                                            call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                                 gas gas_remaining wei
                                                                args address(cd[4]), balanceOf[address(cd[4])]
                                                            require ext_code.size(dividendTrackerAddress)
                                                            call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                                 gas gas_remaining wei
                                                                args address(cd[36]), balanceOf[address(cd[36])]
                                                            if stor7:
                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                    revert with 0, 
                                                                                32,
                                                                                40,
                                                                                0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_21538 + (7 * ceil32(return_data.size)) + 680 len 24] >> 64,
                                                                                0
                                                            else:
                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                     gas gas_remaining wei
                                                                    args gasForProcessing
                                                                if not ext_call.success:
                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    40,
                                                                                    0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, ext_call.return_data[72 len 24] >> 64,
                                                                                    0
                                                                else:
                                                                    require return_data.size >= 96
                                                                    emit ProcessedDividendTracker(ext_call.return_data[0], ext_call.return_data[32], ext_call.return_data[64], gasForProcessing, 1, tx.origin);
                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    40,
                                                                                    0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, Mask(192, 0, ext_call.return_data[64]) >> 64,
                                                                                    0
                                                        else:
                                                            if not cd[68]:
                                                                if cd[68] * totalFees / 100 > -1:
                                                                    revert with 0, 17
                                                                if cd[68] * totalFees / 100 > cd[68]:
                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                if cd[68] < cd[68] * totalFees / 100:
                                                                    revert with 0, 17
                                                                if not address(cd[4]):
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not this.address:
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                if cd[68] * totalFees / 100 > balanceOf[address(cd[4])]:
                                                                    revert with 0, 
                                                                                32,
                                                                                38,
                                                                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_21538 + (7 * ceil32(return_data.size)) + 550 len 26] >> 48,
                                                                                0
                                                                if balanceOf[address(cd[4])] < cd[68] * totalFees / 100:
                                                                    revert with 0, 17
                                                                balanceOf[address(cd[4])] -= cd[68] * totalFees / 100
                                                                if balanceOf[this.address] > !(cd[68] * totalFees / 100):
                                                                    revert with 0, 17
                                                                if balanceOf[this.address] + (cd[68] * totalFees / 100) < balanceOf[this.address]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                balanceOf[address(this.address)] = balanceOf[this.address] + (cd[68] * totalFees / 100)
                                                                emit Transfer((cd[68] * totalFees / 100), address(cd[4]), this.address);
                                                                if not address(cd[4]):
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not address(cd[36]):
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                if cd[68] - (cd[68] * totalFees / 100) > balanceOf[address(cd[4])]:
                                                                    revert with 0, 
                                                                                32,
                                                                                38,
                                                                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_21538 + (7 * ceil32(return_data.size)) + 646 len 26] >> 48,
                                                                                0
                                                                if balanceOf[address(cd[4])] < cd[68] - (cd[68] * totalFees / 100):
                                                                    revert with 0, 17
                                                                balanceOf[address(cd[4])] = balanceOf[address(cd[4])] - cd[68] + (cd[68] * totalFees / 100)
                                                                if balanceOf[address(cd[36])] > !(cd[68] - (cd[68] * totalFees / 100)):
                                                                    revert with 0, 17
                                                                if balanceOf[address(cd[36])] + cd[68] - (cd[68] * totalFees / 100) < balanceOf[address(cd[36])]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                balanceOf[address(cd[36])] = balanceOf[address(cd[36])] + cd[68] - (cd[68] * totalFees / 100)
                                                                emit Transfer((cd[68] - (cd[68] * totalFees / 100)), address(cd[4]), address(cd[36]));
                                                            else:
                                                                if cd[68] and 1 > -1 / cd[68]:
                                                                    revert with 0, 17
                                                                if not cd[68]:
                                                                    revert with 0, 18
                                                                if cd[68] / cd[68] != 1:
                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                if cd[68] * totalFees / 100 > !(cd[68] / 100):
                                                                    revert with 0, 17
                                                                if (cd[68] * totalFees / 100) + (cd[68] / 100) > cd[68]:
                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                if cd[68] < (cd[68] * totalFees / 100) + (cd[68] / 100):
                                                                    revert with 0, 17
                                                                if not address(cd[4]):
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not this.address:
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                if (cd[68] * totalFees / 100) + (cd[68] / 100) > balanceOf[address(cd[4])]:
                                                                    revert with 0, 
                                                                                32,
                                                                                38,
                                                                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_21538 + (7 * ceil32(return_data.size)) + 550 len 26] >> 48,
                                                                                0
                                                                if balanceOf[address(cd[4])] < (cd[68] * totalFees / 100) + (cd[68] / 100):
                                                                    revert with 0, 17
                                                                balanceOf[address(cd[4])] = balanceOf[address(cd[4])] - (cd[68] * totalFees / 100) - (cd[68] / 100)
                                                                if balanceOf[this.address] > !((cd[68] * totalFees / 100) + (cd[68] / 100)):
                                                                    revert with 0, 17
                                                                if balanceOf[this.address] + (cd[68] * totalFees / 100) + (cd[68] / 100) < balanceOf[this.address]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                balanceOf[address(this.address)] = balanceOf[this.address] + (cd[68] * totalFees / 100) + (cd[68] / 100)
                                                                emit Transfer(((cd[68] * totalFees / 100) + (cd[68] / 100)), address(cd[4]), this.address);
                                                                if not address(cd[4]):
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not address(cd[36]):
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                if cd[68] - (cd[68] * totalFees / 100) - (cd[68] / 100) > balanceOf[address(cd[4])]:
                                                                    revert with 0, 
                                                                                32,
                                                                                38,
                                                                                0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_21538 + (7 * ceil32(return_data.size)) + 646 len 26] >> 48,
                                                                                0
                                                                if balanceOf[address(cd[4])] < cd[68] - (cd[68] * totalFees / 100) - (cd[68] / 100):
                                                                    revert with 0, 17
                                                                balanceOf[address(cd[4])] = balanceOf[address(cd[4])] - cd[68] + (cd[68] * totalFees / 100) + (cd[68] / 100)
                                                                if balanceOf[address(cd[36])] > !(cd[68] - (cd[68] * totalFees / 100) - (cd[68] / 100)):
                                                                    revert with 0, 17
                                                                if balanceOf[address(cd[36])] + cd[68] - (cd[68] * totalFees / 100) - (cd[68] / 100) < balanceOf[address(cd[36])]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                balanceOf[address(cd[36])] = balanceOf[address(cd[36])] + cd[68] - (cd[68] * totalFees / 100) - (cd[68] / 100)
                                                                emit Transfer((cd[68] - (cd[68] * totalFees / 100) - (cd[68] / 100)), address(cd[4]), address(cd[36]));
                                                            require ext_code.size(dividendTrackerAddress)
                                                            call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                                 gas gas_remaining wei
                                                                args address(cd[4]), balanceOf[address(cd[4])]
                                                            require ext_code.size(dividendTrackerAddress)
                                                            call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                                 gas gas_remaining wei
                                                                args address(cd[36]), balanceOf[address(cd[36])]
                                                            if stor7:
                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                    revert with 0, 
                                                                                32,
                                                                                40,
                                                                                0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_21538 + (7 * ceil32(return_data.size)) + 744 len 24] >> 64,
                                                                                0
                                                            else:
                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                     gas gas_remaining wei
                                                                    args gasForProcessing
                                                                if not ext_call.success:
                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    40,
                                                                                    0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, ext_call.return_data[72 len 24] >> 64,
                                                                                    0
                                                                else:
                                                                    require return_data.size >= 96
                                                                    emit ProcessedDividendTracker(ext_call.return_data[0], ext_call.return_data[32], ext_call.return_data[64], gasForProcessing, 1, tx.origin);
                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                        revert with 0, 
                                                                                    32,
                                                                                    40,
                                                                                    0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, Mask(192, 0, ext_call.return_data[64]) >> 64,
                                                                                    0
                                    else:
                                        if balanceOf[this.address] and stor14 > -1 / balanceOf[this.address]:
                                            revert with 0, 17
                                        if not balanceOf[this.address]:
                                            revert with 0, 18
                                        if balanceOf[this.address] * stor14 / balanceOf[this.address] != stor14:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _21473 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_21473] = 26
                                        mem[_21473 + 32] = 'SafeMath: division by zero'
                                        if not totalFees:
                                            revert with 0, 'SafeMath: division by zero', 0
                                        _21509 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_21509] = 26
                                        mem[_21509 + 32] = 'SafeMath: division by zero'
                                        _21529 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_21529] = 30
                                        mem[_21529 + 32] = 'SafeMath: subtraction overflow'
                                        if balanceOf[this.address] * stor14 / totalFees / 2 > balanceOf[this.address] * stor14 / totalFees:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if balanceOf[this.address] * stor14 / totalFees < balanceOf[this.address] * stor14 / totalFees / 2:
                                            revert with 0, 17
                                        _21581 = mem[64]
                                        mem[mem[64]] = 2
                                        mem[64] = mem[64] + 96
                                        mem[_21581 + 32 len 64] = call.data[calldata.size len 64]
                                        if 0 >= mem[_21581]:
                                            revert with 0, 50
                                        mem[_21581 + 32] = this.address
                                        staticcall uniswapV2RouterAddress.WETH() with:
                                                gas gas_remaining wei
                                        mem[_21581 + 96] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = _21581 + ceil32(return_data.size) + 96
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                        if 1 >= mem[_21581]:
                                            revert with 0, 50
                                        mem[_21581 + 64] = ext_call.return_data[12 len 20]
                                        if not this.address:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not uniswapV2RouterAddress:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        mem[0] = uniswapV2RouterAddress
                                        mem[32] = sha3(address(this.address), 1)
                                        allowance[address(this.address)][stor6].field_0 = balanceOf[this.address] * stor14 / totalFees / 2
                                        allowance[address(this.address)][stor6].field_255 = 0
                                        emit Approval((balanceOf[this.address] * stor14 / totalFees / 2), this.address, uniswapV2RouterAddress);
                                        mem[_21581 + ceil32(return_data.size) + 96] = 0x791ac94700000000000000000000000000000000000000000000000000000000
                                        mem[_21581 + ceil32(return_data.size) + 100] = balanceOf[this.address] * stor14 / totalFees / 2
                                        mem[_21581 + ceil32(return_data.size) + 132] = 0
                                        mem[_21581 + ceil32(return_data.size) + 164] = 160
                                        mem[_21581 + ceil32(return_data.size) + 260] = mem[_21581]
                                        idx = 0
                                        s = _21581 + ceil32(return_data.size) + 292
                                        t = _21581 + 32
                                        while idx < mem[_21581]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_21581 + ceil32(return_data.size) + 196] = this.address
                                        mem[_21581 + ceil32(return_data.size) + 228] = block.timestamp
                                        require ext_code.size(uniswapV2RouterAddress)
                                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _21581 + ceil32(return_data.size) + (32 * mem[_21581]) + -mem[64] + 288]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _33722 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_33722] = 30
                                        mem[_33722 + 32] = 'SafeMath: subtraction overflow'
                                        if eth.balance(this.address) > eth.balance(this.address):
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if eth.balance(this.address) < eth.balance(this.address):
                                            revert with 0, 17
                                        if not this.address:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not uniswapV2RouterAddress:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        mem[0] = uniswapV2RouterAddress
                                        mem[32] = sha3(address(this.address), 1)
                                        allowance[address(this.address)][stor6].field_0 = (balanceOf[this.address] * stor14 / totalFees) - (balanceOf[this.address] * stor14 / totalFees / 2)
                                        emit Approval(((balanceOf[this.address] * stor14 / totalFees) - (balanceOf[this.address] * stor14 / totalFees / 2)), this.address, uniswapV2RouterAddress);
                                        mem[mem[64] + 68] = 0
                                        mem[mem[64] + 100] = 0
                                        mem[mem[64] + 132] = stor17
                                        mem[mem[64] + 164] = block.timestamp
                                        call uniswapV2RouterAddress.addLiquidityETH(address arg1, uint256 arg2, uint256 arg3, uint256 arg4, address arg5, uint256 arg6) with:
                                             gas gas_remaining wei
                                            args this.address, (balanceOf[this.address] * stor14 / totalFees) - (balanceOf[this.address] * stor14 / totalFees / 2), 0, 0, stor17, block.timestamp
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 96
                                        mem[mem[64] + 32] = 0
                                        mem[mem[64] + 64] = (balanceOf[this.address] * stor14 / totalFees) - (balanceOf[this.address] * stor14 / totalFees / 2)
                                        emit SwapAndLiquify(Mask(255, 1, balanceOf[this.address] * stor14 / totalFees), 0, (balanceOf[this.address] * stor14 / totalFees) - (balanceOf[this.address] * stor14 / totalFees / 2));
                                        mem[0] = this.address
                                        mem[32] = 0
                                        _33906 = mem[64]
                                        mem[mem[64]] = 3
                                        mem[64] = mem[64] + 128
                                        mem[_33906 + 32 len 96] = call.data[calldata.size len 96]
                                        if 0 >= mem[_33906]:
                                            revert with 0, 50
                                        mem[_33906 + 32] = this.address
                                        staticcall uniswapV2RouterAddress.WETH() with:
                                                gas gas_remaining wei
                                        mem[_33906 + 128] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[64] = _33906 + ceil32(return_data.size) + 128
                                        require return_data.size >= 32
                                        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
                                        if 1 >= mem[_33906]:
                                            revert with 0, 50
                                        mem[_33906 + 64] = ext_call.return_data[12 len 20]
                                        if 2 >= mem[_33906]:
                                            revert with 0, 50
                                        mem[_33906 + 96] = sub_4d7effddAddress
                                        if not this.address:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not uniswapV2RouterAddress:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        mem[0] = uniswapV2RouterAddress
                                        mem[32] = sha3(address(this.address), 1)
                                        allowance[address(this.address)][stor6].field_0 = balanceOf[this.address]
                                        emit Approval(balanceOf[this.address], this.address, uniswapV2RouterAddress);
                                        mem[_33906 + ceil32(return_data.size) + 128] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                                        mem[_33906 + ceil32(return_data.size) + 132] = balanceOf[this.address]
                                        mem[_33906 + ceil32(return_data.size) + 164] = 0
                                        mem[_33906 + ceil32(return_data.size) + 196] = 160
                                        mem[_33906 + ceil32(return_data.size) + 292] = mem[_33906]
                                        idx = 0
                                        s = _33906 + ceil32(return_data.size) + 324
                                        t = _33906 + 32
                                        while idx < mem[_33906]:
                                            mem[s] = mem[t + 12 len 20]
                                            idx = idx + 1
                                            s = s + 32
                                            t = t + 32
                                            continue 
                                        mem[_33906 + ceil32(return_data.size) + 228] = this.address
                                        mem[_33906 + ceil32(return_data.size) + 260] = block.timestamp
                                        require ext_code.size(uniswapV2RouterAddress)
                                        call uniswapV2RouterAddress.mem[mem[64] len 4] with:
                                             gas gas_remaining wei
                                            args mem[mem[64] + 4 len _33906 + ceil32(return_data.size) + (32 * mem[_33906]) + -mem[64] + 320]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[mem[64] + 4] = this.address
                                        staticcall sub_4d7effddAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        mem[mem[64]] = ext_call.return_data[0]
                                        _62554 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        _62562 = mem[_62554]
                                        mem[mem[64] + 4] = dividendTrackerAddress
                                        mem[mem[64] + 36] = _62562
                                        call sub_4d7effddAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args dividendTrackerAddress, _62562
                                        mem[mem[64]] = ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _62586 = mem[64]
                                        mem[64] = mem[64] + ceil32(return_data.size)
                                        require return_data.size >= 32
                                        require mem[_62586] == bool(mem[_62586])
                                        if not mem[_62586]:
                                            stor7 = 0
                                            mem[0] = address(cd[4])
                                            mem[32] = 19
                                            if stor19[address(cd[4])]:
                                                if not address(cd[4]):
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not address(cd[36]):
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _62682 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_62682] = 38
                                                mem[_62682 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if cd[68] > balanceOf[address(cd[4])]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_62682 + 70 len 26]
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(cd[4])] < cd[68]:
                                                    revert with 0, 17
                                                balanceOf[address(cd[4])] -= cd[68]
                                                if balanceOf[address(cd[36])] > !cd[68]:
                                                    revert with 0, 17
                                                if balanceOf[address(cd[36])] + cd[68] < balanceOf[address(cd[36])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(cd[36])] += cd[68]
                                                emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                                                require ext_code.size(dividendTrackerAddress)
                                                call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args address(cd[4]), balanceOf[address(cd[4])]
                                                mem[0] = address(cd[36])
                                                mem[32] = 0
                                                require ext_code.size(dividendTrackerAddress)
                                                call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args address(cd[36]), balanceOf[address(cd[36])]
                                                if not ext_call.success:
                                                    if not ext_call.success:
                                                        if stor7:
                                                            _64218 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_64218] = 40
                                                            mem[_64218 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 40
                                                                mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_64218 + 72 len 24]
                                                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                        else:
                                                            call dividendTrackerAddress.process(uint256 arg1) with:
                                                                 gas gas_remaining wei
                                                                args gasForProcessing
                                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                            if not ext_call.success:
                                                                _65250 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_65250] = 40
                                                                mem[_65250 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 40
                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_65250 + 72 len 24]
                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                            else:
                                                                _64221 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 96
                                                                _64656 = mem[_64221 + 32]
                                                                _64657 = mem[_64221 + 64]
                                                                mem[mem[64]] = mem[_64221]
                                                                mem[mem[64] + 64] = _64657
                                                                mem[mem[64] + 96] = gasForProcessing
                                                                emit ProcessedDividendTracker(mem[mem[64]], _64656, _64657, gasForProcessing, 1, tx.origin);
                                                                _66848 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_66848] = 40
                                                                mem[_66848 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 40
                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_66848 + 72 len 24]
                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                    else:
                                                        if stor7:
                                                            _64434 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_64434] = 40
                                                            mem[_64434 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 40
                                                                mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_64434 + 72 len 24]
                                                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                        else:
                                                            call dividendTrackerAddress.process(uint256 arg1) with:
                                                                 gas gas_remaining wei
                                                                args gasForProcessing
                                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                            if not ext_call.success:
                                                                _65649 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_65649] = 40
                                                                mem[_65649 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 40
                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_65649 + 72 len 24]
                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                            else:
                                                                _64437 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 96
                                                                _64905 = mem[_64437 + 32]
                                                                _64906 = mem[_64437 + 64]
                                                                mem[mem[64]] = mem[_64437]
                                                                mem[mem[64] + 64] = _64906
                                                                mem[mem[64] + 96] = gasForProcessing
                                                                emit ProcessedDividendTracker(mem[mem[64]], _64905, _64906, gasForProcessing, 1, tx.origin);
                                                                _67242 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_67242] = 40
                                                                mem[_67242 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 40
                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_67242 + 72 len 24]
                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                else:
                                                    if not ext_call.success:
                                                        if stor7:
                                                            _64438 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_64438] = 40
                                                            mem[_64438 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 40
                                                                mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_64438 + 72 len 24]
                                                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                        else:
                                                            call dividendTrackerAddress.process(uint256 arg1) with:
                                                                 gas gas_remaining wei
                                                                args gasForProcessing
                                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                            if not ext_call.success:
                                                                _65652 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_65652] = 40
                                                                mem[_65652 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 40
                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_65652 + 72 len 24]
                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                            else:
                                                                _64441 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 96
                                                                _64909 = mem[_64441 + 32]
                                                                _64910 = mem[_64441 + 64]
                                                                mem[mem[64]] = mem[_64441]
                                                                mem[mem[64] + 64] = _64910
                                                                mem[mem[64] + 96] = gasForProcessing
                                                                emit ProcessedDividendTracker(mem[mem[64]], _64909, _64910, gasForProcessing, 1, tx.origin);
                                                                _67247 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_67247] = 40
                                                                mem[_67247 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 40
                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_67247 + 72 len 24]
                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                    else:
                                                        if stor7:
                                                            _64658 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_64658] = 40
                                                            mem[_64658 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 40
                                                                mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_64658 + 72 len 24]
                                                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                        else:
                                                            call dividendTrackerAddress.process(uint256 arg1) with:
                                                                 gas gas_remaining wei
                                                                args gasForProcessing
                                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                            if not ext_call.success:
                                                                _66049 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_66049] = 40
                                                                mem[_66049 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 40
                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_66049 + 72 len 24]
                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                            else:
                                                                _64661 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 96
                                                                _65257 = mem[_64661 + 32]
                                                                _65258 = mem[_64661 + 64]
                                                                mem[mem[64]] = mem[_64661]
                                                                mem[mem[64] + 64] = _65258
                                                                mem[mem[64] + 96] = gasForProcessing
                                                                emit ProcessedDividendTracker(mem[mem[64]], _65257, _65258, gasForProcessing, 1, tx.origin);
                                                                _67643 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_67643] = 40
                                                                mem[_67643 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 40
                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_67643 + 72 len 24]
                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                            else:
                                                mem[0] = address(cd[36])
                                                mem[32] = 19
                                                if stor19[address(cd[36])]:
                                                    if not address(cd[4]):
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not address(cd[36]):
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _62740 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_62740] = 38
                                                    mem[_62740 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if cd[68] > balanceOf[address(cd[4])]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_62740 + 70 len 26]
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(cd[4])] < cd[68]:
                                                        revert with 0, 17
                                                    balanceOf[address(cd[4])] -= cd[68]
                                                    if balanceOf[address(cd[36])] > !cd[68]:
                                                        revert with 0, 17
                                                    if balanceOf[address(cd[36])] + cd[68] < balanceOf[address(cd[36])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(cd[36])] += cd[68]
                                                    emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                                                    require ext_code.size(dividendTrackerAddress)
                                                    call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args address(cd[4]), balanceOf[address(cd[4])]
                                                    mem[0] = address(cd[36])
                                                    mem[32] = 0
                                                    require ext_code.size(dividendTrackerAddress)
                                                    call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args address(cd[36]), balanceOf[address(cd[36])]
                                                    if not ext_call.success:
                                                        if not ext_call.success:
                                                            if stor7:
                                                                _64456 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_64456] = 40
                                                                mem[_64456 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 40
                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_64456 + 72 len 24]
                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                            else:
                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                     gas gas_remaining wei
                                                                    args gasForProcessing
                                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                if not ext_call.success:
                                                                    _65673 = mem[64]
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_65673] = 40
                                                                    mem[_65673 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[mem[64] + 4] = 32
                                                                        mem[mem[64] + 36] = 40
                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_65673 + 72 len 24]
                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                else:
                                                                    _64459 = mem[64]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 96
                                                                    _64924 = mem[_64459 + 32]
                                                                    _64925 = mem[_64459 + 64]
                                                                    mem[mem[64]] = mem[_64459]
                                                                    mem[mem[64] + 64] = _64925
                                                                    mem[mem[64] + 96] = gasForProcessing
                                                                    emit ProcessedDividendTracker(mem[mem[64]], _64924, _64925, gasForProcessing, 1, tx.origin);
                                                                    _67272 = mem[64]
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_67272] = 40
                                                                    mem[_67272 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[mem[64] + 4] = 32
                                                                        mem[mem[64] + 36] = 40
                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_67272 + 72 len 24]
                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                        else:
                                                            if stor7:
                                                                _64672 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_64672] = 40
                                                                mem[_64672 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 40
                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_64672 + 72 len 24]
                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                            else:
                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                     gas gas_remaining wei
                                                                    args gasForProcessing
                                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                if not ext_call.success:
                                                                    _66067 = mem[64]
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_66067] = 40
                                                                    mem[_66067 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[mem[64] + 4] = 32
                                                                        mem[mem[64] + 36] = 40
                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_66067 + 72 len 24]
                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                else:
                                                                    _64675 = mem[64]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 96
                                                                    _65274 = mem[_64675 + 32]
                                                                    _65275 = mem[_64675 + 64]
                                                                    mem[mem[64]] = mem[_64675]
                                                                    mem[mem[64] + 64] = _65275
                                                                    mem[mem[64] + 96] = gasForProcessing
                                                                    emit ProcessedDividendTracker(mem[mem[64]], _65274, _65275, gasForProcessing, 1, tx.origin);
                                                                    _67677 = mem[64]
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_67677] = 40
                                                                    mem[_67677 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[mem[64] + 4] = 32
                                                                        mem[mem[64] + 36] = 40
                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_67677 + 72 len 24]
                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                    else:
                                                        if not ext_call.success:
                                                            if stor7:
                                                                _64676 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_64676] = 40
                                                                mem[_64676 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 40
                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_64676 + 72 len 24]
                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                            else:
                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                     gas gas_remaining wei
                                                                    args gasForProcessing
                                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                if not ext_call.success:
                                                                    _66070 = mem[64]
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_66070] = 40
                                                                    mem[_66070 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[mem[64] + 4] = 32
                                                                        mem[mem[64] + 36] = 40
                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_66070 + 72 len 24]
                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                else:
                                                                    _64679 = mem[64]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 96
                                                                    _65278 = mem[_64679 + 32]
                                                                    _65279 = mem[_64679 + 64]
                                                                    mem[mem[64]] = mem[_64679]
                                                                    mem[mem[64] + 64] = _65279
                                                                    mem[mem[64] + 96] = gasForProcessing
                                                                    emit ProcessedDividendTracker(mem[mem[64]], _65278, _65279, gasForProcessing, 1, tx.origin);
                                                                    _67682 = mem[64]
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_67682] = 40
                                                                    mem[_67682 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[mem[64] + 4] = 32
                                                                        mem[mem[64] + 36] = 40
                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_67682 + 72 len 24]
                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                        else:
                                                            if stor7:
                                                                _64926 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_64926] = 40
                                                                mem[_64926 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 40
                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_64926 + 72 len 24]
                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                            else:
                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                     gas gas_remaining wei
                                                                    args gasForProcessing
                                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                if not ext_call.success:
                                                                    _66467 = mem[64]
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_66467] = 40
                                                                    mem[_66467 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[mem[64] + 4] = 32
                                                                        mem[mem[64] + 36] = 40
                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_66467 + 72 len 24]
                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                else:
                                                                    _64929 = mem[64]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 96
                                                                    _65680 = mem[_64929 + 32]
                                                                    _65681 = mem[_64929 + 64]
                                                                    mem[mem[64]] = mem[_64929]
                                                                    mem[mem[64] + 64] = _65681
                                                                    mem[mem[64] + 96] = gasForProcessing
                                                                    emit ProcessedDividendTracker(mem[mem[64]], _65680, _65681, gasForProcessing, 1, tx.origin);
                                                                    _68134 = mem[64]
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_68134] = 40
                                                                    mem[_68134 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[mem[64] + 4] = 32
                                                                        mem[mem[64] + 36] = 40
                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_68134 + 72 len 24]
                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                else:
                                                    if stor7:
                                                        if not address(cd[4]):
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not address(cd[36]):
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        _62685 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_62685] = 38
                                                        mem[_62685 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if cd[68] > balanceOf[address(cd[4])]:
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 38
                                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_62685 + 70 len 26]
                                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                        if balanceOf[address(cd[4])] < cd[68]:
                                                            revert with 0, 17
                                                        balanceOf[address(cd[4])] -= cd[68]
                                                        if balanceOf[address(cd[36])] > !cd[68]:
                                                            revert with 0, 17
                                                        if balanceOf[address(cd[36])] + cd[68] < balanceOf[address(cd[36])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(cd[36])] += cd[68]
                                                        emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                                                        require ext_code.size(dividendTrackerAddress)
                                                        call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args address(cd[4]), balanceOf[address(cd[4])]
                                                        mem[0] = address(cd[36])
                                                        mem[32] = 0
                                                        require ext_code.size(dividendTrackerAddress)
                                                        call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args address(cd[36]), balanceOf[address(cd[36])]
                                                        if not ext_call.success:
                                                            if not ext_call.success:
                                                                if stor7:
                                                                    _64226 = mem[64]
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_64226] = 40
                                                                    mem[_64226 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[mem[64] + 4] = 32
                                                                        mem[mem[64] + 36] = 40
                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_64226 + 72 len 24]
                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                else:
                                                                    call dividendTrackerAddress.process(uint256 arg1) with:
                                                                         gas gas_remaining wei
                                                                        args gasForProcessing
                                                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                    if not ext_call.success:
                                                                        _65259 = mem[64]
                                                                        mem[64] = mem[64] + 96
                                                                        mem[_65259] = 40
                                                                        mem[_65259 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                        if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                            mem[mem[64] + 4] = 32
                                                                            mem[mem[64] + 36] = 40
                                                                            mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_65259 + 72 len 24]
                                                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                    else:
                                                                        _64229 = mem[64]
                                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                                        require return_data.size >= 96
                                                                        _64664 = mem[_64229 + 32]
                                                                        _64665 = mem[_64229 + 64]
                                                                        mem[mem[64]] = mem[_64229]
                                                                        mem[mem[64] + 64] = _64665
                                                                        mem[mem[64] + 96] = gasForProcessing
                                                                        emit ProcessedDividendTracker(mem[mem[64]], _64664, _64665, gasForProcessing, 1, tx.origin);
                                                                        _66858 = mem[64]
                                                                        mem[64] = mem[64] + 96
                                                                        mem[_66858] = 40
                                                                        mem[_66858 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                        if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                            mem[mem[64] + 4] = 32
                                                                            mem[mem[64] + 36] = 40
                                                                            mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_66858 + 72 len 24]
                                                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                            else:
                                                                if stor7:
                                                                    _64444 = mem[64]
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_64444] = 40
                                                                    mem[_64444 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[mem[64] + 4] = 32
                                                                        mem[mem[64] + 36] = 40
                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_64444 + 72 len 24]
                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                else:
                                                                    call dividendTrackerAddress.process(uint256 arg1) with:
                                                                         gas gas_remaining wei
                                                                        args gasForProcessing
                                                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                    if not ext_call.success:
                                                                        _65659 = mem[64]
                                                                        mem[64] = mem[64] + 96
                                                                        mem[_65659] = 40
                                                                        mem[_65659 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                        if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                            mem[mem[64] + 4] = 32
                                                                            mem[mem[64] + 36] = 40
                                                                            mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_65659 + 72 len 24]
                                                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                    else:
                                                                        _64447 = mem[64]
                                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                                        require return_data.size >= 96
                                                                        _64914 = mem[_64447 + 32]
                                                                        _64915 = mem[_64447 + 64]
                                                                        mem[mem[64]] = mem[_64447]
                                                                        mem[mem[64] + 64] = _64915
                                                                        mem[mem[64] + 96] = gasForProcessing
                                                                        emit ProcessedDividendTracker(mem[mem[64]], _64914, _64915, gasForProcessing, 1, tx.origin);
                                                                        _67260 = mem[64]
                                                                        mem[64] = mem[64] + 96
                                                                        mem[_67260] = 40
                                                                        mem[_67260 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                        if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                            mem[mem[64] + 4] = 32
                                                                            mem[mem[64] + 36] = 40
                                                                            mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_67260 + 72 len 24]
                                                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                        else:
                                                            if not ext_call.success:
                                                                if stor7:
                                                                    _64448 = mem[64]
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_64448] = 40
                                                                    mem[_64448 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[mem[64] + 4] = 32
                                                                        mem[mem[64] + 36] = 40
                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_64448 + 72 len 24]
                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                else:
                                                                    call dividendTrackerAddress.process(uint256 arg1) with:
                                                                         gas gas_remaining wei
                                                                        args gasForProcessing
                                                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                    if not ext_call.success:
                                                                        _65662 = mem[64]
                                                                        mem[64] = mem[64] + 96
                                                                        mem[_65662] = 40
                                                                        mem[_65662 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                        if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                            mem[mem[64] + 4] = 32
                                                                            mem[mem[64] + 36] = 40
                                                                            mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_65662 + 72 len 24]
                                                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                    else:
                                                                        _64451 = mem[64]
                                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                                        require return_data.size >= 96
                                                                        _64918 = mem[_64451 + 32]
                                                                        _64919 = mem[_64451 + 64]
                                                                        mem[mem[64]] = mem[_64451]
                                                                        mem[mem[64] + 64] = _64919
                                                                        mem[mem[64] + 96] = gasForProcessing
                                                                        emit ProcessedDividendTracker(mem[mem[64]], _64918, _64919, gasForProcessing, 1, tx.origin);
                                                                        _67265 = mem[64]
                                                                        mem[64] = mem[64] + 96
                                                                        mem[_67265] = 40
                                                                        mem[_67265 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                        if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                            mem[mem[64] + 4] = 32
                                                                            mem[mem[64] + 36] = 40
                                                                            mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_67265 + 72 len 24]
                                                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                            else:
                                                                if stor7:
                                                                    _64666 = mem[64]
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_64666] = 40
                                                                    mem[_64666 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[mem[64] + 4] = 32
                                                                        mem[mem[64] + 36] = 40
                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_64666 + 72 len 24]
                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                else:
                                                                    call dividendTrackerAddress.process(uint256 arg1) with:
                                                                         gas gas_remaining wei
                                                                        args gasForProcessing
                                                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                    if not ext_call.success:
                                                                        _66059 = mem[64]
                                                                        mem[64] = mem[64] + 96
                                                                        mem[_66059] = 40
                                                                        mem[_66059 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                        if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                            mem[mem[64] + 4] = 32
                                                                            mem[mem[64] + 36] = 40
                                                                            mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_66059 + 72 len 24]
                                                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                    else:
                                                                        _64669 = mem[64]
                                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                                        require return_data.size >= 96
                                                                        _65266 = mem[_64669 + 32]
                                                                        _65267 = mem[_64669 + 64]
                                                                        mem[mem[64]] = mem[_64669]
                                                                        mem[mem[64] + 64] = _65267
                                                                        mem[mem[64] + 96] = gasForProcessing
                                                                        emit ProcessedDividendTracker(mem[mem[64]], _65266, _65267, gasForProcessing, 1, tx.origin);
                                                                        _67663 = mem[64]
                                                                        mem[64] = mem[64] + 96
                                                                        mem[_67663] = 40
                                                                        mem[_67663 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                        if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                            mem[mem[64] + 4] = 32
                                                                            mem[mem[64] + 36] = 40
                                                                            mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_67663 + 72 len 24]
                                                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                    else:
                                                        if not cd[68]:
                                                            _62782 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_62782] = 26
                                                            mem[_62782 + 32] = 'SafeMath: division by zero'
                                                            mem[0] = address(cd[36])
                                                            mem[32] = 20
                                                            if not stor20[address(cd[36])]:
                                                                _63324 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_63324] = 30
                                                                mem[_63324 + 32] = 'SafeMath: subtraction overflow'
                                                                if 0 > cd[68]:
                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                if cd[68] < 0:
                                                                    revert with 0, 17
                                                                if not address(cd[4]):
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not this.address:
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                _64087 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_64087] = 38
                                                                mem[_64087 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                if 0 > balanceOf[address(cd[4])]:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 38
                                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_64087 + 70 len 26]
                                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                if balanceOf[address(cd[4])] < 0:
                                                                    revert with 0, 17
                                                                if balanceOf[this.address] > -1:
                                                                    revert with 0, 17
                                                                if balanceOf[this.address] < balanceOf[this.address]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[0] = this.address
                                                                mem[32] = 0
                                                                balanceOf[address(this.address)] = balanceOf[this.address]
                                                                emit Transfer(0, address(cd[4]), this.address);
                                                                if not address(cd[4]):
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not address(cd[36]):
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                _70700 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_70700] = 38
                                                                mem[_70700 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                if cd[68] > balanceOf[address(cd[4])]:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 38
                                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_70700 + 70 len 26]
                                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                if balanceOf[address(cd[4])] < cd[68]:
                                                                    revert with 0, 17
                                                                balanceOf[address(cd[4])] -= cd[68]
                                                                if balanceOf[address(cd[36])] > !cd[68]:
                                                                    revert with 0, 17
                                                                if balanceOf[address(cd[36])] + cd[68] < balanceOf[address(cd[36])]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                balanceOf[address(cd[36])] += cd[68]
                                                                emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                                                                require ext_code.size(dividendTrackerAddress)
                                                                call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                                     gas gas_remaining wei
                                                                    args address(cd[4]), balanceOf[address(cd[4])]
                                                                mem[0] = address(cd[36])
                                                                mem[32] = 0
                                                                require ext_code.size(dividendTrackerAddress)
                                                                call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                                     gas gas_remaining wei
                                                                    args address(cd[36]), balanceOf[address(cd[36])]
                                                                if not ext_call.success:
                                                                    if not ext_call.success:
                                                                        if stor7:
                                                                            _74600 = mem[64]
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_74600] = 40
                                                                            mem[_74600 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[mem[64] + 4] = 32
                                                                                mem[mem[64] + 36] = 40
                                                                                mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_74600 + 72 len 24]
                                                                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                        else:
                                                                            call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                 gas gas_remaining wei
                                                                                args gasForProcessing
                                                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                            if not ext_call.success:
                                                                                _75294 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_75294] = 40
                                                                                mem[_75294 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_75294 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                _74603 = mem[64]
                                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                                require return_data.size >= 96
                                                                                _74877 = mem[_74603 + 32]
                                                                                _74878 = mem[_74603 + 64]
                                                                                mem[mem[64]] = mem[_74603]
                                                                                mem[mem[64] + 64] = _74878
                                                                                mem[mem[64] + 96] = gasForProcessing
                                                                                emit ProcessedDividendTracker(mem[mem[64]], _74877, _74878, gasForProcessing, 1, tx.origin);
                                                                                _76171 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_76171] = 40
                                                                                mem[_76171 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_76171 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                    else:
                                                                        if stor7:
                                                                            _74769 = mem[64]
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_74769] = 40
                                                                            mem[_74769 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[mem[64] + 4] = 32
                                                                                mem[mem[64] + 36] = 40
                                                                                mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_74769 + 72 len 24]
                                                                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                        else:
                                                                            call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                 gas gas_remaining wei
                                                                                args gasForProcessing
                                                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                            if not ext_call.success:
                                                                                _75457 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_75457] = 40
                                                                                mem[_75457 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_75457 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                _74772 = mem[64]
                                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                                require return_data.size >= 96
                                                                                _75056 = mem[_74772 + 32]
                                                                                _75057 = mem[_74772 + 64]
                                                                                mem[mem[64]] = mem[_74772]
                                                                                mem[mem[64] + 64] = _75057
                                                                                mem[mem[64] + 96] = gasForProcessing
                                                                                emit ProcessedDividendTracker(mem[mem[64]], _75056, _75057, gasForProcessing, 1, tx.origin);
                                                                                _76420 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_76420] = 40
                                                                                mem[_76420 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_76420 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                else:
                                                                    if not ext_call.success:
                                                                        if stor7:
                                                                            _74773 = mem[64]
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_74773] = 40
                                                                            mem[_74773 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[mem[64] + 4] = 32
                                                                                mem[mem[64] + 36] = 40
                                                                                mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_74773 + 72 len 24]
                                                                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                        else:
                                                                            call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                 gas gas_remaining wei
                                                                                args gasForProcessing
                                                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                            if not ext_call.success:
                                                                                _75460 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_75460] = 40
                                                                                mem[_75460 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_75460 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                _74776 = mem[64]
                                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                                require return_data.size >= 96
                                                                                _75060 = mem[_74776 + 32]
                                                                                _75061 = mem[_74776 + 64]
                                                                                mem[mem[64]] = mem[_74776]
                                                                                mem[mem[64] + 64] = _75061
                                                                                mem[mem[64] + 96] = gasForProcessing
                                                                                emit ProcessedDividendTracker(mem[mem[64]], _75060, _75061, gasForProcessing, 1, tx.origin);
                                                                                _76425 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_76425] = 40
                                                                                mem[_76425 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_76425 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                    else:
                                                                        if stor7:
                                                                            _74879 = mem[64]
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_74879] = 40
                                                                            mem[_74879 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[mem[64] + 4] = 32
                                                                                mem[mem[64] + 36] = 40
                                                                                mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_74879 + 72 len 24]
                                                                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                        else:
                                                                            call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                 gas gas_remaining wei
                                                                                args gasForProcessing
                                                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                            if not ext_call.success:
                                                                                _75686 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_75686] = 40
                                                                                mem[_75686 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_75686 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                _74882 = mem[64]
                                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                                require return_data.size >= 96
                                                                                _75301 = mem[_74882 + 32]
                                                                                _75302 = mem[_74882 + 64]
                                                                                mem[mem[64]] = mem[_74882]
                                                                                mem[mem[64] + 64] = _75302
                                                                                mem[mem[64] + 96] = gasForProcessing
                                                                                emit ProcessedDividendTracker(mem[mem[64]], _75301, _75302, gasForProcessing, 1, tx.origin);
                                                                                _76792 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_76792] = 40
                                                                                mem[_76792 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_76792 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                            else:
                                                                if not cd[68]:
                                                                    _63559 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_63559] = 26
                                                                    mem[_63559 + 32] = 'SafeMath: division by zero'
                                                                    _65672 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_65672] = 30
                                                                    mem[_65672 + 32] = 'SafeMath: subtraction overflow'
                                                                    if 0 > cd[68]:
                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                    if cd[68] < 0:
                                                                        revert with 0, 17
                                                                    if not address(cd[4]):
                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                    if not this.address:
                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                    _69946 = mem[64]
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_69946] = 38
                                                                    mem[_69946 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                    if 0 > balanceOf[address(cd[4])]:
                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[mem[64] + 4] = 32
                                                                        mem[mem[64] + 36] = 38
                                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_69946 + 70 len 26]
                                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                    if balanceOf[address(cd[4])] < 0:
                                                                        revert with 0, 17
                                                                    if balanceOf[this.address] > -1:
                                                                        revert with 0, 17
                                                                    if balanceOf[this.address] < balanceOf[this.address]:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    mem[0] = this.address
                                                                    mem[32] = 0
                                                                    balanceOf[address(this.address)] = balanceOf[this.address]
                                                                    emit Transfer(0, address(cd[4]), this.address);
                                                                    if not address(cd[4]):
                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                    if not address(cd[36]):
                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                    _73994 = mem[64]
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_73994] = 38
                                                                    mem[_73994 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                    if cd[68] > balanceOf[address(cd[4])]:
                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[mem[64] + 4] = 32
                                                                        mem[mem[64] + 36] = 38
                                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_73994 + 70 len 26]
                                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                    if balanceOf[address(cd[4])] < cd[68]:
                                                                        revert with 0, 17
                                                                    balanceOf[address(cd[4])] -= cd[68]
                                                                    if balanceOf[address(cd[36])] > !cd[68]:
                                                                        revert with 0, 17
                                                                    if balanceOf[address(cd[36])] + cd[68] < balanceOf[address(cd[36])]:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    balanceOf[address(cd[36])] += cd[68]
                                                                    emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                                                                    require ext_code.size(dividendTrackerAddress)
                                                                    call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                                         gas gas_remaining wei
                                                                        args address(cd[4]), balanceOf[address(cd[4])]
                                                                    mem[0] = address(cd[36])
                                                                    mem[32] = 0
                                                                    require ext_code.size(dividendTrackerAddress)
                                                                    call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                                         gas gas_remaining wei
                                                                        args address(cd[36]), balanceOf[address(cd[36])]
                                                                    if not ext_call.success:
                                                                        if not ext_call.success:
                                                                            if stor7:
                                                                                _78713 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_78713] = 40
                                                                                mem[_78713 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_78713 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                     gas gas_remaining wei
                                                                                    args gasForProcessing
                                                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                                if not ext_call.success:
                                                                                    _80173 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_80173] = 40
                                                                                    mem[_80173 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_80173 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                                else:
                                                                                    _78716 = mem[64]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 96
                                                                                    _79392 = mem[_78716 + 32]
                                                                                    _79393 = mem[_78716 + 64]
                                                                                    mem[mem[64]] = mem[_78716]
                                                                                    mem[mem[64] + 64] = _79393
                                                                                    mem[mem[64] + 96] = gasForProcessing
                                                                                    emit ProcessedDividendTracker(mem[mem[64]], _79392, _79393, gasForProcessing, 1, tx.origin);
                                                                                    _81748 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_81748] = 40
                                                                                    mem[_81748 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_81748 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                        else:
                                                                            if stor7:
                                                                                _79032 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_79032] = 40
                                                                                mem[_79032 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_79032 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                     gas gas_remaining wei
                                                                                    args gasForProcessing
                                                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                                if not ext_call.success:
                                                                                    _80530 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_80530] = 40
                                                                                    mem[_80530 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_80530 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                                else:
                                                                                    _79035 = mem[64]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 96
                                                                                    _79803 = mem[_79035 + 32]
                                                                                    _79804 = mem[_79035 + 64]
                                                                                    mem[mem[64]] = mem[_79035]
                                                                                    mem[mem[64] + 64] = _79804
                                                                                    mem[mem[64] + 96] = gasForProcessing
                                                                                    emit ProcessedDividendTracker(mem[mem[64]], _79803, _79804, gasForProcessing, 1, tx.origin);
                                                                                    _82156 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_82156] = 40
                                                                                    mem[_82156 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_82156 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                    else:
                                                                        if not ext_call.success:
                                                                            if stor7:
                                                                                _79036 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_79036] = 40
                                                                                mem[_79036 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_79036 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                     gas gas_remaining wei
                                                                                    args gasForProcessing
                                                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                                if not ext_call.success:
                                                                                    _80533 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_80533] = 40
                                                                                    mem[_80533 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_80533 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                                else:
                                                                                    _79039 = mem[64]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 96
                                                                                    _79807 = mem[_79039 + 32]
                                                                                    _79808 = mem[_79039 + 64]
                                                                                    mem[mem[64]] = mem[_79039]
                                                                                    mem[mem[64] + 64] = _79808
                                                                                    mem[mem[64] + 96] = gasForProcessing
                                                                                    emit ProcessedDividendTracker(mem[mem[64]], _79807, _79808, gasForProcessing, 1, tx.origin);
                                                                                    _82161 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_82161] = 40
                                                                                    mem[_82161 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_82161 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                        else:
                                                                            if stor7:
                                                                                _79394 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_79394] = 40
                                                                                mem[_79394 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_79394 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                     gas gas_remaining wei
                                                                                    args gasForProcessing
                                                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                                if not ext_call.success:
                                                                                    _80943 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_80943] = 40
                                                                                    mem[_80943 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_80943 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                                else:
                                                                                    _79397 = mem[64]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 96
                                                                                    _80180 = mem[_79397 + 32]
                                                                                    _80181 = mem[_79397 + 64]
                                                                                    mem[mem[64]] = mem[_79397]
                                                                                    mem[mem[64] + 64] = _80181
                                                                                    mem[mem[64] + 96] = gasForProcessing
                                                                                    emit ProcessedDividendTracker(mem[mem[64]], _80180, _80181, gasForProcessing, 1, tx.origin);
                                                                                    _82636 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_82636] = 40
                                                                                    mem[_82636 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_82636 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                else:
                                                                    if cd[68] and 1 > -1 / cd[68]:
                                                                        revert with 0, 17
                                                                    if not cd[68]:
                                                                        revert with 0, 18
                                                                    if cd[68] / cd[68] != 1:
                                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                                    _64090 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_64090] = 26
                                                                    mem[_64090 + 32] = 'SafeMath: division by zero'
                                                                    if 0 > !(cd[68] / 100):
                                                                        revert with 0, 17
                                                                    _68116 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_68116] = 30
                                                                    mem[_68116 + 32] = 'SafeMath: subtraction overflow'
                                                                    if cd[68] / 100 > cd[68]:
                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                    if cd[68] < cd[68] / 100:
                                                                        revert with 0, 17
                                                                    if not address(cd[4]):
                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                    if not this.address:
                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                    _72187 = mem[64]
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_72187] = 38
                                                                    mem[_72187 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                    if cd[68] / 100 > balanceOf[address(cd[4])]:
                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[mem[64] + 4] = 32
                                                                        mem[mem[64] + 36] = 38
                                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_72187 + 70 len 26]
                                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                    if balanceOf[address(cd[4])] < cd[68] / 100:
                                                                        revert with 0, 17
                                                                    balanceOf[address(cd[4])] -= cd[68] / 100
                                                                    if balanceOf[this.address] > !(cd[68] / 100):
                                                                        revert with 0, 17
                                                                    if balanceOf[this.address] + (cd[68] / 100) < balanceOf[this.address]:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    mem[0] = this.address
                                                                    mem[32] = 0
                                                                    balanceOf[address(this.address)] = balanceOf[this.address] + (cd[68] / 100)
                                                                    emit Transfer((cd[68] / 100), address(cd[4]), this.address);
                                                                    if not address(cd[4]):
                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                    if not address(cd[36]):
                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                    _74608 = mem[64]
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_74608] = 38
                                                                    mem[_74608 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                    if cd[68] - (cd[68] / 100) > balanceOf[address(cd[4])]:
                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[mem[64] + 4] = 32
                                                                        mem[mem[64] + 36] = 38
                                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_74608 + 70 len 26]
                                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                    if balanceOf[address(cd[4])] < cd[68] - (cd[68] / 100):
                                                                        revert with 0, 17
                                                                    balanceOf[address(cd[4])] = balanceOf[address(cd[4])] - cd[68] + (cd[68] / 100)
                                                                    if balanceOf[address(cd[36])] > !(cd[68] - (cd[68] / 100)):
                                                                        revert with 0, 17
                                                                    if balanceOf[address(cd[36])] + cd[68] - (cd[68] / 100) < balanceOf[address(cd[36])]:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    balanceOf[address(cd[36])] = balanceOf[address(cd[36])] + cd[68] - (cd[68] / 100)
                                                                    emit Transfer((cd[68] - (cd[68] / 100)), address(cd[4]), address(cd[36]));
                                                                    require ext_code.size(dividendTrackerAddress)
                                                                    call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                                         gas gas_remaining wei
                                                                        args address(cd[4]), balanceOf[address(cd[4])]
                                                                    mem[0] = address(cd[36])
                                                                    mem[32] = 0
                                                                    require ext_code.size(dividendTrackerAddress)
                                                                    call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                                         gas gas_remaining wei
                                                                        args address(cd[36]), balanceOf[address(cd[36])]
                                                                    if not ext_call.success:
                                                                        if not ext_call.success:
                                                                            if stor7:
                                                                                _80928 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_80928] = 40
                                                                                mem[_80928 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_80928 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                     gas gas_remaining wei
                                                                                    args gasForProcessing
                                                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                                if not ext_call.success:
                                                                                    _82610 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_82610] = 40
                                                                                    mem[_82610 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_82610 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                                else:
                                                                                    _80931 = mem[64]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 96
                                                                                    _81740 = mem[_80931 + 32]
                                                                                    _81741 = mem[_80931 + 64]
                                                                                    mem[mem[64]] = mem[_80931]
                                                                                    mem[mem[64] + 64] = _81741
                                                                                    mem[mem[64] + 96] = gasForProcessing
                                                                                    emit ProcessedDividendTracker(mem[mem[64]], _81740, _81741, gasForProcessing, 1, tx.origin);
                                                                                    _84454 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_84454] = 40
                                                                                    mem[_84454 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_84454 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                        else:
                                                                            if stor7:
                                                                                _81355 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_81355] = 40
                                                                                mem[_81355 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_81355 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                     gas gas_remaining wei
                                                                                    args gasForProcessing
                                                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                                if not ext_call.success:
                                                                                    _83056 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_83056] = 40
                                                                                    mem[_83056 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_83056 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                                else:
                                                                                    _81358 = mem[64]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 96
                                                                                    _82142 = mem[_81358 + 32]
                                                                                    _82143 = mem[_81358 + 64]
                                                                                    mem[mem[64]] = mem[_81358]
                                                                                    mem[mem[64] + 64] = _82143
                                                                                    mem[mem[64] + 96] = gasForProcessing
                                                                                    emit ProcessedDividendTracker(mem[mem[64]], _82142, _82143, gasForProcessing, 1, tx.origin);
                                                                                    _84901 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_84901] = 40
                                                                                    mem[_84901 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_84901 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                    else:
                                                                        if not ext_call.success:
                                                                            if stor7:
                                                                                _81359 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_81359] = 40
                                                                                mem[_81359 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_81359 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                     gas gas_remaining wei
                                                                                    args gasForProcessing
                                                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                                if not ext_call.success:
                                                                                    _83059 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_83059] = 40
                                                                                    mem[_83059 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_83059 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                                else:
                                                                                    _81362 = mem[64]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 96
                                                                                    _82146 = mem[_81362 + 32]
                                                                                    _82147 = mem[_81362 + 64]
                                                                                    mem[mem[64]] = mem[_81362]
                                                                                    mem[mem[64] + 64] = _82147
                                                                                    mem[mem[64] + 96] = gasForProcessing
                                                                                    emit ProcessedDividendTracker(mem[mem[64]], _82146, _82147, gasForProcessing, 1, tx.origin);
                                                                                    _84906 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_84906] = 40
                                                                                    mem[_84906 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_84906 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                        else:
                                                                            if stor7:
                                                                                _81742 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_81742] = 40
                                                                                mem[_81742 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_81742 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                     gas gas_remaining wei
                                                                                    args gasForProcessing
                                                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                                if not ext_call.success:
                                                                                    _83514 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_83514] = 40
                                                                                    mem[_83514 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_83514 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                                else:
                                                                                    _81745 = mem[64]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 96
                                                                                    _82617 = mem[_81745 + 32]
                                                                                    _82618 = mem[_81745 + 64]
                                                                                    mem[mem[64]] = mem[_81745]
                                                                                    mem[mem[64] + 64] = _82618
                                                                                    mem[mem[64] + 96] = gasForProcessing
                                                                                    emit ProcessedDividendTracker(mem[mem[64]], _82617, _82618, gasForProcessing, 1, tx.origin);
                                                                                    _85420 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_85420] = 40
                                                                                    mem[_85420 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_85420 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                        else:
                                                            if cd[68] and totalFees > -1 / cd[68]:
                                                                revert with 0, 17
                                                            if not cd[68]:
                                                                revert with 0, 18
                                                            if cd[68] * totalFees / cd[68] != totalFees:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _63172 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_63172] = 26
                                                            mem[_63172 + 32] = 'SafeMath: division by zero'
                                                            mem[0] = address(cd[36])
                                                            mem[32] = 20
                                                            if not stor20[address(cd[36])]:
                                                                _63740 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_63740] = 30
                                                                mem[_63740 + 32] = 'SafeMath: subtraction overflow'
                                                                if cd[68] * totalFees / 100 > cd[68]:
                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                if cd[68] < cd[68] * totalFees / 100:
                                                                    revert with 0, 17
                                                                if not address(cd[4]):
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not this.address:
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                _65666 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_65666] = 38
                                                                mem[_65666 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                if cd[68] * totalFees / 100 > balanceOf[address(cd[4])]:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 38
                                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_65666 + 70 len 26]
                                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                if balanceOf[address(cd[4])] < cd[68] * totalFees / 100:
                                                                    revert with 0, 17
                                                                balanceOf[address(cd[4])] -= cd[68] * totalFees / 100
                                                                if balanceOf[this.address] > !(cd[68] * totalFees / 100):
                                                                    revert with 0, 17
                                                                if balanceOf[this.address] + (cd[68] * totalFees / 100) < balanceOf[this.address]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[0] = this.address
                                                                mem[32] = 0
                                                                balanceOf[address(this.address)] = balanceOf[this.address] + (cd[68] * totalFees / 100)
                                                                emit Transfer((cd[68] * totalFees / 100), address(cd[4]), this.address);
                                                                if not address(cd[4]):
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not address(cd[36]):
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                _72780 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_72780] = 38
                                                                mem[_72780 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                if cd[68] - (cd[68] * totalFees / 100) > balanceOf[address(cd[4])]:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 38
                                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_72780 + 70 len 26]
                                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                if balanceOf[address(cd[4])] < cd[68] - (cd[68] * totalFees / 100):
                                                                    revert with 0, 17
                                                                balanceOf[address(cd[4])] = balanceOf[address(cd[4])] - cd[68] + (cd[68] * totalFees / 100)
                                                                if balanceOf[address(cd[36])] > !(cd[68] - (cd[68] * totalFees / 100)):
                                                                    revert with 0, 17
                                                                if balanceOf[address(cd[36])] + cd[68] - (cd[68] * totalFees / 100) < balanceOf[address(cd[36])]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                balanceOf[address(cd[36])] = balanceOf[address(cd[36])] + cd[68] - (cd[68] * totalFees / 100)
                                                                emit Transfer((cd[68] - (cd[68] * totalFees / 100)), address(cd[4]), address(cd[36]));
                                                                require ext_code.size(dividendTrackerAddress)
                                                                call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                                     gas gas_remaining wei
                                                                    args address(cd[4]), balanceOf[address(cd[4])]
                                                                mem[0] = address(cd[36])
                                                                mem[32] = 0
                                                                require ext_code.size(dividendTrackerAddress)
                                                                call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                                     gas gas_remaining wei
                                                                    args address(cd[36]), balanceOf[address(cd[36])]
                                                                if not ext_call.success:
                                                                    if not ext_call.success:
                                                                        if stor7:
                                                                            _75666 = mem[64]
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_75666] = 40
                                                                            mem[_75666 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[mem[64] + 4] = 32
                                                                                mem[mem[64] + 36] = 40
                                                                                mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_75666 + 72 len 24]
                                                                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                        else:
                                                                            call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                 gas gas_remaining wei
                                                                                args gasForProcessing
                                                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                            if not ext_call.success:
                                                                                _76766 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_76766] = 40
                                                                                mem[_76766 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_76766 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                _75669 = mem[64]
                                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                                require return_data.size >= 96
                                                                                _76160 = mem[_75669 + 32]
                                                                                _76161 = mem[_75669 + 64]
                                                                                mem[mem[64]] = mem[_75669]
                                                                                mem[mem[64] + 64] = _76161
                                                                                mem[mem[64] + 96] = gasForProcessing
                                                                                emit ProcessedDividendTracker(mem[mem[64]], _76160, _76161, gasForProcessing, 1, tx.origin);
                                                                                _78012 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_78012] = 40
                                                                                mem[_78012 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_78012 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                    else:
                                                                        if stor7:
                                                                            _75962 = mem[64]
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_75962] = 40
                                                                            mem[_75962 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[mem[64] + 4] = 32
                                                                                mem[mem[64] + 36] = 40
                                                                                mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_75962 + 72 len 24]
                                                                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                        else:
                                                                            call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                 gas gas_remaining wei
                                                                                args gasForProcessing
                                                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                            if not ext_call.success:
                                                                                _77049 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_77049] = 40
                                                                                mem[_77049 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_77049 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                _75965 = mem[64]
                                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                                require return_data.size >= 96
                                                                                _76405 = mem[_75965 + 32]
                                                                                _76406 = mem[_75965 + 64]
                                                                                mem[mem[64]] = mem[_75965]
                                                                                mem[mem[64] + 64] = _76406
                                                                                mem[mem[64] + 96] = gasForProcessing
                                                                                emit ProcessedDividendTracker(mem[mem[64]], _76405, _76406, gasForProcessing, 1, tx.origin);
                                                                                _78322 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_78322] = 40
                                                                                mem[_78322 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_78322 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                else:
                                                                    if not ext_call.success:
                                                                        if stor7:
                                                                            _75966 = mem[64]
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_75966] = 40
                                                                            mem[_75966 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[mem[64] + 4] = 32
                                                                                mem[mem[64] + 36] = 40
                                                                                mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_75966 + 72 len 24]
                                                                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                        else:
                                                                            call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                 gas gas_remaining wei
                                                                                args gasForProcessing
                                                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                            if not ext_call.success:
                                                                                _77052 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_77052] = 40
                                                                                mem[_77052 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_77052 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                _75969 = mem[64]
                                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                                require return_data.size >= 96
                                                                                _76409 = mem[_75969 + 32]
                                                                                _76410 = mem[_75969 + 64]
                                                                                mem[mem[64]] = mem[_75969]
                                                                                mem[mem[64] + 64] = _76410
                                                                                mem[mem[64] + 96] = gasForProcessing
                                                                                emit ProcessedDividendTracker(mem[mem[64]], _76409, _76410, gasForProcessing, 1, tx.origin);
                                                                                _78327 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_78327] = 40
                                                                                mem[_78327 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_78327 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                    else:
                                                                        if stor7:
                                                                            _76162 = mem[64]
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_76162] = 40
                                                                            mem[_76162 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[mem[64] + 4] = 32
                                                                                mem[mem[64] + 36] = 40
                                                                                mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_76162 + 72 len 24]
                                                                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                        else:
                                                                            call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                 gas gas_remaining wei
                                                                                args gasForProcessing
                                                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                            if not ext_call.success:
                                                                                _77349 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_77349] = 40
                                                                                mem[_77349 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_77349 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                _76165 = mem[64]
                                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                                require return_data.size >= 96
                                                                                _76773 = mem[_76165 + 32]
                                                                                _76774 = mem[_76165 + 64]
                                                                                mem[mem[64]] = mem[_76165]
                                                                                mem[mem[64] + 64] = _76774
                                                                                mem[mem[64] + 96] = gasForProcessing
                                                                                emit ProcessedDividendTracker(mem[mem[64]], _76773, _76774, gasForProcessing, 1, tx.origin);
                                                                                _78703 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_78703] = 40
                                                                                mem[_78703 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_78703 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                            else:
                                                                if not cd[68]:
                                                                    _64086 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_64086] = 26
                                                                    mem[_64086 + 32] = 'SafeMath: division by zero'
                                                                    if cd[68] * totalFees / 100 > -1:
                                                                        revert with 0, 17
                                                                    _68112 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_68112] = 30
                                                                    mem[_68112 + 32] = 'SafeMath: subtraction overflow'
                                                                    if cd[68] * totalFees / 100 > cd[68]:
                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                    if cd[68] < cd[68] * totalFees / 100:
                                                                        revert with 0, 17
                                                                    if not address(cd[4]):
                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                    if not this.address:
                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                    _72184 = mem[64]
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_72184] = 38
                                                                    mem[_72184 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                    if cd[68] * totalFees / 100 > balanceOf[address(cd[4])]:
                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[mem[64] + 4] = 32
                                                                        mem[mem[64] + 36] = 38
                                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_72184 + 70 len 26]
                                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                    if balanceOf[address(cd[4])] < cd[68] * totalFees / 100:
                                                                        revert with 0, 17
                                                                    balanceOf[address(cd[4])] -= cd[68] * totalFees / 100
                                                                    if balanceOf[this.address] > !(cd[68] * totalFees / 100):
                                                                        revert with 0, 17
                                                                    if balanceOf[this.address] + (cd[68] * totalFees / 100) < balanceOf[this.address]:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    mem[0] = this.address
                                                                    mem[32] = 0
                                                                    balanceOf[address(this.address)] = balanceOf[this.address] + (cd[68] * totalFees / 100)
                                                                    emit Transfer((cd[68] * totalFees / 100), address(cd[4]), this.address);
                                                                    if not address(cd[4]):
                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                    if not address(cd[36]):
                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                    _74597 = mem[64]
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_74597] = 38
                                                                    mem[_74597 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                    if cd[68] - (cd[68] * totalFees / 100) > balanceOf[address(cd[4])]:
                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[mem[64] + 4] = 32
                                                                        mem[mem[64] + 36] = 38
                                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_74597 + 70 len 26]
                                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                    if balanceOf[address(cd[4])] < cd[68] - (cd[68] * totalFees / 100):
                                                                        revert with 0, 17
                                                                    balanceOf[address(cd[4])] = balanceOf[address(cd[4])] - cd[68] + (cd[68] * totalFees / 100)
                                                                    if balanceOf[address(cd[36])] > !(cd[68] - (cd[68] * totalFees / 100)):
                                                                        revert with 0, 17
                                                                    if balanceOf[address(cd[36])] + cd[68] - (cd[68] * totalFees / 100) < balanceOf[address(cd[36])]:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    balanceOf[address(cd[36])] = balanceOf[address(cd[36])] + cd[68] - (cd[68] * totalFees / 100)
                                                                    emit Transfer((cd[68] - (cd[68] * totalFees / 100)), address(cd[4]), address(cd[36]));
                                                                    require ext_code.size(dividendTrackerAddress)
                                                                    call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                                         gas gas_remaining wei
                                                                        args address(cd[4]), balanceOf[address(cd[4])]
                                                                    mem[0] = address(cd[36])
                                                                    mem[32] = 0
                                                                    require ext_code.size(dividendTrackerAddress)
                                                                    call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                                         gas gas_remaining wei
                                                                        args address(cd[36]), balanceOf[address(cd[36])]
                                                                    if not ext_call.success:
                                                                        if not ext_call.success:
                                                                            if stor7:
                                                                                _80917 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_80917] = 40
                                                                                mem[_80917 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_80917 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                     gas gas_remaining wei
                                                                                    args gasForProcessing
                                                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                                if not ext_call.success:
                                                                                    _82601 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_82601] = 40
                                                                                    mem[_82601 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_82601 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                                else:
                                                                                    _80920 = mem[64]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 96
                                                                                    _81732 = mem[_80920 + 32]
                                                                                    _81733 = mem[_80920 + 64]
                                                                                    mem[mem[64]] = mem[_80920]
                                                                                    mem[mem[64] + 64] = _81733
                                                                                    mem[mem[64] + 96] = gasForProcessing
                                                                                    emit ProcessedDividendTracker(mem[mem[64]], _81732, _81733, gasForProcessing, 1, tx.origin);
                                                                                    _84444 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_84444] = 40
                                                                                    mem[_84444 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_84444 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                        else:
                                                                            if stor7:
                                                                                _81344 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_81344] = 40
                                                                                mem[_81344 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_81344 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                     gas gas_remaining wei
                                                                                    args gasForProcessing
                                                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                                if not ext_call.success:
                                                                                    _83046 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_83046] = 40
                                                                                    mem[_83046 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_83046 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                                else:
                                                                                    _81347 = mem[64]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 96
                                                                                    _82133 = mem[_81347 + 32]
                                                                                    _82134 = mem[_81347 + 64]
                                                                                    mem[mem[64]] = mem[_81347]
                                                                                    mem[mem[64] + 64] = _82134
                                                                                    mem[mem[64] + 96] = gasForProcessing
                                                                                    emit ProcessedDividendTracker(mem[mem[64]], _82133, _82134, gasForProcessing, 1, tx.origin);
                                                                                    _84883 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_84883] = 40
                                                                                    mem[_84883 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_84883 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                    else:
                                                                        if not ext_call.success:
                                                                            if stor7:
                                                                                _81348 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_81348] = 40
                                                                                mem[_81348 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_81348 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                     gas gas_remaining wei
                                                                                    args gasForProcessing
                                                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                                if not ext_call.success:
                                                                                    _83049 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_83049] = 40
                                                                                    mem[_83049 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_83049 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                                else:
                                                                                    _81351 = mem[64]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 96
                                                                                    _82137 = mem[_81351 + 32]
                                                                                    _82138 = mem[_81351 + 64]
                                                                                    mem[mem[64]] = mem[_81351]
                                                                                    mem[mem[64] + 64] = _82138
                                                                                    mem[mem[64] + 96] = gasForProcessing
                                                                                    emit ProcessedDividendTracker(mem[mem[64]], _82137, _82138, gasForProcessing, 1, tx.origin);
                                                                                    _84888 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_84888] = 40
                                                                                    mem[_84888 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_84888 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                        else:
                                                                            if stor7:
                                                                                _81734 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_81734] = 40
                                                                                mem[_81734 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_81734 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                     gas gas_remaining wei
                                                                                    args gasForProcessing
                                                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                                if not ext_call.success:
                                                                                    _83504 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_83504] = 40
                                                                                    mem[_83504 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_83504 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                                else:
                                                                                    _81737 = mem[64]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 96
                                                                                    _82608 = mem[_81737 + 32]
                                                                                    _82609 = mem[_81737 + 64]
                                                                                    mem[mem[64]] = mem[_81737]
                                                                                    mem[mem[64] + 64] = _82609
                                                                                    mem[mem[64] + 96] = gasForProcessing
                                                                                    emit ProcessedDividendTracker(mem[mem[64]], _82608, _82609, gasForProcessing, 1, tx.origin);
                                                                                    _85400 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_85400] = 40
                                                                                    mem[_85400 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_85400 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                else:
                                                                    if cd[68] and 1 > -1 / cd[68]:
                                                                        revert with 0, 17
                                                                    if not cd[68]:
                                                                        revert with 0, 18
                                                                    if cd[68] / cd[68] != 1:
                                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                                    _65669 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_65669] = 26
                                                                    mem[_65669 + 32] = 'SafeMath: division by zero'
                                                                    if cd[68] * totalFees / 100 > !(cd[68] / 100):
                                                                        revert with 0, 17
                                                                    _70699 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_70699] = 30
                                                                    mem[_70699 + 32] = 'SafeMath: subtraction overflow'
                                                                    if (cd[68] * totalFees / 100) + (cd[68] / 100) > cd[68]:
                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                    if cd[68] < (cd[68] * totalFees / 100) + (cd[68] / 100):
                                                                        revert with 0, 17
                                                                    if not address(cd[4]):
                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                    if not this.address:
                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                    _73382 = mem[64]
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_73382] = 38
                                                                    mem[_73382 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                    if (cd[68] * totalFees / 100) + (cd[68] / 100) > balanceOf[address(cd[4])]:
                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[mem[64] + 4] = 32
                                                                        mem[mem[64] + 36] = 38
                                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_73382 + 70 len 26]
                                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                    if balanceOf[address(cd[4])] < (cd[68] * totalFees / 100) + (cd[68] / 100):
                                                                        revert with 0, 17
                                                                    balanceOf[address(cd[4])] = balanceOf[address(cd[4])] - (cd[68] * totalFees / 100) - (cd[68] / 100)
                                                                    if balanceOf[this.address] > !((cd[68] * totalFees / 100) + (cd[68] / 100)):
                                                                        revert with 0, 17
                                                                    if balanceOf[this.address] + (cd[68] * totalFees / 100) + (cd[68] / 100) < balanceOf[this.address]:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    mem[0] = this.address
                                                                    mem[32] = 0
                                                                    balanceOf[address(this.address)] = balanceOf[this.address] + (cd[68] * totalFees / 100) + (cd[68] / 100)
                                                                    emit Transfer(((cd[68] * totalFees / 100) + (cd[68] / 100)), address(cd[4]), this.address);
                                                                    if not address(cd[4]):
                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                    if not address(cd[36]):
                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                    _75674 = mem[64]
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_75674] = 38
                                                                    mem[_75674 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                    if cd[68] - (cd[68] * totalFees / 100) - (cd[68] / 100) > balanceOf[address(cd[4])]:
                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[mem[64] + 4] = 32
                                                                        mem[mem[64] + 36] = 38
                                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_75674 + 70 len 26]
                                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                    if balanceOf[address(cd[4])] < cd[68] - (cd[68] * totalFees / 100) - (cd[68] / 100):
                                                                        revert with 0, 17
                                                                    balanceOf[address(cd[4])] = balanceOf[address(cd[4])] - cd[68] + (cd[68] * totalFees / 100) + (cd[68] / 100)
                                                                    if balanceOf[address(cd[36])] > !(cd[68] - (cd[68] * totalFees / 100) - (cd[68] / 100)):
                                                                        revert with 0, 17
                                                                    if balanceOf[address(cd[36])] + cd[68] - (cd[68] * totalFees / 100) - (cd[68] / 100) < balanceOf[address(cd[36])]:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    balanceOf[address(cd[36])] = balanceOf[address(cd[36])] + cd[68] - (cd[68] * totalFees / 100) - (cd[68] / 100)
                                                                    emit Transfer((cd[68] - (cd[68] * totalFees / 100) - (cd[68] / 100)), address(cd[4]), address(cd[36]));
                                                                    require ext_code.size(dividendTrackerAddress)
                                                                    call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                                         gas gas_remaining wei
                                                                        args address(cd[4]), balanceOf[address(cd[4])]
                                                                    mem[0] = address(cd[36])
                                                                    mem[32] = 0
                                                                    require ext_code.size(dividendTrackerAddress)
                                                                    call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                                         gas gas_remaining wei
                                                                        args address(cd[36]), balanceOf[address(cd[36])]
                                                                    if not ext_call.success:
                                                                        if not ext_call.success:
                                                                            if stor7:
                                                                                _83489 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_83489] = 40
                                                                                mem[_83489 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_83489 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                     gas gas_remaining wei
                                                                                    args gasForProcessing
                                                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                                if not ext_call.success:
                                                                                    _85374 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_85374] = 40
                                                                                    mem[_85374 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_85374 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                                else:
                                                                                    _83492 = mem[64]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 96
                                                                                    _84436 = mem[_83492 + 32]
                                                                                    _84437 = mem[_83492 + 64]
                                                                                    mem[mem[64]] = mem[_83492]
                                                                                    mem[mem[64] + 64] = _84437
                                                                                    mem[mem[64] + 96] = gasForProcessing
                                                                                    emit ProcessedDividendTracker(mem[mem[64]], _84436, _84437, gasForProcessing, 1, tx.origin);
                                                                                    _87300 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_87300] = 40
                                                                                    mem[_87300 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_87300 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                        else:
                                                                            if stor7:
                                                                                _83999 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_83999] = 40
                                                                                mem[_83999 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_83999 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                     gas gas_remaining wei
                                                                                    args gasForProcessing
                                                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                                if not ext_call.success:
                                                                                    _85853 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_85853] = 40
                                                                                    mem[_85853 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_85853 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                                else:
                                                                                    _84002 = mem[64]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 96
                                                                                    _84869 = mem[_84002 + 32]
                                                                                    _84870 = mem[_84002 + 64]
                                                                                    mem[mem[64]] = mem[_84002]
                                                                                    mem[mem[64] + 64] = _84870
                                                                                    mem[mem[64] + 96] = gasForProcessing
                                                                                    emit ProcessedDividendTracker(mem[mem[64]], _84869, _84870, gasForProcessing, 1, tx.origin);
                                                                                    _87762 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_87762] = 40
                                                                                    mem[_87762 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_87762 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                    else:
                                                                        if not ext_call.success:
                                                                            if stor7:
                                                                                _84003 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_84003] = 40
                                                                                mem[_84003 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_84003 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                     gas gas_remaining wei
                                                                                    args gasForProcessing
                                                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                                if not ext_call.success:
                                                                                    _85856 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_85856] = 40
                                                                                    mem[_85856 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_85856 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                                else:
                                                                                    _84006 = mem[64]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 96
                                                                                    _84873 = mem[_84006 + 32]
                                                                                    _84874 = mem[_84006 + 64]
                                                                                    mem[mem[64]] = mem[_84006]
                                                                                    mem[mem[64] + 64] = _84874
                                                                                    mem[mem[64] + 96] = gasForProcessing
                                                                                    emit ProcessedDividendTracker(mem[mem[64]], _84873, _84874, gasForProcessing, 1, tx.origin);
                                                                                    _87767 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_87767] = 40
                                                                                    mem[_87767 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_87767 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                        else:
                                                                            if stor7:
                                                                                _84438 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_84438] = 40
                                                                                mem[_84438 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_84438 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                     gas gas_remaining wei
                                                                                    args gasForProcessing
                                                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                                if not ext_call.success:
                                                                                    _86329 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_86329] = 40
                                                                                    mem[_86329 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_86329 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                                else:
                                                                                    _84441 = mem[64]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 96
                                                                                    _85381 = mem[_84441 + 32]
                                                                                    _85382 = mem[_84441 + 64]
                                                                                    mem[mem[64]] = mem[_84441]
                                                                                    mem[mem[64] + 64] = _85382
                                                                                    mem[mem[64] + 96] = gasForProcessing
                                                                                    emit ProcessedDividendTracker(mem[mem[64]], _85381, _85382, gasForProcessing, 1, tx.origin);
                                                                                    _88187 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_88187] = 40
                                                                                    mem[_88187 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_88187 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                        else:
                                            require ext_code.size(dividendTrackerAddress)
                                            call dividendTrackerAddress.distributeDogeDividends(uint256 arg1) with:
                                                 gas gas_remaining wei
                                                args _62562
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[mem[64] + 32] = _62562
                                            emit SendDividends(balanceOf[this.address], _62562);
                                            stor7 = 0
                                            mem[0] = address(cd[4])
                                            mem[32] = 19
                                            if stor19[address(cd[4])]:
                                                if not address(cd[4]):
                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                if not address(cd[36]):
                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                _62846 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_62846] = 38
                                                mem[_62846 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                if cd[68] > balanceOf[address(cd[4])]:
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 38
                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_62846 + 70 len 26]
                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                if balanceOf[address(cd[4])] < cd[68]:
                                                    revert with 0, 17
                                                balanceOf[address(cd[4])] -= cd[68]
                                                if balanceOf[address(cd[36])] > !cd[68]:
                                                    revert with 0, 17
                                                if balanceOf[address(cd[36])] + cd[68] < balanceOf[address(cd[36])]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(cd[36])] += cd[68]
                                                emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                                                require ext_code.size(dividendTrackerAddress)
                                                call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args address(cd[4]), balanceOf[address(cd[4])]
                                                mem[0] = address(cd[36])
                                                mem[32] = 0
                                                require ext_code.size(dividendTrackerAddress)
                                                call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                     gas gas_remaining wei
                                                    args address(cd[36]), balanceOf[address(cd[36])]
                                                if not ext_call.success:
                                                    if not ext_call.success:
                                                        if stor7:
                                                            _64930 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_64930] = 40
                                                            mem[_64930 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 40
                                                                mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_64930 + 72 len 24]
                                                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                        else:
                                                            call dividendTrackerAddress.process(uint256 arg1) with:
                                                                 gas gas_remaining wei
                                                                args gasForProcessing
                                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                            if not ext_call.success:
                                                                _66470 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_66470] = 40
                                                                mem[_66470 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 40
                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_66470 + 72 len 24]
                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                            else:
                                                                _64933 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 96
                                                                _65684 = mem[_64933 + 32]
                                                                _65685 = mem[_64933 + 64]
                                                                mem[mem[64]] = mem[_64933]
                                                                mem[mem[64] + 64] = _65685
                                                                mem[mem[64] + 96] = gasForProcessing
                                                                emit ProcessedDividendTracker(mem[mem[64]], _65684, _65685, gasForProcessing, 1, tx.origin);
                                                                _68139 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_68139] = 40
                                                                mem[_68139 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 40
                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_68139 + 72 len 24]
                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                    else:
                                                        if stor7:
                                                            _65280 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_65280] = 40
                                                            mem[_65280 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 40
                                                                mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_65280 + 72 len 24]
                                                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                        else:
                                                            call dividendTrackerAddress.process(uint256 arg1) with:
                                                                 gas gas_remaining wei
                                                                args gasForProcessing
                                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                            if not ext_call.success:
                                                                _66878 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_66878] = 40
                                                                mem[_66878 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 40
                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_66878 + 72 len 24]
                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                            else:
                                                                _65283 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 96
                                                                _66077 = mem[_65283 + 32]
                                                                _66078 = mem[_65283 + 64]
                                                                mem[mem[64]] = mem[_65283]
                                                                mem[mem[64] + 64] = _66078
                                                                mem[mem[64] + 96] = gasForProcessing
                                                                emit ProcessedDividendTracker(mem[mem[64]], _66077, _66078, gasForProcessing, 1, tx.origin);
                                                                _68571 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_68571] = 40
                                                                mem[_68571 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 40
                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_68571 + 72 len 24]
                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                else:
                                                    if not ext_call.success:
                                                        if stor7:
                                                            _65284 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_65284] = 40
                                                            mem[_65284 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 40
                                                                mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_65284 + 72 len 24]
                                                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                        else:
                                                            call dividendTrackerAddress.process(uint256 arg1) with:
                                                                 gas gas_remaining wei
                                                                args gasForProcessing
                                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                            if not ext_call.success:
                                                                _66881 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_66881] = 40
                                                                mem[_66881 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 40
                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_66881 + 72 len 24]
                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                            else:
                                                                _65287 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 96
                                                                _66081 = mem[_65287 + 32]
                                                                _66082 = mem[_65287 + 64]
                                                                mem[mem[64]] = mem[_65287]
                                                                mem[mem[64] + 64] = _66082
                                                                mem[mem[64] + 96] = gasForProcessing
                                                                emit ProcessedDividendTracker(mem[mem[64]], _66081, _66082, gasForProcessing, 1, tx.origin);
                                                                _68576 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_68576] = 40
                                                                mem[_68576 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 40
                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_68576 + 72 len 24]
                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                    else:
                                                        if stor7:
                                                            _65686 = mem[64]
                                                            mem[64] = mem[64] + 96
                                                            mem[_65686] = 40
                                                            mem[_65686 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 40
                                                                mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_65686 + 72 len 24]
                                                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                        else:
                                                            call dividendTrackerAddress.process(uint256 arg1) with:
                                                                 gas gas_remaining wei
                                                                args gasForProcessing
                                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                            if not ext_call.success:
                                                                _67287 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_67287] = 40
                                                                mem[_67287 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 40
                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_67287 + 72 len 24]
                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                            else:
                                                                _65689 = mem[64]
                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                require return_data.size >= 96
                                                                _66477 = mem[_65689 + 32]
                                                                _66478 = mem[_65689 + 64]
                                                                mem[mem[64]] = mem[_65689]
                                                                mem[mem[64] + 64] = _66478
                                                                mem[mem[64] + 96] = gasForProcessing
                                                                emit ProcessedDividendTracker(mem[mem[64]], _66477, _66478, gasForProcessing, 1, tx.origin);
                                                                _68987 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_68987] = 40
                                                                mem[_68987 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 40
                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_68987 + 72 len 24]
                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                            else:
                                                mem[0] = address(cd[36])
                                                mem[32] = 19
                                                if stor19[address(cd[36])]:
                                                    if not address(cd[4]):
                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                    if not address(cd[36]):
                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                    _62933 = mem[64]
                                                    mem[64] = mem[64] + 96
                                                    mem[_62933] = 38
                                                    mem[_62933 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                    if cd[68] > balanceOf[address(cd[4])]:
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 38
                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_62933 + 70 len 26]
                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                    if balanceOf[address(cd[4])] < cd[68]:
                                                        revert with 0, 17
                                                    balanceOf[address(cd[4])] -= cd[68]
                                                    if balanceOf[address(cd[36])] > !cd[68]:
                                                        revert with 0, 17
                                                    if balanceOf[address(cd[36])] + cd[68] < balanceOf[address(cd[36])]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    balanceOf[address(cd[36])] += cd[68]
                                                    emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                                                    require ext_code.size(dividendTrackerAddress)
                                                    call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args address(cd[4]), balanceOf[address(cd[4])]
                                                    mem[0] = address(cd[36])
                                                    mem[32] = 0
                                                    require ext_code.size(dividendTrackerAddress)
                                                    call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                         gas gas_remaining wei
                                                        args address(cd[36]), balanceOf[address(cd[36])]
                                                    if not ext_call.success:
                                                        if not ext_call.success:
                                                            if stor7:
                                                                _65302 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_65302] = 40
                                                                mem[_65302 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 40
                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_65302 + 72 len 24]
                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                            else:
                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                     gas gas_remaining wei
                                                                    args gasForProcessing
                                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                if not ext_call.success:
                                                                    _66902 = mem[64]
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_66902] = 40
                                                                    mem[_66902 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[mem[64] + 4] = 32
                                                                        mem[mem[64] + 36] = 40
                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_66902 + 72 len 24]
                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                else:
                                                                    _65305 = mem[64]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 96
                                                                    _66096 = mem[_65305 + 32]
                                                                    _66097 = mem[_65305 + 64]
                                                                    mem[mem[64]] = mem[_65305]
                                                                    mem[mem[64] + 64] = _66097
                                                                    mem[mem[64] + 96] = gasForProcessing
                                                                    emit ProcessedDividendTracker(mem[mem[64]], _66096, _66097, gasForProcessing, 1, tx.origin);
                                                                    _68601 = mem[64]
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_68601] = 40
                                                                    mem[_68601 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[mem[64] + 4] = 32
                                                                        mem[mem[64] + 36] = 40
                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_68601 + 72 len 24]
                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                        else:
                                                            if stor7:
                                                                _65700 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_65700] = 40
                                                                mem[_65700 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 40
                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_65700 + 72 len 24]
                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                            else:
                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                     gas gas_remaining wei
                                                                    args gasForProcessing
                                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                if not ext_call.success:
                                                                    _67305 = mem[64]
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_67305] = 40
                                                                    mem[_67305 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[mem[64] + 4] = 32
                                                                        mem[mem[64] + 36] = 40
                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_67305 + 72 len 24]
                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                else:
                                                                    _65703 = mem[64]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 96
                                                                    _66494 = mem[_65703 + 32]
                                                                    _66495 = mem[_65703 + 64]
                                                                    mem[mem[64]] = mem[_65703]
                                                                    mem[mem[64] + 64] = _66495
                                                                    mem[mem[64] + 96] = gasForProcessing
                                                                    emit ProcessedDividendTracker(mem[mem[64]], _66494, _66495, gasForProcessing, 1, tx.origin);
                                                                    _69021 = mem[64]
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_69021] = 40
                                                                    mem[_69021 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[mem[64] + 4] = 32
                                                                        mem[mem[64] + 36] = 40
                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_69021 + 72 len 24]
                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                    else:
                                                        if not ext_call.success:
                                                            if stor7:
                                                                _65704 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_65704] = 40
                                                                mem[_65704 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 40
                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_65704 + 72 len 24]
                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                            else:
                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                     gas gas_remaining wei
                                                                    args gasForProcessing
                                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                if not ext_call.success:
                                                                    _67308 = mem[64]
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_67308] = 40
                                                                    mem[_67308 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[mem[64] + 4] = 32
                                                                        mem[mem[64] + 36] = 40
                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_67308 + 72 len 24]
                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                else:
                                                                    _65707 = mem[64]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 96
                                                                    _66498 = mem[_65707 + 32]
                                                                    _66499 = mem[_65707 + 64]
                                                                    mem[mem[64]] = mem[_65707]
                                                                    mem[mem[64] + 64] = _66499
                                                                    mem[mem[64] + 96] = gasForProcessing
                                                                    emit ProcessedDividendTracker(mem[mem[64]], _66498, _66499, gasForProcessing, 1, tx.origin);
                                                                    _69026 = mem[64]
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_69026] = 40
                                                                    mem[_69026 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[mem[64] + 4] = 32
                                                                        mem[mem[64] + 36] = 40
                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_69026 + 72 len 24]
                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                        else:
                                                            if stor7:
                                                                _66098 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_66098] = 40
                                                                mem[_66098 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 40
                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_66098 + 72 len 24]
                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                            else:
                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                     gas gas_remaining wei
                                                                    args gasForProcessing
                                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                if not ext_call.success:
                                                                    _67712 = mem[64]
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_67712] = 40
                                                                    mem[_67712 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[mem[64] + 4] = 32
                                                                        mem[mem[64] + 36] = 40
                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_67712 + 72 len 24]
                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                else:
                                                                    _66101 = mem[64]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 96
                                                                    _66909 = mem[_66101 + 32]
                                                                    _66910 = mem[_66101 + 64]
                                                                    mem[mem[64]] = mem[_66101]
                                                                    mem[mem[64] + 64] = _66910
                                                                    mem[mem[64] + 96] = gasForProcessing
                                                                    emit ProcessedDividendTracker(mem[mem[64]], _66909, _66910, gasForProcessing, 1, tx.origin);
                                                                    _69514 = mem[64]
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_69514] = 40
                                                                    mem[_69514 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[mem[64] + 4] = 32
                                                                        mem[mem[64] + 36] = 40
                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_69514 + 72 len 24]
                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                else:
                                                    if stor7:
                                                        if not address(cd[4]):
                                                            revert with 0, 'ERC20: transfer from the zero address'
                                                        if not address(cd[36]):
                                                            revert with 0, 'ERC20: transfer to the zero address'
                                                        _62849 = mem[64]
                                                        mem[64] = mem[64] + 96
                                                        mem[_62849] = 38
                                                        mem[_62849 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                        if cd[68] > balanceOf[address(cd[4])]:
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 38
                                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_62849 + 70 len 26]
                                                            revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                        if balanceOf[address(cd[4])] < cd[68]:
                                                            revert with 0, 17
                                                        balanceOf[address(cd[4])] -= cd[68]
                                                        if balanceOf[address(cd[36])] > !cd[68]:
                                                            revert with 0, 17
                                                        if balanceOf[address(cd[36])] + cd[68] < balanceOf[address(cd[36])]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        balanceOf[address(cd[36])] += cd[68]
                                                        emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                                                        require ext_code.size(dividendTrackerAddress)
                                                        call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args address(cd[4]), balanceOf[address(cd[4])]
                                                        mem[0] = address(cd[36])
                                                        mem[32] = 0
                                                        require ext_code.size(dividendTrackerAddress)
                                                        call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                             gas gas_remaining wei
                                                            args address(cd[36]), balanceOf[address(cd[36])]
                                                        if not ext_call.success:
                                                            if not ext_call.success:
                                                                if stor7:
                                                                    _64938 = mem[64]
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_64938] = 40
                                                                    mem[_64938 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[mem[64] + 4] = 32
                                                                        mem[mem[64] + 36] = 40
                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_64938 + 72 len 24]
                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                else:
                                                                    call dividendTrackerAddress.process(uint256 arg1) with:
                                                                         gas gas_remaining wei
                                                                        args gasForProcessing
                                                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                    if not ext_call.success:
                                                                        _66479 = mem[64]
                                                                        mem[64] = mem[64] + 96
                                                                        mem[_66479] = 40
                                                                        mem[_66479 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                        if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                            mem[mem[64] + 4] = 32
                                                                            mem[mem[64] + 36] = 40
                                                                            mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_66479 + 72 len 24]
                                                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                    else:
                                                                        _64941 = mem[64]
                                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                                        require return_data.size >= 96
                                                                        _65692 = mem[_64941 + 32]
                                                                        _65693 = mem[_64941 + 64]
                                                                        mem[mem[64]] = mem[_64941]
                                                                        mem[mem[64] + 64] = _65693
                                                                        mem[mem[64] + 96] = gasForProcessing
                                                                        emit ProcessedDividendTracker(mem[mem[64]], _65692, _65693, gasForProcessing, 1, tx.origin);
                                                                        _68149 = mem[64]
                                                                        mem[64] = mem[64] + 96
                                                                        mem[_68149] = 40
                                                                        mem[_68149 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                        if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                            mem[mem[64] + 4] = 32
                                                                            mem[mem[64] + 36] = 40
                                                                            mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_68149 + 72 len 24]
                                                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                            else:
                                                                if stor7:
                                                                    _65290 = mem[64]
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_65290] = 40
                                                                    mem[_65290 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[mem[64] + 4] = 32
                                                                        mem[mem[64] + 36] = 40
                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_65290 + 72 len 24]
                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                else:
                                                                    call dividendTrackerAddress.process(uint256 arg1) with:
                                                                         gas gas_remaining wei
                                                                        args gasForProcessing
                                                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                    if not ext_call.success:
                                                                        _66888 = mem[64]
                                                                        mem[64] = mem[64] + 96
                                                                        mem[_66888] = 40
                                                                        mem[_66888 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                        if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                            mem[mem[64] + 4] = 32
                                                                            mem[mem[64] + 36] = 40
                                                                            mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_66888 + 72 len 24]
                                                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                    else:
                                                                        _65293 = mem[64]
                                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                                        require return_data.size >= 96
                                                                        _66086 = mem[_65293 + 32]
                                                                        _66087 = mem[_65293 + 64]
                                                                        mem[mem[64]] = mem[_65293]
                                                                        mem[mem[64] + 64] = _66087
                                                                        mem[mem[64] + 96] = gasForProcessing
                                                                        emit ProcessedDividendTracker(mem[mem[64]], _66086, _66087, gasForProcessing, 1, tx.origin);
                                                                        _68589 = mem[64]
                                                                        mem[64] = mem[64] + 96
                                                                        mem[_68589] = 40
                                                                        mem[_68589 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                        if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                            mem[mem[64] + 4] = 32
                                                                            mem[mem[64] + 36] = 40
                                                                            mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_68589 + 72 len 24]
                                                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                        else:
                                                            if not ext_call.success:
                                                                if stor7:
                                                                    _65294 = mem[64]
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_65294] = 40
                                                                    mem[_65294 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[mem[64] + 4] = 32
                                                                        mem[mem[64] + 36] = 40
                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_65294 + 72 len 24]
                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                else:
                                                                    call dividendTrackerAddress.process(uint256 arg1) with:
                                                                         gas gas_remaining wei
                                                                        args gasForProcessing
                                                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                    if not ext_call.success:
                                                                        _66891 = mem[64]
                                                                        mem[64] = mem[64] + 96
                                                                        mem[_66891] = 40
                                                                        mem[_66891 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                        if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                            mem[mem[64] + 4] = 32
                                                                            mem[mem[64] + 36] = 40
                                                                            mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_66891 + 72 len 24]
                                                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                    else:
                                                                        _65297 = mem[64]
                                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                                        require return_data.size >= 96
                                                                        _66090 = mem[_65297 + 32]
                                                                        _66091 = mem[_65297 + 64]
                                                                        mem[mem[64]] = mem[_65297]
                                                                        mem[mem[64] + 64] = _66091
                                                                        mem[mem[64] + 96] = gasForProcessing
                                                                        emit ProcessedDividendTracker(mem[mem[64]], _66090, _66091, gasForProcessing, 1, tx.origin);
                                                                        _68594 = mem[64]
                                                                        mem[64] = mem[64] + 96
                                                                        mem[_68594] = 40
                                                                        mem[_68594 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                        if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                            mem[mem[64] + 4] = 32
                                                                            mem[mem[64] + 36] = 40
                                                                            mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_68594 + 72 len 24]
                                                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                            else:
                                                                if stor7:
                                                                    _65694 = mem[64]
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_65694] = 40
                                                                    mem[_65694 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[mem[64] + 4] = 32
                                                                        mem[mem[64] + 36] = 40
                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_65694 + 72 len 24]
                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                else:
                                                                    call dividendTrackerAddress.process(uint256 arg1) with:
                                                                         gas gas_remaining wei
                                                                        args gasForProcessing
                                                                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                    if not ext_call.success:
                                                                        _67297 = mem[64]
                                                                        mem[64] = mem[64] + 96
                                                                        mem[_67297] = 40
                                                                        mem[_67297 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                        if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                            mem[mem[64] + 4] = 32
                                                                            mem[mem[64] + 36] = 40
                                                                            mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_67297 + 72 len 24]
                                                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                    else:
                                                                        _65697 = mem[64]
                                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                                        require return_data.size >= 96
                                                                        _66486 = mem[_65697 + 32]
                                                                        _66487 = mem[_65697 + 64]
                                                                        mem[mem[64]] = mem[_65697]
                                                                        mem[mem[64] + 64] = _66487
                                                                        mem[mem[64] + 96] = gasForProcessing
                                                                        emit ProcessedDividendTracker(mem[mem[64]], _66486, _66487, gasForProcessing, 1, tx.origin);
                                                                        _69007 = mem[64]
                                                                        mem[64] = mem[64] + 96
                                                                        mem[_69007] = 40
                                                                        mem[_69007 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                        if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                            mem[mem[64] + 4] = 32
                                                                            mem[mem[64] + 36] = 40
                                                                            mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_69007 + 72 len 24]
                                                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                    else:
                                                        if not cd[68]:
                                                            _62984 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_62984] = 26
                                                            mem[_62984 + 32] = 'SafeMath: division by zero'
                                                            mem[0] = address(cd[36])
                                                            mem[32] = 20
                                                            if not stor20[address(cd[36])]:
                                                                _63504 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_63504] = 30
                                                                mem[_63504 + 32] = 'SafeMath: subtraction overflow'
                                                                if 0 > cd[68]:
                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                if cd[68] < 0:
                                                                    revert with 0, 17
                                                                if not address(cd[4]):
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not this.address:
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                _64687 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_64687] = 38
                                                                mem[_64687 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                if 0 > balanceOf[address(cd[4])]:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 38
                                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_64687 + 70 len 26]
                                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                if balanceOf[address(cd[4])] < 0:
                                                                    revert with 0, 17
                                                                if balanceOf[this.address] > -1:
                                                                    revert with 0, 17
                                                                if balanceOf[this.address] < balanceOf[this.address]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[0] = this.address
                                                                mem[32] = 0
                                                                balanceOf[address(this.address)] = balanceOf[this.address]
                                                                emit Transfer(0, address(cd[4]), this.address);
                                                                if not address(cd[4]):
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not address(cd[36]):
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                _71921 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_71921] = 38
                                                                mem[_71921 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                if cd[68] > balanceOf[address(cd[4])]:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 38
                                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_71921 + 70 len 26]
                                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                if balanceOf[address(cd[4])] < cd[68]:
                                                                    revert with 0, 17
                                                                balanceOf[address(cd[4])] -= cd[68]
                                                                if balanceOf[address(cd[36])] > !cd[68]:
                                                                    revert with 0, 17
                                                                if balanceOf[address(cd[36])] + cd[68] < balanceOf[address(cd[36])]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                balanceOf[address(cd[36])] += cd[68]
                                                                emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                                                                require ext_code.size(dividendTrackerAddress)
                                                                call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                                     gas gas_remaining wei
                                                                    args address(cd[4]), balanceOf[address(cd[4])]
                                                                mem[0] = address(cd[36])
                                                                mem[32] = 0
                                                                require ext_code.size(dividendTrackerAddress)
                                                                call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                                     gas gas_remaining wei
                                                                    args address(cd[36]), balanceOf[address(cd[36])]
                                                                if not ext_call.success:
                                                                    if not ext_call.success:
                                                                        if stor7:
                                                                            _75069 = mem[64]
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_75069] = 40
                                                                            mem[_75069 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[mem[64] + 4] = 32
                                                                                mem[mem[64] + 36] = 40
                                                                                mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_75069 + 72 len 24]
                                                                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                        else:
                                                                            call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                 gas gas_remaining wei
                                                                                args gasForProcessing
                                                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                            if not ext_call.success:
                                                                                _75983 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_75983] = 40
                                                                                mem[_75983 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_75983 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                _75072 = mem[64]
                                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                                require return_data.size >= 96
                                                                                _75473 = mem[_75072 + 32]
                                                                                _75474 = mem[_75072 + 64]
                                                                                mem[mem[64]] = mem[_75072]
                                                                                mem[mem[64] + 64] = _75474
                                                                                mem[mem[64] + 96] = gasForProcessing
                                                                                emit ProcessedDividendTracker(mem[mem[64]], _75473, _75474, gasForProcessing, 1, tx.origin);
                                                                                _77087 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_77087] = 40
                                                                                mem[_77087 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_77087 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                    else:
                                                                        if stor7:
                                                                            _75306 = mem[64]
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_75306] = 40
                                                                            mem[_75306 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[mem[64] + 4] = 32
                                                                                mem[mem[64] + 36] = 40
                                                                                mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_75306 + 72 len 24]
                                                                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                        else:
                                                                            call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                 gas gas_remaining wei
                                                                                args gasForProcessing
                                                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                            if not ext_call.success:
                                                                                _76188 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_76188] = 40
                                                                                mem[_76188 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_76188 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                _75309 = mem[64]
                                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                                require return_data.size >= 96
                                                                                _75700 = mem[_75309 + 32]
                                                                                _75701 = mem[_75309 + 64]
                                                                                mem[mem[64]] = mem[_75309]
                                                                                mem[mem[64] + 64] = _75701
                                                                                mem[mem[64] + 96] = gasForProcessing
                                                                                emit ProcessedDividendTracker(mem[mem[64]], _75700, _75701, gasForProcessing, 1, tx.origin);
                                                                                _77391 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_77391] = 40
                                                                                mem[_77391 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_77391 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                else:
                                                                    if not ext_call.success:
                                                                        if stor7:
                                                                            _75310 = mem[64]
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_75310] = 40
                                                                            mem[_75310 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[mem[64] + 4] = 32
                                                                                mem[mem[64] + 36] = 40
                                                                                mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_75310 + 72 len 24]
                                                                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                        else:
                                                                            call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                 gas gas_remaining wei
                                                                                args gasForProcessing
                                                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                            if not ext_call.success:
                                                                                _76191 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_76191] = 40
                                                                                mem[_76191 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_76191 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                _75313 = mem[64]
                                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                                require return_data.size >= 96
                                                                                _75704 = mem[_75313 + 32]
                                                                                _75705 = mem[_75313 + 64]
                                                                                mem[mem[64]] = mem[_75313]
                                                                                mem[mem[64] + 64] = _75705
                                                                                mem[mem[64] + 96] = gasForProcessing
                                                                                emit ProcessedDividendTracker(mem[mem[64]], _75704, _75705, gasForProcessing, 1, tx.origin);
                                                                                _77396 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_77396] = 40
                                                                                mem[_77396 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_77396 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                    else:
                                                                        if stor7:
                                                                            _75475 = mem[64]
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_75475] = 40
                                                                            mem[_75475 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[mem[64] + 4] = 32
                                                                                mem[mem[64] + 36] = 40
                                                                                mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_75475 + 72 len 24]
                                                                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                        else:
                                                                            call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                 gas gas_remaining wei
                                                                                args gasForProcessing
                                                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                            if not ext_call.success:
                                                                                _76452 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_76452] = 40
                                                                                mem[_76452 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_76452 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                _75478 = mem[64]
                                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                                require return_data.size >= 96
                                                                                _75990 = mem[_75478 + 32]
                                                                                _75991 = mem[_75478 + 64]
                                                                                mem[mem[64]] = mem[_75478]
                                                                                mem[mem[64] + 64] = _75991
                                                                                mem[mem[64] + 96] = gasForProcessing
                                                                                emit ProcessedDividendTracker(mem[mem[64]], _75990, _75991, gasForProcessing, 1, tx.origin);
                                                                                _77767 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_77767] = 40
                                                                                mem[_77767 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_77767 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                            else:
                                                                if not cd[68]:
                                                                    _63807 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_63807] = 26
                                                                    mem[_63807 + 32] = 'SafeMath: division by zero'
                                                                    _66901 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_66901] = 30
                                                                    mem[_66901 + 32] = 'SafeMath: subtraction overflow'
                                                                    if 0 > cd[68]:
                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                    if cd[68] < 0:
                                                                        revert with 0, 17
                                                                    if not address(cd[4]):
                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                    if not this.address:
                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                    _71190 = mem[64]
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_71190] = 38
                                                                    mem[_71190 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                    if 0 > balanceOf[address(cd[4])]:
                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[mem[64] + 4] = 32
                                                                        mem[mem[64] + 36] = 38
                                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_71190 + 70 len 26]
                                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                    if balanceOf[address(cd[4])] < 0:
                                                                        revert with 0, 17
                                                                    if balanceOf[this.address] > -1:
                                                                        revert with 0, 17
                                                                    if balanceOf[this.address] < balanceOf[this.address]:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    mem[0] = this.address
                                                                    mem[32] = 0
                                                                    balanceOf[address(this.address)] = balanceOf[this.address]
                                                                    emit Transfer(0, address(cd[4]), this.address);
                                                                    if not address(cd[4]):
                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                    if not address(cd[36]):
                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                    _74294 = mem[64]
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_74294] = 38
                                                                    mem[_74294 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                    if cd[68] > balanceOf[address(cd[4])]:
                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[mem[64] + 4] = 32
                                                                        mem[mem[64] + 36] = 38
                                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_74294 + 70 len 26]
                                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                    if balanceOf[address(cd[4])] < cd[68]:
                                                                        revert with 0, 17
                                                                    balanceOf[address(cd[4])] -= cd[68]
                                                                    if balanceOf[address(cd[36])] > !cd[68]:
                                                                        revert with 0, 17
                                                                    if balanceOf[address(cd[36])] + cd[68] < balanceOf[address(cd[36])]:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    balanceOf[address(cd[36])] += cd[68]
                                                                    emit Transfer(cd[68], address(cd[4]), address(cd[36]));
                                                                    require ext_code.size(dividendTrackerAddress)
                                                                    call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                                         gas gas_remaining wei
                                                                        args address(cd[4]), balanceOf[address(cd[4])]
                                                                    mem[0] = address(cd[36])
                                                                    mem[32] = 0
                                                                    require ext_code.size(dividendTrackerAddress)
                                                                    call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                                         gas gas_remaining wei
                                                                        args address(cd[36]), balanceOf[address(cd[36])]
                                                                    if not ext_call.success:
                                                                        if not ext_call.success:
                                                                            if stor7:
                                                                                _79836 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_79836] = 40
                                                                                mem[_79836 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_79836 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                     gas gas_remaining wei
                                                                                    args gasForProcessing
                                                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                                if not ext_call.success:
                                                                                    _81395 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_81395] = 40
                                                                                    mem[_81395 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_81395 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                                else:
                                                                                    _79839 = mem[64]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 96
                                                                                    _80575 = mem[_79839 + 32]
                                                                                    _80576 = mem[_79839 + 64]
                                                                                    mem[mem[64]] = mem[_79839]
                                                                                    mem[mem[64] + 64] = _80576
                                                                                    mem[mem[64] + 96] = gasForProcessing
                                                                                    emit ProcessedDividendTracker(mem[mem[64]], _80575, _80576, gasForProcessing, 1, tx.origin);
                                                                                    _83115 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_83115] = 40
                                                                                    mem[_83115 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_83115 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                        else:
                                                                            if stor7:
                                                                                _80212 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_80212] = 40
                                                                                mem[_80212 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_80212 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                     gas gas_remaining wei
                                                                                    args gasForProcessing
                                                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                                if not ext_call.success:
                                                                                    _81780 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_81780] = 40
                                                                                    mem[_81780 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_81780 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                                else:
                                                                                    _80215 = mem[64]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 96
                                                                                    _80979 = mem[_80215 + 32]
                                                                                    _80980 = mem[_80215 + 64]
                                                                                    mem[mem[64]] = mem[_80215]
                                                                                    mem[mem[64] + 64] = _80980
                                                                                    mem[mem[64] + 96] = gasForProcessing
                                                                                    emit ProcessedDividendTracker(mem[mem[64]], _80979, _80980, gasForProcessing, 1, tx.origin);
                                                                                    _83565 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_83565] = 40
                                                                                    mem[_83565 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_83565 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                    else:
                                                                        if not ext_call.success:
                                                                            if stor7:
                                                                                _80216 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_80216] = 40
                                                                                mem[_80216 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_80216 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                     gas gas_remaining wei
                                                                                    args gasForProcessing
                                                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                                if not ext_call.success:
                                                                                    _81783 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_81783] = 40
                                                                                    mem[_81783 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_81783 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                                else:
                                                                                    _80219 = mem[64]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 96
                                                                                    _80983 = mem[_80219 + 32]
                                                                                    _80984 = mem[_80219 + 64]
                                                                                    mem[mem[64]] = mem[_80219]
                                                                                    mem[mem[64] + 64] = _80984
                                                                                    mem[mem[64] + 96] = gasForProcessing
                                                                                    emit ProcessedDividendTracker(mem[mem[64]], _80983, _80984, gasForProcessing, 1, tx.origin);
                                                                                    _83570 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_83570] = 40
                                                                                    mem[_83570 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_83570 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                        else:
                                                                            if stor7:
                                                                                _80577 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_80577] = 40
                                                                                mem[_80577 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_80577 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                     gas gas_remaining wei
                                                                                    args gasForProcessing
                                                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                                if not ext_call.success:
                                                                                    _82199 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_82199] = 40
                                                                                    mem[_82199 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_82199 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                                else:
                                                                                    _80580 = mem[64]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 96
                                                                                    _81402 = mem[_80580 + 32]
                                                                                    _81403 = mem[_80580 + 64]
                                                                                    mem[mem[64]] = mem[_80580]
                                                                                    mem[mem[64] + 64] = _81403
                                                                                    mem[mem[64] + 96] = gasForProcessing
                                                                                    emit ProcessedDividendTracker(mem[mem[64]], _81402, _81403, gasForProcessing, 1, tx.origin);
                                                                                    _84076 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_84076] = 40
                                                                                    mem[_84076 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_84076 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                else:
                                                                    if cd[68] and 1 > -1 / cd[68]:
                                                                        revert with 0, 17
                                                                    if not cd[68]:
                                                                        revert with 0, 18
                                                                    if cd[68] / cd[68] != 1:
                                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                                    _64690 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_64690] = 26
                                                                    mem[_64690 + 32] = 'SafeMath: division by zero'
                                                                    if 0 > !(cd[68] / 100):
                                                                        revert with 0, 17
                                                                    _69496 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_69496] = 30
                                                                    mem[_69496 + 32] = 'SafeMath: subtraction overflow'
                                                                    if cd[68] / 100 > cd[68]:
                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                    if cd[68] < cd[68] / 100:
                                                                        revert with 0, 17
                                                                    if not address(cd[4]):
                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                    if not this.address:
                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                    _72997 = mem[64]
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_72997] = 38
                                                                    mem[_72997 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                    if cd[68] / 100 > balanceOf[address(cd[4])]:
                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[mem[64] + 4] = 32
                                                                        mem[mem[64] + 36] = 38
                                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_72997 + 70 len 26]
                                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                    if balanceOf[address(cd[4])] < cd[68] / 100:
                                                                        revert with 0, 17
                                                                    balanceOf[address(cd[4])] -= cd[68] / 100
                                                                    if balanceOf[this.address] > !(cd[68] / 100):
                                                                        revert with 0, 17
                                                                    if balanceOf[this.address] + (cd[68] / 100) < balanceOf[this.address]:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    mem[0] = this.address
                                                                    mem[32] = 0
                                                                    balanceOf[address(this.address)] = balanceOf[this.address] + (cd[68] / 100)
                                                                    emit Transfer((cd[68] / 100), address(cd[4]), this.address);
                                                                    if not address(cd[4]):
                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                    if not address(cd[36]):
                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                    _75077 = mem[64]
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_75077] = 38
                                                                    mem[_75077 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                    if cd[68] - (cd[68] / 100) > balanceOf[address(cd[4])]:
                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[mem[64] + 4] = 32
                                                                        mem[mem[64] + 36] = 38
                                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_75077 + 70 len 26]
                                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                    if balanceOf[address(cd[4])] < cd[68] - (cd[68] / 100):
                                                                        revert with 0, 17
                                                                    balanceOf[address(cd[4])] = balanceOf[address(cd[4])] - cd[68] + (cd[68] / 100)
                                                                    if balanceOf[address(cd[36])] > !(cd[68] - (cd[68] / 100)):
                                                                        revert with 0, 17
                                                                    if balanceOf[address(cd[36])] + cd[68] - (cd[68] / 100) < balanceOf[address(cd[36])]:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    balanceOf[address(cd[36])] = balanceOf[address(cd[36])] + cd[68] - (cd[68] / 100)
                                                                    emit Transfer((cd[68] - (cd[68] / 100)), address(cd[4]), address(cd[36]));
                                                                    require ext_code.size(dividendTrackerAddress)
                                                                    call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                                         gas gas_remaining wei
                                                                        args address(cd[4]), balanceOf[address(cd[4])]
                                                                    mem[0] = address(cd[36])
                                                                    mem[32] = 0
                                                                    require ext_code.size(dividendTrackerAddress)
                                                                    call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                                         gas gas_remaining wei
                                                                        args address(cd[36]), balanceOf[address(cd[36])]
                                                                    if not ext_call.success:
                                                                        if not ext_call.success:
                                                                            if stor7:
                                                                                _82184 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_82184] = 40
                                                                                mem[_82184 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_82184 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                     gas gas_remaining wei
                                                                                    args gasForProcessing
                                                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                                if not ext_call.success:
                                                                                    _84050 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_84050] = 40
                                                                                    mem[_84050 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_84050 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                                else:
                                                                                    _82187 = mem[64]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 96
                                                                                    _83107 = mem[_82187 + 32]
                                                                                    _83108 = mem[_82187 + 64]
                                                                                    mem[mem[64]] = mem[_82187]
                                                                                    mem[mem[64] + 64] = _83108
                                                                                    mem[mem[64] + 96] = gasForProcessing
                                                                                    emit ProcessedDividendTracker(mem[mem[64]], _83107, _83108, gasForProcessing, 1, tx.origin);
                                                                                    _85921 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_85921] = 40
                                                                                    mem[_85921 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_85921 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                        else:
                                                                            if stor7:
                                                                                _82664 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_82664] = 40
                                                                                mem[_82664 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_82664 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                     gas gas_remaining wei
                                                                                    args gasForProcessing
                                                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                                if not ext_call.success:
                                                                                    _84499 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_84499] = 40
                                                                                    mem[_84499 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_84499 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                                else:
                                                                                    _82667 = mem[64]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 96
                                                                                    _83551 = mem[_82667 + 32]
                                                                                    _83552 = mem[_82667 + 64]
                                                                                    mem[mem[64]] = mem[_82667]
                                                                                    mem[mem[64] + 64] = _83552
                                                                                    mem[mem[64] + 96] = gasForProcessing
                                                                                    emit ProcessedDividendTracker(mem[mem[64]], _83551, _83552, gasForProcessing, 1, tx.origin);
                                                                                    _86404 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_86404] = 40
                                                                                    mem[_86404 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_86404 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                    else:
                                                                        if not ext_call.success:
                                                                            if stor7:
                                                                                _82668 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_82668] = 40
                                                                                mem[_82668 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_82668 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                     gas gas_remaining wei
                                                                                    args gasForProcessing
                                                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                                if not ext_call.success:
                                                                                    _84502 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_84502] = 40
                                                                                    mem[_84502 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_84502 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                                else:
                                                                                    _82671 = mem[64]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 96
                                                                                    _83555 = mem[_82671 + 32]
                                                                                    _83556 = mem[_82671 + 64]
                                                                                    mem[mem[64]] = mem[_82671]
                                                                                    mem[mem[64] + 64] = _83556
                                                                                    mem[mem[64] + 96] = gasForProcessing
                                                                                    emit ProcessedDividendTracker(mem[mem[64]], _83555, _83556, gasForProcessing, 1, tx.origin);
                                                                                    _86409 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_86409] = 40
                                                                                    mem[_86409 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_86409 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                        else:
                                                                            if stor7:
                                                                                _83109 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_83109] = 40
                                                                                mem[_83109 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_83109 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                     gas gas_remaining wei
                                                                                    args gasForProcessing
                                                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                                if not ext_call.success:
                                                                                    _84951 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_84951] = 40
                                                                                    mem[_84951 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_84951 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                                else:
                                                                                    _83112 = mem[64]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 96
                                                                                    _84057 = mem[_83112 + 32]
                                                                                    _84058 = mem[_83112 + 64]
                                                                                    mem[mem[64]] = mem[_83112]
                                                                                    mem[mem[64] + 64] = _84058
                                                                                    mem[mem[64] + 96] = gasForProcessing
                                                                                    emit ProcessedDividendTracker(mem[mem[64]], _84057, _84058, gasForProcessing, 1, tx.origin);
                                                                                    _86919 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_86919] = 40
                                                                                    mem[_86919 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_86919 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                        else:
                                                            if cd[68] and totalFees > -1 / cd[68]:
                                                                revert with 0, 17
                                                            if not cd[68]:
                                                                revert with 0, 18
                                                            if cd[68] * totalFees / cd[68] != totalFees:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _63327 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_63327] = 26
                                                            mem[_63327 + 32] = 'SafeMath: division by zero'
                                                            mem[0] = address(cd[36])
                                                            mem[32] = 20
                                                            if not stor20[address(cd[36])]:
                                                                _64025 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_64025] = 30
                                                                mem[_64025 + 32] = 'SafeMath: subtraction overflow'
                                                                if cd[68] * totalFees / 100 > cd[68]:
                                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                                if cd[68] < cd[68] * totalFees / 100:
                                                                    revert with 0, 17
                                                                if not address(cd[4]):
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not this.address:
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                _66895 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_66895] = 38
                                                                mem[_66895 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                if cd[68] * totalFees / 100 > balanceOf[address(cd[4])]:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 38
                                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_66895 + 70 len 26]
                                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                if balanceOf[address(cd[4])] < cd[68] * totalFees / 100:
                                                                    revert with 0, 17
                                                                balanceOf[address(cd[4])] -= cd[68] * totalFees / 100
                                                                if balanceOf[this.address] > !(cd[68] * totalFees / 100):
                                                                    revert with 0, 17
                                                                if balanceOf[this.address] + (cd[68] * totalFees / 100) < balanceOf[this.address]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                mem[0] = this.address
                                                                mem[32] = 0
                                                                balanceOf[address(this.address)] = balanceOf[this.address] + (cd[68] * totalFees / 100)
                                                                emit Transfer((cd[68] * totalFees / 100), address(cd[4]), this.address);
                                                                if not address(cd[4]):
                                                                    revert with 0, 'ERC20: transfer from the zero address'
                                                                if not address(cd[36]):
                                                                    revert with 0, 'ERC20: transfer to the zero address'
                                                                _73249 = mem[64]
                                                                mem[64] = mem[64] + 96
                                                                mem[_73249] = 38
                                                                mem[_73249 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                if cd[68] - (cd[68] * totalFees / 100) > balanceOf[address(cd[4])]:
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 38
                                                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_73249 + 70 len 26]
                                                                    revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                if balanceOf[address(cd[4])] < cd[68] - (cd[68] * totalFees / 100):
                                                                    revert with 0, 17
                                                                balanceOf[address(cd[4])] = balanceOf[address(cd[4])] - cd[68] + (cd[68] * totalFees / 100)
                                                                if balanceOf[address(cd[36])] > !(cd[68] - (cd[68] * totalFees / 100)):
                                                                    revert with 0, 17
                                                                if balanceOf[address(cd[36])] + cd[68] - (cd[68] * totalFees / 100) < balanceOf[address(cd[36])]:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                balanceOf[address(cd[36])] = balanceOf[address(cd[36])] + cd[68] - (cd[68] * totalFees / 100)
                                                                emit Transfer((cd[68] - (cd[68] * totalFees / 100)), address(cd[4]), address(cd[36]));
                                                                require ext_code.size(dividendTrackerAddress)
                                                                call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                                     gas gas_remaining wei
                                                                    args address(cd[4]), balanceOf[address(cd[4])]
                                                                mem[0] = address(cd[36])
                                                                mem[32] = 0
                                                                require ext_code.size(dividendTrackerAddress)
                                                                call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                                     gas gas_remaining wei
                                                                    args address(cd[36]), balanceOf[address(cd[36])]
                                                                if not ext_call.success:
                                                                    if not ext_call.success:
                                                                        if stor7:
                                                                            _76432 = mem[64]
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_76432] = 40
                                                                            mem[_76432 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[mem[64] + 4] = 32
                                                                                mem[mem[64] + 36] = 40
                                                                                mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_76432 + 72 len 24]
                                                                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                        else:
                                                                            call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                 gas gas_remaining wei
                                                                                args gasForProcessing
                                                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                            if not ext_call.success:
                                                                                _77741 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_77741] = 40
                                                                                mem[_77741 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_77741 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                _76435 = mem[64]
                                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                                require return_data.size >= 96
                                                                                _77076 = mem[_76435 + 32]
                                                                                _77077 = mem[_76435 + 64]
                                                                                mem[mem[64]] = mem[_76435]
                                                                                mem[mem[64] + 64] = _77077
                                                                                mem[mem[64] + 96] = gasForProcessing
                                                                                emit ProcessedDividendTracker(mem[mem[64]], _77076, _77077, gasForProcessing, 1, tx.origin);
                                                                                _79044 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_79044] = 40
                                                                                mem[_79044 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_79044 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                    else:
                                                                        if stor7:
                                                                            _76795 = mem[64]
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_76795] = 40
                                                                            mem[_76795 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[mem[64] + 4] = 32
                                                                                mem[mem[64] + 36] = 40
                                                                                mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_76795 + 72 len 24]
                                                                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                        else:
                                                                            call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                 gas gas_remaining wei
                                                                                args gasForProcessing
                                                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                            if not ext_call.success:
                                                                                _78045 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_78045] = 40
                                                                                mem[_78045 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_78045 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                _76798 = mem[64]
                                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                                require return_data.size >= 96
                                                                                _77376 = mem[_76798 + 32]
                                                                                _77377 = mem[_76798 + 64]
                                                                                mem[mem[64]] = mem[_76798]
                                                                                mem[mem[64] + 64] = _77377
                                                                                mem[mem[64] + 96] = gasForProcessing
                                                                                emit ProcessedDividendTracker(mem[mem[64]], _77376, _77377, gasForProcessing, 1, tx.origin);
                                                                                _79406 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_79406] = 40
                                                                                mem[_79406 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_79406 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                else:
                                                                    if not ext_call.success:
                                                                        if stor7:
                                                                            _76799 = mem[64]
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_76799] = 40
                                                                            mem[_76799 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[mem[64] + 4] = 32
                                                                                mem[mem[64] + 36] = 40
                                                                                mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_76799 + 72 len 24]
                                                                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                        else:
                                                                            call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                 gas gas_remaining wei
                                                                                args gasForProcessing
                                                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                            if not ext_call.success:
                                                                                _78048 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_78048] = 40
                                                                                mem[_78048 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_78048 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                _76802 = mem[64]
                                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                                require return_data.size >= 96
                                                                                _77380 = mem[_76802 + 32]
                                                                                _77381 = mem[_76802 + 64]
                                                                                mem[mem[64]] = mem[_76802]
                                                                                mem[mem[64] + 64] = _77381
                                                                                mem[mem[64] + 96] = gasForProcessing
                                                                                emit ProcessedDividendTracker(mem[mem[64]], _77380, _77381, gasForProcessing, 1, tx.origin);
                                                                                _79411 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_79411] = 40
                                                                                mem[_79411 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_79411 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                    else:
                                                                        if stor7:
                                                                            _77078 = mem[64]
                                                                            mem[64] = mem[64] + 96
                                                                            mem[_77078] = 40
                                                                            mem[_77078 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                            if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[mem[64] + 4] = 32
                                                                                mem[mem[64] + 36] = 40
                                                                                mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_77078 + 72 len 24]
                                                                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                        else:
                                                                            call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                 gas gas_remaining wei
                                                                                args gasForProcessing
                                                                            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                            if not ext_call.success:
                                                                                _78357 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_78357] = 40
                                                                                mem[_78357 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_78357 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                _77081 = mem[64]
                                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                                require return_data.size >= 96
                                                                                _77748 = mem[_77081 + 32]
                                                                                _77749 = mem[_77081 + 64]
                                                                                mem[mem[64]] = mem[_77081]
                                                                                mem[mem[64] + 64] = _77749
                                                                                mem[mem[64] + 96] = gasForProcessing
                                                                                emit ProcessedDividendTracker(mem[mem[64]], _77748, _77749, gasForProcessing, 1, tx.origin);
                                                                                _79826 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_79826] = 40
                                                                                mem[_79826 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_79826 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                            else:
                                                                if not cd[68]:
                                                                    _64686 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_64686] = 26
                                                                    mem[_64686 + 32] = 'SafeMath: division by zero'
                                                                    if cd[68] * totalFees / 100 > -1:
                                                                        revert with 0, 17
                                                                    _69492 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_69492] = 30
                                                                    mem[_69492 + 32] = 'SafeMath: subtraction overflow'
                                                                    if cd[68] * totalFees / 100 > cd[68]:
                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                    if cd[68] < cd[68] * totalFees / 100:
                                                                        revert with 0, 17
                                                                    if not address(cd[4]):
                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                    if not this.address:
                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                    _72994 = mem[64]
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_72994] = 38
                                                                    mem[_72994 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                    if cd[68] * totalFees / 100 > balanceOf[address(cd[4])]:
                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[mem[64] + 4] = 32
                                                                        mem[mem[64] + 36] = 38
                                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_72994 + 70 len 26]
                                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                    if balanceOf[address(cd[4])] < cd[68] * totalFees / 100:
                                                                        revert with 0, 17
                                                                    balanceOf[address(cd[4])] -= cd[68] * totalFees / 100
                                                                    if balanceOf[this.address] > !(cd[68] * totalFees / 100):
                                                                        revert with 0, 17
                                                                    if balanceOf[this.address] + (cd[68] * totalFees / 100) < balanceOf[this.address]:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    mem[0] = this.address
                                                                    mem[32] = 0
                                                                    balanceOf[address(this.address)] = balanceOf[this.address] + (cd[68] * totalFees / 100)
                                                                    emit Transfer((cd[68] * totalFees / 100), address(cd[4]), this.address);
                                                                    if not address(cd[4]):
                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                    if not address(cd[36]):
                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                    _75066 = mem[64]
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_75066] = 38
                                                                    mem[_75066 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                    if cd[68] - (cd[68] * totalFees / 100) > balanceOf[address(cd[4])]:
                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[mem[64] + 4] = 32
                                                                        mem[mem[64] + 36] = 38
                                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_75066 + 70 len 26]
                                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                    if balanceOf[address(cd[4])] < cd[68] - (cd[68] * totalFees / 100):
                                                                        revert with 0, 17
                                                                    balanceOf[address(cd[4])] = balanceOf[address(cd[4])] - cd[68] + (cd[68] * totalFees / 100)
                                                                    if balanceOf[address(cd[36])] > !(cd[68] - (cd[68] * totalFees / 100)):
                                                                        revert with 0, 17
                                                                    if balanceOf[address(cd[36])] + cd[68] - (cd[68] * totalFees / 100) < balanceOf[address(cd[36])]:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    balanceOf[address(cd[36])] = balanceOf[address(cd[36])] + cd[68] - (cd[68] * totalFees / 100)
                                                                    emit Transfer((cd[68] - (cd[68] * totalFees / 100)), address(cd[4]), address(cd[36]));
                                                                    require ext_code.size(dividendTrackerAddress)
                                                                    call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                                         gas gas_remaining wei
                                                                        args address(cd[4]), balanceOf[address(cd[4])]
                                                                    mem[0] = address(cd[36])
                                                                    mem[32] = 0
                                                                    require ext_code.size(dividendTrackerAddress)
                                                                    call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                                         gas gas_remaining wei
                                                                        args address(cd[36]), balanceOf[address(cd[36])]
                                                                    if not ext_call.success:
                                                                        if not ext_call.success:
                                                                            if stor7:
                                                                                _82173 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_82173] = 40
                                                                                mem[_82173 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_82173 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                     gas gas_remaining wei
                                                                                    args gasForProcessing
                                                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                                if not ext_call.success:
                                                                                    _84041 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_84041] = 40
                                                                                    mem[_84041 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_84041 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                                else:
                                                                                    _82176 = mem[64]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 96
                                                                                    _83099 = mem[_82176 + 32]
                                                                                    _83100 = mem[_82176 + 64]
                                                                                    mem[mem[64]] = mem[_82176]
                                                                                    mem[mem[64] + 64] = _83100
                                                                                    mem[mem[64] + 96] = gasForProcessing
                                                                                    emit ProcessedDividendTracker(mem[mem[64]], _83099, _83100, gasForProcessing, 1, tx.origin);
                                                                                    _85911 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_85911] = 40
                                                                                    mem[_85911 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_85911 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                        else:
                                                                            if stor7:
                                                                                _82653 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_82653] = 40
                                                                                mem[_82653 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_82653 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                     gas gas_remaining wei
                                                                                    args gasForProcessing
                                                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                                if not ext_call.success:
                                                                                    _84489 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_84489] = 40
                                                                                    mem[_84489 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_84489 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                                else:
                                                                                    _82656 = mem[64]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 96
                                                                                    _83542 = mem[_82656 + 32]
                                                                                    _83543 = mem[_82656 + 64]
                                                                                    mem[mem[64]] = mem[_82656]
                                                                                    mem[mem[64] + 64] = _83543
                                                                                    mem[mem[64] + 96] = gasForProcessing
                                                                                    emit ProcessedDividendTracker(mem[mem[64]], _83542, _83543, gasForProcessing, 1, tx.origin);
                                                                                    _86386 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_86386] = 40
                                                                                    mem[_86386 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_86386 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                    else:
                                                                        if not ext_call.success:
                                                                            if stor7:
                                                                                _82657 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_82657] = 40
                                                                                mem[_82657 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_82657 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                     gas gas_remaining wei
                                                                                    args gasForProcessing
                                                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                                if not ext_call.success:
                                                                                    _84492 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_84492] = 40
                                                                                    mem[_84492 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_84492 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                                else:
                                                                                    _82660 = mem[64]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 96
                                                                                    _83546 = mem[_82660 + 32]
                                                                                    _83547 = mem[_82660 + 64]
                                                                                    mem[mem[64]] = mem[_82660]
                                                                                    mem[mem[64] + 64] = _83547
                                                                                    mem[mem[64] + 96] = gasForProcessing
                                                                                    emit ProcessedDividendTracker(mem[mem[64]], _83546, _83547, gasForProcessing, 1, tx.origin);
                                                                                    _86391 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_86391] = 40
                                                                                    mem[_86391 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_86391 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                        else:
                                                                            if stor7:
                                                                                _83101 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_83101] = 40
                                                                                mem[_83101 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_83101 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                     gas gas_remaining wei
                                                                                    args gasForProcessing
                                                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                                if not ext_call.success:
                                                                                    _84941 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_84941] = 40
                                                                                    mem[_84941 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_84941 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                                else:
                                                                                    _83104 = mem[64]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 96
                                                                                    _84048 = mem[_83104 + 32]
                                                                                    _84049 = mem[_83104 + 64]
                                                                                    mem[mem[64]] = mem[_83104]
                                                                                    mem[mem[64] + 64] = _84049
                                                                                    mem[mem[64] + 96] = gasForProcessing
                                                                                    emit ProcessedDividendTracker(mem[mem[64]], _84048, _84049, gasForProcessing, 1, tx.origin);
                                                                                    _86899 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_86899] = 40
                                                                                    mem[_86899 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_86899 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                else:
                                                                    if cd[68] and 1 > -1 / cd[68]:
                                                                        revert with 0, 17
                                                                    if not cd[68]:
                                                                        revert with 0, 18
                                                                    if cd[68] / cd[68] != 1:
                                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                                    _66898 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_66898] = 26
                                                                    mem[_66898 + 32] = 'SafeMath: division by zero'
                                                                    if cd[68] * totalFees / 100 > !(cd[68] / 100):
                                                                        revert with 0, 17
                                                                    _71920 = mem[64]
                                                                    mem[64] = mem[64] + 64
                                                                    mem[_71920] = 30
                                                                    mem[_71920 + 32] = 'SafeMath: subtraction overflow'
                                                                    if (cd[68] * totalFees / 100) + (cd[68] / 100) > cd[68]:
                                                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                                                    if cd[68] < (cd[68] * totalFees / 100) + (cd[68] / 100):
                                                                        revert with 0, 17
                                                                    if not address(cd[4]):
                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                    if not this.address:
                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                    _73701 = mem[64]
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_73701] = 38
                                                                    mem[_73701 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                    if (cd[68] * totalFees / 100) + (cd[68] / 100) > balanceOf[address(cd[4])]:
                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[mem[64] + 4] = 32
                                                                        mem[mem[64] + 36] = 38
                                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_73701 + 70 len 26]
                                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                    if balanceOf[address(cd[4])] < (cd[68] * totalFees / 100) + (cd[68] / 100):
                                                                        revert with 0, 17
                                                                    balanceOf[address(cd[4])] = balanceOf[address(cd[4])] - (cd[68] * totalFees / 100) - (cd[68] / 100)
                                                                    if balanceOf[this.address] > !((cd[68] * totalFees / 100) + (cd[68] / 100)):
                                                                        revert with 0, 17
                                                                    if balanceOf[this.address] + (cd[68] * totalFees / 100) + (cd[68] / 100) < balanceOf[this.address]:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    mem[0] = this.address
                                                                    mem[32] = 0
                                                                    balanceOf[address(this.address)] = balanceOf[this.address] + (cd[68] * totalFees / 100) + (cd[68] / 100)
                                                                    emit Transfer(((cd[68] * totalFees / 100) + (cd[68] / 100)), address(cd[4]), this.address);
                                                                    if not address(cd[4]):
                                                                        revert with 0, 'ERC20: transfer from the zero address'
                                                                    if not address(cd[36]):
                                                                        revert with 0, 'ERC20: transfer to the zero address'
                                                                    _76440 = mem[64]
                                                                    mem[64] = mem[64] + 96
                                                                    mem[_76440] = 38
                                                                    mem[_76440 + 32 len 38] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63
                                                                    if cd[68] - (cd[68] * totalFees / 100) - (cd[68] / 100) > balanceOf[address(cd[4])]:
                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[mem[64] + 4] = 32
                                                                        mem[mem[64] + 36] = 38
                                                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e7420657863656564732062616c616e63, mem[_76440 + 70 len 26]
                                                                        revert with 0, 32, 38, mem[mem[64] + 68 len 38], 0
                                                                    if balanceOf[address(cd[4])] < cd[68] - (cd[68] * totalFees / 100) - (cd[68] / 100):
                                                                        revert with 0, 17
                                                                    balanceOf[address(cd[4])] = balanceOf[address(cd[4])] - cd[68] + (cd[68] * totalFees / 100) + (cd[68] / 100)
                                                                    if balanceOf[address(cd[36])] > !(cd[68] - (cd[68] * totalFees / 100) - (cd[68] / 100)):
                                                                        revert with 0, 17
                                                                    if balanceOf[address(cd[36])] + cd[68] - (cd[68] * totalFees / 100) - (cd[68] / 100) < balanceOf[address(cd[36])]:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    balanceOf[address(cd[36])] = balanceOf[address(cd[36])] + cd[68] - (cd[68] * totalFees / 100) - (cd[68] / 100)
                                                                    emit Transfer((cd[68] - (cd[68] * totalFees / 100) - (cd[68] / 100)), address(cd[4]), address(cd[36]));
                                                                    require ext_code.size(dividendTrackerAddress)
                                                                    call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                                         gas gas_remaining wei
                                                                        args address(cd[4]), balanceOf[address(cd[4])]
                                                                    mem[0] = address(cd[36])
                                                                    mem[32] = 0
                                                                    require ext_code.size(dividendTrackerAddress)
                                                                    call dividendTrackerAddress.setBalance(address arg1, uint256 arg2) with:
                                                                         gas gas_remaining wei
                                                                        args address(cd[36]), balanceOf[address(cd[36])]
                                                                    if not ext_call.success:
                                                                        if not ext_call.success:
                                                                            if stor7:
                                                                                _84926 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_84926] = 40
                                                                                mem[_84926 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_84926 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                     gas gas_remaining wei
                                                                                    args gasForProcessing
                                                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                                if not ext_call.success:
                                                                                    _86873 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_86873] = 40
                                                                                    mem[_86873 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_86873 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                                else:
                                                                                    _84929 = mem[64]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 96
                                                                                    _85903 = mem[_84929 + 32]
                                                                                    _85904 = mem[_84929 + 64]
                                                                                    mem[mem[64]] = mem[_84929]
                                                                                    mem[mem[64] + 64] = _85904
                                                                                    mem[mem[64] + 96] = gasForProcessing
                                                                                    emit ProcessedDividendTracker(mem[mem[64]], _85903, _85904, gasForProcessing, 1, tx.origin);
                                                                                    _88581 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_88581] = 40
                                                                                    mem[_88581 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_88581 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                        else:
                                                                            if stor7:
                                                                                _85431 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_85431] = 40
                                                                                mem[_85431 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_85431 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                     gas gas_remaining wei
                                                                                    args gasForProcessing
                                                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                                if not ext_call.success:
                                                                                    _87352 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_87352] = 40
                                                                                    mem[_87352 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_87352 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                                else:
                                                                                    _85434 = mem[64]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 96
                                                                                    _86372 = mem[_85434 + 32]
                                                                                    _86373 = mem[_85434 + 64]
                                                                                    mem[mem[64]] = mem[_85434]
                                                                                    mem[mem[64] + 64] = _86373
                                                                                    mem[mem[64] + 96] = gasForProcessing
                                                                                    emit ProcessedDividendTracker(mem[mem[64]], _86372, _86373, gasForProcessing, 1, tx.origin);
                                                                                    _88982 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_88982] = 40
                                                                                    mem[_88982 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_88982 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                    else:
                                                                        if not ext_call.success:
                                                                            if stor7:
                                                                                _85435 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_85435] = 40
                                                                                mem[_85435 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_85435 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                     gas gas_remaining wei
                                                                                    args gasForProcessing
                                                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                                if not ext_call.success:
                                                                                    _87355 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_87355] = 40
                                                                                    mem[_87355 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_87355 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                                else:
                                                                                    _85438 = mem[64]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 96
                                                                                    _86376 = mem[_85438 + 32]
                                                                                    _86377 = mem[_85438 + 64]
                                                                                    mem[mem[64]] = mem[_85438]
                                                                                    mem[mem[64] + 64] = _86377
                                                                                    mem[mem[64] + 96] = gasForProcessing
                                                                                    emit ProcessedDividendTracker(mem[mem[64]], _86376, _86377, gasForProcessing, 1, tx.origin);
                                                                                    _88987 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_88987] = 40
                                                                                    mem[_88987 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_88987 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                        else:
                                                                            if stor7:
                                                                                _85905 = mem[64]
                                                                                mem[64] = mem[64] + 96
                                                                                mem[_85905] = 40
                                                                                mem[_85905 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 40
                                                                                    mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_85905 + 72 len 24]
                                                                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                            else:
                                                                                call dividendTrackerAddress.process(uint256 arg1) with:
                                                                                     gas gas_remaining wei
                                                                                    args gasForProcessing
                                                                                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                                                                                if not ext_call.success:
                                                                                    _87806 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_87806] = 40
                                                                                    mem[_87806 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_87806 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                                                                else:
                                                                                    _85908 = mem[64]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 96
                                                                                    _86880 = mem[_85908 + 32]
                                                                                    _86881 = mem[_85908 + 64]
                                                                                    mem[mem[64]] = mem[_85908]
                                                                                    mem[mem[64] + 64] = _86881
                                                                                    mem[mem[64] + 96] = gasForProcessing
                                                                                    emit ProcessedDividendTracker(mem[mem[64]], _86880, _86881, gasForProcessing, 1, tx.origin);
                                                                                    _89354 = mem[64]
                                                                                    mem[64] = mem[64] + 96
                                                                                    mem[_89354] = 40
                                                                                    mem[_89354 + 32 len 40] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                                                    if cd[68] > allowance[address(cd[4])][msg.sender].field_0:
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 40
                                                                                        mem[mem[64] + 68 len 64] = 0x6545524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_89354 + 72 len 24]
                                                                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
        ('le', ('cd', 68), ('field', 0, ('stor', ('map', 'msg.sender', ('map', ('mask_shl', 160, 0, 0, ('cd', 4)), ('name', 'allowance', 1))))))
        if allowance[address(cd[4])][msg.sender].field_0 < cd[68]:
            revert with 0, 17
        if not address(cd[4]):
            revert with 0, 'ERC20: approve from the zero address'
        if not msg.sender:
            revert with 0, 'ERC20: approve to the zero address'
        allowance[address(cd[4])][address(msg.sender)].field_0 = allowance[address(cd[4])][msg.sender].field_0 - cd[68]
        emit Approval((allowance[address(cd[4])][msg.sender].field_0 - cd[68]), address(cd[4]), msg.sender);
    return 1
}



}

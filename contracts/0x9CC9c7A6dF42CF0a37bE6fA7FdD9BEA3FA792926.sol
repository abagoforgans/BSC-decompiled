contract main {




// =====================  Runtime code  =====================


#
#  - transferFrom(address arg1, address arg2, uint256 arg3)
#
const totalSupply = 100000 * 10^18


address owner;
mapping of uint256 stor1;
mapping of uint256 stor2;
mapping of uint256 allowance;
mapping of uint8 stor4;
array of address stor5;
address stor6;
uint256 stor7;
uint256 totalFees;
array of uint256 name;
array of uint256 symbol;
uint8 decimals;

function name() payable {
    return name[0 len name.length]
}

function totalFees() payable {
    return totalFees
}

function decimals() payable {
    return decimals
}

function owner() payable {
    return owner
}

function symbol() payable {
    return symbol[0 len symbol.length]
}

function isExcluded(address arg1) payable {
    require calldata.size - 4 >= 32
    return bool(stor4[address(arg1)])
}

function allowance(address arg1, address arg2) payable {
    require calldata.size - 4 >= 64
    return allowance[address(arg1)][address(arg2)]
}

function _fallback() payable {
    revert
}

function renounceOwnership() payable {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    emit OwnershipTransferred(owner, 0);
    owner = 0
}

function sub_eae8a7af(?) payable {
    if stor6 != msg.sender:
        revert with 0, 'Can't please try again.'
    if not stor7 / 1000:
        stor1[stor6] = 0
    else:
        require stor7 / 1000
        if 900 * stor7 / 1000 / stor7 / 1000 != 900:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
        stor1[stor6] = 900 * stor7 / 1000
    emit Transfer((25 * 10^18 * 3600), 0, stor6);
}

function transferOwnership(address arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    38,
                    0x734f776e61626c653a206e6577206f776e657220697320746865207a65726f20616464726573,
                    mem[202 len 26]
    emit OwnershipTransferred(owner, arg1);
    owner = arg1
}

function includeAccount(address arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not stor4[address(arg1)]:
        revert with 0, 'Account is not excluded'
    idx = 0
    while idx < stor5.length:
        mem[0] = 5
        if stor5[idx] != arg1:
            idx = idx + 1
            continue 
        require stor5.length - 1 < stor5.length
        require idx < stor5.length
        stor5[idx] = stor5[stor5.length]
        stor2[address(arg1)] = 0
        stor4[address(arg1)] = 0
        require stor5.length
        stor5[stor5.length] = 0
        stor5.length--
}

function approve(address arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    if not msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    36,
                    0x7345524332303a20617070726f76652066726f6d20746865207a65726f20616464726573,
                    mem[200 len 28]
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    34,
                    0x7345524332303a20617070726f766520746f20746865207a65726f20616464726573,
                    mem[198 len 30]
    allowance[address(msg.sender)][address(arg1)] = arg2
    emit Approval(arg2, msg.sender, arg1);
    return 1
}

function decreaseAllowance(address arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    if arg2 > allowance[address(msg.sender)][address(arg1)]:
        revert with 0, 
                    32,
                    37,
                    0x6e45524332303a2064656372656173656420616c6c6f77616e63652062656c6f77207a6572,
                    mem[165 len 27],
                    mem[219 len 5]
    if not msg.sender:
        revert with 0, 32, 36, 0x7345524332303a20617070726f76652066726f6d20746865207a65726f20616464726573, mem[296 len 28]
    if not arg1:
        revert with 0, 32, 34, 0x7345524332303a20617070726f766520746f20746865207a65726f20616464726573, mem[294 len 30]
    allowance[address(msg.sender)][address(arg1)] -= arg2
    emit Approval((allowance[address(msg.sender)][address(arg1)] - arg2), msg.sender, arg1);
    return 1
}

function increaseAllowance(address arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    if allowance[address(msg.sender)][address(arg1)] + arg2 < allowance[address(msg.sender)][address(arg1)]:
        revert with 0, 'SafeMath: addition overflow'
    if not msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    36,
                    0x7345524332303a20617070726f76652066726f6d20746865207a65726f20616464726573,
                    mem[200 len 28]
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    34,
                    0x7345524332303a20617070726f766520746f20746865207a65726f20616464726573,
                    mem[198 len 30]
    allowance[address(msg.sender)][address(arg1)] += arg2
    emit Approval((allowance[address(msg.sender)][address(arg1)] + arg2), msg.sender, arg1);
    return 1
}

function tokenFromReflection(uint256 arg1) payable {
    mem[64] = 96
    require calldata.size - 4 >= 32
    if arg1 > stor7:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    42,
                    0x73416d6f756e74206d757374206265206c657373207468616e20746f74616c207265666c656374696f6e,
                    mem[206 len 22]
    idx = 0
    s = 100000 * 10^18
    t = stor7
    while idx < stor5.length:
        mem[0] = stor5[idx]
        mem[32] = 1
        if stor1[stor5[idx]] > t:
            _77 = mem[64]
            mem[64] = mem[64] + 64
            mem[_77] = 26
            mem[_77 + 32] = 'SafeMath: division by zero'
            _95 = mem[64]
            mem[64] = mem[64] + 64
            mem[_95] = 26
            mem[_95 + 32] = 'SafeMath: division by zero'
            if stor7 / 100000 * 10^18 > 0:
                require stor7 / 100000 * 10^18
                return (arg1 / stor7 / 100000 * 10^18)
            _101 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[_101 + idx + 68] = mem[_95 + idx + 32]
                idx = idx + 32
                continue 
            mem[_101 + 68] = mem[_101 + 74 len 26]
            revert with memory
              from mem[64]
               len _101 + -mem[64] + 100
        require idx < stor5.length
        mem[0] = stor5[idx]
        mem[32] = 2
        if stor2[stor5[idx]] > s:
            _81 = mem[64]
            mem[64] = mem[64] + 64
            mem[_81] = 26
            mem[_81 + 32] = 'SafeMath: division by zero'
            _107 = mem[64]
            mem[64] = mem[64] + 64
            mem[_107] = 26
            mem[_107 + 32] = 'SafeMath: division by zero'
            if stor7 / 100000 * 10^18 > 0:
                require stor7 / 100000 * 10^18
                return (arg1 / stor7 / 100000 * 10^18)
            _113 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[_113 + idx + 68] = mem[_107 + idx + 32]
                idx = idx + 32
                continue 
            mem[_113 + 68] = mem[_113 + 74 len 26]
            revert with memory
              from mem[64]
               len _113 + -mem[64] + 100
        require idx < stor5.length
        mem[0] = stor5[idx]
        mem[32] = 1
        _80 = mem[64]
        mem[64] = mem[64] + 64
        mem[_80] = 30
        mem[_80 + 32] = 'SafeMath: subtraction overflow'
        if stor1[stor5[idx]] > t:
            _82 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[_82 + idx + 68] = mem[_80 + idx + 32]
                idx = idx + 32
                continue 
            mem[_82 + 68] = mem[_82 + 70 len 30]
            revert with memory
              from mem[64]
               len _82 + -mem[64] + 100
        require idx < stor5.length
        mem[0] = stor5[idx]
        mem[32] = 2
        _96 = mem[64]
        mem[64] = mem[64] + 64
        mem[_96] = 30
        mem[_96 + 32] = 'SafeMath: subtraction overflow'
        if stor2[stor5[idx]] <= s:
            idx = idx + 1
            s = s - stor2[stor5[idx]]
            t = t - stor1[stor5[idx]]
            continue 
        _104 = mem[64]
        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 32
        mem[mem[64] + 36] = 30
        idx = 0
        while idx < 30:
            mem[_104 + idx + 68] = mem[_96 + idx + 32]
            idx = idx + 32
            continue 
        mem[_104 + 68] = mem[_104 + 70 len 30]
        revert with memory
          from mem[64]
           len _104 + -mem[64] + 100
    if t < stor7 / 100000 * 10^18:
        if stor7 / 100000 * 10^18 <= 0:
            revert with 0, 'SafeMath: division by zero'
        if stor7 / 100000 * 10^18:
            return (arg1 / stor7 / 100000 * 10^18)
    else:
        if s <= 0:
            revert with 0, 'SafeMath: division by zero'
        if s:
            if t / s <= 0:
                revert with 0, 'SafeMath: division by zero'
            if t / s:
                return (arg1 / t / s)
    revert
}

function balanceOf(address arg1) payable {
    mem[64] = 96
    require calldata.size - 4 >= 32
    if stor4[address(arg1)]:
        return stor2[address(arg1)]
    mem[0] = arg1
    mem[32] = 1
    if stor1[address(arg1)] > stor7:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    42,
                    0x73416d6f756e74206d757374206265206c657373207468616e20746f74616c207265666c656374696f6e,
                    mem[206 len 22]
    idx = 0
    s = 100000 * 10^18
    t = stor7
    while idx < stor5.length:
        mem[0] = stor5[idx]
        mem[32] = 1
        if stor1[stor5[idx]] > t:
            _82 = mem[64]
            mem[64] = mem[64] + 64
            mem[_82] = 26
            mem[_82 + 32] = 'SafeMath: division by zero'
            _100 = mem[64]
            mem[64] = mem[64] + 64
            mem[_100] = 26
            mem[_100 + 32] = 'SafeMath: division by zero'
            if stor7 / 100000 * 10^18 > 0:
                require stor7 / 100000 * 10^18
                return (stor1[address(arg1)] / stor7 / 100000 * 10^18)
            _106 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[_106 + idx + 68] = mem[_100 + idx + 32]
                idx = idx + 32
                continue 
            mem[_106 + 68] = mem[_106 + 74 len 26]
            revert with memory
              from mem[64]
               len _106 + -mem[64] + 100
        require idx < stor5.length
        mem[0] = stor5[idx]
        mem[32] = 2
        if stor2[stor5[idx]] > s:
            _86 = mem[64]
            mem[64] = mem[64] + 64
            mem[_86] = 26
            mem[_86 + 32] = 'SafeMath: division by zero'
            _112 = mem[64]
            mem[64] = mem[64] + 64
            mem[_112] = 26
            mem[_112 + 32] = 'SafeMath: division by zero'
            if stor7 / 100000 * 10^18 > 0:
                require stor7 / 100000 * 10^18
                return (stor1[address(arg1)] / stor7 / 100000 * 10^18)
            _118 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[_118 + idx + 68] = mem[_112 + idx + 32]
                idx = idx + 32
                continue 
            mem[_118 + 68] = mem[_118 + 74 len 26]
            revert with memory
              from mem[64]
               len _118 + -mem[64] + 100
        require idx < stor5.length
        mem[0] = stor5[idx]
        mem[32] = 1
        _85 = mem[64]
        mem[64] = mem[64] + 64
        mem[_85] = 30
        mem[_85 + 32] = 'SafeMath: subtraction overflow'
        if stor1[stor5[idx]] > t:
            _87 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[_87 + idx + 68] = mem[_85 + idx + 32]
                idx = idx + 32
                continue 
            mem[_87 + 68] = mem[_87 + 70 len 30]
            revert with memory
              from mem[64]
               len _87 + -mem[64] + 100
        require idx < stor5.length
        mem[0] = stor5[idx]
        mem[32] = 2
        _101 = mem[64]
        mem[64] = mem[64] + 64
        mem[_101] = 30
        mem[_101 + 32] = 'SafeMath: subtraction overflow'
        if stor2[stor5[idx]] <= s:
            idx = idx + 1
            s = s - stor2[stor5[idx]]
            t = t - stor1[stor5[idx]]
            continue 
        _109 = mem[64]
        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 32
        mem[mem[64] + 36] = 30
        idx = 0
        while idx < 30:
            mem[_109 + idx + 68] = mem[_101 + idx + 32]
            idx = idx + 32
            continue 
        mem[_109 + 68] = mem[_109 + 70 len 30]
        revert with memory
          from mem[64]
           len _109 + -mem[64] + 100
    if t < stor7 / 100000 * 10^18:
        if stor7 / 100000 * 10^18 <= 0:
            revert with 0, 'SafeMath: division by zero'
        if stor7 / 100000 * 10^18:
            return (stor1[address(arg1)] / stor7 / 100000 * 10^18)
    else:
        if s <= 0:
            revert with 0, 'SafeMath: division by zero'
        if s:
            if t / s <= 0:
                revert with 0, 'SafeMath: division by zero'
            if t / s:
                return (stor1[address(arg1)] / t / s)
    revert
}

function excludeAccount(address arg1) payable {
    mem[64] = 96
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if stor4[address(arg1)]:
        revert with 0, 'Account is not excluded'
    if stor1[address(arg1)] > 0:
        mem[0] = arg1
        mem[32] = 1
        if stor1[address(arg1)] > stor7:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        42,
                        0x73416d6f756e74206d757374206265206c657373207468616e20746f74616c207265666c656374696f6e,
                        mem[206 len 22]
        idx = 0
        s = 100000 * 10^18
        t = stor7
        while idx < stor5.length:
            mem[0] = stor5[idx]
            mem[32] = 1
            if stor1[stor5[idx]] > t:
                _90 = mem[64]
                mem[64] = mem[64] + 64
                mem[_90] = 26
                mem[_90 + 32] = 'SafeMath: division by zero'
                _108 = mem[64]
                mem[64] = mem[64] + 64
                mem[_108] = 26
                mem[_108 + 32] = 'SafeMath: division by zero'
                if stor7 / 100000 * 10^18 > 0:
                    require stor7 / 100000 * 10^18
                    stor2[address(arg1)] = stor1[address(arg1)] / stor7 / 100000 * 10^18
                    stor4[address(arg1)] = 1
                    stor5.length++
                    stor5[stor5.length] = arg1
                _114 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_114 + idx + 68] = mem[_108 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_114 + 68] = mem[_114 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _114 + -mem[64] + 100
            require idx < stor5.length
            mem[0] = stor5[idx]
            mem[32] = 2
            if stor2[stor5[idx]] > s:
                _94 = mem[64]
                mem[64] = mem[64] + 64
                mem[_94] = 26
                mem[_94 + 32] = 'SafeMath: division by zero'
                _120 = mem[64]
                mem[64] = mem[64] + 64
                mem[_120] = 26
                mem[_120 + 32] = 'SafeMath: division by zero'
                if stor7 / 100000 * 10^18 > 0:
                    require stor7 / 100000 * 10^18
                    stor2[address(arg1)] = stor1[address(arg1)] / stor7 / 100000 * 10^18
                    stor4[address(arg1)] = 1
                    stor5.length++
                    stor5[stor5.length] = arg1
                _126 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_126 + idx + 68] = mem[_120 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_126 + 68] = mem[_126 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _126 + -mem[64] + 100
            require idx < stor5.length
            mem[0] = stor5[idx]
            mem[32] = 1
            _93 = mem[64]
            mem[64] = mem[64] + 64
            mem[_93] = 30
            mem[_93 + 32] = 'SafeMath: subtraction overflow'
            if stor1[stor5[idx]] > t:
                _95 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_95 + idx + 68] = mem[_93 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_95 + 68] = mem[_95 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _95 + -mem[64] + 100
            require idx < stor5.length
            mem[0] = stor5[idx]
            mem[32] = 2
            _109 = mem[64]
            mem[64] = mem[64] + 64
            mem[_109] = 30
            mem[_109 + 32] = 'SafeMath: subtraction overflow'
            if stor2[stor5[idx]] <= s:
                idx = idx + 1
                s = s - stor2[stor5[idx]]
                t = t - stor1[stor5[idx]]
                continue 
            _117 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[_117 + idx + 68] = mem[_109 + idx + 32]
                idx = idx + 32
                continue 
            mem[_117 + 68] = mem[_117 + 70 len 30]
            revert with memory
              from mem[64]
               len _117 + -mem[64] + 100
        if t < stor7 / 100000 * 10^18:
            if stor7 / 100000 * 10^18 <= 0:
                revert with 0, 'SafeMath: division by zero'
            require stor7 / 100000 * 10^18
            stor2[address(arg1)] = stor1[address(arg1)] / stor7 / 100000 * 10^18
        else:
            if s <= 0:
                revert with 0, 'SafeMath: division by zero'
            require s
            if t / s <= 0:
                revert with 0, 'SafeMath: division by zero'
            require t / s
            stor2[address(arg1)] = stor1[address(arg1)] / t / s
    stor4[address(arg1)] = 1
    stor5.length++
    stor5[stor5.length] = arg1
}

function reflectionFromToken(uint256 arg1, bool arg2) payable {
    require calldata.size - 4 >= 64
    if arg1 > 100000 * 10^18:
        revert with 0, 'Amount must be less than supply'
    mem[96] = 26
    mem[128] = 'SafeMath: division by zero'
    if arg2:
        if not arg1 / 100:
            mem[64] = 224
            mem[160] = 30
            mem[192] = 'SafeMath: subtraction overflow'
            if 0 > arg1:
                revert with 0, 'SafeMath: subtraction overflow'
            idx = 0
            s = 100000 * 10^18
            t = stor7
            while idx < stor5.length:
                mem[0] = stor5[idx]
                mem[32] = 1
                if stor1[stor5[idx]] > t:
                    _628 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_628] = 26
                    mem[_628 + 32] = 'SafeMath: division by zero'
                    if not arg1:
                        return 0
                    require arg1
                    if arg1 * stor7 / 100000 * 10^18 / arg1 != stor7 / 100000 * 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _800 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_800] = 30
                    mem[_800 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= arg1 * stor7 / 100000 * 10^18:
                        return (arg1 * stor7 / 100000 * 10^18)
                    _832 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_832 + idx + 68] = mem[_800 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_832 + 68] = mem[_832 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _832 + -mem[64] + 100
                require idx < stor5.length
                mem[0] = stor5[idx]
                mem[32] = 2
                if stor2[stor5[idx]] > s:
                    _642 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_642] = 26
                    mem[_642 + 32] = 'SafeMath: division by zero'
                    if not arg1:
                        return 0
                    require arg1
                    if arg1 * stor7 / 100000 * 10^18 / arg1 != stor7 / 100000 * 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _835 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_835] = 30
                    mem[_835 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= arg1 * stor7 / 100000 * 10^18:
                        return (arg1 * stor7 / 100000 * 10^18)
                    _880 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_880 + idx + 68] = mem[_835 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_880 + 68] = mem[_880 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _880 + -mem[64] + 100
                require idx < stor5.length
                mem[0] = stor5[idx]
                mem[32] = 1
                _638 = mem[64]
                mem[64] = mem[64] + 64
                mem[_638] = 30
                mem[_638 + 32] = 'SafeMath: subtraction overflow'
                if stor1[stor5[idx]] > t:
                    _648 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_648 + idx + 68] = mem[_638 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_648 + 68] = mem[_648 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _648 + -mem[64] + 100
                require idx < stor5.length
                mem[0] = stor5[idx]
                mem[32] = 2
                _699 = mem[64]
                mem[64] = mem[64] + 64
                mem[_699] = 30
                mem[_699 + 32] = 'SafeMath: subtraction overflow'
                if stor2[stor5[idx]] <= s:
                    idx = idx + 1
                    s = s - stor2[stor5[idx]]
                    t = t - stor1[stor5[idx]]
                    continue 
                _716 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_716 + idx + 68] = mem[_699 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_716 + 68] = mem[_716 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _716 + -mem[64] + 100
            _598 = mem[64]
            mem[64] = mem[64] + 64
            mem[_598] = 26
            mem[_598 + 32] = 'SafeMath: division by zero'
            if t < stor7 / 100000 * 10^18:
                _660 = mem[64]
                mem[64] = mem[64] + 64
                mem[_660] = 26
                mem[_660 + 32] = 'SafeMath: division by zero'
                if not arg1:
                    return 0
                require arg1
                if arg1 * stor7 / 100000 * 10^18 / arg1 != stor7 / 100000 * 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if 0 > arg1 * stor7 / 100000 * 10^18:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (arg1 * stor7 / 100000 * 10^18)
            _659 = mem[64]
            mem[64] = mem[64] + 64
            mem[_659] = 26
            mem[_659 + 32] = 'SafeMath: division by zero'
            if s <= 0:
                revert with 0, 'SafeMath: division by zero'
            require s
            if not arg1:
                return 0
            require arg1
            if arg1 * t / s / arg1 != t / s:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            if 0 > arg1 * t / s:
                revert with 0, 'SafeMath: subtraction overflow'
            return (arg1 * t / s)
        require arg1 / 100
        if 5 * arg1 / 100 / arg1 / 100 != 5:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
        mem[64] = 224
        mem[160] = 30
        mem[192] = 'SafeMath: subtraction overflow'
        if 5 * arg1 / 100 > arg1:
            revert with 0, 'SafeMath: subtraction overflow'
        idx = 0
        s = 100000 * 10^18
        t = stor7
        while idx < stor5.length:
            mem[0] = stor5[idx]
            mem[32] = 1
            if stor1[stor5[idx]] > t:
                _625 = mem[64]
                mem[64] = mem[64] + 64
                mem[_625] = 26
                mem[_625 + 32] = 'SafeMath: division by zero'
                if not arg1:
                    if not 5 * arg1 / 100:
                        return 0
                    require 5 * arg1 / 100
                    if 5 * arg1 / 100 * stor7 / 100000 * 10^18 / 5 * arg1 / 100 != stor7 / 100000 * 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _798 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_798] = 30
                    mem[_798 + 32] = 'SafeMath: subtraction overflow'
                    if 5 * arg1 / 100 * stor7 / 100000 * 10^18 <= 0:
                        return (-5 * arg1 / 100 * stor7 / 100000 * 10^18)
                    _825 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_825 + idx + 68] = mem[_798 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_825 + 68] = mem[_825 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _825 + -mem[64] + 100
                require arg1
                if arg1 * stor7 / 100000 * 10^18 / arg1 != stor7 / 100000 * 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if not 5 * arg1 / 100:
                    _797 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_797] = 30
                    mem[_797 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= arg1 * stor7 / 100000 * 10^18:
                        return (arg1 * stor7 / 100000 * 10^18)
                    _822 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_822 + idx + 68] = mem[_797 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_822 + 68] = mem[_822 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _822 + -mem[64] + 100
                require 5 * arg1 / 100
                if 5 * arg1 / 100 * stor7 / 100000 * 10^18 / 5 * arg1 / 100 != stor7 / 100000 * 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _821 = mem[64]
                mem[64] = mem[64] + 64
                mem[_821] = 30
                mem[_821 + 32] = 'SafeMath: subtraction overflow'
                if 5 * arg1 / 100 * stor7 / 100000 * 10^18 <= arg1 * stor7 / 100000 * 10^18:
                    return ((arg1 * stor7 / 100000 * 10^18) - (5 * arg1 / 100 * stor7 / 100000 * 10^18))
                _865 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_865 + idx + 68] = mem[_821 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_865 + 68] = mem[_865 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _865 + -mem[64] + 100
            require idx < stor5.length
            mem[0] = stor5[idx]
            mem[32] = 2
            if stor2[stor5[idx]] > s:
                _641 = mem[64]
                mem[64] = mem[64] + 64
                mem[_641] = 26
                mem[_641 + 32] = 'SafeMath: division by zero'
                if not arg1:
                    if not 5 * arg1 / 100:
                        return 0
                    require 5 * arg1 / 100
                    if 5 * arg1 / 100 * stor7 / 100000 * 10^18 / 5 * arg1 / 100 != stor7 / 100000 * 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _829 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_829] = 30
                    mem[_829 + 32] = 'SafeMath: subtraction overflow'
                    if 5 * arg1 / 100 * stor7 / 100000 * 10^18 <= 0:
                        return (-5 * arg1 / 100 * stor7 / 100000 * 10^18)
                    _874 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_874 + idx + 68] = mem[_829 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_874 + 68] = mem[_874 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _874 + -mem[64] + 100
                require arg1
                if arg1 * stor7 / 100000 * 10^18 / arg1 != stor7 / 100000 * 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if not 5 * arg1 / 100:
                    _828 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_828] = 30
                    mem[_828 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= arg1 * stor7 / 100000 * 10^18:
                        return (arg1 * stor7 / 100000 * 10^18)
                    _871 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_871 + idx + 68] = mem[_828 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_871 + 68] = mem[_871 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _871 + -mem[64] + 100
                require 5 * arg1 / 100
                if 5 * arg1 / 100 * stor7 / 100000 * 10^18 / 5 * arg1 / 100 != stor7 / 100000 * 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _870 = mem[64]
                mem[64] = mem[64] + 64
                mem[_870] = 30
                mem[_870 + 32] = 'SafeMath: subtraction overflow'
                if 5 * arg1 / 100 * stor7 / 100000 * 10^18 <= arg1 * stor7 / 100000 * 10^18:
                    return ((arg1 * stor7 / 100000 * 10^18) - (5 * arg1 / 100 * stor7 / 100000 * 10^18))
                _936 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_936 + idx + 68] = mem[_870 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_936 + 68] = mem[_936 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _936 + -mem[64] + 100
            require idx < stor5.length
            mem[0] = stor5[idx]
            mem[32] = 1
            _637 = mem[64]
            mem[64] = mem[64] + 64
            mem[_637] = 30
            mem[_637 + 32] = 'SafeMath: subtraction overflow'
            if stor1[stor5[idx]] > t:
                _645 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_645 + idx + 68] = mem[_637 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_645 + 68] = mem[_645 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _645 + -mem[64] + 100
            require idx < stor5.length
            mem[0] = stor5[idx]
            mem[32] = 2
            _697 = mem[64]
            mem[64] = mem[64] + 64
            mem[_697] = 30
            mem[_697 + 32] = 'SafeMath: subtraction overflow'
            if stor2[stor5[idx]] <= s:
                idx = idx + 1
                s = s - stor2[stor5[idx]]
                t = t - stor1[stor5[idx]]
                continue 
            _711 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[_711 + idx + 68] = mem[_697 + idx + 32]
                idx = idx + 32
                continue 
            mem[_711 + 68] = mem[_711 + 70 len 30]
            revert with memory
              from mem[64]
               len _711 + -mem[64] + 100
        _593 = mem[64]
        mem[64] = mem[64] + 64
        mem[_593] = 26
        mem[_593 + 32] = 'SafeMath: division by zero'
        if t < stor7 / 100000 * 10^18:
            _658 = mem[64]
            mem[64] = mem[64] + 64
            mem[_658] = 26
            mem[_658 + 32] = 'SafeMath: division by zero'
            if not arg1:
                if not 5 * arg1 / 100:
                    return 0
                require 5 * arg1 / 100
                if 5 * arg1 / 100 * stor7 / 100000 * 10^18 / 5 * arg1 / 100 != stor7 / 100000 * 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if 5 * arg1 / 100 * stor7 / 100000 * 10^18 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (-5 * arg1 / 100 * stor7 / 100000 * 10^18)
            require arg1
            if arg1 * stor7 / 100000 * 10^18 / arg1 != stor7 / 100000 * 10^18:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            if not 5 * arg1 / 100:
                if 0 > arg1 * stor7 / 100000 * 10^18:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (arg1 * stor7 / 100000 * 10^18)
            require 5 * arg1 / 100
            if 5 * arg1 / 100 * stor7 / 100000 * 10^18 / 5 * arg1 / 100 != stor7 / 100000 * 10^18:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            if 5 * arg1 / 100 * stor7 / 100000 * 10^18 > arg1 * stor7 / 100000 * 10^18:
                revert with 0, 'SafeMath: subtraction overflow'
            return ((arg1 * stor7 / 100000 * 10^18) - (5 * arg1 / 100 * stor7 / 100000 * 10^18))
        _657 = mem[64]
        mem[64] = mem[64] + 64
        mem[_657] = 26
        mem[_657 + 32] = 'SafeMath: division by zero'
        if s <= 0:
            revert with 0, 'SafeMath: division by zero'
        require s
        if not arg1:
            if not 5 * arg1 / 100:
                return 0
            require 5 * arg1 / 100
            if 5 * arg1 / 100 * t / s / 5 * arg1 / 100 != t / s:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            if 5 * arg1 / 100 * t / s > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            return (-5 * arg1 / 100 * t / s)
        require arg1
        if arg1 * t / s / arg1 != t / s:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
        if not 5 * arg1 / 100:
            if 0 > arg1 * t / s:
                revert with 0, 'SafeMath: subtraction overflow'
            return (arg1 * t / s)
        require 5 * arg1 / 100
        if 5 * arg1 / 100 * t / s / 5 * arg1 / 100 != t / s:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
        if 5 * arg1 / 100 * t / s > arg1 * t / s:
            revert with 0, 'SafeMath: subtraction overflow'
        return ((arg1 * t / s) - (5 * arg1 / 100 * t / s))
    if not arg1 / 100:
        mem[64] = 224
        mem[160] = 30
        mem[192] = 'SafeMath: subtraction overflow'
        if 0 > arg1:
            revert with 0, 'SafeMath: subtraction overflow'
        idx = 0
        s = 100000 * 10^18
        t = stor7
        while idx < stor5.length:
            mem[0] = stor5[idx]
            mem[32] = 1
            if stor1[stor5[idx]] > t:
                _634 = mem[64]
                mem[64] = mem[64] + 64
                mem[_634] = 26
                mem[_634 + 32] = 'SafeMath: division by zero'
                if not arg1:
                    return 0
                require arg1
                if arg1 * stor7 / 100000 * 10^18 / arg1 != stor7 / 100000 * 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _805 = mem[64]
                mem[64] = mem[64] + 64
                mem[_805] = 30
                mem[_805 + 32] = 'SafeMath: subtraction overflow'
                if 0 <= arg1 * stor7 / 100000 * 10^18:
                    return (arg1 * stor7 / 100000 * 10^18)
                _849 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_849 + idx + 68] = mem[_805 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_849 + 68] = mem[_849 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _849 + -mem[64] + 100
            require idx < stor5.length
            mem[0] = stor5[idx]
            mem[32] = 2
            if stor2[stor5[idx]] > s:
                _644 = mem[64]
                mem[64] = mem[64] + 64
                mem[_644] = 26
                mem[_644 + 32] = 'SafeMath: division by zero'
                if not arg1:
                    return 0
                require arg1
                if arg1 * stor7 / 100000 * 10^18 / arg1 != stor7 / 100000 * 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _852 = mem[64]
                mem[64] = mem[64] + 64
                mem[_852] = 30
                mem[_852 + 32] = 'SafeMath: subtraction overflow'
                if 0 <= arg1 * stor7 / 100000 * 10^18:
                    return (arg1 * stor7 / 100000 * 10^18)
                _902 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_902 + idx + 68] = mem[_852 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_902 + 68] = mem[_902 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _902 + -mem[64] + 100
            require idx < stor5.length
            mem[0] = stor5[idx]
            mem[32] = 1
            _640 = mem[64]
            mem[64] = mem[64] + 64
            mem[_640] = 30
            mem[_640 + 32] = 'SafeMath: subtraction overflow'
            if stor1[stor5[idx]] > t:
                _654 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_654 + idx + 68] = mem[_640 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_654 + 68] = mem[_654 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _654 + -mem[64] + 100
            require idx < stor5.length
            mem[0] = stor5[idx]
            mem[32] = 2
            _703 = mem[64]
            mem[64] = mem[64] + 64
            mem[_703] = 30
            mem[_703 + 32] = 'SafeMath: subtraction overflow'
            if stor2[stor5[idx]] <= s:
                idx = idx + 1
                s = s - stor2[stor5[idx]]
                t = t - stor1[stor5[idx]]
                continue 
            _726 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[_726 + idx + 68] = mem[_703 + idx + 32]
                idx = idx + 32
                continue 
            mem[_726 + 68] = mem[_726 + 70 len 30]
            revert with memory
              from mem[64]
               len _726 + -mem[64] + 100
        _608 = mem[64]
        mem[64] = mem[64] + 64
        mem[_608] = 26
        mem[_608 + 32] = 'SafeMath: division by zero'
        if t < stor7 / 100000 * 10^18:
            _664 = mem[64]
            mem[64] = mem[64] + 64
            mem[_664] = 26
            mem[_664 + 32] = 'SafeMath: division by zero'
            if not arg1:
                return 0
            require arg1
            if arg1 * stor7 / 100000 * 10^18 / arg1 != stor7 / 100000 * 10^18:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            if 0 > arg1 * stor7 / 100000 * 10^18:
                revert with 0, 'SafeMath: subtraction overflow'
            return (arg1 * stor7 / 100000 * 10^18)
        _663 = mem[64]
        mem[64] = mem[64] + 64
        mem[_663] = 26
        mem[_663 + 32] = 'SafeMath: division by zero'
        if s <= 0:
            revert with 0, 'SafeMath: division by zero'
        require s
        if not arg1:
            return 0
        require arg1
        if arg1 * t / s / arg1 != t / s:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
        if 0 > arg1 * t / s:
            revert with 0, 'SafeMath: subtraction overflow'
    else:
        require arg1 / 100
        if 5 * arg1 / 100 / arg1 / 100 != 5:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
        mem[64] = 224
        mem[160] = 30
        mem[192] = 'SafeMath: subtraction overflow'
        if 5 * arg1 / 100 > arg1:
            revert with 0, 'SafeMath: subtraction overflow'
        idx = 0
        s = 100000 * 10^18
        t = stor7
        while idx < stor5.length:
            mem[0] = stor5[idx]
            mem[32] = 1
            if stor1[stor5[idx]] > t:
                _631 = mem[64]
                mem[64] = mem[64] + 64
                mem[_631] = 26
                mem[_631 + 32] = 'SafeMath: division by zero'
                if not arg1:
                    if not 5 * arg1 / 100:
                        return 0
                    require 5 * arg1 / 100
                    if 5 * arg1 / 100 * stor7 / 100000 * 10^18 / 5 * arg1 / 100 != stor7 / 100000 * 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _803 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_803] = 30
                    mem[_803 + 32] = 'SafeMath: subtraction overflow'
                    if 5 * arg1 / 100 * stor7 / 100000 * 10^18 <= 0:
                        return 0
                    _842 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_842 + idx + 68] = mem[_803 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_842 + 68] = mem[_842 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _842 + -mem[64] + 100
                require arg1
                if arg1 * stor7 / 100000 * 10^18 / arg1 != stor7 / 100000 * 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if not 5 * arg1 / 100:
                    _802 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_802] = 30
                    mem[_802 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= arg1 * stor7 / 100000 * 10^18:
                        return (arg1 * stor7 / 100000 * 10^18)
                    _839 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_839 + idx + 68] = mem[_802 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_839 + 68] = mem[_839 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _839 + -mem[64] + 100
                require 5 * arg1 / 100
                if 5 * arg1 / 100 * stor7 / 100000 * 10^18 / 5 * arg1 / 100 != stor7 / 100000 * 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _838 = mem[64]
                mem[64] = mem[64] + 64
                mem[_838] = 30
                mem[_838 + 32] = 'SafeMath: subtraction overflow'
                if 5 * arg1 / 100 * stor7 / 100000 * 10^18 <= arg1 * stor7 / 100000 * 10^18:
                    return (arg1 * stor7 / 100000 * 10^18)
                _887 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_887 + idx + 68] = mem[_838 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_887 + 68] = mem[_887 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _887 + -mem[64] + 100
            require idx < stor5.length
            mem[0] = stor5[idx]
            mem[32] = 2
            if stor2[stor5[idx]] > s:
                _643 = mem[64]
                mem[64] = mem[64] + 64
                mem[_643] = 26
                mem[_643 + 32] = 'SafeMath: division by zero'
                if not arg1:
                    if not 5 * arg1 / 100:
                        return 0
                    require 5 * arg1 / 100
                    if 5 * arg1 / 100 * stor7 / 100000 * 10^18 / 5 * arg1 / 100 != stor7 / 100000 * 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _846 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_846] = 30
                    mem[_846 + 32] = 'SafeMath: subtraction overflow'
                    if 5 * arg1 / 100 * stor7 / 100000 * 10^18 <= 0:
                        return 0
                    _896 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_896 + idx + 68] = mem[_846 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_896 + 68] = mem[_896 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _896 + -mem[64] + 100
                require arg1
                if arg1 * stor7 / 100000 * 10^18 / arg1 != stor7 / 100000 * 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if not 5 * arg1 / 100:
                    _845 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_845] = 30
                    mem[_845 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= arg1 * stor7 / 100000 * 10^18:
                        return (arg1 * stor7 / 100000 * 10^18)
                    _893 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_893 + idx + 68] = mem[_845 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_893 + 68] = mem[_893 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _893 + -mem[64] + 100
                require 5 * arg1 / 100
                if 5 * arg1 / 100 * stor7 / 100000 * 10^18 / 5 * arg1 / 100 != stor7 / 100000 * 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _892 = mem[64]
                mem[64] = mem[64] + 64
                mem[_892] = 30
                mem[_892 + 32] = 'SafeMath: subtraction overflow'
                if 5 * arg1 / 100 * stor7 / 100000 * 10^18 <= arg1 * stor7 / 100000 * 10^18:
                    return (arg1 * stor7 / 100000 * 10^18)
                _970 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_970 + idx + 68] = mem[_892 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_970 + 68] = mem[_970 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _970 + -mem[64] + 100
            require idx < stor5.length
            mem[0] = stor5[idx]
            mem[32] = 1
            _639 = mem[64]
            mem[64] = mem[64] + 64
            mem[_639] = 30
            mem[_639 + 32] = 'SafeMath: subtraction overflow'
            if stor1[stor5[idx]] > t:
                _651 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_651 + idx + 68] = mem[_639 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_651 + 68] = mem[_651 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _651 + -mem[64] + 100
            require idx < stor5.length
            mem[0] = stor5[idx]
            mem[32] = 2
            _701 = mem[64]
            mem[64] = mem[64] + 64
            mem[_701] = 30
            mem[_701 + 32] = 'SafeMath: subtraction overflow'
            if stor2[stor5[idx]] <= s:
                idx = idx + 1
                s = s - stor2[stor5[idx]]
                t = t - stor1[stor5[idx]]
                continue 
            _721 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[_721 + idx + 68] = mem[_701 + idx + 32]
                idx = idx + 32
                continue 
            mem[_721 + 68] = mem[_721 + 70 len 30]
            revert with memory
              from mem[64]
               len _721 + -mem[64] + 100
        _603 = mem[64]
        mem[64] = mem[64] + 64
        mem[_603] = 26
        mem[_603 + 32] = 'SafeMath: division by zero'
        if t < stor7 / 100000 * 10^18:
            _662 = mem[64]
            mem[64] = mem[64] + 64
            mem[_662] = 26
            mem[_662 + 32] = 'SafeMath: division by zero'
            if not arg1:
                if 5 * arg1 / 100:
                    require 5 * arg1 / 100
                    if 5 * arg1 / 100 * stor7 / 100000 * 10^18 / 5 * arg1 / 100 != stor7 / 100000 * 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if 5 * arg1 / 100 * stor7 / 100000 * 10^18 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    else:
                        return 0
                else:
                    return 0
            require arg1
            if arg1 * stor7 / 100000 * 10^18 / arg1 != stor7 / 100000 * 10^18:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            if not 5 * arg1 / 100:
                if 0 > arg1 * stor7 / 100000 * 10^18:
                    revert with 0, 'SafeMath: subtraction overflow'
            else:
                require 5 * arg1 / 100
                if 5 * arg1 / 100 * stor7 / 100000 * 10^18 / 5 * arg1 / 100 != stor7 / 100000 * 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if 5 * arg1 / 100 * stor7 / 100000 * 10^18 > arg1 * stor7 / 100000 * 10^18:
                    revert with 0, 'SafeMath: subtraction overflow'
            return (arg1 * stor7 / 100000 * 10^18)
        _661 = mem[64]
        mem[64] = mem[64] + 64
        mem[_661] = 26
        mem[_661 + 32] = 'SafeMath: division by zero'
        if s <= 0:
            revert with 0, 'SafeMath: division by zero'
        require s
        if not arg1:
            if 5 * arg1 / 100:
                require 5 * arg1 / 100
                if 5 * arg1 / 100 * t / s / 5 * arg1 / 100 != t / s:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if 5 * arg1 / 100 * t / s > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                else:
                    return 0
            else:
                return 0
        require arg1
        if arg1 * t / s / arg1 != t / s:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
        if not 5 * arg1 / 100:
            if 0 > arg1 * t / s:
                revert with 0, 'SafeMath: subtraction overflow'
        else:
            require 5 * arg1 / 100
            if 5 * arg1 / 100 * t / s / 5 * arg1 / 100 != t / s:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            if 5 * arg1 / 100 * t / s > arg1 * t / s:
                revert with 0, 'SafeMath: subtraction overflow'
    return (arg1 * t / s)
}

function reflect(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    mem[0] = msg.sender
    mem[32] = 4
    if stor4[address(msg.sender)]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    44,
                    0x734578636c75646564206164647265737365732063616e6e6f742063616c6c20746869732066756e6374696f,
                    mem[208 len 20]
    mem[96] = 26
    mem[128] = 'SafeMath: division by zero'
    if not arg1 / 100:
        mem[64] = 224
        mem[160] = 30
        mem[192] = 'SafeMath: subtraction overflow'
        if 0 > arg1:
            revert with 0, 'SafeMath: subtraction overflow'
        idx = 0
        s = 100000 * 10^18
        t = stor7
        while idx < stor5.length:
            mem[0] = stor5[idx]
            mem[32] = 1
            if stor1[stor5[idx]] > t:
                _750 = mem[64]
                mem[64] = mem[64] + 64
                mem[_750] = 26
                mem[_750 + 32] = 'SafeMath: division by zero'
                if not arg1:
                    _828 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_828] = 30
                    mem[_828 + 32] = 'SafeMath: subtraction overflow'
                    mem[0] = msg.sender
                    mem[32] = 1
                    _896 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_896] = 30
                    mem[_896 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > stor1[address(msg.sender)]:
                        _945 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_945 + idx + 68] = mem[_896 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_945 + 68] = mem[_945 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _945 + -mem[64] + 100
                    mem[0] = msg.sender
                    mem[32] = 1
                    _1036 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1036] = 30
                    mem[_1036 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= stor7:
                        if totalFees + arg1 < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        totalFees += arg1
                    _1105 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_1105 + idx + 68] = mem[_1036 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1105 + 68] = mem[_1105 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1105 + -mem[64] + 100
                require arg1
                if arg1 * stor7 / 100000 * 10^18 / arg1 != stor7 / 100000 * 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _836 = mem[64]
                mem[64] = mem[64] + 64
                mem[_836] = 30
                mem[_836 + 32] = 'SafeMath: subtraction overflow'
                if 0 > arg1 * stor7 / 100000 * 10^18:
                    _857 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_857 + idx + 68] = mem[_836 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_857 + 68] = mem[_857 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _857 + -mem[64] + 100
                mem[0] = msg.sender
                mem[32] = 1
                _944 = mem[64]
                mem[64] = mem[64] + 64
                mem[_944] = 30
                mem[_944 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                    _1008 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_1008 + idx + 68] = mem[_944 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1008 + 68] = mem[_1008 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1008 + -mem[64] + 100
                mem[0] = msg.sender
                mem[32] = 1
                stor1[address(msg.sender)] += -1 * arg1 * stor7 / 100000 * 10^18
                _1102 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1102] = 30
                mem[_1102 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor7 / 100000 * 10^18 <= stor7:
                    stor7 += -1 * arg1 * stor7 / 100000 * 10^18
                    if totalFees + arg1 < totalFees:
                        revert with 0, 'SafeMath: addition overflow'
                    totalFees += arg1
                _1186 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_1186 + idx + 68] = mem[_1102 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_1186 + 68] = mem[_1186 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _1186 + -mem[64] + 100
            require idx < stor5.length
            mem[0] = stor5[idx]
            mem[32] = 2
            if stor2[stor5[idx]] <= s:
                require idx < stor5.length
                mem[0] = stor5[idx]
                mem[32] = 1
                _754 = mem[64]
                mem[64] = mem[64] + 64
                mem[_754] = 30
                mem[_754 + 32] = 'SafeMath: subtraction overflow'
                if stor1[stor5[idx]] > t:
                    _760 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_760 + idx + 68] = mem[_754 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_760 + 68] = mem[_760 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _760 + -mem[64] + 100
                require idx < stor5.length
                mem[0] = stor5[idx]
                mem[32] = 2
                _785 = mem[64]
                mem[64] = mem[64] + 64
                mem[_785] = 30
                mem[_785 + 32] = 'SafeMath: subtraction overflow'
                if stor2[stor5[idx]] <= s:
                    idx = idx + 1
                    s = s - stor2[stor5[idx]]
                    t = t - stor1[stor5[idx]]
                    continue 
                _796 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_796 + idx + 68] = mem[_785 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_796 + 68] = mem[_796 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _796 + -mem[64] + 100
            _756 = mem[64]
            mem[64] = mem[64] + 64
            mem[_756] = 26
            mem[_756 + 32] = 'SafeMath: division by zero'
            if not arg1:
                _837 = mem[64]
                mem[64] = mem[64] + 64
                mem[_837] = 30
                mem[_837 + 32] = 'SafeMath: subtraction overflow'
                mem[0] = msg.sender
                mem[32] = 1
                _950 = mem[64]
                mem[64] = mem[64] + 64
                mem[_950] = 30
                mem[_950 + 32] = 'SafeMath: subtraction overflow'
                if 0 > stor1[address(msg.sender)]:
                    _1014 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_1014 + idx + 68] = mem[_950 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1014 + 68] = mem[_1014 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1014 + -mem[64] + 100
                mem[0] = msg.sender
                mem[32] = 1
                _1108 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1108] = 30
                mem[_1108 + 32] = 'SafeMath: subtraction overflow'
                if 0 <= stor7:
                    if totalFees + arg1 < totalFees:
                        revert with 0, 'SafeMath: addition overflow'
                    totalFees += arg1
                _1193 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_1193 + idx + 68] = mem[_1108 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_1193 + 68] = mem[_1193 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _1193 + -mem[64] + 100
            require arg1
            if arg1 * stor7 / 100000 * 10^18 / arg1 != stor7 / 100000 * 10^18:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _860 = mem[64]
            mem[64] = mem[64] + 64
            mem[_860] = 30
            mem[_860 + 32] = 'SafeMath: subtraction overflow'
            if 0 > arg1 * stor7 / 100000 * 10^18:
                _886 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_886 + idx + 68] = mem[_860 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_886 + 68] = mem[_886 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _886 + -mem[64] + 100
            mem[0] = msg.sender
            mem[32] = 1
            _1013 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1013] = 30
            mem[_1013 + 32] = 'SafeMath: subtraction overflow'
            if arg1 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                _1081 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_1081 + idx + 68] = mem[_1013 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_1081 + 68] = mem[_1081 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _1081 + -mem[64] + 100
            mem[0] = msg.sender
            mem[32] = 1
            stor1[address(msg.sender)] += -1 * arg1 * stor7 / 100000 * 10^18
            _1190 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1190] = 30
            mem[_1190 + 32] = 'SafeMath: subtraction overflow'
            if arg1 * stor7 / 100000 * 10^18 <= stor7:
                stor7 += -1 * arg1 * stor7 / 100000 * 10^18
                if totalFees + arg1 < totalFees:
                    revert with 0, 'SafeMath: addition overflow'
                totalFees += arg1
            _1280 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[_1280 + idx + 68] = mem[_1190 + idx + 32]
                idx = idx + 32
                continue 
            mem[_1280 + 68] = mem[_1280 + 70 len 30]
            revert with memory
              from mem[64]
               len _1280 + -mem[64] + 100
        _736 = mem[64]
        mem[64] = mem[64] + 64
        mem[_736] = 26
        mem[_736 + 32] = 'SafeMath: division by zero'
        if t < stor7 / 100000 * 10^18:
            _766 = mem[64]
            mem[64] = mem[64] + 64
            mem[_766] = 26
            mem[_766 + 32] = 'SafeMath: division by zero'
            if not arg1:
                if 0 > stor1[address(msg.sender)]:
                    revert with 0, 'SafeMath: subtraction overflow'
                if 0 > stor7:
                    revert with 0, 'SafeMath: subtraction overflow'
            else:
                require arg1
                if arg1 * stor7 / 100000 * 10^18 / arg1 != stor7 / 100000 * 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if 0 > arg1 * stor7 / 100000 * 10^18:
                    revert with 0, 'SafeMath: subtraction overflow'
                if arg1 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                    revert with 0, 'SafeMath: subtraction overflow'
                stor1[address(msg.sender)] += -1 * arg1 * stor7 / 100000 * 10^18
                if arg1 * stor7 / 100000 * 10^18 > stor7:
                    revert with 0, 'SafeMath: subtraction overflow'
                stor7 += -1 * arg1 * stor7 / 100000 * 10^18
        else:
            _765 = mem[64]
            mem[64] = mem[64] + 64
            mem[_765] = 26
            mem[_765 + 32] = 'SafeMath: division by zero'
            if s <= 0:
                revert with 0, 'SafeMath: division by zero'
            require s
            if not arg1:
                if 0 > stor1[address(msg.sender)]:
                    revert with 0, 'SafeMath: subtraction overflow'
                if 0 > stor7:
                    revert with 0, 'SafeMath: subtraction overflow'
            else:
                require arg1
                if arg1 * t / s / arg1 != t / s:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if 0 > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow'
                if arg1 * t / s > stor1[address(msg.sender)]:
                    revert with 0, 'SafeMath: subtraction overflow'
                stor1[address(msg.sender)] += -1 * arg1 * t / s
                if arg1 * t / s > stor7:
                    revert with 0, 'SafeMath: subtraction overflow'
                stor7 += -1 * arg1 * t / s
    else:
        require arg1 / 100
        if 5 * arg1 / 100 / arg1 / 100 != 5:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
        mem[64] = 224
        mem[160] = 30
        mem[192] = 'SafeMath: subtraction overflow'
        if 5 * arg1 / 100 > arg1:
            revert with 0, 'SafeMath: subtraction overflow'
        idx = 0
        s = 100000 * 10^18
        t = stor7
        while idx < stor5.length:
            mem[0] = stor5[idx]
            mem[32] = 1
            if stor1[stor5[idx]] > t:
                _747 = mem[64]
                mem[64] = mem[64] + 64
                mem[_747] = 26
                mem[_747 + 32] = 'SafeMath: division by zero'
                if not arg1:
                    if not 5 * arg1 / 100:
                        _827 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_827] = 30
                        mem[_827 + 32] = 'SafeMath: subtraction overflow'
                        mem[0] = msg.sender
                        mem[32] = 1
                        _893 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_893] = 30
                        mem[_893 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor1[address(msg.sender)]:
                            _936 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_936 + idx + 68] = mem[_893 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_936 + 68] = mem[_936 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _936 + -mem[64] + 100
                        mem[0] = msg.sender
                        mem[32] = 1
                        _1027 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1027] = 30
                        mem[_1027 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= stor7:
                            if totalFees + arg1 < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += arg1
                        _1096 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_1096 + idx + 68] = mem[_1027 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1096 + 68] = mem[_1096 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _1096 + -mem[64] + 100
                    require 5 * arg1 / 100
                    if 5 * arg1 / 100 * stor7 / 100000 * 10^18 / 5 * arg1 / 100 != stor7 / 100000 * 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _834 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_834] = 30
                    mem[_834 + 32] = 'SafeMath: subtraction overflow'
                    if 5 * arg1 / 100 * stor7 / 100000 * 10^18 > 0:
                        _850 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_850 + idx + 68] = mem[_834 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_850 + 68] = mem[_850 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _850 + -mem[64] + 100
                    mem[0] = msg.sender
                    mem[32] = 1
                    _935 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_935] = 30
                    mem[_935 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > stor1[address(msg.sender)]:
                        _990 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_990 + idx + 68] = mem[_935 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_990 + 68] = mem[_990 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _990 + -mem[64] + 100
                    mem[0] = msg.sender
                    mem[32] = 1
                    _1093 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1093] = 30
                    mem[_1093 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= stor7:
                        if totalFees + arg1 < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        totalFees += arg1
                    _1167 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_1167 + idx + 68] = mem[_1093 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1167 + 68] = mem[_1167 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1167 + -mem[64] + 100
                require arg1
                if arg1 * stor7 / 100000 * 10^18 / arg1 != stor7 / 100000 * 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if not 5 * arg1 / 100:
                    _833 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_833] = 30
                    mem[_833 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor7 / 100000 * 10^18:
                        _847 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_847 + idx + 68] = mem[_833 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_847 + 68] = mem[_847 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _847 + -mem[64] + 100
                    mem[0] = msg.sender
                    mem[32] = 1
                    _934 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_934] = 30
                    mem[_934 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                        _987 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_987 + idx + 68] = mem[_934 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_987 + 68] = mem[_987 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _987 + -mem[64] + 100
                    mem[0] = msg.sender
                    mem[32] = 1
                    stor1[address(msg.sender)] += -1 * arg1 * stor7 / 100000 * 10^18
                    _1090 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1090] = 30
                    mem[_1090 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor7 / 100000 * 10^18 <= stor7:
                        stor7 += -1 * arg1 * stor7 / 100000 * 10^18
                        if totalFees + arg1 < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        totalFees += arg1
                    _1164 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_1164 + idx + 68] = mem[_1090 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1164 + 68] = mem[_1164 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1164 + -mem[64] + 100
                require 5 * arg1 / 100
                if 5 * arg1 / 100 * stor7 / 100000 * 10^18 / 5 * arg1 / 100 != stor7 / 100000 * 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _846 = mem[64]
                mem[64] = mem[64] + 64
                mem[_846] = 30
                mem[_846 + 32] = 'SafeMath: subtraction overflow'
                if 5 * arg1 / 100 * stor7 / 100000 * 10^18 > arg1 * stor7 / 100000 * 10^18:
                    _869 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_869 + idx + 68] = mem[_846 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_869 + 68] = mem[_869 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _869 + -mem[64] + 100
                mem[0] = msg.sender
                mem[32] = 1
                _986 = mem[64]
                mem[64] = mem[64] + 64
                mem[_986] = 30
                mem[_986 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                    _1053 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_1053 + idx + 68] = mem[_986 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1053 + 68] = mem[_1053 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1053 + -mem[64] + 100
                mem[0] = msg.sender
                mem[32] = 1
                stor1[address(msg.sender)] += -1 * arg1 * stor7 / 100000 * 10^18
                _1161 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1161] = 30
                mem[_1161 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor7 / 100000 * 10^18 <= stor7:
                    stor7 += -1 * arg1 * stor7 / 100000 * 10^18
                    if totalFees + arg1 < totalFees:
                        revert with 0, 'SafeMath: addition overflow'
                    totalFees += arg1
                _1246 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_1246 + idx + 68] = mem[_1161 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_1246 + 68] = mem[_1246 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _1246 + -mem[64] + 100
            require idx < stor5.length
            mem[0] = stor5[idx]
            mem[32] = 2
            if stor2[stor5[idx]] <= s:
                require idx < stor5.length
                mem[0] = stor5[idx]
                mem[32] = 1
                _753 = mem[64]
                mem[64] = mem[64] + 64
                mem[_753] = 30
                mem[_753 + 32] = 'SafeMath: subtraction overflow'
                if stor1[stor5[idx]] > t:
                    _757 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_757 + idx + 68] = mem[_753 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_757 + 68] = mem[_757 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _757 + -mem[64] + 100
                require idx < stor5.length
                mem[0] = stor5[idx]
                mem[32] = 2
                _783 = mem[64]
                mem[64] = mem[64] + 64
                mem[_783] = 30
                mem[_783 + 32] = 'SafeMath: subtraction overflow'
                if stor2[stor5[idx]] <= s:
                    idx = idx + 1
                    s = s - stor2[stor5[idx]]
                    t = t - stor1[stor5[idx]]
                    continue 
                _791 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_791 + idx + 68] = mem[_783 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_791 + 68] = mem[_791 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _791 + -mem[64] + 100
            _755 = mem[64]
            mem[64] = mem[64] + 64
            mem[_755] = 26
            mem[_755 + 32] = 'SafeMath: division by zero'
            if not arg1:
                if not 5 * arg1 / 100:
                    _835 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_835] = 30
                    mem[_835 + 32] = 'SafeMath: subtraction overflow'
                    mem[0] = msg.sender
                    mem[32] = 1
                    _943 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_943] = 30
                    mem[_943 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > stor1[address(msg.sender)]:
                        _999 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_999 + idx + 68] = mem[_943 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_999 + 68] = mem[_999 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _999 + -mem[64] + 100
                    mem[0] = msg.sender
                    mem[32] = 1
                    _1099 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1099] = 30
                    mem[_1099 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= stor7:
                        if totalFees + arg1 < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        totalFees += arg1
                    _1177 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_1177 + idx + 68] = mem[_1099 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1177 + 68] = mem[_1177 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1177 + -mem[64] + 100
                require 5 * arg1 / 100
                if 5 * arg1 / 100 * stor7 / 100000 * 10^18 / 5 * arg1 / 100 != stor7 / 100000 * 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _854 = mem[64]
                mem[64] = mem[64] + 64
                mem[_854] = 30
                mem[_854 + 32] = 'SafeMath: subtraction overflow'
                if 5 * arg1 / 100 * stor7 / 100000 * 10^18 > 0:
                    _879 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_879 + idx + 68] = mem[_854 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_879 + 68] = mem[_879 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _879 + -mem[64] + 100
                mem[0] = msg.sender
                mem[32] = 1
                _998 = mem[64]
                mem[64] = mem[64] + 64
                mem[_998] = 30
                mem[_998 + 32] = 'SafeMath: subtraction overflow'
                if 0 > stor1[address(msg.sender)]:
                    _1065 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_1065 + idx + 68] = mem[_998 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1065 + 68] = mem[_1065 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1065 + -mem[64] + 100
                mem[0] = msg.sender
                mem[32] = 1
                _1174 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1174] = 30
                mem[_1174 + 32] = 'SafeMath: subtraction overflow'
                if 0 <= stor7:
                    if totalFees + arg1 < totalFees:
                        revert with 0, 'SafeMath: addition overflow'
                    totalFees += arg1
                _1260 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_1260 + idx + 68] = mem[_1174 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_1260 + 68] = mem[_1260 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _1260 + -mem[64] + 100
            require arg1
            if arg1 * stor7 / 100000 * 10^18 / arg1 != stor7 / 100000 * 10^18:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            if not 5 * arg1 / 100:
                _853 = mem[64]
                mem[64] = mem[64] + 64
                mem[_853] = 30
                mem[_853 + 32] = 'SafeMath: subtraction overflow'
                if 0 > arg1 * stor7 / 100000 * 10^18:
                    _876 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_876 + idx + 68] = mem[_853 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_876 + 68] = mem[_876 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _876 + -mem[64] + 100
                mem[0] = msg.sender
                mem[32] = 1
                _997 = mem[64]
                mem[64] = mem[64] + 64
                mem[_997] = 30
                mem[_997 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                    _1062 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_1062 + idx + 68] = mem[_997 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1062 + 68] = mem[_1062 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1062 + -mem[64] + 100
                mem[0] = msg.sender
                mem[32] = 1
                stor1[address(msg.sender)] += -1 * arg1 * stor7 / 100000 * 10^18
                _1171 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1171] = 30
                mem[_1171 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor7 / 100000 * 10^18 <= stor7:
                    stor7 += -1 * arg1 * stor7 / 100000 * 10^18
                    if totalFees + arg1 < totalFees:
                        revert with 0, 'SafeMath: addition overflow'
                    totalFees += arg1
                _1257 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_1257 + idx + 68] = mem[_1171 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_1257 + 68] = mem[_1257 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _1257 + -mem[64] + 100
            require 5 * arg1 / 100
            if 5 * arg1 / 100 * stor7 / 100000 * 10^18 / 5 * arg1 / 100 != stor7 / 100000 * 10^18:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _875 = mem[64]
            mem[64] = mem[64] + 64
            mem[_875] = 30
            mem[_875 + 32] = 'SafeMath: subtraction overflow'
            if 5 * arg1 / 100 * stor7 / 100000 * 10^18 > arg1 * stor7 / 100000 * 10^18:
                _916 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_916 + idx + 68] = mem[_875 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_916 + 68] = mem[_916 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _916 + -mem[64] + 100
            mem[0] = msg.sender
            mem[32] = 1
            _1061 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1061] = 30
            mem[_1061 + 32] = 'SafeMath: subtraction overflow'
            if arg1 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                _1133 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_1133 + idx + 68] = mem[_1061 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_1133 + 68] = mem[_1133 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _1133 + -mem[64] + 100
            mem[0] = msg.sender
            mem[32] = 1
            stor1[address(msg.sender)] += -1 * arg1 * stor7 / 100000 * 10^18
            _1254 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1254] = 30
            mem[_1254 + 32] = 'SafeMath: subtraction overflow'
            if arg1 * stor7 / 100000 * 10^18 <= stor7:
                stor7 += -1 * arg1 * stor7 / 100000 * 10^18
                if totalFees + arg1 < totalFees:
                    revert with 0, 'SafeMath: addition overflow'
                totalFees += arg1
            _1332 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[_1332 + idx + 68] = mem[_1254 + idx + 32]
                idx = idx + 32
                continue 
            mem[_1332 + 68] = mem[_1332 + 70 len 30]
            revert with memory
              from mem[64]
               len _1332 + -mem[64] + 100
        _731 = mem[64]
        mem[64] = mem[64] + 64
        mem[_731] = 26
        mem[_731 + 32] = 'SafeMath: division by zero'
        if t < stor7 / 100000 * 10^18:
            _764 = mem[64]
            mem[64] = mem[64] + 64
            mem[_764] = 26
            mem[_764 + 32] = 'SafeMath: division by zero'
            if not arg1:
                if 5 * arg1 / 100:
                    require 5 * arg1 / 100
                    if 5 * arg1 / 100 * stor7 / 100000 * 10^18 / 5 * arg1 / 100 != stor7 / 100000 * 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if 5 * arg1 / 100 * stor7 / 100000 * 10^18 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                if 0 > stor1[address(msg.sender)]:
                    revert with 0, 'SafeMath: subtraction overflow'
                if 0 > stor7:
                    revert with 0, 'SafeMath: subtraction overflow'
            else:
                require arg1
                if arg1 * stor7 / 100000 * 10^18 / arg1 != stor7 / 100000 * 10^18:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if not 5 * arg1 / 100:
                    if 0 > arg1 * stor7 / 100000 * 10^18:
                        revert with 0, 'SafeMath: subtraction overflow'
                else:
                    require 5 * arg1 / 100
                    if 5 * arg1 / 100 * stor7 / 100000 * 10^18 / 5 * arg1 / 100 != stor7 / 100000 * 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if 5 * arg1 / 100 * stor7 / 100000 * 10^18 > arg1 * stor7 / 100000 * 10^18:
                        revert with 0, 'SafeMath: subtraction overflow'
                if arg1 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                    revert with 0, 'SafeMath: subtraction overflow'
                stor1[address(msg.sender)] += -1 * arg1 * stor7 / 100000 * 10^18
                if arg1 * stor7 / 100000 * 10^18 > stor7:
                    revert with 0, 'SafeMath: subtraction overflow'
                stor7 += -1 * arg1 * stor7 / 100000 * 10^18
        else:
            _763 = mem[64]
            mem[64] = mem[64] + 64
            mem[_763] = 26
            mem[_763 + 32] = 'SafeMath: division by zero'
            if s <= 0:
                revert with 0, 'SafeMath: division by zero'
            require s
            if not arg1:
                if 5 * arg1 / 100:
                    require 5 * arg1 / 100
                    if 5 * arg1 / 100 * t / s / 5 * arg1 / 100 != t / s:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if 5 * arg1 / 100 * t / s > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                if 0 > stor1[address(msg.sender)]:
                    revert with 0, 'SafeMath: subtraction overflow'
                if 0 > stor7:
                    revert with 0, 'SafeMath: subtraction overflow'
            else:
                require arg1
                if arg1 * t / s / arg1 != t / s:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if not 5 * arg1 / 100:
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow'
                else:
                    require 5 * arg1 / 100
                    if 5 * arg1 / 100 * t / s / 5 * arg1 / 100 != t / s:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if 5 * arg1 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow'
                if arg1 * t / s > stor1[address(msg.sender)]:
                    revert with 0, 'SafeMath: subtraction overflow'
                stor1[address(msg.sender)] += -1 * arg1 * t / s
                if arg1 * t / s > stor7:
                    revert with 0, 'SafeMath: subtraction overflow'
                stor7 += -1 * arg1 * t / s
    if totalFees + arg1 < totalFees:
        revert with 0, 'SafeMath: addition overflow'
    totalFees += arg1
}

function transfer(address arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    if not msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    37,
                    0x6f45524332303a207472616e736665722066726f6d20746865207a65726f20616464726573,
                    mem[201 len 27]
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    35,
                    0xfe45524332303a207472616e7366657220746f20746865207a65726f20616464726573,
                    mem[199 len 29]
    if arg2 <= 0:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    41,
                    0x655472616e7366657220616d6f756e74206d7573742062652067726561746572207468616e207a6572,
                    mem[205 len 23]
    if not stor4[address(msg.sender)]:
        if stor4[address(msg.sender)]:
            mem[0] = msg.sender
            mem[32] = 4
            if stor4[address(msg.sender)]:
                mem[96] = 26
                mem[128] = 'SafeMath: division by zero'
                if not arg2 / 100:
                    mem[64] = 224
                    mem[160] = 30
                    mem[192] = 'SafeMath: subtraction overflow'
                    if 0 > arg2:
                        revert with 0, 'SafeMath: subtraction overflow'
                    idx = 0
                    s = 100000 * 10^18
                    t = stor7
                    while idx < stor5.length:
                        mem[0] = stor5[idx]
                        mem[32] = 1
                        if stor1[stor5[idx]] > t:
                            _14481 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14481] = 26
                            mem[_14481 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                _15679 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15679] = 30
                                mem[_15679 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = msg.sender
                                mem[32] = 1
                                _16615 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16615] = 30
                                mem[_16615 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _17266 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_17266 + idx + 68] = mem[_16615 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_17266 + 68] = mem[_17266 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _17266 + -mem[64] + 100
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                _20888 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20888] = 30
                                mem[_20888 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor7:
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _22035 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_22035 + idx + 68] = mem[_20888 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22035 + 68] = mem[_22035 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _22035 + -mem[64] + 100
                            require arg2
                            if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _15771 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15771] = 30
                            mem[_15771 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg2 * stor7 / 100000 * 10^18:
                                _15946 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_15946 + idx + 68] = mem[_15771 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15946 + 68] = mem[_15946 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _15946 + -mem[64] + 100
                            mem[0] = msg.sender
                            mem[32] = 1
                            _17265 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_17265] = 30
                            mem[_17265 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                _17946 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_17946 + idx + 68] = mem[_17265 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_17946 + 68] = mem[_17946 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _17946 + -mem[64] + 100
                            stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                            if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                            _22034 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22034] = 30
                            mem[_22034 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor7:
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg2, msg.sender, arg1);
                                return 1
                            _22994 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_22994 + idx + 68] = mem[_22034 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_22994 + 68] = mem[_22994 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _22994 + -mem[64] + 100
                        require idx < stor5.length
                        mem[0] = stor5[idx]
                        mem[32] = 2
                        if stor2[stor5[idx]] <= s:
                            require idx < stor5.length
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            _14569 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14569] = 30
                            mem[_14569 + 32] = 'SafeMath: subtraction overflow'
                            if stor1[stor5[idx]] > t:
                                _14631 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_14631 + idx + 68] = mem[_14569 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14631 + 68] = mem[_14631 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _14631 + -mem[64] + 100
                            require idx < stor5.length
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            _15020 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15020] = 30
                            mem[_15020 + 32] = 'SafeMath: subtraction overflow'
                            if stor2[stor5[idx]] <= s:
                                idx = idx + 1
                                s = s - stor2[stor5[idx]]
                                t = t - stor1[stor5[idx]]
                                continue 
                            _15115 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_15115 + idx + 68] = mem[_15020 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_15115 + 68] = mem[_15115 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _15115 + -mem[64] + 100
                        _14599 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14599] = 26
                        mem[_14599 + 32] = 'SafeMath: division by zero'
                        if not arg2:
                            _15772 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15772] = 30
                            mem[_15772 + 32] = 'SafeMath: subtraction overflow'
                            mem[0] = msg.sender
                            mem[32] = 1
                            _17271 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_17271] = 30
                            mem[_17271 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor1[address(msg.sender)]:
                                _17953 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_17953 + idx + 68] = mem[_17271 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_17953 + 68] = mem[_17953 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _17953 + -mem[64] + 100
                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            _22039 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22039] = 30
                            mem[_22039 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor7:
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg2, msg.sender, arg1);
                                return 1
                            _22999 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_22999 + idx + 68] = mem[_22039 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_22999 + 68] = mem[_22999 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _22999 + -mem[64] + 100
                        require arg2
                        if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _15949 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15949] = 30
                        mem[_15949 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg2 * stor7 / 100000 * 10^18:
                            _16269 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_16269 + idx + 68] = mem[_15949 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_16269 + 68] = mem[_16269 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _16269 + -mem[64] + 100
                        mem[0] = msg.sender
                        mem[32] = 1
                        _17952 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_17952] = 30
                        mem[_17952 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                            _18910 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_18910 + idx + 68] = mem[_17952 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_18910 + 68] = mem[_18910 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _18910 + -mem[64] + 100
                        stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                        if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg1
                        mem[32] = 1
                        stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                        _22998 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_22998] = 30
                        mem[_22998 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= stor7:
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(arg2, msg.sender, arg1);
                            return 1
                        _23767 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_23767 + idx + 68] = mem[_22998 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_23767 + 68] = mem[_23767 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _23767 + -mem[64] + 100
                    _14243 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14243] = 26
                    mem[_14243 + 32] = 'SafeMath: division by zero'
                    if t < stor7 / 100000 * 10^18:
                        _14721 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14721] = 26
                        mem[_14721 + 32] = 'SafeMath: division by zero'
                        if not arg2:
                            if 0 > stor1[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                        else:
                            require arg2
                            if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if 0 > arg2 * stor7 / 100000 * 10^18:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                            if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                    else:
                        _14720 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14720] = 26
                        mem[_14720 + 32] = 'SafeMath: division by zero'
                        if s <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require s
                        if not arg2:
                            if 0 > stor1[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                        else:
                            require arg2
                            if arg2 * t / s / arg2 != t / s:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if 0 > arg2 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if arg2 * t / s > stor1[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor1[address(msg.sender)] += -1 * arg2 * t / s
                            if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor1[address(arg1)] += arg2 * t / s
                    if 0 > stor7:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if totalFees < totalFees:
                        revert with 0, 'SafeMath: addition overflow'
                    emit Transfer(arg2, msg.sender, arg1);
                else:
                    require arg2 / 100
                    if 5 * arg2 / 100 / arg2 / 100 != 5:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                    mem[64] = 224
                    mem[160] = 30
                    mem[192] = 'SafeMath: subtraction overflow'
                    if 5 * arg2 / 100 > arg2:
                        revert with 0, 'SafeMath: subtraction overflow'
                    idx = 0
                    s = 100000 * 10^18
                    t = stor7
                    while idx < stor5.length:
                        mem[0] = stor5[idx]
                        mem[32] = 1
                        if stor1[stor5[idx]] > t:
                            _14478 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14478] = 26
                            mem[_14478 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                if not 5 * arg2 / 100:
                                    _15678 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15678] = 30
                                    mem[_15678 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _16612 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16612] = 30
                                    mem[_16612 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _17257 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_17257 + idx + 68] = mem[_16612 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17257 + 68] = mem[_17257 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _17257 + -mem[64] + 100
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _20877 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20877] = 30
                                    mem[_20877 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor7:
                                        if totalFees + (5 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 5 * arg2 / 100
                                        emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _22020 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_22020 + idx + 68] = mem[_20877 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22020 + 68] = mem[_22020 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _22020 + -mem[64] + 100
                                require 5 * arg2 / 100
                                if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _15769 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15769] = 30
                                mem[_15769 + 32] = 'SafeMath: subtraction overflow'
                                if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > 0:
                                    _15939 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_15939 + idx + 68] = mem[_15769 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15939 + 68] = mem[_15939 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _15939 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _17256 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17256] = 30
                                mem[_17256 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _17927 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_17927 + idx + 68] = mem[_17256 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_17927 + 68] = mem[_17927 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _17927 + -mem[64] + 100
                                if stor1[address(arg1)] - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                _22019 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22019] = 30
                                mem[_22019 + 32] = 'SafeMath: subtraction overflow'
                                if 5 * arg2 / 100 * stor7 / 100000 * 10^18 <= stor7:
                                    stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                    if totalFees + (5 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 5 * arg2 / 100
                                    emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _22980 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_22980 + idx + 68] = mem[_22019 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22980 + 68] = mem[_22980 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _22980 + -mem[64] + 100
                            require arg2
                            if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not 5 * arg2 / 100:
                                _15768 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15768] = 30
                                mem[_15768 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor7 / 100000 * 10^18:
                                    _15936 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_15936 + idx + 68] = mem[_15768 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15936 + 68] = mem[_15936 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _15936 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _17255 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17255] = 30
                                mem[_17255 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                    _17924 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_17924 + idx + 68] = mem[_17255 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_17924 + 68] = mem[_17924 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _17924 + -mem[64] + 100
                                stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                                _22018 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22018] = 30
                                mem[_22018 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor7:
                                    if totalFees + (5 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 5 * arg2 / 100
                                    emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _22977 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_22977 + idx + 68] = mem[_22018 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22977 + 68] = mem[_22977 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _22977 + -mem[64] + 100
                            require 5 * arg2 / 100
                            if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _15935 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15935] = 30
                            mem[_15935 + 32] = 'SafeMath: subtraction overflow'
                            if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > arg2 * stor7 / 100000 * 10^18:
                                _16252 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_16252 + idx + 68] = mem[_15935 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_16252 + 68] = mem[_16252 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _16252 + -mem[64] + 100
                            mem[0] = msg.sender
                            mem[32] = 1
                            _17923 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_17923] = 30
                            mem[_17923 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                _18874 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_18874 + idx + 68] = mem[_17923 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_18874 + 68] = mem[_18874 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _18874 + -mem[64] + 100
                            stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                            if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18)
                            _22976 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22976] = 30
                            mem[_22976 + 32] = 'SafeMath: subtraction overflow'
                            if 5 * arg2 / 100 * stor7 / 100000 * 10^18 <= stor7:
                                stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                if totalFees + (5 * arg2 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 5 * arg2 / 100
                                emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                return 1
                            _23739 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_23739 + idx + 68] = mem[_22976 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_23739 + 68] = mem[_23739 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _23739 + -mem[64] + 100
                        require idx < stor5.length
                        mem[0] = stor5[idx]
                        mem[32] = 2
                        if stor2[stor5[idx]] <= s:
                            require idx < stor5.length
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            _14568 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14568] = 30
                            mem[_14568 + 32] = 'SafeMath: subtraction overflow'
                            if stor1[stor5[idx]] > t:
                                _14628 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_14628 + idx + 68] = mem[_14568 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14628 + 68] = mem[_14628 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _14628 + -mem[64] + 100
                            require idx < stor5.length
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            _15018 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15018] = 30
                            mem[_15018 + 32] = 'SafeMath: subtraction overflow'
                            if stor2[stor5[idx]] <= s:
                                idx = idx + 1
                                s = s - stor2[stor5[idx]]
                                t = t - stor1[stor5[idx]]
                                continue 
                            _15110 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_15110 + idx + 68] = mem[_15018 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_15110 + 68] = mem[_15110 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _15110 + -mem[64] + 100
                        _14598 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14598] = 26
                        mem[_14598 + 32] = 'SafeMath: division by zero'
                        if not arg2:
                            if not 5 * arg2 / 100:
                                _15770 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15770] = 30
                                mem[_15770 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = msg.sender
                                mem[32] = 1
                                _17264 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17264] = 30
                                mem[_17264 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _17937 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_17937 + idx + 68] = mem[_17264 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_17937 + 68] = mem[_17937 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _17937 + -mem[64] + 100
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                _22027 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22027] = 30
                                mem[_22027 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor7:
                                    if totalFees + (5 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 5 * arg2 / 100
                                    emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _22987 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_22987 + idx + 68] = mem[_22027 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22987 + 68] = mem[_22987 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _22987 + -mem[64] + 100
                            require 5 * arg2 / 100
                            if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _15943 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15943] = 30
                            mem[_15943 + 32] = 'SafeMath: subtraction overflow'
                            if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > 0:
                                _16262 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_16262 + idx + 68] = mem[_15943 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_16262 + 68] = mem[_16262 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _16262 + -mem[64] + 100
                            mem[0] = msg.sender
                            mem[32] = 1
                            _17936 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_17936] = 30
                            mem[_17936 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor1[address(msg.sender)]:
                                _18890 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_18890 + idx + 68] = mem[_17936 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_18890 + 68] = mem[_18890 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _18890 + -mem[64] + 100
                            if stor1[address(arg1)] - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                            _22986 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22986] = 30
                            mem[_22986 + 32] = 'SafeMath: subtraction overflow'
                            if 5 * arg2 / 100 * stor7 / 100000 * 10^18 <= stor7:
                                stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                if totalFees + (5 * arg2 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 5 * arg2 / 100
                                emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                return 1
                            _23751 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_23751 + idx + 68] = mem[_22986 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_23751 + 68] = mem[_23751 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _23751 + -mem[64] + 100
                        require arg2
                        if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if not 5 * arg2 / 100:
                            _15942 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15942] = 30
                            mem[_15942 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg2 * stor7 / 100000 * 10^18:
                                _16259 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_16259 + idx + 68] = mem[_15942 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_16259 + 68] = mem[_16259 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _16259 + -mem[64] + 100
                            mem[0] = msg.sender
                            mem[32] = 1
                            _17935 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_17935] = 30
                            mem[_17935 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                _18887 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_18887 + idx + 68] = mem[_17935 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_18887 + 68] = mem[_18887 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _18887 + -mem[64] + 100
                            stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                            if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                            _22985 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22985] = 30
                            mem[_22985 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor7:
                                if totalFees + (5 * arg2 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 5 * arg2 / 100
                                emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                return 1
                            _23748 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_23748 + idx + 68] = mem[_22985 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_23748 + 68] = mem[_23748 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _23748 + -mem[64] + 100
                        require 5 * arg2 / 100
                        if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _16258 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16258] = 30
                        mem[_16258 + 32] = 'SafeMath: subtraction overflow'
                        if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > arg2 * stor7 / 100000 * 10^18:
                            _16747 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_16747 + idx + 68] = mem[_16258 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_16747 + 68] = mem[_16747 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _16747 + -mem[64] + 100
                        mem[0] = msg.sender
                        mem[32] = 1
                        _18886 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_18886] = 30
                        mem[_18886 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                            _19978 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_19978 + idx + 68] = mem[_18886 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_19978 + 68] = mem[_19978 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _19978 + -mem[64] + 100
                        stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                        if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg1
                        mem[32] = 1
                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18)
                        _23747 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23747] = 30
                        mem[_23747 + 32] = 'SafeMath: subtraction overflow'
                        if 5 * arg2 / 100 * stor7 / 100000 * 10^18 <= stor7:
                            stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                            if totalFees + (5 * arg2 / 100) < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += 5 * arg2 / 100
                            emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                            return 1
                        _24584 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_24584 + idx + 68] = mem[_23747 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_24584 + 68] = mem[_24584 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _24584 + -mem[64] + 100
                    _14238 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14238] = 26
                    mem[_14238 + 32] = 'SafeMath: division by zero'
                    if t < stor7 / 100000 * 10^18:
                        _14719 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14719] = 26
                        mem[_14719 + 32] = 'SafeMath: division by zero'
                        if not arg2:
                            if not 5 * arg2 / 100:
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if 0 > stor7:
                                    revert with 0, 'SafeMath: subtraction overflow'
                            else:
                                require 5 * arg2 / 100
                                if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if stor1[address(arg1)] - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > stor7:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                        else:
                            require arg2
                            if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not 5 * arg2 / 100:
                                if 0 > arg2 * stor7 / 100000 * 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                                if 0 > stor7:
                                    revert with 0, 'SafeMath: subtraction overflow'
                            else:
                                require 5 * arg2 / 100
                                if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > arg2 * stor7 / 100000 * 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18)
                                if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > stor7:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                    else:
                        _14718 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14718] = 26
                        mem[_14718 + 32] = 'SafeMath: division by zero'
                        if s <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require s
                        if not arg2:
                            if not 5 * arg2 / 100:
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if 0 > stor7:
                                    revert with 0, 'SafeMath: subtraction overflow'
                            else:
                                require 5 * arg2 / 100
                                if 5 * arg2 / 100 * t / s / 5 * arg2 / 100 != t / s:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if 5 * arg2 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if stor1[address(arg1)] - (5 * arg2 / 100 * t / s) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] += -5 * arg2 / 100 * t / s
                                if 5 * arg2 / 100 * t / s > stor7:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor7 += -5 * arg2 / 100 * t / s
                        else:
                            require arg2
                            if arg2 * t / s / arg2 != t / s:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not 5 * arg2 / 100:
                                if 0 > arg2 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if arg2 * t / s > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor1[address(msg.sender)] += -1 * arg2 * t / s
                                if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] += arg2 * t / s
                                if 0 > stor7:
                                    revert with 0, 'SafeMath: subtraction overflow'
                            else:
                                require 5 * arg2 / 100
                                if 5 * arg2 / 100 * t / s / 5 * arg2 / 100 != t / s:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if 5 * arg2 / 100 * t / s > arg2 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if arg2 * t / s > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor1[address(msg.sender)] += -1 * arg2 * t / s
                                if stor1[address(arg1)] + (arg2 * t / s) - (5 * arg2 / 100 * t / s) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (5 * arg2 / 100 * t / s)
                                if 5 * arg2 / 100 * t / s > stor7:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor7 += -5 * arg2 / 100 * t / s
                    if totalFees + (5 * arg2 / 100) < totalFees:
                        revert with 0, 'SafeMath: addition overflow'
                    totalFees += 5 * arg2 / 100
                    emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
            else:
                mem[0] = arg1
                mem[32] = 4
                mem[96] = 26
                mem[128] = 'SafeMath: division by zero'
                if stor4[address(arg1)]:
                    if not arg2 / 100:
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if 0 > arg2:
                            revert with 0, 'SafeMath: subtraction overflow'
                        idx = 0
                        s = 100000 * 10^18
                        t = stor7
                        while idx < stor5.length:
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            if stor1[stor5[idx]] > t:
                                _14487 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14487] = 26
                                mem[_14487 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    _15681 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15681] = 30
                                    mem[_15681 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _16623 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16623] = 30
                                    mem[_16623 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _17285 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_17285 + idx + 68] = mem[_16623 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17285 + 68] = mem[_17285 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _17285 + -mem[64] + 100
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _20911 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20911] = 30
                                    mem[_20911 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor7:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _22068 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_22068 + idx + 68] = mem[_20911 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22068 + 68] = mem[_22068 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _22068 + -mem[64] + 100
                                require arg2
                                if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _15776 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15776] = 30
                                mem[_15776 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor7 / 100000 * 10^18:
                                    _15963 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_15963 + idx + 68] = mem[_15776 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15963 + 68] = mem[_15963 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _15963 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _17284 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17284] = 30
                                mem[_17284 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                    _17989 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_17989 + idx + 68] = mem[_17284 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_17989 + 68] = mem[_17989 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _17989 + -mem[64] + 100
                                stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                                _22067 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22067] = 30
                                mem[_22067 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor7:
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _23030 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_23030 + idx + 68] = mem[_22067 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23030 + 68] = mem[_23030 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _23030 + -mem[64] + 100
                            require idx < stor5.length
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            if stor2[stor5[idx]] <= s:
                                require idx < stor5.length
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                _14571 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14571] = 30
                                mem[_14571 + 32] = 'SafeMath: subtraction overflow'
                                if stor1[stor5[idx]] > t:
                                    _14637 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_14637 + idx + 68] = mem[_14571 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14637 + 68] = mem[_14637 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _14637 + -mem[64] + 100
                                require idx < stor5.length
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                _15024 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15024] = 30
                                mem[_15024 + 32] = 'SafeMath: subtraction overflow'
                                if stor2[stor5[idx]] <= s:
                                    idx = idx + 1
                                    s = s - stor2[stor5[idx]]
                                    t = t - stor1[stor5[idx]]
                                    continue 
                                _15125 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_15125 + idx + 68] = mem[_15024 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15125 + 68] = mem[_15125 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _15125 + -mem[64] + 100
                            _14601 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14601] = 26
                            mem[_14601 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                _15777 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15777] = 30
                                mem[_15777 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = msg.sender
                                mem[32] = 1
                                _17290 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17290] = 30
                                mem[_17290 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _17996 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_17996 + idx + 68] = mem[_17290 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_17996 + 68] = mem[_17996 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _17996 + -mem[64] + 100
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                _22072 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22072] = 30
                                mem[_22072 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor7:
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _23035 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_23035 + idx + 68] = mem[_22072 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23035 + 68] = mem[_23035 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _23035 + -mem[64] + 100
                            require arg2
                            if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _15966 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15966] = 30
                            mem[_15966 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg2 * stor7 / 100000 * 10^18:
                                _16293 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_16293 + idx + 68] = mem[_15966 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_16293 + 68] = mem[_16293 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _16293 + -mem[64] + 100
                            mem[0] = msg.sender
                            mem[32] = 1
                            _17995 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_17995] = 30
                            mem[_17995 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                _18966 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_18966 + idx + 68] = mem[_17995 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_18966 + 68] = mem[_18966 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _18966 + -mem[64] + 100
                            stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                            if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                            _23034 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23034] = 30
                            mem[_23034 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor7:
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg2, msg.sender, arg1);
                                return 1
                            _23811 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_23811 + idx + 68] = mem[_23034 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_23811 + 68] = mem[_23811 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _23811 + -mem[64] + 100
                        _14253 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14253] = 26
                        mem[_14253 + 32] = 'SafeMath: division by zero'
                        if t < stor7 / 100000 * 10^18:
                            _14725 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14725] = 26
                            mem[_14725 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                            else:
                                require arg2
                                if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if 0 > arg2 * stor7 / 100000 * 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                        else:
                            _14724 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14724] = 26
                            mem[_14724 + 32] = 'SafeMath: division by zero'
                            if s <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require s
                            if not arg2:
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                            else:
                                require arg2
                                if arg2 * t / s / arg2 != t / s:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if 0 > arg2 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if arg2 * t / s > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor1[address(msg.sender)] += -1 * arg2 * t / s
                                if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] += arg2 * t / s
                        if 0 > stor7:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if totalFees < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        emit Transfer(arg2, msg.sender, arg1);
                    else:
                        require arg2 / 100
                        if 5 * arg2 / 100 / arg2 / 100 != 5:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if 5 * arg2 / 100 > arg2:
                            revert with 0, 'SafeMath: subtraction overflow'
                        idx = 0
                        s = 100000 * 10^18
                        t = stor7
                        while idx < stor5.length:
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            if stor1[stor5[idx]] > t:
                                _14484 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14484] = 26
                                mem[_14484 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not 5 * arg2 / 100:
                                        _15680 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_15680] = 30
                                        mem[_15680 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _16620 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16620] = 30
                                        mem[_16620 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _17276 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_17276 + idx + 68] = mem[_16620 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_17276 + 68] = mem[_17276 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _17276 + -mem[64] + 100
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _20900 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_20900] = 30
                                        mem[_20900 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor7:
                                            if totalFees + (5 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 5 * arg2 / 100
                                            emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _22053 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_22053 + idx + 68] = mem[_20900 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22053 + 68] = mem[_22053 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _22053 + -mem[64] + 100
                                    require 5 * arg2 / 100
                                    if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _15774 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15774] = 30
                                    mem[_15774 + 32] = 'SafeMath: subtraction overflow'
                                    if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > 0:
                                        _15956 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_15956 + idx + 68] = mem[_15774 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_15956 + 68] = mem[_15956 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _15956 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _17275 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17275] = 30
                                    mem[_17275 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _17970 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_17970 + idx + 68] = mem[_17275 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17970 + 68] = mem[_17970 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _17970 + -mem[64] + 100
                                    if stor1[address(arg1)] - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                    _22052 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22052] = 30
                                    mem[_22052 + 32] = 'SafeMath: subtraction overflow'
                                    if 5 * arg2 / 100 * stor7 / 100000 * 10^18 <= stor7:
                                        stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                        if totalFees + (5 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 5 * arg2 / 100
                                        emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _23016 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_23016 + idx + 68] = mem[_22052 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23016 + 68] = mem[_23016 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _23016 + -mem[64] + 100
                                require arg2
                                if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not 5 * arg2 / 100:
                                    _15773 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15773] = 30
                                    mem[_15773 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor7 / 100000 * 10^18:
                                        _15953 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_15953 + idx + 68] = mem[_15773 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_15953 + 68] = mem[_15953 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _15953 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _17274 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17274] = 30
                                    mem[_17274 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                        _17967 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_17967 + idx + 68] = mem[_17274 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17967 + 68] = mem[_17967 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _17967 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                                    _22051 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22051] = 30
                                    mem[_22051 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor7:
                                        if totalFees + (5 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 5 * arg2 / 100
                                        emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _23013 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_23013 + idx + 68] = mem[_22051 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23013 + 68] = mem[_23013 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _23013 + -mem[64] + 100
                                require 5 * arg2 / 100
                                if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _15952 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15952] = 30
                                mem[_15952 + 32] = 'SafeMath: subtraction overflow'
                                if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > arg2 * stor7 / 100000 * 10^18:
                                    _16276 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_16276 + idx + 68] = mem[_15952 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_16276 + 68] = mem[_16276 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _16276 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _17966 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17966] = 30
                                mem[_17966 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                    _18930 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_18930 + idx + 68] = mem[_17966 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18930 + 68] = mem[_18930 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _18930 + -mem[64] + 100
                                stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18)
                                _23012 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23012] = 30
                                mem[_23012 + 32] = 'SafeMath: subtraction overflow'
                                if 5 * arg2 / 100 * stor7 / 100000 * 10^18 <= stor7:
                                    stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                    if totalFees + (5 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 5 * arg2 / 100
                                    emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _23783 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_23783 + idx + 68] = mem[_23012 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23783 + 68] = mem[_23783 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _23783 + -mem[64] + 100
                            require idx < stor5.length
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            if stor2[stor5[idx]] <= s:
                                require idx < stor5.length
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                _14570 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14570] = 30
                                mem[_14570 + 32] = 'SafeMath: subtraction overflow'
                                if stor1[stor5[idx]] > t:
                                    _14634 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_14634 + idx + 68] = mem[_14570 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14634 + 68] = mem[_14634 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _14634 + -mem[64] + 100
                                require idx < stor5.length
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                _15022 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15022] = 30
                                mem[_15022 + 32] = 'SafeMath: subtraction overflow'
                                if stor2[stor5[idx]] <= s:
                                    idx = idx + 1
                                    s = s - stor2[stor5[idx]]
                                    t = t - stor1[stor5[idx]]
                                    continue 
                                _15120 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_15120 + idx + 68] = mem[_15022 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15120 + 68] = mem[_15120 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _15120 + -mem[64] + 100
                            _14600 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14600] = 26
                            mem[_14600 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                if not 5 * arg2 / 100:
                                    _15775 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15775] = 30
                                    mem[_15775 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _17283 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17283] = 30
                                    mem[_17283 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _17980 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_17980 + idx + 68] = mem[_17283 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17980 + 68] = mem[_17980 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _17980 + -mem[64] + 100
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _22060 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22060] = 30
                                    mem[_22060 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor7:
                                        if totalFees + (5 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 5 * arg2 / 100
                                        emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _23023 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_23023 + idx + 68] = mem[_22060 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23023 + 68] = mem[_23023 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _23023 + -mem[64] + 100
                                require 5 * arg2 / 100
                                if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _15960 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15960] = 30
                                mem[_15960 + 32] = 'SafeMath: subtraction overflow'
                                if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > 0:
                                    _16286 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_16286 + idx + 68] = mem[_15960 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_16286 + 68] = mem[_16286 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _16286 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _17979 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17979] = 30
                                mem[_17979 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _18946 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_18946 + idx + 68] = mem[_17979 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18946 + 68] = mem[_18946 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _18946 + -mem[64] + 100
                                if stor1[address(arg1)] - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                _23022 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23022] = 30
                                mem[_23022 + 32] = 'SafeMath: subtraction overflow'
                                if 5 * arg2 / 100 * stor7 / 100000 * 10^18 <= stor7:
                                    stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                    if totalFees + (5 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 5 * arg2 / 100
                                    emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _23795 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_23795 + idx + 68] = mem[_23022 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23795 + 68] = mem[_23795 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _23795 + -mem[64] + 100
                            require arg2
                            if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not 5 * arg2 / 100:
                                _15959 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15959] = 30
                                mem[_15959 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor7 / 100000 * 10^18:
                                    _16283 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_16283 + idx + 68] = mem[_15959 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_16283 + 68] = mem[_16283 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _16283 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _17978 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17978] = 30
                                mem[_17978 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                    _18943 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_18943 + idx + 68] = mem[_17978 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18943 + 68] = mem[_18943 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _18943 + -mem[64] + 100
                                stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                                _23021 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23021] = 30
                                mem[_23021 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor7:
                                    if totalFees + (5 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 5 * arg2 / 100
                                    emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _23792 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_23792 + idx + 68] = mem[_23021 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23792 + 68] = mem[_23792 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _23792 + -mem[64] + 100
                            require 5 * arg2 / 100
                            if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _16282 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16282] = 30
                            mem[_16282 + 32] = 'SafeMath: subtraction overflow'
                            if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > arg2 * stor7 / 100000 * 10^18:
                                _16782 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_16782 + idx + 68] = mem[_16282 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_16782 + 68] = mem[_16782 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _16782 + -mem[64] + 100
                            mem[0] = msg.sender
                            mem[32] = 1
                            _18942 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_18942] = 30
                            mem[_18942 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                _20040 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_20040 + idx + 68] = mem[_18942 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20040 + 68] = mem[_20040 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _20040 + -mem[64] + 100
                            stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                            if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18)
                            _23791 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23791] = 30
                            mem[_23791 + 32] = 'SafeMath: subtraction overflow'
                            if 5 * arg2 / 100 * stor7 / 100000 * 10^18 <= stor7:
                                stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                if totalFees + (5 * arg2 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 5 * arg2 / 100
                                emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                return 1
                            _24634 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_24634 + idx + 68] = mem[_23791 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_24634 + 68] = mem[_24634 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _24634 + -mem[64] + 100
                        _14248 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14248] = 26
                        mem[_14248 + 32] = 'SafeMath: division by zero'
                        if t < stor7 / 100000 * 10^18:
                            _14723 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14723] = 26
                            mem[_14723 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                if not 5 * arg2 / 100:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if 0 > stor7:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                else:
                                    require 5 * arg2 / 100
                                    if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor1[address(arg1)] - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                    if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > stor7:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                            else:
                                require arg2
                                if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not 5 * arg2 / 100:
                                    if 0 > arg2 * stor7 / 100000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                                    if 0 > stor7:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                else:
                                    require 5 * arg2 / 100
                                    if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > arg2 * stor7 / 100000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18)
                                    if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > stor7:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                        else:
                            _14722 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14722] = 26
                            mem[_14722 + 32] = 'SafeMath: division by zero'
                            if s <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require s
                            if not arg2:
                                if not 5 * arg2 / 100:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if 0 > stor7:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                else:
                                    require 5 * arg2 / 100
                                    if 5 * arg2 / 100 * t / s / 5 * arg2 / 100 != t / s:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 5 * arg2 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor1[address(arg1)] - (5 * arg2 / 100 * t / s) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += -5 * arg2 / 100 * t / s
                                    if 5 * arg2 / 100 * t / s > stor7:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor7 += -5 * arg2 / 100 * t / s
                            else:
                                require arg2
                                if arg2 * t / s / arg2 != t / s:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not 5 * arg2 / 100:
                                    if 0 > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += arg2 * t / s
                                    if 0 > stor7:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                else:
                                    require 5 * arg2 / 100
                                    if 5 * arg2 / 100 * t / s / 5 * arg2 / 100 != t / s:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 5 * arg2 / 100 * t / s > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor1[address(arg1)] + (arg2 * t / s) - (5 * arg2 / 100 * t / s) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (5 * arg2 / 100 * t / s)
                                    if 5 * arg2 / 100 * t / s > stor7:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor7 += -5 * arg2 / 100 * t / s
                        if totalFees + (5 * arg2 / 100) < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        totalFees += 5 * arg2 / 100
                        emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                else:
                    if not arg2 / 100:
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if 0 > arg2:
                            revert with 0, 'SafeMath: subtraction overflow'
                        idx = 0
                        s = 100000 * 10^18
                        t = stor7
                        while idx < stor5.length:
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            if stor1[stor5[idx]] > t:
                                _14493 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14493] = 26
                                mem[_14493 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    _15683 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15683] = 30
                                    mem[_15683 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _16631 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16631] = 30
                                    mem[_16631 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _17304 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_17304 + idx + 68] = mem[_16631 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17304 + 68] = mem[_17304 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _17304 + -mem[64] + 100
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _20934 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20934] = 30
                                    mem[_20934 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor7:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _22101 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_22101 + idx + 68] = mem[_20934 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22101 + 68] = mem[_22101 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _22101 + -mem[64] + 100
                                require arg2
                                if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _15781 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15781] = 30
                                mem[_15781 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor7 / 100000 * 10^18:
                                    _15980 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_15980 + idx + 68] = mem[_15781 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15980 + 68] = mem[_15980 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _15980 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _17303 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17303] = 30
                                mem[_17303 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                    _18032 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_18032 + idx + 68] = mem[_17303 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18032 + 68] = mem[_18032 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _18032 + -mem[64] + 100
                                stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                                _22100 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22100] = 30
                                mem[_22100 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor7:
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _23066 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_23066 + idx + 68] = mem[_22100 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23066 + 68] = mem[_23066 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _23066 + -mem[64] + 100
                            require idx < stor5.length
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            if stor2[stor5[idx]] <= s:
                                require idx < stor5.length
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                _14573 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14573] = 30
                                mem[_14573 + 32] = 'SafeMath: subtraction overflow'
                                if stor1[stor5[idx]] > t:
                                    _14643 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_14643 + idx + 68] = mem[_14573 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14643 + 68] = mem[_14643 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _14643 + -mem[64] + 100
                                require idx < stor5.length
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                _15028 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15028] = 30
                                mem[_15028 + 32] = 'SafeMath: subtraction overflow'
                                if stor2[stor5[idx]] <= s:
                                    idx = idx + 1
                                    s = s - stor2[stor5[idx]]
                                    t = t - stor1[stor5[idx]]
                                    continue 
                                _15135 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_15135 + idx + 68] = mem[_15028 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15135 + 68] = mem[_15135 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _15135 + -mem[64] + 100
                            _14603 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14603] = 26
                            mem[_14603 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                _15782 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15782] = 30
                                mem[_15782 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = msg.sender
                                mem[32] = 1
                                _17309 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17309] = 30
                                mem[_17309 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _18039 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_18039 + idx + 68] = mem[_17309 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18039 + 68] = mem[_18039 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _18039 + -mem[64] + 100
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                _22105 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22105] = 30
                                mem[_22105 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor7:
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _23071 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_23071 + idx + 68] = mem[_22105 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23071 + 68] = mem[_23071 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _23071 + -mem[64] + 100
                            require arg2
                            if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _15983 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15983] = 30
                            mem[_15983 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg2 * stor7 / 100000 * 10^18:
                                _16317 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_16317 + idx + 68] = mem[_15983 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_16317 + 68] = mem[_16317 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _16317 + -mem[64] + 100
                            mem[0] = msg.sender
                            mem[32] = 1
                            _18038 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_18038] = 30
                            mem[_18038 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                _19022 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_19022 + idx + 68] = mem[_18038 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19022 + 68] = mem[_19022 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _19022 + -mem[64] + 100
                            stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                            if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                            _23070 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23070] = 30
                            mem[_23070 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor7:
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg2, msg.sender, arg1);
                                return 1
                            _23855 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_23855 + idx + 68] = mem[_23070 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_23855 + 68] = mem[_23855 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _23855 + -mem[64] + 100
                        _14263 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14263] = 26
                        mem[_14263 + 32] = 'SafeMath: division by zero'
                        if t < stor7 / 100000 * 10^18:
                            _14729 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14729] = 26
                            mem[_14729 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                            else:
                                require arg2
                                if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if 0 > arg2 * stor7 / 100000 * 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                        else:
                            _14728 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14728] = 26
                            mem[_14728 + 32] = 'SafeMath: division by zero'
                            if s <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require s
                            if not arg2:
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                            else:
                                require arg2
                                if arg2 * t / s / arg2 != t / s:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if 0 > arg2 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if arg2 * t / s > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor1[address(msg.sender)] += -1 * arg2 * t / s
                                if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] += arg2 * t / s
                        if 0 > stor7:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if totalFees < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        emit Transfer(arg2, msg.sender, arg1);
                    else:
                        require arg2 / 100
                        if 5 * arg2 / 100 / arg2 / 100 != 5:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if 5 * arg2 / 100 > arg2:
                            revert with 0, 'SafeMath: subtraction overflow'
                        idx = 0
                        s = 100000 * 10^18
                        t = stor7
                        while idx < stor5.length:
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            if stor1[stor5[idx]] > t:
                                _14490 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14490] = 26
                                mem[_14490 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not 5 * arg2 / 100:
                                        _15682 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_15682] = 30
                                        mem[_15682 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _16628 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16628] = 30
                                        mem[_16628 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _17295 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_17295 + idx + 68] = mem[_16628 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_17295 + 68] = mem[_17295 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _17295 + -mem[64] + 100
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _20923 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_20923] = 30
                                        mem[_20923 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor7:
                                            if totalFees + (5 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 5 * arg2 / 100
                                            emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _22086 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_22086 + idx + 68] = mem[_20923 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22086 + 68] = mem[_22086 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _22086 + -mem[64] + 100
                                    require 5 * arg2 / 100
                                    if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _15779 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15779] = 30
                                    mem[_15779 + 32] = 'SafeMath: subtraction overflow'
                                    if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > 0:
                                        _15973 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_15973 + idx + 68] = mem[_15779 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_15973 + 68] = mem[_15973 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _15973 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _17294 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17294] = 30
                                    mem[_17294 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _18013 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_18013 + idx + 68] = mem[_17294 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18013 + 68] = mem[_18013 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _18013 + -mem[64] + 100
                                    if stor1[address(arg1)] - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                    _22085 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22085] = 30
                                    mem[_22085 + 32] = 'SafeMath: subtraction overflow'
                                    if 5 * arg2 / 100 * stor7 / 100000 * 10^18 <= stor7:
                                        stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                        if totalFees + (5 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 5 * arg2 / 100
                                        emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _23052 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_23052 + idx + 68] = mem[_22085 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23052 + 68] = mem[_23052 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _23052 + -mem[64] + 100
                                require arg2
                                if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not 5 * arg2 / 100:
                                    _15778 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15778] = 30
                                    mem[_15778 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor7 / 100000 * 10^18:
                                        _15970 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_15970 + idx + 68] = mem[_15778 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_15970 + 68] = mem[_15970 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _15970 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _17293 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17293] = 30
                                    mem[_17293 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                        _18010 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_18010 + idx + 68] = mem[_17293 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18010 + 68] = mem[_18010 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _18010 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                                    _22084 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22084] = 30
                                    mem[_22084 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor7:
                                        if totalFees + (5 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 5 * arg2 / 100
                                        emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _23049 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_23049 + idx + 68] = mem[_22084 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23049 + 68] = mem[_23049 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _23049 + -mem[64] + 100
                                require 5 * arg2 / 100
                                if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _15969 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15969] = 30
                                mem[_15969 + 32] = 'SafeMath: subtraction overflow'
                                if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > arg2 * stor7 / 100000 * 10^18:
                                    _16300 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_16300 + idx + 68] = mem[_15969 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_16300 + 68] = mem[_16300 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _16300 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _18009 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18009] = 30
                                mem[_18009 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                    _18986 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_18986 + idx + 68] = mem[_18009 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18986 + 68] = mem[_18986 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _18986 + -mem[64] + 100
                                stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18)
                                _23048 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23048] = 30
                                mem[_23048 + 32] = 'SafeMath: subtraction overflow'
                                if 5 * arg2 / 100 * stor7 / 100000 * 10^18 <= stor7:
                                    stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                    if totalFees + (5 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 5 * arg2 / 100
                                    emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _23827 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_23827 + idx + 68] = mem[_23048 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23827 + 68] = mem[_23827 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _23827 + -mem[64] + 100
                            require idx < stor5.length
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            if stor2[stor5[idx]] <= s:
                                require idx < stor5.length
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                _14572 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14572] = 30
                                mem[_14572 + 32] = 'SafeMath: subtraction overflow'
                                if stor1[stor5[idx]] > t:
                                    _14640 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_14640 + idx + 68] = mem[_14572 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14640 + 68] = mem[_14640 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _14640 + -mem[64] + 100
                                require idx < stor5.length
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                _15026 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15026] = 30
                                mem[_15026 + 32] = 'SafeMath: subtraction overflow'
                                if stor2[stor5[idx]] <= s:
                                    idx = idx + 1
                                    s = s - stor2[stor5[idx]]
                                    t = t - stor1[stor5[idx]]
                                    continue 
                                _15130 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_15130 + idx + 68] = mem[_15026 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15130 + 68] = mem[_15130 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _15130 + -mem[64] + 100
                            _14602 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14602] = 26
                            mem[_14602 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                if not 5 * arg2 / 100:
                                    _15780 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15780] = 30
                                    mem[_15780 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _17302 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17302] = 30
                                    mem[_17302 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _18023 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_18023 + idx + 68] = mem[_17302 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18023 + 68] = mem[_18023 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _18023 + -mem[64] + 100
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _22093 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22093] = 30
                                    mem[_22093 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor7:
                                        if totalFees + (5 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 5 * arg2 / 100
                                        emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _23059 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_23059 + idx + 68] = mem[_22093 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23059 + 68] = mem[_23059 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _23059 + -mem[64] + 100
                                require 5 * arg2 / 100
                                if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _15977 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15977] = 30
                                mem[_15977 + 32] = 'SafeMath: subtraction overflow'
                                if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > 0:
                                    _16310 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_16310 + idx + 68] = mem[_15977 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_16310 + 68] = mem[_16310 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _16310 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _18022 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18022] = 30
                                mem[_18022 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _19002 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_19002 + idx + 68] = mem[_18022 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19002 + 68] = mem[_19002 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _19002 + -mem[64] + 100
                                if stor1[address(arg1)] - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                _23058 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23058] = 30
                                mem[_23058 + 32] = 'SafeMath: subtraction overflow'
                                if 5 * arg2 / 100 * stor7 / 100000 * 10^18 <= stor7:
                                    stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                    if totalFees + (5 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 5 * arg2 / 100
                                    emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _23839 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_23839 + idx + 68] = mem[_23058 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23839 + 68] = mem[_23839 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _23839 + -mem[64] + 100
                            require arg2
                            if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not 5 * arg2 / 100:
                                _15976 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15976] = 30
                                mem[_15976 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor7 / 100000 * 10^18:
                                    _16307 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_16307 + idx + 68] = mem[_15976 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_16307 + 68] = mem[_16307 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _16307 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _18021 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18021] = 30
                                mem[_18021 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                    _18999 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_18999 + idx + 68] = mem[_18021 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18999 + 68] = mem[_18999 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _18999 + -mem[64] + 100
                                stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                                _23057 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23057] = 30
                                mem[_23057 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor7:
                                    if totalFees + (5 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 5 * arg2 / 100
                                    emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _23836 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_23836 + idx + 68] = mem[_23057 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23836 + 68] = mem[_23836 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _23836 + -mem[64] + 100
                            require 5 * arg2 / 100
                            if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _16306 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16306] = 30
                            mem[_16306 + 32] = 'SafeMath: subtraction overflow'
                            if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > arg2 * stor7 / 100000 * 10^18:
                                _16817 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_16817 + idx + 68] = mem[_16306 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_16817 + 68] = mem[_16817 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _16817 + -mem[64] + 100
                            mem[0] = msg.sender
                            mem[32] = 1
                            _18998 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_18998] = 30
                            mem[_18998 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                _20102 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_20102 + idx + 68] = mem[_18998 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20102 + 68] = mem[_20102 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _20102 + -mem[64] + 100
                            stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                            if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18)
                            _23835 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23835] = 30
                            mem[_23835 + 32] = 'SafeMath: subtraction overflow'
                            if 5 * arg2 / 100 * stor7 / 100000 * 10^18 <= stor7:
                                stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                if totalFees + (5 * arg2 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 5 * arg2 / 100
                                emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                return 1
                            _24684 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_24684 + idx + 68] = mem[_23835 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_24684 + 68] = mem[_24684 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _24684 + -mem[64] + 100
                        _14258 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14258] = 26
                        mem[_14258 + 32] = 'SafeMath: division by zero'
                        if t < stor7 / 100000 * 10^18:
                            _14727 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14727] = 26
                            mem[_14727 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                if not 5 * arg2 / 100:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if 0 > stor7:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                else:
                                    require 5 * arg2 / 100
                                    if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor1[address(arg1)] - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                    if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > stor7:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                            else:
                                require arg2
                                if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not 5 * arg2 / 100:
                                    if 0 > arg2 * stor7 / 100000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                                    if 0 > stor7:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                else:
                                    require 5 * arg2 / 100
                                    if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > arg2 * stor7 / 100000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18)
                                    if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > stor7:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                        else:
                            _14726 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14726] = 26
                            mem[_14726 + 32] = 'SafeMath: division by zero'
                            if s <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require s
                            if not arg2:
                                if not 5 * arg2 / 100:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if 0 > stor7:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                else:
                                    require 5 * arg2 / 100
                                    if 5 * arg2 / 100 * t / s / 5 * arg2 / 100 != t / s:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 5 * arg2 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor1[address(arg1)] - (5 * arg2 / 100 * t / s) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += -5 * arg2 / 100 * t / s
                                    if 5 * arg2 / 100 * t / s > stor7:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor7 += -5 * arg2 / 100 * t / s
                            else:
                                require arg2
                                if arg2 * t / s / arg2 != t / s:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not 5 * arg2 / 100:
                                    if 0 > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += arg2 * t / s
                                    if 0 > stor7:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                else:
                                    require 5 * arg2 / 100
                                    if 5 * arg2 / 100 * t / s / 5 * arg2 / 100 != t / s:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 5 * arg2 / 100 * t / s > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor1[address(arg1)] + (arg2 * t / s) - (5 * arg2 / 100 * t / s) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (5 * arg2 / 100 * t / s)
                                    if 5 * arg2 / 100 * t / s > stor7:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor7 += -5 * arg2 / 100 * t / s
                        if totalFees + (5 * arg2 / 100) < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        totalFees += 5 * arg2 / 100
                        emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
        else:
            mem[0] = arg1
            mem[32] = 4
            if stor4[address(arg1)]:
                mem[96] = 26
                mem[128] = 'SafeMath: division by zero'
                if not arg2 / 100:
                    mem[64] = 224
                    mem[160] = 30
                    mem[192] = 'SafeMath: subtraction overflow'
                    if 0 > arg2:
                        revert with 0, 'SafeMath: subtraction overflow'
                    idx = 0
                    s = 100000 * 10^18
                    t = stor7
                    while idx < stor5.length:
                        mem[0] = stor5[idx]
                        mem[32] = 1
                        if stor1[stor5[idx]] > t:
                            _14517 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14517] = 26
                            mem[_14517 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                _15691 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15691] = 30
                                mem[_15691 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = msg.sender
                                mem[32] = 1
                                _16663 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16663] = 30
                                mem[_16663 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _17380 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_17380 + idx + 68] = mem[_16663 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_17380 + 68] = mem[_17380 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _17380 + -mem[64] + 100
                                if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] += arg2
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                _22743 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22743] = 30
                                mem[_22743 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor7:
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _23612 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_23612 + idx + 68] = mem[_22743 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23612 + 68] = mem[_23612 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _23612 + -mem[64] + 100
                            require arg2
                            if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _15801 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15801] = 30
                            mem[_15801 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg2 * stor7 / 100000 * 10^18:
                                _16048 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_16048 + idx + 68] = mem[_15801 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_16048 + 68] = mem[_16048 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _16048 + -mem[64] + 100
                            mem[0] = msg.sender
                            mem[32] = 1
                            _17379 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_17379] = 30
                            mem[_17379 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                _18204 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_18204 + idx + 68] = mem[_17379 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_18204 + 68] = mem[_18204 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _18204 + -mem[64] + 100
                            stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                            if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(arg1)] += arg2
                            if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                            _23611 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23611] = 30
                            mem[_23611 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor7:
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg2, msg.sender, arg1);
                                return 1
                            _24426 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_24426 + idx + 68] = mem[_23611 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_24426 + 68] = mem[_24426 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _24426 + -mem[64] + 100
                        require idx < stor5.length
                        mem[0] = stor5[idx]
                        mem[32] = 2
                        if stor2[stor5[idx]] <= s:
                            require idx < stor5.length
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            _14581 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14581] = 30
                            mem[_14581 + 32] = 'SafeMath: subtraction overflow'
                            if stor1[stor5[idx]] > t:
                                _14667 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_14667 + idx + 68] = mem[_14581 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14667 + 68] = mem[_14667 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _14667 + -mem[64] + 100
                            require idx < stor5.length
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            _15044 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15044] = 30
                            mem[_15044 + 32] = 'SafeMath: subtraction overflow'
                            if stor2[stor5[idx]] <= s:
                                idx = idx + 1
                                s = s - stor2[stor5[idx]]
                                t = t - stor1[stor5[idx]]
                                continue 
                            _15175 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_15175 + idx + 68] = mem[_15044 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_15175 + 68] = mem[_15175 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _15175 + -mem[64] + 100
                        _14611 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14611] = 26
                        mem[_14611 + 32] = 'SafeMath: division by zero'
                        if not arg2:
                            _15802 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15802] = 30
                            mem[_15802 + 32] = 'SafeMath: subtraction overflow'
                            mem[0] = msg.sender
                            mem[32] = 1
                            _17385 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_17385] = 30
                            mem[_17385 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor1[address(msg.sender)]:
                                _18211 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_18211 + idx + 68] = mem[_17385 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_18211 + 68] = mem[_18211 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _18211 + -mem[64] + 100
                            if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(arg1)] += arg2
                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            _23616 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23616] = 30
                            mem[_23616 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor7:
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg2, msg.sender, arg1);
                                return 1
                            _24431 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_24431 + idx + 68] = mem[_23616 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_24431 + 68] = mem[_24431 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _24431 + -mem[64] + 100
                        require arg2
                        if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _16051 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16051] = 30
                        mem[_16051 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg2 * stor7 / 100000 * 10^18:
                            _16413 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_16413 + idx + 68] = mem[_16051 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_16413 + 68] = mem[_16413 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _16413 + -mem[64] + 100
                        mem[0] = msg.sender
                        mem[32] = 1
                        _18210 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_18210] = 30
                        mem[_18210 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                            _19246 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_19246 + idx + 68] = mem[_18210 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_19246 + 68] = mem[_19246 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _19246 + -mem[64] + 100
                        stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                        if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor2[address(arg1)] += arg2
                        if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg1
                        mem[32] = 1
                        stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                        _24430 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24430] = 30
                        mem[_24430 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= stor7:
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(arg2, msg.sender, arg1);
                            return 1
                        _25338 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_25338 + idx + 68] = mem[_24430 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_25338 + 68] = mem[_25338 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _25338 + -mem[64] + 100
                    _14303 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14303] = 26
                    mem[_14303 + 32] = 'SafeMath: division by zero'
                    if t < stor7 / 100000 * 10^18:
                        _14745 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14745] = 26
                        mem[_14745 + 32] = 'SafeMath: division by zero'
                        if not arg2:
                            if 0 > stor1[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(arg1)] += arg2
                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                        else:
                            require arg2
                            if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if 0 > arg2 * stor7 / 100000 * 10^18:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                            if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(arg1)] += arg2
                            if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                    else:
                        _14744 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14744] = 26
                        mem[_14744 + 32] = 'SafeMath: division by zero'
                        if s <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require s
                        if not arg2:
                            if 0 > stor1[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(arg1)] += arg2
                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                        else:
                            require arg2
                            if arg2 * t / s / arg2 != t / s:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if 0 > arg2 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if arg2 * t / s > stor1[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor1[address(msg.sender)] += -1 * arg2 * t / s
                            if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(arg1)] += arg2
                            if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor1[address(arg1)] += arg2 * t / s
                    if 0 > stor7:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if totalFees < totalFees:
                        revert with 0, 'SafeMath: addition overflow'
                    emit Transfer(arg2, msg.sender, arg1);
                else:
                    require arg2 / 100
                    if 5 * arg2 / 100 / arg2 / 100 != 5:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                    mem[64] = 224
                    mem[160] = 30
                    mem[192] = 'SafeMath: subtraction overflow'
                    if 5 * arg2 / 100 > arg2:
                        revert with 0, 'SafeMath: subtraction overflow'
                    idx = 0
                    s = 100000 * 10^18
                    t = stor7
                    while idx < stor5.length:
                        mem[0] = stor5[idx]
                        mem[32] = 1
                        if stor1[stor5[idx]] > t:
                            _14514 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14514] = 26
                            mem[_14514 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                if not 5 * arg2 / 100:
                                    _15690 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15690] = 30
                                    mem[_15690 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _16660 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16660] = 30
                                    mem[_16660 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _17371 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_17371 + idx + 68] = mem[_16660 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17371 + 68] = mem[_17371 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _17371 + -mem[64] + 100
                                    if stor2[address(arg1)] + arg2 - (5 * arg2 / 100) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (5 * arg2 / 100)
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _22731 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22731] = 30
                                    mem[_22731 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor7:
                                        if totalFees + (5 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 5 * arg2 / 100
                                        emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _23603 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_23603 + idx + 68] = mem[_22731 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23603 + 68] = mem[_23603 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _23603 + -mem[64] + 100
                                require 5 * arg2 / 100
                                if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _15799 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15799] = 30
                                mem[_15799 + 32] = 'SafeMath: subtraction overflow'
                                if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > 0:
                                    _16041 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_16041 + idx + 68] = mem[_15799 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_16041 + 68] = mem[_16041 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _16041 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _17370 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17370] = 30
                                mem[_17370 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _18185 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_18185 + idx + 68] = mem[_17370 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18185 + 68] = mem[_18185 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _18185 + -mem[64] + 100
                                if stor2[address(arg1)] + arg2 - (5 * arg2 / 100) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (5 * arg2 / 100)
                                if stor1[address(arg1)] - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                _23602 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23602] = 30
                                mem[_23602 + 32] = 'SafeMath: subtraction overflow'
                                if 5 * arg2 / 100 * stor7 / 100000 * 10^18 <= stor7:
                                    stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                    if totalFees + (5 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 5 * arg2 / 100
                                    emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _24412 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_24412 + idx + 68] = mem[_23602 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24412 + 68] = mem[_24412 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _24412 + -mem[64] + 100
                            require arg2
                            if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not 5 * arg2 / 100:
                                _15798 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15798] = 30
                                mem[_15798 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor7 / 100000 * 10^18:
                                    _16038 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_16038 + idx + 68] = mem[_15798 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_16038 + 68] = mem[_16038 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _16038 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _17369 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17369] = 30
                                mem[_17369 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                    _18182 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_18182 + idx + 68] = mem[_17369 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18182 + 68] = mem[_18182 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _18182 + -mem[64] + 100
                                stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                if stor2[address(arg1)] + arg2 - (5 * arg2 / 100) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (5 * arg2 / 100)
                                if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                                _23601 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23601] = 30
                                mem[_23601 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor7:
                                    if totalFees + (5 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 5 * arg2 / 100
                                    emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _24409 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_24409 + idx + 68] = mem[_23601 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24409 + 68] = mem[_24409 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _24409 + -mem[64] + 100
                            require 5 * arg2 / 100
                            if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _16037 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16037] = 30
                            mem[_16037 + 32] = 'SafeMath: subtraction overflow'
                            if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > arg2 * stor7 / 100000 * 10^18:
                                _16396 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_16396 + idx + 68] = mem[_16037 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_16396 + 68] = mem[_16396 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _16396 + -mem[64] + 100
                            mem[0] = msg.sender
                            mem[32] = 1
                            _18181 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_18181] = 30
                            mem[_18181 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                _19210 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_19210 + idx + 68] = mem[_18181 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19210 + 68] = mem[_19210 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _19210 + -mem[64] + 100
                            stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                            if stor2[address(arg1)] + arg2 - (5 * arg2 / 100) < stor2[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (5 * arg2 / 100)
                            if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18)
                            _24408 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24408] = 30
                            mem[_24408 + 32] = 'SafeMath: subtraction overflow'
                            if 5 * arg2 / 100 * stor7 / 100000 * 10^18 <= stor7:
                                stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                if totalFees + (5 * arg2 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 5 * arg2 / 100
                                emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                return 1
                            _25310 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_25310 + idx + 68] = mem[_24408 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_25310 + 68] = mem[_25310 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _25310 + -mem[64] + 100
                        require idx < stor5.length
                        mem[0] = stor5[idx]
                        mem[32] = 2
                        if stor2[stor5[idx]] <= s:
                            require idx < stor5.length
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            _14580 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14580] = 30
                            mem[_14580 + 32] = 'SafeMath: subtraction overflow'
                            if stor1[stor5[idx]] > t:
                                _14664 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_14664 + idx + 68] = mem[_14580 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14664 + 68] = mem[_14664 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _14664 + -mem[64] + 100
                            require idx < stor5.length
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            _15042 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15042] = 30
                            mem[_15042 + 32] = 'SafeMath: subtraction overflow'
                            if stor2[stor5[idx]] <= s:
                                idx = idx + 1
                                s = s - stor2[stor5[idx]]
                                t = t - stor1[stor5[idx]]
                                continue 
                            _15170 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_15170 + idx + 68] = mem[_15042 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_15170 + 68] = mem[_15170 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _15170 + -mem[64] + 100
                        _14610 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14610] = 26
                        mem[_14610 + 32] = 'SafeMath: division by zero'
                        if not arg2:
                            if not 5 * arg2 / 100:
                                _15800 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15800] = 30
                                mem[_15800 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = msg.sender
                                mem[32] = 1
                                _17378 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17378] = 30
                                mem[_17378 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _18195 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_18195 + idx + 68] = mem[_17378 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18195 + 68] = mem[_18195 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _18195 + -mem[64] + 100
                                if stor2[address(arg1)] + arg2 - (5 * arg2 / 100) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (5 * arg2 / 100)
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                _23608 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23608] = 30
                                mem[_23608 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor7:
                                    if totalFees + (5 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 5 * arg2 / 100
                                    emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _24419 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_24419 + idx + 68] = mem[_23608 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24419 + 68] = mem[_24419 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _24419 + -mem[64] + 100
                            require 5 * arg2 / 100
                            if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _16045 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16045] = 30
                            mem[_16045 + 32] = 'SafeMath: subtraction overflow'
                            if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > 0:
                                _16406 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_16406 + idx + 68] = mem[_16045 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_16406 + 68] = mem[_16406 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _16406 + -mem[64] + 100
                            mem[0] = msg.sender
                            mem[32] = 1
                            _18194 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_18194] = 30
                            mem[_18194 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor1[address(msg.sender)]:
                                _19226 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_19226 + idx + 68] = mem[_18194 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19226 + 68] = mem[_19226 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _19226 + -mem[64] + 100
                            if stor2[address(arg1)] + arg2 - (5 * arg2 / 100) < stor2[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (5 * arg2 / 100)
                            if stor1[address(arg1)] - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                            _24418 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24418] = 30
                            mem[_24418 + 32] = 'SafeMath: subtraction overflow'
                            if 5 * arg2 / 100 * stor7 / 100000 * 10^18 <= stor7:
                                stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                if totalFees + (5 * arg2 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 5 * arg2 / 100
                                emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                return 1
                            _25322 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_25322 + idx + 68] = mem[_24418 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_25322 + 68] = mem[_25322 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _25322 + -mem[64] + 100
                        require arg2
                        if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if not 5 * arg2 / 100:
                            _16044 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16044] = 30
                            mem[_16044 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg2 * stor7 / 100000 * 10^18:
                                _16403 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_16403 + idx + 68] = mem[_16044 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_16403 + 68] = mem[_16403 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _16403 + -mem[64] + 100
                            mem[0] = msg.sender
                            mem[32] = 1
                            _18193 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_18193] = 30
                            mem[_18193 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                _19223 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_19223 + idx + 68] = mem[_18193 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19223 + 68] = mem[_19223 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _19223 + -mem[64] + 100
                            stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                            if stor2[address(arg1)] + arg2 - (5 * arg2 / 100) < stor2[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (5 * arg2 / 100)
                            if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                            _24417 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24417] = 30
                            mem[_24417 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor7:
                                if totalFees + (5 * arg2 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 5 * arg2 / 100
                                emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                return 1
                            _25319 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_25319 + idx + 68] = mem[_24417 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_25319 + 68] = mem[_25319 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _25319 + -mem[64] + 100
                        require 5 * arg2 / 100
                        if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _16402 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16402] = 30
                        mem[_16402 + 32] = 'SafeMath: subtraction overflow'
                        if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > arg2 * stor7 / 100000 * 10^18:
                            _16957 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_16957 + idx + 68] = mem[_16402 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_16957 + 68] = mem[_16957 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _16957 + -mem[64] + 100
                        mem[0] = msg.sender
                        mem[32] = 1
                        _19222 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19222] = 30
                        mem[_19222 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                            _20350 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_20350 + idx + 68] = mem[_19222 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_20350 + 68] = mem[_20350 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _20350 + -mem[64] + 100
                        stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                        if stor2[address(arg1)] + arg2 - (5 * arg2 / 100) < stor2[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (5 * arg2 / 100)
                        if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg1
                        mem[32] = 1
                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18)
                        _25318 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25318] = 30
                        mem[_25318 + 32] = 'SafeMath: subtraction overflow'
                        if 5 * arg2 / 100 * stor7 / 100000 * 10^18 <= stor7:
                            stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                            if totalFees + (5 * arg2 / 100) < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += 5 * arg2 / 100
                            emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                            return 1
                        _26221 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_26221 + idx + 68] = mem[_25318 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_26221 + 68] = mem[_26221 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _26221 + -mem[64] + 100
                    _14298 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14298] = 26
                    mem[_14298 + 32] = 'SafeMath: division by zero'
                    if t < stor7 / 100000 * 10^18:
                        _14743 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14743] = 26
                        mem[_14743 + 32] = 'SafeMath: division by zero'
                        if not arg2:
                            if not 5 * arg2 / 100:
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if stor2[address(arg1)] + arg2 - (5 * arg2 / 100) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (5 * arg2 / 100)
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if 0 > stor7:
                                    revert with 0, 'SafeMath: subtraction overflow'
                            else:
                                require 5 * arg2 / 100
                                if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if stor2[address(arg1)] + arg2 - (5 * arg2 / 100) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (5 * arg2 / 100)
                                if stor1[address(arg1)] - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > stor7:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                        else:
                            require arg2
                            if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not 5 * arg2 / 100:
                                if 0 > arg2 * stor7 / 100000 * 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                if stor2[address(arg1)] + arg2 - (5 * arg2 / 100) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (5 * arg2 / 100)
                                if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                                if 0 > stor7:
                                    revert with 0, 'SafeMath: subtraction overflow'
                            else:
                                require 5 * arg2 / 100
                                if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > arg2 * stor7 / 100000 * 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                if stor2[address(arg1)] + arg2 - (5 * arg2 / 100) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (5 * arg2 / 100)
                                if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18)
                                if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > stor7:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                    else:
                        _14742 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14742] = 26
                        mem[_14742 + 32] = 'SafeMath: division by zero'
                        if s <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require s
                        if not arg2:
                            if not 5 * arg2 / 100:
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if stor2[address(arg1)] + arg2 - (5 * arg2 / 100) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (5 * arg2 / 100)
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if 0 > stor7:
                                    revert with 0, 'SafeMath: subtraction overflow'
                            else:
                                require 5 * arg2 / 100
                                if 5 * arg2 / 100 * t / s / 5 * arg2 / 100 != t / s:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if 5 * arg2 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if stor2[address(arg1)] + arg2 - (5 * arg2 / 100) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (5 * arg2 / 100)
                                if stor1[address(arg1)] - (5 * arg2 / 100 * t / s) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] += -5 * arg2 / 100 * t / s
                                if 5 * arg2 / 100 * t / s > stor7:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor7 += -5 * arg2 / 100 * t / s
                        else:
                            require arg2
                            if arg2 * t / s / arg2 != t / s:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not 5 * arg2 / 100:
                                if 0 > arg2 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if arg2 * t / s > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor1[address(msg.sender)] += -1 * arg2 * t / s
                                if stor2[address(arg1)] + arg2 - (5 * arg2 / 100) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (5 * arg2 / 100)
                                if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] += arg2 * t / s
                                if 0 > stor7:
                                    revert with 0, 'SafeMath: subtraction overflow'
                            else:
                                require 5 * arg2 / 100
                                if 5 * arg2 / 100 * t / s / 5 * arg2 / 100 != t / s:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if 5 * arg2 / 100 * t / s > arg2 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if arg2 * t / s > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor1[address(msg.sender)] += -1 * arg2 * t / s
                                if stor2[address(arg1)] + arg2 - (5 * arg2 / 100) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (5 * arg2 / 100)
                                if stor1[address(arg1)] + (arg2 * t / s) - (5 * arg2 / 100 * t / s) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (5 * arg2 / 100 * t / s)
                                if 5 * arg2 / 100 * t / s > stor7:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor7 += -5 * arg2 / 100 * t / s
                    if totalFees + (5 * arg2 / 100) < totalFees:
                        revert with 0, 'SafeMath: addition overflow'
                    totalFees += 5 * arg2 / 100
                    emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
            else:
                mem[0] = msg.sender
                mem[32] = 4
                if stor4[address(msg.sender)]:
                    mem[96] = 26
                    mem[128] = 'SafeMath: division by zero'
                    if not arg2 / 100:
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if 0 > arg2:
                            revert with 0, 'SafeMath: subtraction overflow'
                        idx = 0
                        s = 100000 * 10^18
                        t = stor7
                        while idx < stor5.length:
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            if stor1[stor5[idx]] > t:
                                _14499 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14499] = 26
                                mem[_14499 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    _15685 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15685] = 30
                                    mem[_15685 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _16639 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16639] = 30
                                    mem[_16639 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _17323 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_17323 + idx + 68] = mem[_16639 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17323 + 68] = mem[_17323 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _17323 + -mem[64] + 100
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _20957 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20957] = 30
                                    mem[_20957 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor7:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _22134 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_22134 + idx + 68] = mem[_20957 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22134 + 68] = mem[_22134 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _22134 + -mem[64] + 100
                                require arg2
                                if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _15786 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15786] = 30
                                mem[_15786 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor7 / 100000 * 10^18:
                                    _15997 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_15997 + idx + 68] = mem[_15786 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15997 + 68] = mem[_15997 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _15997 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _17322 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17322] = 30
                                mem[_17322 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                    _18075 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_18075 + idx + 68] = mem[_17322 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18075 + 68] = mem[_18075 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _18075 + -mem[64] + 100
                                stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                                _22133 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22133] = 30
                                mem[_22133 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor7:
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _23102 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_23102 + idx + 68] = mem[_22133 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23102 + 68] = mem[_23102 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _23102 + -mem[64] + 100
                            require idx < stor5.length
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            if stor2[stor5[idx]] <= s:
                                require idx < stor5.length
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                _14575 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14575] = 30
                                mem[_14575 + 32] = 'SafeMath: subtraction overflow'
                                if stor1[stor5[idx]] > t:
                                    _14649 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_14649 + idx + 68] = mem[_14575 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14649 + 68] = mem[_14649 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _14649 + -mem[64] + 100
                                require idx < stor5.length
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                _15032 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15032] = 30
                                mem[_15032 + 32] = 'SafeMath: subtraction overflow'
                                if stor2[stor5[idx]] <= s:
                                    idx = idx + 1
                                    s = s - stor2[stor5[idx]]
                                    t = t - stor1[stor5[idx]]
                                    continue 
                                _15145 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_15145 + idx + 68] = mem[_15032 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15145 + 68] = mem[_15145 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _15145 + -mem[64] + 100
                            _14605 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14605] = 26
                            mem[_14605 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                _15787 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15787] = 30
                                mem[_15787 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = msg.sender
                                mem[32] = 1
                                _17328 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17328] = 30
                                mem[_17328 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _18082 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_18082 + idx + 68] = mem[_17328 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18082 + 68] = mem[_18082 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _18082 + -mem[64] + 100
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                _22138 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22138] = 30
                                mem[_22138 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor7:
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _23107 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_23107 + idx + 68] = mem[_22138 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23107 + 68] = mem[_23107 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _23107 + -mem[64] + 100
                            require arg2
                            if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _16000 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16000] = 30
                            mem[_16000 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg2 * stor7 / 100000 * 10^18:
                                _16341 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_16341 + idx + 68] = mem[_16000 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_16341 + 68] = mem[_16341 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _16341 + -mem[64] + 100
                            mem[0] = msg.sender
                            mem[32] = 1
                            _18081 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_18081] = 30
                            mem[_18081 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                _19078 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_19078 + idx + 68] = mem[_18081 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19078 + 68] = mem[_19078 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _19078 + -mem[64] + 100
                            stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                            if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                            _23106 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23106] = 30
                            mem[_23106 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor7:
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg2, msg.sender, arg1);
                                return 1
                            _23899 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_23899 + idx + 68] = mem[_23106 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_23899 + 68] = mem[_23899 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _23899 + -mem[64] + 100
                        _14273 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14273] = 26
                        mem[_14273 + 32] = 'SafeMath: division by zero'
                        if t < stor7 / 100000 * 10^18:
                            _14733 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14733] = 26
                            mem[_14733 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                            else:
                                require arg2
                                if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if 0 > arg2 * stor7 / 100000 * 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                        else:
                            _14732 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14732] = 26
                            mem[_14732 + 32] = 'SafeMath: division by zero'
                            if s <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require s
                            if not arg2:
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                            else:
                                require arg2
                                if arg2 * t / s / arg2 != t / s:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if 0 > arg2 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if arg2 * t / s > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor1[address(msg.sender)] += -1 * arg2 * t / s
                                if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] += arg2 * t / s
                        if 0 > stor7:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if totalFees < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        emit Transfer(arg2, msg.sender, arg1);
                    else:
                        require arg2 / 100
                        if 5 * arg2 / 100 / arg2 / 100 != 5:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if 5 * arg2 / 100 > arg2:
                            revert with 0, 'SafeMath: subtraction overflow'
                        idx = 0
                        s = 100000 * 10^18
                        t = stor7
                        while idx < stor5.length:
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            if stor1[stor5[idx]] > t:
                                _14496 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14496] = 26
                                mem[_14496 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not 5 * arg2 / 100:
                                        _15684 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_15684] = 30
                                        mem[_15684 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _16636 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16636] = 30
                                        mem[_16636 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _17314 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_17314 + idx + 68] = mem[_16636 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_17314 + 68] = mem[_17314 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _17314 + -mem[64] + 100
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _20946 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_20946] = 30
                                        mem[_20946 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor7:
                                            if totalFees + (5 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 5 * arg2 / 100
                                            emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _22119 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_22119 + idx + 68] = mem[_20946 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22119 + 68] = mem[_22119 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _22119 + -mem[64] + 100
                                    require 5 * arg2 / 100
                                    if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _15784 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15784] = 30
                                    mem[_15784 + 32] = 'SafeMath: subtraction overflow'
                                    if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > 0:
                                        _15990 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_15990 + idx + 68] = mem[_15784 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_15990 + 68] = mem[_15990 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _15990 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _17313 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17313] = 30
                                    mem[_17313 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _18056 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_18056 + idx + 68] = mem[_17313 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18056 + 68] = mem[_18056 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _18056 + -mem[64] + 100
                                    if stor1[address(arg1)] - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                    _22118 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22118] = 30
                                    mem[_22118 + 32] = 'SafeMath: subtraction overflow'
                                    if 5 * arg2 / 100 * stor7 / 100000 * 10^18 <= stor7:
                                        stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                        if totalFees + (5 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 5 * arg2 / 100
                                        emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _23088 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_23088 + idx + 68] = mem[_22118 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23088 + 68] = mem[_23088 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _23088 + -mem[64] + 100
                                require arg2
                                if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not 5 * arg2 / 100:
                                    _15783 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15783] = 30
                                    mem[_15783 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor7 / 100000 * 10^18:
                                        _15987 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_15987 + idx + 68] = mem[_15783 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_15987 + 68] = mem[_15987 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _15987 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _17312 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17312] = 30
                                    mem[_17312 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                        _18053 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_18053 + idx + 68] = mem[_17312 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18053 + 68] = mem[_18053 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _18053 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                                    _22117 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22117] = 30
                                    mem[_22117 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor7:
                                        if totalFees + (5 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 5 * arg2 / 100
                                        emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _23085 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_23085 + idx + 68] = mem[_22117 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23085 + 68] = mem[_23085 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _23085 + -mem[64] + 100
                                require 5 * arg2 / 100
                                if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _15986 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15986] = 30
                                mem[_15986 + 32] = 'SafeMath: subtraction overflow'
                                if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > arg2 * stor7 / 100000 * 10^18:
                                    _16324 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_16324 + idx + 68] = mem[_15986 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_16324 + 68] = mem[_16324 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _16324 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _18052 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18052] = 30
                                mem[_18052 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                    _19042 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_19042 + idx + 68] = mem[_18052 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19042 + 68] = mem[_19042 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _19042 + -mem[64] + 100
                                stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18)
                                _23084 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23084] = 30
                                mem[_23084 + 32] = 'SafeMath: subtraction overflow'
                                if 5 * arg2 / 100 * stor7 / 100000 * 10^18 <= stor7:
                                    stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                    if totalFees + (5 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 5 * arg2 / 100
                                    emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _23871 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_23871 + idx + 68] = mem[_23084 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23871 + 68] = mem[_23871 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _23871 + -mem[64] + 100
                            require idx < stor5.length
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            if stor2[stor5[idx]] <= s:
                                require idx < stor5.length
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                _14574 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14574] = 30
                                mem[_14574 + 32] = 'SafeMath: subtraction overflow'
                                if stor1[stor5[idx]] > t:
                                    _14646 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_14646 + idx + 68] = mem[_14574 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14646 + 68] = mem[_14646 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _14646 + -mem[64] + 100
                                require idx < stor5.length
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                _15030 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15030] = 30
                                mem[_15030 + 32] = 'SafeMath: subtraction overflow'
                                if stor2[stor5[idx]] <= s:
                                    idx = idx + 1
                                    s = s - stor2[stor5[idx]]
                                    t = t - stor1[stor5[idx]]
                                    continue 
                                _15140 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_15140 + idx + 68] = mem[_15030 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15140 + 68] = mem[_15140 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _15140 + -mem[64] + 100
                            _14604 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14604] = 26
                            mem[_14604 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                if not 5 * arg2 / 100:
                                    _15785 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15785] = 30
                                    mem[_15785 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _17321 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17321] = 30
                                    mem[_17321 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _18066 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_18066 + idx + 68] = mem[_17321 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18066 + 68] = mem[_18066 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _18066 + -mem[64] + 100
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _22126 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22126] = 30
                                    mem[_22126 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor7:
                                        if totalFees + (5 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 5 * arg2 / 100
                                        emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _23095 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_23095 + idx + 68] = mem[_22126 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23095 + 68] = mem[_23095 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _23095 + -mem[64] + 100
                                require 5 * arg2 / 100
                                if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _15994 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15994] = 30
                                mem[_15994 + 32] = 'SafeMath: subtraction overflow'
                                if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > 0:
                                    _16334 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_16334 + idx + 68] = mem[_15994 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_16334 + 68] = mem[_16334 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _16334 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _18065 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18065] = 30
                                mem[_18065 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _19058 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_19058 + idx + 68] = mem[_18065 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19058 + 68] = mem[_19058 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _19058 + -mem[64] + 100
                                if stor1[address(arg1)] - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                _23094 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23094] = 30
                                mem[_23094 + 32] = 'SafeMath: subtraction overflow'
                                if 5 * arg2 / 100 * stor7 / 100000 * 10^18 <= stor7:
                                    stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                    if totalFees + (5 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 5 * arg2 / 100
                                    emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _23883 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_23883 + idx + 68] = mem[_23094 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23883 + 68] = mem[_23883 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _23883 + -mem[64] + 100
                            require arg2
                            if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not 5 * arg2 / 100:
                                _15993 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15993] = 30
                                mem[_15993 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor7 / 100000 * 10^18:
                                    _16331 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_16331 + idx + 68] = mem[_15993 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_16331 + 68] = mem[_16331 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _16331 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _18064 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18064] = 30
                                mem[_18064 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                    _19055 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_19055 + idx + 68] = mem[_18064 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19055 + 68] = mem[_19055 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _19055 + -mem[64] + 100
                                stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                                _23093 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23093] = 30
                                mem[_23093 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor7:
                                    if totalFees + (5 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 5 * arg2 / 100
                                    emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _23880 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_23880 + idx + 68] = mem[_23093 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23880 + 68] = mem[_23880 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _23880 + -mem[64] + 100
                            require 5 * arg2 / 100
                            if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _16330 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16330] = 30
                            mem[_16330 + 32] = 'SafeMath: subtraction overflow'
                            if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > arg2 * stor7 / 100000 * 10^18:
                                _16852 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_16852 + idx + 68] = mem[_16330 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_16852 + 68] = mem[_16852 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _16852 + -mem[64] + 100
                            mem[0] = msg.sender
                            mem[32] = 1
                            _19054 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19054] = 30
                            mem[_19054 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                _20164 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_20164 + idx + 68] = mem[_19054 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20164 + 68] = mem[_20164 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _20164 + -mem[64] + 100
                            stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                            if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18)
                            _23879 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23879] = 30
                            mem[_23879 + 32] = 'SafeMath: subtraction overflow'
                            if 5 * arg2 / 100 * stor7 / 100000 * 10^18 <= stor7:
                                stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                if totalFees + (5 * arg2 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 5 * arg2 / 100
                                emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                return 1
                            _24734 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_24734 + idx + 68] = mem[_23879 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_24734 + 68] = mem[_24734 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _24734 + -mem[64] + 100
                        _14268 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14268] = 26
                        mem[_14268 + 32] = 'SafeMath: division by zero'
                        if t < stor7 / 100000 * 10^18:
                            _14731 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14731] = 26
                            mem[_14731 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                if not 5 * arg2 / 100:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if 0 > stor7:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                else:
                                    require 5 * arg2 / 100
                                    if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor1[address(arg1)] - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                    if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > stor7:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                            else:
                                require arg2
                                if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not 5 * arg2 / 100:
                                    if 0 > arg2 * stor7 / 100000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                                    if 0 > stor7:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                else:
                                    require 5 * arg2 / 100
                                    if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > arg2 * stor7 / 100000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18)
                                    if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > stor7:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                        else:
                            _14730 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14730] = 26
                            mem[_14730 + 32] = 'SafeMath: division by zero'
                            if s <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require s
                            if not arg2:
                                if not 5 * arg2 / 100:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if 0 > stor7:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                else:
                                    require 5 * arg2 / 100
                                    if 5 * arg2 / 100 * t / s / 5 * arg2 / 100 != t / s:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 5 * arg2 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor1[address(arg1)] - (5 * arg2 / 100 * t / s) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += -5 * arg2 / 100 * t / s
                                    if 5 * arg2 / 100 * t / s > stor7:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor7 += -5 * arg2 / 100 * t / s
                            else:
                                require arg2
                                if arg2 * t / s / arg2 != t / s:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not 5 * arg2 / 100:
                                    if 0 > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += arg2 * t / s
                                    if 0 > stor7:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                else:
                                    require 5 * arg2 / 100
                                    if 5 * arg2 / 100 * t / s / 5 * arg2 / 100 != t / s:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 5 * arg2 / 100 * t / s > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor1[address(arg1)] + (arg2 * t / s) - (5 * arg2 / 100 * t / s) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (5 * arg2 / 100 * t / s)
                                    if 5 * arg2 / 100 * t / s > stor7:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor7 += -5 * arg2 / 100 * t / s
                        if totalFees + (5 * arg2 / 100) < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        totalFees += 5 * arg2 / 100
                        emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                else:
                    mem[0] = arg1
                    mem[32] = 4
                    mem[96] = 26
                    mem[128] = 'SafeMath: division by zero'
                    if stor4[address(arg1)]:
                        if not arg2 / 100:
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if 0 > arg2:
                                revert with 0, 'SafeMath: subtraction overflow'
                            idx = 0
                            s = 100000 * 10^18
                            t = stor7
                            while idx < stor5.length:
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                if stor1[stor5[idx]] > t:
                                    _14505 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14505] = 26
                                    mem[_14505 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        _15687 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_15687] = 30
                                        mem[_15687 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _16647 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16647] = 30
                                        mem[_16647 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _17342 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_17342 + idx + 68] = mem[_16647 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_17342 + 68] = mem[_17342 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _17342 + -mem[64] + 100
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _20980 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_20980] = 30
                                        mem[_20980 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor7:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _22167 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_22167 + idx + 68] = mem[_20980 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22167 + 68] = mem[_22167 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _22167 + -mem[64] + 100
                                    require arg2
                                    if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _15791 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15791] = 30
                                    mem[_15791 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor7 / 100000 * 10^18:
                                        _16014 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_16014 + idx + 68] = mem[_15791 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_16014 + 68] = mem[_16014 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _16014 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _17341 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17341] = 30
                                    mem[_17341 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                        _18118 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_18118 + idx + 68] = mem[_17341 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18118 + 68] = mem[_18118 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _18118 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                                    _22166 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22166] = 30
                                    mem[_22166 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor7:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _23138 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_23138 + idx + 68] = mem[_22166 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23138 + 68] = mem[_23138 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _23138 + -mem[64] + 100
                                require idx < stor5.length
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                if stor2[stor5[idx]] <= s:
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    _14577 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14577] = 30
                                    mem[_14577 + 32] = 'SafeMath: subtraction overflow'
                                    if stor1[stor5[idx]] > t:
                                        _14655 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_14655 + idx + 68] = mem[_14577 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14655 + 68] = mem[_14655 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _14655 + -mem[64] + 100
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    _15036 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15036] = 30
                                    mem[_15036 + 32] = 'SafeMath: subtraction overflow'
                                    if stor2[stor5[idx]] <= s:
                                        idx = idx + 1
                                        s = s - stor2[stor5[idx]]
                                        t = t - stor1[stor5[idx]]
                                        continue 
                                    _15155 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_15155 + idx + 68] = mem[_15036 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15155 + 68] = mem[_15155 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _15155 + -mem[64] + 100
                                _14607 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14607] = 26
                                mem[_14607 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    _15792 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15792] = 30
                                    mem[_15792 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _17347 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17347] = 30
                                    mem[_17347 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _18125 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_18125 + idx + 68] = mem[_17347 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18125 + 68] = mem[_18125 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _18125 + -mem[64] + 100
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _22171 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22171] = 30
                                    mem[_22171 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor7:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _23143 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_23143 + idx + 68] = mem[_22171 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23143 + 68] = mem[_23143 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _23143 + -mem[64] + 100
                                require arg2
                                if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _16017 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16017] = 30
                                mem[_16017 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor7 / 100000 * 10^18:
                                    _16365 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_16365 + idx + 68] = mem[_16017 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_16365 + 68] = mem[_16365 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _16365 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _18124 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18124] = 30
                                mem[_18124 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                    _19134 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_19134 + idx + 68] = mem[_18124 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19134 + 68] = mem[_19134 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _19134 + -mem[64] + 100
                                stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                                _23142 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23142] = 30
                                mem[_23142 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor7:
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _23943 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_23943 + idx + 68] = mem[_23142 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23943 + 68] = mem[_23943 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _23943 + -mem[64] + 100
                            _14283 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14283] = 26
                            mem[_14283 + 32] = 'SafeMath: division by zero'
                            if t < stor7 / 100000 * 10^18:
                                _14737 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14737] = 26
                                mem[_14737 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                else:
                                    require arg2
                                    if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 0 > arg2 * stor7 / 100000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                            else:
                                _14736 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14736] = 26
                                mem[_14736 + 32] = 'SafeMath: division by zero'
                                if s <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require s
                                if not arg2:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                else:
                                    require arg2
                                    if arg2 * t / s / arg2 != t / s:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 0 > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += arg2 * t / s
                            if 0 > stor7:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(arg2, msg.sender, arg1);
                        else:
                            require arg2 / 100
                            if 5 * arg2 / 100 / arg2 / 100 != 5:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if 5 * arg2 / 100 > arg2:
                                revert with 0, 'SafeMath: subtraction overflow'
                            idx = 0
                            s = 100000 * 10^18
                            t = stor7
                            while idx < stor5.length:
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                if stor1[stor5[idx]] > t:
                                    _14502 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14502] = 26
                                    mem[_14502 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if not 5 * arg2 / 100:
                                            _15686 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_15686] = 30
                                            mem[_15686 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _16644 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_16644] = 30
                                            mem[_16644 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _17333 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_17333 + idx + 68] = mem[_16644 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_17333 + 68] = mem[_17333 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _17333 + -mem[64] + 100
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _20969 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_20969] = 30
                                            mem[_20969 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor7:
                                                if totalFees + (5 * arg2 / 100) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += 5 * arg2 / 100
                                                emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                                return 1
                                            _22152 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_22152 + idx + 68] = mem[_20969 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_22152 + 68] = mem[_22152 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _22152 + -mem[64] + 100
                                        require 5 * arg2 / 100
                                        if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _15789 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_15789] = 30
                                        mem[_15789 + 32] = 'SafeMath: subtraction overflow'
                                        if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > 0:
                                            _16007 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_16007 + idx + 68] = mem[_15789 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_16007 + 68] = mem[_16007 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _16007 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _17332 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17332] = 30
                                        mem[_17332 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _18099 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_18099 + idx + 68] = mem[_17332 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_18099 + 68] = mem[_18099 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _18099 + -mem[64] + 100
                                        if stor1[address(arg1)] - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                        _22151 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22151] = 30
                                        mem[_22151 + 32] = 'SafeMath: subtraction overflow'
                                        if 5 * arg2 / 100 * stor7 / 100000 * 10^18 <= stor7:
                                            stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                            if totalFees + (5 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 5 * arg2 / 100
                                            emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _23124 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_23124 + idx + 68] = mem[_22151 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23124 + 68] = mem[_23124 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _23124 + -mem[64] + 100
                                    require arg2
                                    if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not 5 * arg2 / 100:
                                        _15788 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_15788] = 30
                                        mem[_15788 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor7 / 100000 * 10^18:
                                            _16004 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_16004 + idx + 68] = mem[_15788 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_16004 + 68] = mem[_16004 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _16004 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _17331 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17331] = 30
                                        mem[_17331 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                            _18096 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_18096 + idx + 68] = mem[_17331 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_18096 + 68] = mem[_18096 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _18096 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                                        _22150 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22150] = 30
                                        mem[_22150 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor7:
                                            if totalFees + (5 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 5 * arg2 / 100
                                            emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _23121 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_23121 + idx + 68] = mem[_22150 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23121 + 68] = mem[_23121 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _23121 + -mem[64] + 100
                                    require 5 * arg2 / 100
                                    if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _16003 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16003] = 30
                                    mem[_16003 + 32] = 'SafeMath: subtraction overflow'
                                    if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > arg2 * stor7 / 100000 * 10^18:
                                        _16348 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_16348 + idx + 68] = mem[_16003 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_16348 + 68] = mem[_16348 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _16348 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _18095 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18095] = 30
                                    mem[_18095 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                        _19098 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_19098 + idx + 68] = mem[_18095 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19098 + 68] = mem[_19098 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _19098 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18)
                                    _23120 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23120] = 30
                                    mem[_23120 + 32] = 'SafeMath: subtraction overflow'
                                    if 5 * arg2 / 100 * stor7 / 100000 * 10^18 <= stor7:
                                        stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                        if totalFees + (5 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 5 * arg2 / 100
                                        emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _23915 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_23915 + idx + 68] = mem[_23120 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23915 + 68] = mem[_23915 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _23915 + -mem[64] + 100
                                require idx < stor5.length
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                if stor2[stor5[idx]] <= s:
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    _14576 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14576] = 30
                                    mem[_14576 + 32] = 'SafeMath: subtraction overflow'
                                    if stor1[stor5[idx]] > t:
                                        _14652 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_14652 + idx + 68] = mem[_14576 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14652 + 68] = mem[_14652 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _14652 + -mem[64] + 100
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    _15034 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15034] = 30
                                    mem[_15034 + 32] = 'SafeMath: subtraction overflow'
                                    if stor2[stor5[idx]] <= s:
                                        idx = idx + 1
                                        s = s - stor2[stor5[idx]]
                                        t = t - stor1[stor5[idx]]
                                        continue 
                                    _15150 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_15150 + idx + 68] = mem[_15034 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15150 + 68] = mem[_15150 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _15150 + -mem[64] + 100
                                _14606 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14606] = 26
                                mem[_14606 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not 5 * arg2 / 100:
                                        _15790 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_15790] = 30
                                        mem[_15790 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _17340 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17340] = 30
                                        mem[_17340 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _18109 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_18109 + idx + 68] = mem[_17340 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_18109 + 68] = mem[_18109 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _18109 + -mem[64] + 100
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _22159 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22159] = 30
                                        mem[_22159 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor7:
                                            if totalFees + (5 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 5 * arg2 / 100
                                            emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _23131 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_23131 + idx + 68] = mem[_22159 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23131 + 68] = mem[_23131 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _23131 + -mem[64] + 100
                                    require 5 * arg2 / 100
                                    if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _16011 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16011] = 30
                                    mem[_16011 + 32] = 'SafeMath: subtraction overflow'
                                    if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > 0:
                                        _16358 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_16358 + idx + 68] = mem[_16011 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_16358 + 68] = mem[_16358 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _16358 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _18108 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18108] = 30
                                    mem[_18108 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _19114 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_19114 + idx + 68] = mem[_18108 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19114 + 68] = mem[_19114 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _19114 + -mem[64] + 100
                                    if stor1[address(arg1)] - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                    _23130 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23130] = 30
                                    mem[_23130 + 32] = 'SafeMath: subtraction overflow'
                                    if 5 * arg2 / 100 * stor7 / 100000 * 10^18 <= stor7:
                                        stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                        if totalFees + (5 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 5 * arg2 / 100
                                        emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _23927 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_23927 + idx + 68] = mem[_23130 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23927 + 68] = mem[_23927 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _23927 + -mem[64] + 100
                                require arg2
                                if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not 5 * arg2 / 100:
                                    _16010 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16010] = 30
                                    mem[_16010 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor7 / 100000 * 10^18:
                                        _16355 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_16355 + idx + 68] = mem[_16010 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_16355 + 68] = mem[_16355 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _16355 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _18107 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18107] = 30
                                    mem[_18107 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                        _19111 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_19111 + idx + 68] = mem[_18107 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19111 + 68] = mem[_19111 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _19111 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                                    _23129 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23129] = 30
                                    mem[_23129 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor7:
                                        if totalFees + (5 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 5 * arg2 / 100
                                        emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _23924 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_23924 + idx + 68] = mem[_23129 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23924 + 68] = mem[_23924 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _23924 + -mem[64] + 100
                                require 5 * arg2 / 100
                                if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _16354 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16354] = 30
                                mem[_16354 + 32] = 'SafeMath: subtraction overflow'
                                if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > arg2 * stor7 / 100000 * 10^18:
                                    _16887 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_16887 + idx + 68] = mem[_16354 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_16887 + 68] = mem[_16887 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _16887 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _19110 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19110] = 30
                                mem[_19110 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                    _20226 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_20226 + idx + 68] = mem[_19110 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20226 + 68] = mem[_20226 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _20226 + -mem[64] + 100
                                stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18)
                                _23923 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23923] = 30
                                mem[_23923 + 32] = 'SafeMath: subtraction overflow'
                                if 5 * arg2 / 100 * stor7 / 100000 * 10^18 <= stor7:
                                    stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                    if totalFees + (5 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 5 * arg2 / 100
                                    emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _24784 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_24784 + idx + 68] = mem[_23923 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24784 + 68] = mem[_24784 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _24784 + -mem[64] + 100
                            _14278 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14278] = 26
                            mem[_14278 + 32] = 'SafeMath: division by zero'
                            if t < stor7 / 100000 * 10^18:
                                _14735 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14735] = 26
                                mem[_14735 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not 5 * arg2 / 100:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 > stor7:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require 5 * arg2 / 100
                                        if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                        if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > stor7:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                else:
                                    require arg2
                                    if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not 5 * arg2 / 100:
                                        if 0 > arg2 * stor7 / 100000 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                                        if 0 > stor7:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require 5 * arg2 / 100
                                        if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > arg2 * stor7 / 100000 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18)
                                        if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > stor7:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                            else:
                                _14734 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14734] = 26
                                mem[_14734 + 32] = 'SafeMath: division by zero'
                                if s <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require s
                                if not arg2:
                                    if not 5 * arg2 / 100:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 > stor7:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require 5 * arg2 / 100
                                        if 5 * arg2 / 100 * t / s / 5 * arg2 / 100 != t / s:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 5 * arg2 / 100 * t / s > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] - (5 * arg2 / 100 * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += -5 * arg2 / 100 * t / s
                                        if 5 * arg2 / 100 * t / s > stor7:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor7 += -5 * arg2 / 100 * t / s
                                else:
                                    require arg2
                                    if arg2 * t / s / arg2 != t / s:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not 5 * arg2 / 100:
                                        if 0 > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += arg2 * t / s
                                        if 0 > stor7:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require 5 * arg2 / 100
                                        if 5 * arg2 / 100 * t / s / 5 * arg2 / 100 != t / s:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 5 * arg2 / 100 * t / s > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor1[address(arg1)] + (arg2 * t / s) - (5 * arg2 / 100 * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (5 * arg2 / 100 * t / s)
                                        if 5 * arg2 / 100 * t / s > stor7:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor7 += -5 * arg2 / 100 * t / s
                            if totalFees + (5 * arg2 / 100) < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += 5 * arg2 / 100
                            emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                    else:
                        if not arg2 / 100:
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if 0 > arg2:
                                revert with 0, 'SafeMath: subtraction overflow'
                            idx = 0
                            s = 100000 * 10^18
                            t = stor7
                            while idx < stor5.length:
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                if stor1[stor5[idx]] > t:
                                    _14511 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14511] = 26
                                    mem[_14511 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        _15689 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_15689] = 30
                                        mem[_15689 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _16655 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16655] = 30
                                        mem[_16655 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _17361 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_17361 + idx + 68] = mem[_16655 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_17361 + 68] = mem[_17361 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _17361 + -mem[64] + 100
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _21003 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_21003] = 30
                                        mem[_21003 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor7:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _22200 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_22200 + idx + 68] = mem[_21003 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22200 + 68] = mem[_22200 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _22200 + -mem[64] + 100
                                    require arg2
                                    if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _15796 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15796] = 30
                                    mem[_15796 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor7 / 100000 * 10^18:
                                        _16031 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_16031 + idx + 68] = mem[_15796 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_16031 + 68] = mem[_16031 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _16031 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _17360 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17360] = 30
                                    mem[_17360 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                        _18161 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_18161 + idx + 68] = mem[_17360 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18161 + 68] = mem[_18161 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _18161 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                                    _22199 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22199] = 30
                                    mem[_22199 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor7:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _23174 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_23174 + idx + 68] = mem[_22199 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23174 + 68] = mem[_23174 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _23174 + -mem[64] + 100
                                require idx < stor5.length
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                if stor2[stor5[idx]] <= s:
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    _14579 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14579] = 30
                                    mem[_14579 + 32] = 'SafeMath: subtraction overflow'
                                    if stor1[stor5[idx]] > t:
                                        _14661 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_14661 + idx + 68] = mem[_14579 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14661 + 68] = mem[_14661 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _14661 + -mem[64] + 100
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    _15040 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15040] = 30
                                    mem[_15040 + 32] = 'SafeMath: subtraction overflow'
                                    if stor2[stor5[idx]] <= s:
                                        idx = idx + 1
                                        s = s - stor2[stor5[idx]]
                                        t = t - stor1[stor5[idx]]
                                        continue 
                                    _15165 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_15165 + idx + 68] = mem[_15040 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15165 + 68] = mem[_15165 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _15165 + -mem[64] + 100
                                _14609 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14609] = 26
                                mem[_14609 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    _15797 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15797] = 30
                                    mem[_15797 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _17366 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17366] = 30
                                    mem[_17366 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _18168 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_18168 + idx + 68] = mem[_17366 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18168 + 68] = mem[_18168 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _18168 + -mem[64] + 100
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _22204 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22204] = 30
                                    mem[_22204 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor7:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _23179 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_23179 + idx + 68] = mem[_22204 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23179 + 68] = mem[_23179 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _23179 + -mem[64] + 100
                                require arg2
                                if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _16034 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16034] = 30
                                mem[_16034 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor7 / 100000 * 10^18:
                                    _16389 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_16389 + idx + 68] = mem[_16034 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_16389 + 68] = mem[_16389 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _16389 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _18167 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18167] = 30
                                mem[_18167 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                    _19190 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_19190 + idx + 68] = mem[_18167 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19190 + 68] = mem[_19190 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _19190 + -mem[64] + 100
                                stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                                _23178 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23178] = 30
                                mem[_23178 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor7:
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _23987 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_23987 + idx + 68] = mem[_23178 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23987 + 68] = mem[_23987 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _23987 + -mem[64] + 100
                            _14293 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14293] = 26
                            mem[_14293 + 32] = 'SafeMath: division by zero'
                            if t < stor7 / 100000 * 10^18:
                                _14741 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14741] = 26
                                mem[_14741 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                else:
                                    require arg2
                                    if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 0 > arg2 * stor7 / 100000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                            else:
                                _14740 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14740] = 26
                                mem[_14740 + 32] = 'SafeMath: division by zero'
                                if s <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require s
                                if not arg2:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                else:
                                    require arg2
                                    if arg2 * t / s / arg2 != t / s:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 0 > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += arg2 * t / s
                            if 0 > stor7:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(arg2, msg.sender, arg1);
                        else:
                            require arg2 / 100
                            if 5 * arg2 / 100 / arg2 / 100 != 5:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if 5 * arg2 / 100 > arg2:
                                revert with 0, 'SafeMath: subtraction overflow'
                            idx = 0
                            s = 100000 * 10^18
                            t = stor7
                            while idx < stor5.length:
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                if stor1[stor5[idx]] > t:
                                    _14508 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14508] = 26
                                    mem[_14508 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if not 5 * arg2 / 100:
                                            _15688 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_15688] = 30
                                            mem[_15688 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _16652 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_16652] = 30
                                            mem[_16652 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _17352 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_17352 + idx + 68] = mem[_16652 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_17352 + 68] = mem[_17352 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _17352 + -mem[64] + 100
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _20992 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_20992] = 30
                                            mem[_20992 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor7:
                                                if totalFees + (5 * arg2 / 100) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += 5 * arg2 / 100
                                                emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                                return 1
                                            _22185 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_22185 + idx + 68] = mem[_20992 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_22185 + 68] = mem[_22185 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _22185 + -mem[64] + 100
                                        require 5 * arg2 / 100
                                        if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _15794 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_15794] = 30
                                        mem[_15794 + 32] = 'SafeMath: subtraction overflow'
                                        if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > 0:
                                            _16024 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_16024 + idx + 68] = mem[_15794 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_16024 + 68] = mem[_16024 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _16024 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _17351 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17351] = 30
                                        mem[_17351 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _18142 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_18142 + idx + 68] = mem[_17351 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_18142 + 68] = mem[_18142 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _18142 + -mem[64] + 100
                                        if stor1[address(arg1)] - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                        _22184 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22184] = 30
                                        mem[_22184 + 32] = 'SafeMath: subtraction overflow'
                                        if 5 * arg2 / 100 * stor7 / 100000 * 10^18 <= stor7:
                                            stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                            if totalFees + (5 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 5 * arg2 / 100
                                            emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _23160 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_23160 + idx + 68] = mem[_22184 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23160 + 68] = mem[_23160 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _23160 + -mem[64] + 100
                                    require arg2
                                    if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not 5 * arg2 / 100:
                                        _15793 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_15793] = 30
                                        mem[_15793 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor7 / 100000 * 10^18:
                                            _16021 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_16021 + idx + 68] = mem[_15793 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_16021 + 68] = mem[_16021 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _16021 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _17350 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17350] = 30
                                        mem[_17350 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                            _18139 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_18139 + idx + 68] = mem[_17350 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_18139 + 68] = mem[_18139 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _18139 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                                        _22183 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22183] = 30
                                        mem[_22183 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor7:
                                            if totalFees + (5 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 5 * arg2 / 100
                                            emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _23157 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_23157 + idx + 68] = mem[_22183 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23157 + 68] = mem[_23157 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _23157 + -mem[64] + 100
                                    require 5 * arg2 / 100
                                    if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _16020 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16020] = 30
                                    mem[_16020 + 32] = 'SafeMath: subtraction overflow'
                                    if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > arg2 * stor7 / 100000 * 10^18:
                                        _16372 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_16372 + idx + 68] = mem[_16020 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_16372 + 68] = mem[_16372 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _16372 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _18138 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18138] = 30
                                    mem[_18138 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                        _19154 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_19154 + idx + 68] = mem[_18138 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19154 + 68] = mem[_19154 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _19154 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18)
                                    _23156 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23156] = 30
                                    mem[_23156 + 32] = 'SafeMath: subtraction overflow'
                                    if 5 * arg2 / 100 * stor7 / 100000 * 10^18 <= stor7:
                                        stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                        if totalFees + (5 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 5 * arg2 / 100
                                        emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _23959 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_23959 + idx + 68] = mem[_23156 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23959 + 68] = mem[_23959 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _23959 + -mem[64] + 100
                                require idx < stor5.length
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                if stor2[stor5[idx]] <= s:
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    _14578 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14578] = 30
                                    mem[_14578 + 32] = 'SafeMath: subtraction overflow'
                                    if stor1[stor5[idx]] > t:
                                        _14658 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_14658 + idx + 68] = mem[_14578 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14658 + 68] = mem[_14658 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _14658 + -mem[64] + 100
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    _15038 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15038] = 30
                                    mem[_15038 + 32] = 'SafeMath: subtraction overflow'
                                    if stor2[stor5[idx]] <= s:
                                        idx = idx + 1
                                        s = s - stor2[stor5[idx]]
                                        t = t - stor1[stor5[idx]]
                                        continue 
                                    _15160 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_15160 + idx + 68] = mem[_15038 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15160 + 68] = mem[_15160 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _15160 + -mem[64] + 100
                                _14608 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14608] = 26
                                mem[_14608 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not 5 * arg2 / 100:
                                        _15795 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_15795] = 30
                                        mem[_15795 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _17359 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17359] = 30
                                        mem[_17359 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _18152 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_18152 + idx + 68] = mem[_17359 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_18152 + 68] = mem[_18152 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _18152 + -mem[64] + 100
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _22192 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22192] = 30
                                        mem[_22192 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor7:
                                            if totalFees + (5 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 5 * arg2 / 100
                                            emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _23167 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_23167 + idx + 68] = mem[_22192 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23167 + 68] = mem[_23167 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _23167 + -mem[64] + 100
                                    require 5 * arg2 / 100
                                    if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _16028 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16028] = 30
                                    mem[_16028 + 32] = 'SafeMath: subtraction overflow'
                                    if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > 0:
                                        _16382 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_16382 + idx + 68] = mem[_16028 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_16382 + 68] = mem[_16382 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _16382 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _18151 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18151] = 30
                                    mem[_18151 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _19170 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_19170 + idx + 68] = mem[_18151 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19170 + 68] = mem[_19170 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _19170 + -mem[64] + 100
                                    if stor1[address(arg1)] - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                    _23166 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23166] = 30
                                    mem[_23166 + 32] = 'SafeMath: subtraction overflow'
                                    if 5 * arg2 / 100 * stor7 / 100000 * 10^18 <= stor7:
                                        stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                        if totalFees + (5 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 5 * arg2 / 100
                                        emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _23971 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_23971 + idx + 68] = mem[_23166 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23971 + 68] = mem[_23971 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _23971 + -mem[64] + 100
                                require arg2
                                if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not 5 * arg2 / 100:
                                    _16027 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16027] = 30
                                    mem[_16027 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor7 / 100000 * 10^18:
                                        _16379 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_16379 + idx + 68] = mem[_16027 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_16379 + 68] = mem[_16379 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _16379 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _18150 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18150] = 30
                                    mem[_18150 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                        _19167 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_19167 + idx + 68] = mem[_18150 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19167 + 68] = mem[_19167 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _19167 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                                    _23165 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23165] = 30
                                    mem[_23165 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor7:
                                        if totalFees + (5 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 5 * arg2 / 100
                                        emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _23968 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_23968 + idx + 68] = mem[_23165 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23968 + 68] = mem[_23968 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _23968 + -mem[64] + 100
                                require 5 * arg2 / 100
                                if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _16378 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16378] = 30
                                mem[_16378 + 32] = 'SafeMath: subtraction overflow'
                                if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > arg2 * stor7 / 100000 * 10^18:
                                    _16922 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_16922 + idx + 68] = mem[_16378 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_16922 + 68] = mem[_16922 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _16922 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _19166 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19166] = 30
                                mem[_19166 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                    _20288 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_20288 + idx + 68] = mem[_19166 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20288 + 68] = mem[_20288 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _20288 + -mem[64] + 100
                                stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18)
                                _23967 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23967] = 30
                                mem[_23967 + 32] = 'SafeMath: subtraction overflow'
                                if 5 * arg2 / 100 * stor7 / 100000 * 10^18 <= stor7:
                                    stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                    if totalFees + (5 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 5 * arg2 / 100
                                    emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _24834 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_24834 + idx + 68] = mem[_23967 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24834 + 68] = mem[_24834 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _24834 + -mem[64] + 100
                            _14288 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14288] = 26
                            mem[_14288 + 32] = 'SafeMath: division by zero'
                            if t < stor7 / 100000 * 10^18:
                                _14739 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14739] = 26
                                mem[_14739 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not 5 * arg2 / 100:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 > stor7:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require 5 * arg2 / 100
                                        if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                        if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > stor7:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                else:
                                    require arg2
                                    if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not 5 * arg2 / 100:
                                        if 0 > arg2 * stor7 / 100000 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                                        if 0 > stor7:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require 5 * arg2 / 100
                                        if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > arg2 * stor7 / 100000 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18)
                                        if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > stor7:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                            else:
                                _14738 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14738] = 26
                                mem[_14738 + 32] = 'SafeMath: division by zero'
                                if s <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require s
                                if not arg2:
                                    if not 5 * arg2 / 100:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 > stor7:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require 5 * arg2 / 100
                                        if 5 * arg2 / 100 * t / s / 5 * arg2 / 100 != t / s:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 5 * arg2 / 100 * t / s > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] - (5 * arg2 / 100 * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += -5 * arg2 / 100 * t / s
                                        if 5 * arg2 / 100 * t / s > stor7:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor7 += -5 * arg2 / 100 * t / s
                                else:
                                    require arg2
                                    if arg2 * t / s / arg2 != t / s:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not 5 * arg2 / 100:
                                        if 0 > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += arg2 * t / s
                                        if 0 > stor7:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require 5 * arg2 / 100
                                        if 5 * arg2 / 100 * t / s / 5 * arg2 / 100 != t / s:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 5 * arg2 / 100 * t / s > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor1[address(arg1)] + (arg2 * t / s) - (5 * arg2 / 100 * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (5 * arg2 / 100 * t / s)
                                        if 5 * arg2 / 100 * t / s > stor7:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor7 += -5 * arg2 / 100 * t / s
                            if totalFees + (5 * arg2 / 100) < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += 5 * arg2 / 100
                            emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
    else:
        mem[0] = arg1
        mem[32] = 4
        if not stor4[address(arg1)]:
            mem[96] = 26
            mem[128] = 'SafeMath: division by zero'
            if not arg2 / 100:
                mem[64] = 224
                mem[160] = 30
                mem[192] = 'SafeMath: subtraction overflow'
                if 0 > arg2:
                    revert with 0, 'SafeMath: subtraction overflow'
                idx = 0
                s = 100000 * 10^18
                t = stor7
                while idx < stor5.length:
                    mem[0] = stor5[idx]
                    mem[32] = 1
                    if stor1[stor5[idx]] > t:
                        _14565 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14565] = 26
                        mem[_14565 + 32] = 'SafeMath: division by zero'
                        if not arg2:
                            _15707 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15707] = 30
                            mem[_15707 + 32] = 'SafeMath: subtraction overflow'
                            mem[0] = msg.sender
                            mem[32] = 2
                            _16727 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16727] = 30
                            mem[_16727 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 > stor2[address(msg.sender)]:
                                _17532 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_17532 + idx + 68] = mem[_16727 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_17532 + 68] = mem[_17532 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _17532 + -mem[64] + 100
                            stor2[address(msg.sender)] -= arg2
                            mem[0] = msg.sender
                            mem[32] = 1
                            _18857 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_18857] = 30
                            mem[_18857 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor1[address(msg.sender)]:
                                _19943 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_19943 + idx + 68] = mem[_18857 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19943 + 68] = mem[_19943 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _19943 + -mem[64] + 100
                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            _23723 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23723] = 30
                            mem[_23723 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor7:
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg2, msg.sender, arg1);
                                return 1
                            _24554 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_24554 + idx + 68] = mem[_23723 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_24554 + 68] = mem[_24554 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _24554 + -mem[64] + 100
                        require arg2
                        if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _15841 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15841] = 30
                        mem[_15841 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg2 * stor7 / 100000 * 10^18:
                            _16184 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_16184 + idx + 68] = mem[_15841 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_16184 + 68] = mem[_16184 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _16184 + -mem[64] + 100
                        mem[0] = msg.sender
                        mem[32] = 2
                        _17531 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_17531] = 30
                        mem[_17531 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 > stor2[address(msg.sender)]:
                            _18548 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_18548 + idx + 68] = mem[_17531 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_18548 + 68] = mem[_18548 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _18548 + -mem[64] + 100
                        stor2[address(msg.sender)] -= arg2
                        mem[0] = msg.sender
                        mem[32] = 1
                        _19940 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19940] = 30
                        mem[_19940 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                            _21238 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_21238 + idx + 68] = mem[_19940 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_21238 + 68] = mem[_21238 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _21238 + -mem[64] + 100
                        stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                        if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg1
                        mem[32] = 1
                        stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                        _24553 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24553] = 30
                        mem[_24553 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= stor7:
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(arg2, msg.sender, arg1);
                            return 1
                        _25510 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_25510 + idx + 68] = mem[_24553 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_25510 + 68] = mem[_25510 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _25510 + -mem[64] + 100
                    require idx < stor5.length
                    mem[0] = stor5[idx]
                    mem[32] = 2
                    if stor2[stor5[idx]] <= s:
                        require idx < stor5.length
                        mem[0] = stor5[idx]
                        mem[32] = 1
                        _14597 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14597] = 30
                        mem[_14597 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor5[idx]] > t:
                            _14715 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_14715 + idx + 68] = mem[_14597 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_14715 + 68] = mem[_14715 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _14715 + -mem[64] + 100
                        require idx < stor5.length
                        mem[0] = stor5[idx]
                        mem[32] = 2
                        _15076 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15076] = 30
                        mem[_15076 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor5[idx]] <= s:
                            idx = idx + 1
                            s = s - stor2[stor5[idx]]
                            t = t - stor1[stor5[idx]]
                            continue 
                        _15255 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_15255 + idx + 68] = mem[_15076 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_15255 + 68] = mem[_15255 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _15255 + -mem[64] + 100
                    _14627 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14627] = 26
                    mem[_14627 + 32] = 'SafeMath: division by zero'
                    if not arg2:
                        _15842 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15842] = 30
                        mem[_15842 + 32] = 'SafeMath: subtraction overflow'
                        mem[0] = msg.sender
                        mem[32] = 2
                        _17537 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_17537] = 30
                        mem[_17537 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 > stor2[address(msg.sender)]:
                            _18555 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_18555 + idx + 68] = mem[_17537 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_18555 + 68] = mem[_18555 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _18555 + -mem[64] + 100
                        stor2[address(msg.sender)] -= arg2
                        mem[0] = msg.sender
                        mem[32] = 1
                        _19946 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19946] = 30
                        mem[_19946 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor1[address(msg.sender)]:
                            _21247 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_21247 + idx + 68] = mem[_19946 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_21247 + 68] = mem[_21247 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _21247 + -mem[64] + 100
                        if stor1[address(arg1)] < stor1[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg1
                        mem[32] = 1
                        _24558 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24558] = 30
                        mem[_24558 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= stor7:
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(arg2, msg.sender, arg1);
                            return 1
                        _25515 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_25515 + idx + 68] = mem[_24558 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_25515 + 68] = mem[_25515 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _25515 + -mem[64] + 100
                    require arg2
                    if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _16187 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_16187] = 30
                    mem[_16187 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg2 * stor7 / 100000 * 10^18:
                        _16605 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_16605 + idx + 68] = mem[_16187 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_16605 + 68] = mem[_16605 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _16605 + -mem[64] + 100
                    mem[0] = msg.sender
                    mem[32] = 2
                    _18554 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_18554] = 30
                    mem[_18554 + 32] = 'SafeMath: subtraction overflow'
                    if arg2 > stor2[address(msg.sender)]:
                        _19690 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_19690 + idx + 68] = mem[_18554 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_19690 + 68] = mem[_19690 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _19690 + -mem[64] + 100
                    stor2[address(msg.sender)] -= arg2
                    mem[0] = msg.sender
                    mem[32] = 1
                    _21244 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_21244] = 30
                    mem[_21244 + 32] = 'SafeMath: subtraction overflow'
                    if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                        _22543 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_22543 + idx + 68] = mem[_21244 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_22543 + 68] = mem[_22543 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _22543 + -mem[64] + 100
                    stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                    if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[0] = arg1
                    mem[32] = 1
                    stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                    _25514 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_25514] = 30
                    mem[_25514 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= stor7:
                        if totalFees < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        emit Transfer(arg2, msg.sender, arg1);
                        return 1
                    _26420 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_26420 + idx + 68] = mem[_25514 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_26420 + 68] = mem[_26420 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _26420 + -mem[64] + 100
                _14383 = mem[64]
                mem[64] = mem[64] + 64
                mem[_14383] = 26
                mem[_14383 + 32] = 'SafeMath: division by zero'
                if t < stor7 / 100000 * 10^18:
                    _14777 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14777] = 26
                    mem[_14777 + 32] = 'SafeMath: division by zero'
                    if not arg2:
                        if arg2 > stor2[address(msg.sender)]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        stor2[address(msg.sender)] -= arg2
                        if 0 > stor1[address(msg.sender)]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if stor1[address(arg1)] < stor1[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                    else:
                        require arg2
                        if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if 0 > arg2 * stor7 / 100000 * 10^18:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if arg2 > stor2[address(msg.sender)]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        stor2[address(msg.sender)] -= arg2
                        if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                        if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                else:
                    _14776 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14776] = 26
                    mem[_14776 + 32] = 'SafeMath: division by zero'
                    if s <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require s
                    if not arg2:
                        if arg2 > stor2[address(msg.sender)]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        stor2[address(msg.sender)] -= arg2
                        if 0 > stor1[address(msg.sender)]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if stor1[address(arg1)] < stor1[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                    else:
                        require arg2
                        if arg2 * t / s / arg2 != t / s:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if 0 > arg2 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if arg2 > stor2[address(msg.sender)]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        stor2[address(msg.sender)] -= arg2
                        if arg2 * t / s > stor1[address(msg.sender)]:
                            revert with 0, 'SafeMath: subtraction overflow'
                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                        if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor1[address(arg1)] += arg2 * t / s
                if 0 > stor7:
                    revert with 0, 'SafeMath: subtraction overflow'
                if totalFees < totalFees:
                    revert with 0, 'SafeMath: addition overflow'
                emit Transfer(arg2, msg.sender, arg1);
            else:
                require arg2 / 100
                if 5 * arg2 / 100 / arg2 / 100 != 5:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                mem[64] = 224
                mem[160] = 30
                mem[192] = 'SafeMath: subtraction overflow'
                if 5 * arg2 / 100 > arg2:
                    revert with 0, 'SafeMath: subtraction overflow'
                idx = 0
                s = 100000 * 10^18
                t = stor7
                while idx < stor5.length:
                    mem[0] = stor5[idx]
                    mem[32] = 1
                    if stor1[stor5[idx]] > t:
                        _14562 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14562] = 26
                        mem[_14562 + 32] = 'SafeMath: division by zero'
                        if not arg2:
                            if not 5 * arg2 / 100:
                                _15706 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15706] = 30
                                mem[_15706 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = msg.sender
                                mem[32] = 2
                                _16724 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16724] = 30
                                mem[_16724 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 > stor2[address(msg.sender)]:
                                    _17523 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_17523 + idx + 68] = mem[_16724 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_17523 + 68] = mem[_17523 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _17523 + -mem[64] + 100
                                stor2[address(msg.sender)] -= arg2
                                mem[0] = msg.sender
                                mem[32] = 1
                                _18848 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18848] = 30
                                mem[_18848 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _19934 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_19934 + idx + 68] = mem[_18848 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19934 + 68] = mem[_19934 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _19934 + -mem[64] + 100
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                _23712 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23712] = 30
                                mem[_23712 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor7:
                                    if totalFees + (5 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 5 * arg2 / 100
                                    emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _24539 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_24539 + idx + 68] = mem[_23712 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24539 + 68] = mem[_24539 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _24539 + -mem[64] + 100
                            require 5 * arg2 / 100
                            if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _15839 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15839] = 30
                            mem[_15839 + 32] = 'SafeMath: subtraction overflow'
                            if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > 0:
                                _16177 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_16177 + idx + 68] = mem[_15839 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_16177 + 68] = mem[_16177 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _16177 + -mem[64] + 100
                            mem[0] = msg.sender
                            mem[32] = 2
                            _17522 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_17522] = 30
                            mem[_17522 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 > stor2[address(msg.sender)]:
                                _18529 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_18529 + idx + 68] = mem[_17522 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_18529 + 68] = mem[_18529 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _18529 + -mem[64] + 100
                            stor2[address(msg.sender)] -= arg2
                            mem[0] = msg.sender
                            mem[32] = 1
                            _19931 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19931] = 30
                            mem[_19931 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor1[address(msg.sender)]:
                                _21217 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_21217 + idx + 68] = mem[_19931 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21217 + 68] = mem[_21217 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _21217 + -mem[64] + 100
                            if stor1[address(arg1)] - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                            _24538 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24538] = 30
                            mem[_24538 + 32] = 'SafeMath: subtraction overflow'
                            if 5 * arg2 / 100 * stor7 / 100000 * 10^18 <= stor7:
                                stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                if totalFees + (5 * arg2 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 5 * arg2 / 100
                                emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                return 1
                            _25496 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_25496 + idx + 68] = mem[_24538 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_25496 + 68] = mem[_25496 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _25496 + -mem[64] + 100
                        require arg2
                        if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if not 5 * arg2 / 100:
                            _15838 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15838] = 30
                            mem[_15838 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg2 * stor7 / 100000 * 10^18:
                                _16174 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_16174 + idx + 68] = mem[_15838 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_16174 + 68] = mem[_16174 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _16174 + -mem[64] + 100
                            mem[0] = msg.sender
                            mem[32] = 2
                            _17521 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_17521] = 30
                            mem[_17521 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 > stor2[address(msg.sender)]:
                                _18526 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_18526 + idx + 68] = mem[_17521 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_18526 + 68] = mem[_18526 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _18526 + -mem[64] + 100
                            stor2[address(msg.sender)] -= arg2
                            mem[0] = msg.sender
                            mem[32] = 1
                            _19928 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19928] = 30
                            mem[_19928 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                _21214 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_21214 + idx + 68] = mem[_19928 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21214 + 68] = mem[_21214 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _21214 + -mem[64] + 100
                            stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                            if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                            _24537 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24537] = 30
                            mem[_24537 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor7:
                                if totalFees + (5 * arg2 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 5 * arg2 / 100
                                emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                return 1
                            _25493 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_25493 + idx + 68] = mem[_24537 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_25493 + 68] = mem[_25493 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _25493 + -mem[64] + 100
                        require 5 * arg2 / 100
                        if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _16173 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16173] = 30
                        mem[_16173 + 32] = 'SafeMath: subtraction overflow'
                        if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > arg2 * stor7 / 100000 * 10^18:
                            _16588 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_16588 + idx + 68] = mem[_16173 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_16588 + 68] = mem[_16588 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _16588 + -mem[64] + 100
                        mem[0] = msg.sender
                        mem[32] = 2
                        _18525 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_18525] = 30
                        mem[_18525 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 > stor2[address(msg.sender)]:
                            _19658 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_19658 + idx + 68] = mem[_18525 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_19658 + 68] = mem[_19658 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _19658 + -mem[64] + 100
                        stor2[address(msg.sender)] -= arg2
                        mem[0] = msg.sender
                        mem[32] = 1
                        _21211 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21211] = 30
                        mem[_21211 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                            _22501 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_22501 + idx + 68] = mem[_21211 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_22501 + 68] = mem[_22501 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _22501 + -mem[64] + 100
                        stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                        if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg1
                        mem[32] = 1
                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18)
                        _25492 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25492] = 30
                        mem[_25492 + 32] = 'SafeMath: subtraction overflow'
                        if 5 * arg2 / 100 * stor7 / 100000 * 10^18 <= stor7:
                            stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                            if totalFees + (5 * arg2 / 100) < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += 5 * arg2 / 100
                            emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                            return 1
                        _26392 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_26392 + idx + 68] = mem[_25492 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_26392 + 68] = mem[_26392 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _26392 + -mem[64] + 100
                    require idx < stor5.length
                    mem[0] = stor5[idx]
                    mem[32] = 2
                    if stor2[stor5[idx]] <= s:
                        require idx < stor5.length
                        mem[0] = stor5[idx]
                        mem[32] = 1
                        _14596 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14596] = 30
                        mem[_14596 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor5[idx]] > t:
                            _14712 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_14712 + idx + 68] = mem[_14596 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_14712 + 68] = mem[_14712 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _14712 + -mem[64] + 100
                        require idx < stor5.length
                        mem[0] = stor5[idx]
                        mem[32] = 2
                        _15074 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15074] = 30
                        mem[_15074 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor5[idx]] <= s:
                            idx = idx + 1
                            s = s - stor2[stor5[idx]]
                            t = t - stor1[stor5[idx]]
                            continue 
                        _15250 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_15250 + idx + 68] = mem[_15074 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_15250 + 68] = mem[_15250 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _15250 + -mem[64] + 100
                    _14626 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14626] = 26
                    mem[_14626 + 32] = 'SafeMath: division by zero'
                    if not arg2:
                        if not 5 * arg2 / 100:
                            _15840 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15840] = 30
                            mem[_15840 + 32] = 'SafeMath: subtraction overflow'
                            mem[0] = msg.sender
                            mem[32] = 2
                            _17530 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_17530] = 30
                            mem[_17530 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 > stor2[address(msg.sender)]:
                                _18539 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_18539 + idx + 68] = mem[_17530 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_18539 + 68] = mem[_18539 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _18539 + -mem[64] + 100
                            stor2[address(msg.sender)] -= arg2
                            mem[0] = msg.sender
                            mem[32] = 1
                            _19937 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19937] = 30
                            mem[_19937 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor1[address(msg.sender)]:
                                _21229 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_21229 + idx + 68] = mem[_19937 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21229 + 68] = mem[_21229 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _21229 + -mem[64] + 100
                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            _24546 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24546] = 30
                            mem[_24546 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor7:
                                if totalFees + (5 * arg2 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 5 * arg2 / 100
                                emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                return 1
                            _25503 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_25503 + idx + 68] = mem[_24546 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_25503 + 68] = mem[_25503 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _25503 + -mem[64] + 100
                        require 5 * arg2 / 100
                        if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _16181 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16181] = 30
                        mem[_16181 + 32] = 'SafeMath: subtraction overflow'
                        if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > 0:
                            _16598 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_16598 + idx + 68] = mem[_16181 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_16598 + 68] = mem[_16598 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _16598 + -mem[64] + 100
                        mem[0] = msg.sender
                        mem[32] = 2
                        _18538 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_18538] = 30
                        mem[_18538 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 > stor2[address(msg.sender)]:
                            _19672 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_19672 + idx + 68] = mem[_18538 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_19672 + 68] = mem[_19672 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _19672 + -mem[64] + 100
                        stor2[address(msg.sender)] -= arg2
                        mem[0] = msg.sender
                        mem[32] = 1
                        _21226 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21226] = 30
                        mem[_21226 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor1[address(msg.sender)]:
                            _22519 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_22519 + idx + 68] = mem[_21226 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_22519 + 68] = mem[_22519 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _22519 + -mem[64] + 100
                        if stor1[address(arg1)] - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg1
                        mem[32] = 1
                        stor1[address(arg1)] += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                        _25502 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25502] = 30
                        mem[_25502 + 32] = 'SafeMath: subtraction overflow'
                        if 5 * arg2 / 100 * stor7 / 100000 * 10^18 <= stor7:
                            stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                            if totalFees + (5 * arg2 / 100) < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += 5 * arg2 / 100
                            emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                            return 1
                        _26404 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_26404 + idx + 68] = mem[_25502 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_26404 + 68] = mem[_26404 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _26404 + -mem[64] + 100
                    require arg2
                    if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if not 5 * arg2 / 100:
                        _16180 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16180] = 30
                        mem[_16180 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg2 * stor7 / 100000 * 10^18:
                            _16595 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_16595 + idx + 68] = mem[_16180 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_16595 + 68] = mem[_16595 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _16595 + -mem[64] + 100
                        mem[0] = msg.sender
                        mem[32] = 2
                        _18537 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_18537] = 30
                        mem[_18537 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 > stor2[address(msg.sender)]:
                            _19669 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_19669 + idx + 68] = mem[_18537 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_19669 + 68] = mem[_19669 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _19669 + -mem[64] + 100
                        stor2[address(msg.sender)] -= arg2
                        mem[0] = msg.sender
                        mem[32] = 1
                        _21223 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21223] = 30
                        mem[_21223 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                            _22516 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_22516 + idx + 68] = mem[_21223 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_22516 + 68] = mem[_22516 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _22516 + -mem[64] + 100
                        stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                        if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg1
                        mem[32] = 1
                        stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                        _25501 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25501] = 30
                        mem[_25501 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= stor7:
                            if totalFees + (5 * arg2 / 100) < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += 5 * arg2 / 100
                            emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                            return 1
                        _26401 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_26401 + idx + 68] = mem[_25501 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_26401 + 68] = mem[_26401 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _26401 + -mem[64] + 100
                    require 5 * arg2 / 100
                    if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _16594 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_16594] = 30
                    mem[_16594 + 32] = 'SafeMath: subtraction overflow'
                    if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > arg2 * stor7 / 100000 * 10^18:
                        _17237 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_17237 + idx + 68] = mem[_16594 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_17237 + 68] = mem[_17237 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _17237 + -mem[64] + 100
                    mem[0] = msg.sender
                    mem[32] = 2
                    _19668 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19668] = 30
                    mem[_19668 + 32] = 'SafeMath: subtraction overflow'
                    if arg2 > stor2[address(msg.sender)]:
                        _20842 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_20842 + idx + 68] = mem[_19668 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_20842 + 68] = mem[_20842 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _20842 + -mem[64] + 100
                    stor2[address(msg.sender)] -= arg2
                    mem[0] = msg.sender
                    mem[32] = 1
                    _22513 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_22513] = 30
                    mem[_22513 + 32] = 'SafeMath: subtraction overflow'
                    if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                        _23499 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_23499 + idx + 68] = mem[_22513 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_23499 + 68] = mem[_23499 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _23499 + -mem[64] + 100
                    stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                    if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[0] = arg1
                    mem[32] = 1
                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18)
                    _26400 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_26400] = 30
                    mem[_26400 + 32] = 'SafeMath: subtraction overflow'
                    if 5 * arg2 / 100 * stor7 / 100000 * 10^18 <= stor7:
                        stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                        if totalFees + (5 * arg2 / 100) < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        totalFees += 5 * arg2 / 100
                        emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                        return 1
                    _27101 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_27101 + idx + 68] = mem[_26400 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_27101 + 68] = mem[_27101 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _27101 + -mem[64] + 100
                _14378 = mem[64]
                mem[64] = mem[64] + 64
                mem[_14378] = 26
                mem[_14378 + 32] = 'SafeMath: division by zero'
                if t < stor7 / 100000 * 10^18:
                    _14775 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14775] = 26
                    mem[_14775 + 32] = 'SafeMath: division by zero'
                    if not arg2:
                        if not 5 * arg2 / 100:
                            if arg2 > stor2[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor2[address(msg.sender)] -= arg2
                            if 0 > stor1[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            if 0 > stor7:
                                revert with 0, 'SafeMath: subtraction overflow'
                        else:
                            require 5 * arg2 / 100
                            if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if arg2 > stor2[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor2[address(msg.sender)] -= arg2
                            if 0 > stor1[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if stor1[address(arg1)] - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor1[address(arg1)] += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                            if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > stor7:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                    else:
                        require arg2
                        if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if not 5 * arg2 / 100:
                            if 0 > arg2 * stor7 / 100000 * 10^18:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if arg2 > stor2[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor2[address(msg.sender)] -= arg2
                            if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                            if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                            if 0 > stor7:
                                revert with 0, 'SafeMath: subtraction overflow'
                        else:
                            require 5 * arg2 / 100
                            if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > arg2 * stor7 / 100000 * 10^18:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if arg2 > stor2[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor2[address(msg.sender)] -= arg2
                            if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                            if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18)
                            if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > stor7:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                else:
                    _14774 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14774] = 26
                    mem[_14774 + 32] = 'SafeMath: division by zero'
                    if s <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require s
                    if not arg2:
                        if not 5 * arg2 / 100:
                            if arg2 > stor2[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor2[address(msg.sender)] -= arg2
                            if 0 > stor1[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            if 0 > stor7:
                                revert with 0, 'SafeMath: subtraction overflow'
                        else:
                            require 5 * arg2 / 100
                            if 5 * arg2 / 100 * t / s / 5 * arg2 / 100 != t / s:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if 5 * arg2 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if arg2 > stor2[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor2[address(msg.sender)] -= arg2
                            if 0 > stor1[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if stor1[address(arg1)] - (5 * arg2 / 100 * t / s) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor1[address(arg1)] += -5 * arg2 / 100 * t / s
                            if 5 * arg2 / 100 * t / s > stor7:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor7 += -5 * arg2 / 100 * t / s
                    else:
                        require arg2
                        if arg2 * t / s / arg2 != t / s:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if not 5 * arg2 / 100:
                            if 0 > arg2 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if arg2 > stor2[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor2[address(msg.sender)] -= arg2
                            if arg2 * t / s > stor1[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor1[address(msg.sender)] += -1 * arg2 * t / s
                            if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor1[address(arg1)] += arg2 * t / s
                            if 0 > stor7:
                                revert with 0, 'SafeMath: subtraction overflow'
                        else:
                            require 5 * arg2 / 100
                            if 5 * arg2 / 100 * t / s / 5 * arg2 / 100 != t / s:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if 5 * arg2 / 100 * t / s > arg2 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if arg2 > stor2[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor2[address(msg.sender)] -= arg2
                            if arg2 * t / s > stor1[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor1[address(msg.sender)] += -1 * arg2 * t / s
                            if stor1[address(arg1)] + (arg2 * t / s) - (5 * arg2 / 100 * t / s) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (5 * arg2 / 100 * t / s)
                            if 5 * arg2 / 100 * t / s > stor7:
                                revert with 0, 'SafeMath: subtraction overflow'
                            stor7 += -5 * arg2 / 100 * t / s
                if totalFees + (5 * arg2 / 100) < totalFees:
                    revert with 0, 'SafeMath: addition overflow'
                totalFees += 5 * arg2 / 100
                emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
        else:
            if stor4[address(msg.sender)]:
                mem[0] = msg.sender
                mem[32] = 4
                if stor4[address(msg.sender)]:
                    mem[96] = 26
                    mem[128] = 'SafeMath: division by zero'
                    if not arg2 / 100:
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if 0 > arg2:
                            revert with 0, 'SafeMath: subtraction overflow'
                        idx = 0
                        s = 100000 * 10^18
                        t = stor7
                        while idx < stor5.length:
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            if stor1[stor5[idx]] > t:
                                _14523 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14523] = 26
                                mem[_14523 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    _15693 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15693] = 30
                                    mem[_15693 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _16671 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16671] = 30
                                    mem[_16671 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _17399 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_17399 + idx + 68] = mem[_16671 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17399 + 68] = mem[_17399 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _17399 + -mem[64] + 100
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _21056 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21056] = 30
                                    mem[_21056 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor7:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _22273 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_22273 + idx + 68] = mem[_21056 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22273 + 68] = mem[_22273 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _22273 + -mem[64] + 100
                                require arg2
                                if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _15806 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15806] = 30
                                mem[_15806 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor7 / 100000 * 10^18:
                                    _16065 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_16065 + idx + 68] = mem[_15806 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_16065 + 68] = mem[_16065 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _16065 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _17398 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17398] = 30
                                mem[_17398 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                    _18247 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_18247 + idx + 68] = mem[_17398 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18247 + 68] = mem[_18247 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _18247 + -mem[64] + 100
                                stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                                _22272 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22272] = 30
                                mem[_22272 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor7:
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _23244 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_23244 + idx + 68] = mem[_22272 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23244 + 68] = mem[_23244 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _23244 + -mem[64] + 100
                            require idx < stor5.length
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            if stor2[stor5[idx]] <= s:
                                require idx < stor5.length
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                _14583 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14583] = 30
                                mem[_14583 + 32] = 'SafeMath: subtraction overflow'
                                if stor1[stor5[idx]] > t:
                                    _14673 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_14673 + idx + 68] = mem[_14583 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14673 + 68] = mem[_14673 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _14673 + -mem[64] + 100
                                require idx < stor5.length
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                _15048 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15048] = 30
                                mem[_15048 + 32] = 'SafeMath: subtraction overflow'
                                if stor2[stor5[idx]] <= s:
                                    idx = idx + 1
                                    s = s - stor2[stor5[idx]]
                                    t = t - stor1[stor5[idx]]
                                    continue 
                                _15185 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_15185 + idx + 68] = mem[_15048 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15185 + 68] = mem[_15185 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _15185 + -mem[64] + 100
                            _14613 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14613] = 26
                            mem[_14613 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                _15807 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15807] = 30
                                mem[_15807 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = msg.sender
                                mem[32] = 1
                                _17404 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17404] = 30
                                mem[_17404 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _18254 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_18254 + idx + 68] = mem[_17404 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18254 + 68] = mem[_18254 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _18254 + -mem[64] + 100
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                _22277 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22277] = 30
                                mem[_22277 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor7:
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _23249 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_23249 + idx + 68] = mem[_22277 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23249 + 68] = mem[_23249 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _23249 + -mem[64] + 100
                            require arg2
                            if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _16068 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16068] = 30
                            mem[_16068 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg2 * stor7 / 100000 * 10^18:
                                _16437 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_16437 + idx + 68] = mem[_16068 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_16437 + 68] = mem[_16437 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _16437 + -mem[64] + 100
                            mem[0] = msg.sender
                            mem[32] = 1
                            _18253 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_18253] = 30
                            mem[_18253 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                _19302 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_19302 + idx + 68] = mem[_18253 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19302 + 68] = mem[_19302 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _19302 + -mem[64] + 100
                            stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                            if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                            _23248 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23248] = 30
                            mem[_23248 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor7:
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg2, msg.sender, arg1);
                                return 1
                            _24049 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_24049 + idx + 68] = mem[_23248 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_24049 + 68] = mem[_24049 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _24049 + -mem[64] + 100
                        _14313 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14313] = 26
                        mem[_14313 + 32] = 'SafeMath: division by zero'
                        if t < stor7 / 100000 * 10^18:
                            _14749 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14749] = 26
                            mem[_14749 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                            else:
                                require arg2
                                if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if 0 > arg2 * stor7 / 100000 * 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                        else:
                            _14748 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14748] = 26
                            mem[_14748 + 32] = 'SafeMath: division by zero'
                            if s <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require s
                            if not arg2:
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                            else:
                                require arg2
                                if arg2 * t / s / arg2 != t / s:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if 0 > arg2 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if arg2 * t / s > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor1[address(msg.sender)] += -1 * arg2 * t / s
                                if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] += arg2 * t / s
                        if 0 > stor7:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if totalFees < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        emit Transfer(arg2, msg.sender, arg1);
                    else:
                        require arg2 / 100
                        if 5 * arg2 / 100 / arg2 / 100 != 5:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if 5 * arg2 / 100 > arg2:
                            revert with 0, 'SafeMath: subtraction overflow'
                        idx = 0
                        s = 100000 * 10^18
                        t = stor7
                        while idx < stor5.length:
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            if stor1[stor5[idx]] > t:
                                _14520 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14520] = 26
                                mem[_14520 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not 5 * arg2 / 100:
                                        _15692 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_15692] = 30
                                        mem[_15692 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _16668 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16668] = 30
                                        mem[_16668 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _17390 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_17390 + idx + 68] = mem[_16668 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_17390 + 68] = mem[_17390 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _17390 + -mem[64] + 100
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _21045 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_21045] = 30
                                        mem[_21045 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor7:
                                            if totalFees + (5 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 5 * arg2 / 100
                                            emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _22258 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_22258 + idx + 68] = mem[_21045 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22258 + 68] = mem[_22258 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _22258 + -mem[64] + 100
                                    require 5 * arg2 / 100
                                    if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _15804 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15804] = 30
                                    mem[_15804 + 32] = 'SafeMath: subtraction overflow'
                                    if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > 0:
                                        _16058 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_16058 + idx + 68] = mem[_15804 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_16058 + 68] = mem[_16058 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _16058 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _17389 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17389] = 30
                                    mem[_17389 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _18228 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_18228 + idx + 68] = mem[_17389 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18228 + 68] = mem[_18228 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _18228 + -mem[64] + 100
                                    if stor1[address(arg1)] - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                    _22257 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22257] = 30
                                    mem[_22257 + 32] = 'SafeMath: subtraction overflow'
                                    if 5 * arg2 / 100 * stor7 / 100000 * 10^18 <= stor7:
                                        stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                        if totalFees + (5 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 5 * arg2 / 100
                                        emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _23230 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_23230 + idx + 68] = mem[_22257 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23230 + 68] = mem[_23230 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _23230 + -mem[64] + 100
                                require arg2
                                if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not 5 * arg2 / 100:
                                    _15803 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15803] = 30
                                    mem[_15803 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor7 / 100000 * 10^18:
                                        _16055 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_16055 + idx + 68] = mem[_15803 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_16055 + 68] = mem[_16055 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _16055 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _17388 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17388] = 30
                                    mem[_17388 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                        _18225 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_18225 + idx + 68] = mem[_17388 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18225 + 68] = mem[_18225 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _18225 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                                    _22256 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22256] = 30
                                    mem[_22256 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor7:
                                        if totalFees + (5 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 5 * arg2 / 100
                                        emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _23227 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_23227 + idx + 68] = mem[_22256 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23227 + 68] = mem[_23227 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _23227 + -mem[64] + 100
                                require 5 * arg2 / 100
                                if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _16054 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16054] = 30
                                mem[_16054 + 32] = 'SafeMath: subtraction overflow'
                                if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > arg2 * stor7 / 100000 * 10^18:
                                    _16420 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_16420 + idx + 68] = mem[_16054 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_16420 + 68] = mem[_16420 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _16420 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _18224 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18224] = 30
                                mem[_18224 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                    _19266 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_19266 + idx + 68] = mem[_18224 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19266 + 68] = mem[_19266 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _19266 + -mem[64] + 100
                                stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18)
                                _23226 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23226] = 30
                                mem[_23226 + 32] = 'SafeMath: subtraction overflow'
                                if 5 * arg2 / 100 * stor7 / 100000 * 10^18 <= stor7:
                                    stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                    if totalFees + (5 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 5 * arg2 / 100
                                    emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _24021 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_24021 + idx + 68] = mem[_23226 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24021 + 68] = mem[_24021 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _24021 + -mem[64] + 100
                            require idx < stor5.length
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            if stor2[stor5[idx]] <= s:
                                require idx < stor5.length
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                _14582 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14582] = 30
                                mem[_14582 + 32] = 'SafeMath: subtraction overflow'
                                if stor1[stor5[idx]] > t:
                                    _14670 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_14670 + idx + 68] = mem[_14582 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14670 + 68] = mem[_14670 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _14670 + -mem[64] + 100
                                require idx < stor5.length
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                _15046 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15046] = 30
                                mem[_15046 + 32] = 'SafeMath: subtraction overflow'
                                if stor2[stor5[idx]] <= s:
                                    idx = idx + 1
                                    s = s - stor2[stor5[idx]]
                                    t = t - stor1[stor5[idx]]
                                    continue 
                                _15180 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_15180 + idx + 68] = mem[_15046 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15180 + 68] = mem[_15180 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _15180 + -mem[64] + 100
                            _14612 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14612] = 26
                            mem[_14612 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                if not 5 * arg2 / 100:
                                    _15805 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15805] = 30
                                    mem[_15805 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _17397 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17397] = 30
                                    mem[_17397 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _18238 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_18238 + idx + 68] = mem[_17397 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18238 + 68] = mem[_18238 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _18238 + -mem[64] + 100
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _22265 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22265] = 30
                                    mem[_22265 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor7:
                                        if totalFees + (5 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 5 * arg2 / 100
                                        emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _23237 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_23237 + idx + 68] = mem[_22265 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23237 + 68] = mem[_23237 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _23237 + -mem[64] + 100
                                require 5 * arg2 / 100
                                if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _16062 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16062] = 30
                                mem[_16062 + 32] = 'SafeMath: subtraction overflow'
                                if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > 0:
                                    _16430 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_16430 + idx + 68] = mem[_16062 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_16430 + 68] = mem[_16430 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _16430 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _18237 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18237] = 30
                                mem[_18237 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _19282 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_19282 + idx + 68] = mem[_18237 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19282 + 68] = mem[_19282 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _19282 + -mem[64] + 100
                                if stor1[address(arg1)] - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                _23236 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23236] = 30
                                mem[_23236 + 32] = 'SafeMath: subtraction overflow'
                                if 5 * arg2 / 100 * stor7 / 100000 * 10^18 <= stor7:
                                    stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                    if totalFees + (5 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 5 * arg2 / 100
                                    emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _24033 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_24033 + idx + 68] = mem[_23236 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24033 + 68] = mem[_24033 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _24033 + -mem[64] + 100
                            require arg2
                            if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not 5 * arg2 / 100:
                                _16061 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16061] = 30
                                mem[_16061 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor7 / 100000 * 10^18:
                                    _16427 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_16427 + idx + 68] = mem[_16061 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_16427 + 68] = mem[_16427 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _16427 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _18236 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18236] = 30
                                mem[_18236 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                    _19279 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_19279 + idx + 68] = mem[_18236 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19279 + 68] = mem[_19279 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _19279 + -mem[64] + 100
                                stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                                _23235 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23235] = 30
                                mem[_23235 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor7:
                                    if totalFees + (5 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 5 * arg2 / 100
                                    emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _24030 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_24030 + idx + 68] = mem[_23235 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24030 + 68] = mem[_24030 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _24030 + -mem[64] + 100
                            require 5 * arg2 / 100
                            if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _16426 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16426] = 30
                            mem[_16426 + 32] = 'SafeMath: subtraction overflow'
                            if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > arg2 * stor7 / 100000 * 10^18:
                                _16992 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_16992 + idx + 68] = mem[_16426 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_16992 + 68] = mem[_16992 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _16992 + -mem[64] + 100
                            mem[0] = msg.sender
                            mem[32] = 1
                            _19278 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19278] = 30
                            mem[_19278 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                _20412 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_20412 + idx + 68] = mem[_19278 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20412 + 68] = mem[_20412 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _20412 + -mem[64] + 100
                            stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                            if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18)
                            _24029 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24029] = 30
                            mem[_24029 + 32] = 'SafeMath: subtraction overflow'
                            if 5 * arg2 / 100 * stor7 / 100000 * 10^18 <= stor7:
                                stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                if totalFees + (5 * arg2 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 5 * arg2 / 100
                                emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                return 1
                            _24892 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_24892 + idx + 68] = mem[_24029 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_24892 + 68] = mem[_24892 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _24892 + -mem[64] + 100
                        _14308 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14308] = 26
                        mem[_14308 + 32] = 'SafeMath: division by zero'
                        if t < stor7 / 100000 * 10^18:
                            _14747 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14747] = 26
                            mem[_14747 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                if not 5 * arg2 / 100:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if 0 > stor7:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                else:
                                    require 5 * arg2 / 100
                                    if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor1[address(arg1)] - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                    if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > stor7:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                            else:
                                require arg2
                                if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not 5 * arg2 / 100:
                                    if 0 > arg2 * stor7 / 100000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                                    if 0 > stor7:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                else:
                                    require 5 * arg2 / 100
                                    if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > arg2 * stor7 / 100000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18)
                                    if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > stor7:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                        else:
                            _14746 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14746] = 26
                            mem[_14746 + 32] = 'SafeMath: division by zero'
                            if s <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require s
                            if not arg2:
                                if not 5 * arg2 / 100:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if 0 > stor7:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                else:
                                    require 5 * arg2 / 100
                                    if 5 * arg2 / 100 * t / s / 5 * arg2 / 100 != t / s:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 5 * arg2 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor1[address(arg1)] - (5 * arg2 / 100 * t / s) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += -5 * arg2 / 100 * t / s
                                    if 5 * arg2 / 100 * t / s > stor7:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor7 += -5 * arg2 / 100 * t / s
                            else:
                                require arg2
                                if arg2 * t / s / arg2 != t / s:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not 5 * arg2 / 100:
                                    if 0 > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += arg2 * t / s
                                    if 0 > stor7:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                else:
                                    require 5 * arg2 / 100
                                    if 5 * arg2 / 100 * t / s / 5 * arg2 / 100 != t / s:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 5 * arg2 / 100 * t / s > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor1[address(arg1)] + (arg2 * t / s) - (5 * arg2 / 100 * t / s) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (5 * arg2 / 100 * t / s)
                                    if 5 * arg2 / 100 * t / s > stor7:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor7 += -5 * arg2 / 100 * t / s
                        if totalFees + (5 * arg2 / 100) < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        totalFees += 5 * arg2 / 100
                        emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                else:
                    mem[0] = arg1
                    mem[32] = 4
                    mem[96] = 26
                    mem[128] = 'SafeMath: division by zero'
                    if stor4[address(arg1)]:
                        if not arg2 / 100:
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if 0 > arg2:
                                revert with 0, 'SafeMath: subtraction overflow'
                            idx = 0
                            s = 100000 * 10^18
                            t = stor7
                            while idx < stor5.length:
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                if stor1[stor5[idx]] > t:
                                    _14529 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14529] = 26
                                    mem[_14529 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        _15695 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_15695] = 30
                                        mem[_15695 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _16679 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16679] = 30
                                        mem[_16679 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _17418 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_17418 + idx + 68] = mem[_16679 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_17418 + 68] = mem[_17418 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _17418 + -mem[64] + 100
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _21079 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_21079] = 30
                                        mem[_21079 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor7:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _22306 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_22306 + idx + 68] = mem[_21079 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22306 + 68] = mem[_22306 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _22306 + -mem[64] + 100
                                    require arg2
                                    if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _15811 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15811] = 30
                                    mem[_15811 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor7 / 100000 * 10^18:
                                        _16082 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_16082 + idx + 68] = mem[_15811 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_16082 + 68] = mem[_16082 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _16082 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _17417 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17417] = 30
                                    mem[_17417 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                        _18290 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_18290 + idx + 68] = mem[_17417 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18290 + 68] = mem[_18290 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _18290 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                                    _22305 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22305] = 30
                                    mem[_22305 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor7:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _23280 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_23280 + idx + 68] = mem[_22305 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23280 + 68] = mem[_23280 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _23280 + -mem[64] + 100
                                require idx < stor5.length
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                if stor2[stor5[idx]] <= s:
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    _14585 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14585] = 30
                                    mem[_14585 + 32] = 'SafeMath: subtraction overflow'
                                    if stor1[stor5[idx]] > t:
                                        _14679 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_14679 + idx + 68] = mem[_14585 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14679 + 68] = mem[_14679 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _14679 + -mem[64] + 100
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    _15052 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15052] = 30
                                    mem[_15052 + 32] = 'SafeMath: subtraction overflow'
                                    if stor2[stor5[idx]] <= s:
                                        idx = idx + 1
                                        s = s - stor2[stor5[idx]]
                                        t = t - stor1[stor5[idx]]
                                        continue 
                                    _15195 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_15195 + idx + 68] = mem[_15052 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15195 + 68] = mem[_15195 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _15195 + -mem[64] + 100
                                _14615 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14615] = 26
                                mem[_14615 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    _15812 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15812] = 30
                                    mem[_15812 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _17423 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17423] = 30
                                    mem[_17423 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _18297 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_18297 + idx + 68] = mem[_17423 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18297 + 68] = mem[_18297 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _18297 + -mem[64] + 100
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _22310 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22310] = 30
                                    mem[_22310 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor7:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _23285 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_23285 + idx + 68] = mem[_22310 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23285 + 68] = mem[_23285 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _23285 + -mem[64] + 100
                                require arg2
                                if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _16085 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16085] = 30
                                mem[_16085 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor7 / 100000 * 10^18:
                                    _16461 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_16461 + idx + 68] = mem[_16085 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_16461 + 68] = mem[_16461 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _16461 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _18296 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18296] = 30
                                mem[_18296 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                    _19358 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_19358 + idx + 68] = mem[_18296 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19358 + 68] = mem[_19358 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _19358 + -mem[64] + 100
                                stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                                _23284 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23284] = 30
                                mem[_23284 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor7:
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _24093 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_24093 + idx + 68] = mem[_23284 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24093 + 68] = mem[_24093 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _24093 + -mem[64] + 100
                            _14323 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14323] = 26
                            mem[_14323 + 32] = 'SafeMath: division by zero'
                            if t < stor7 / 100000 * 10^18:
                                _14753 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14753] = 26
                                mem[_14753 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                else:
                                    require arg2
                                    if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 0 > arg2 * stor7 / 100000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                            else:
                                _14752 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14752] = 26
                                mem[_14752 + 32] = 'SafeMath: division by zero'
                                if s <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require s
                                if not arg2:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                else:
                                    require arg2
                                    if arg2 * t / s / arg2 != t / s:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 0 > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += arg2 * t / s
                            if 0 > stor7:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(arg2, msg.sender, arg1);
                        else:
                            require arg2 / 100
                            if 5 * arg2 / 100 / arg2 / 100 != 5:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if 5 * arg2 / 100 > arg2:
                                revert with 0, 'SafeMath: subtraction overflow'
                            idx = 0
                            s = 100000 * 10^18
                            t = stor7
                            while idx < stor5.length:
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                if stor1[stor5[idx]] > t:
                                    _14526 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14526] = 26
                                    mem[_14526 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if not 5 * arg2 / 100:
                                            _15694 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_15694] = 30
                                            mem[_15694 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _16676 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_16676] = 30
                                            mem[_16676 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _17409 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_17409 + idx + 68] = mem[_16676 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_17409 + 68] = mem[_17409 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _17409 + -mem[64] + 100
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _21068 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_21068] = 30
                                            mem[_21068 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor7:
                                                if totalFees + (5 * arg2 / 100) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += 5 * arg2 / 100
                                                emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                                return 1
                                            _22291 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_22291 + idx + 68] = mem[_21068 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_22291 + 68] = mem[_22291 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _22291 + -mem[64] + 100
                                        require 5 * arg2 / 100
                                        if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _15809 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_15809] = 30
                                        mem[_15809 + 32] = 'SafeMath: subtraction overflow'
                                        if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > 0:
                                            _16075 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_16075 + idx + 68] = mem[_15809 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_16075 + 68] = mem[_16075 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _16075 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _17408 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17408] = 30
                                        mem[_17408 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _18271 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_18271 + idx + 68] = mem[_17408 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_18271 + 68] = mem[_18271 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _18271 + -mem[64] + 100
                                        if stor1[address(arg1)] - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                        _22290 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22290] = 30
                                        mem[_22290 + 32] = 'SafeMath: subtraction overflow'
                                        if 5 * arg2 / 100 * stor7 / 100000 * 10^18 <= stor7:
                                            stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                            if totalFees + (5 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 5 * arg2 / 100
                                            emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _23266 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_23266 + idx + 68] = mem[_22290 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23266 + 68] = mem[_23266 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _23266 + -mem[64] + 100
                                    require arg2
                                    if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not 5 * arg2 / 100:
                                        _15808 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_15808] = 30
                                        mem[_15808 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor7 / 100000 * 10^18:
                                            _16072 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_16072 + idx + 68] = mem[_15808 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_16072 + 68] = mem[_16072 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _16072 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _17407 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17407] = 30
                                        mem[_17407 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                            _18268 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_18268 + idx + 68] = mem[_17407 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_18268 + 68] = mem[_18268 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _18268 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                                        _22289 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22289] = 30
                                        mem[_22289 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor7:
                                            if totalFees + (5 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 5 * arg2 / 100
                                            emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _23263 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_23263 + idx + 68] = mem[_22289 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23263 + 68] = mem[_23263 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _23263 + -mem[64] + 100
                                    require 5 * arg2 / 100
                                    if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _16071 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16071] = 30
                                    mem[_16071 + 32] = 'SafeMath: subtraction overflow'
                                    if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > arg2 * stor7 / 100000 * 10^18:
                                        _16444 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_16444 + idx + 68] = mem[_16071 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_16444 + 68] = mem[_16444 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _16444 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _18267 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18267] = 30
                                    mem[_18267 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                        _19322 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_19322 + idx + 68] = mem[_18267 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19322 + 68] = mem[_19322 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _19322 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18)
                                    _23262 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23262] = 30
                                    mem[_23262 + 32] = 'SafeMath: subtraction overflow'
                                    if 5 * arg2 / 100 * stor7 / 100000 * 10^18 <= stor7:
                                        stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                        if totalFees + (5 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 5 * arg2 / 100
                                        emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _24065 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_24065 + idx + 68] = mem[_23262 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24065 + 68] = mem[_24065 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _24065 + -mem[64] + 100
                                require idx < stor5.length
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                if stor2[stor5[idx]] <= s:
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    _14584 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14584] = 30
                                    mem[_14584 + 32] = 'SafeMath: subtraction overflow'
                                    if stor1[stor5[idx]] > t:
                                        _14676 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_14676 + idx + 68] = mem[_14584 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14676 + 68] = mem[_14676 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _14676 + -mem[64] + 100
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    _15050 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15050] = 30
                                    mem[_15050 + 32] = 'SafeMath: subtraction overflow'
                                    if stor2[stor5[idx]] <= s:
                                        idx = idx + 1
                                        s = s - stor2[stor5[idx]]
                                        t = t - stor1[stor5[idx]]
                                        continue 
                                    _15190 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_15190 + idx + 68] = mem[_15050 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15190 + 68] = mem[_15190 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _15190 + -mem[64] + 100
                                _14614 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14614] = 26
                                mem[_14614 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not 5 * arg2 / 100:
                                        _15810 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_15810] = 30
                                        mem[_15810 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _17416 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17416] = 30
                                        mem[_17416 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _18281 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_18281 + idx + 68] = mem[_17416 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_18281 + 68] = mem[_18281 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _18281 + -mem[64] + 100
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _22298 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22298] = 30
                                        mem[_22298 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor7:
                                            if totalFees + (5 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 5 * arg2 / 100
                                            emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _23273 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_23273 + idx + 68] = mem[_22298 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23273 + 68] = mem[_23273 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _23273 + -mem[64] + 100
                                    require 5 * arg2 / 100
                                    if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _16079 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16079] = 30
                                    mem[_16079 + 32] = 'SafeMath: subtraction overflow'
                                    if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > 0:
                                        _16454 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_16454 + idx + 68] = mem[_16079 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_16454 + 68] = mem[_16454 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _16454 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _18280 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18280] = 30
                                    mem[_18280 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _19338 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_19338 + idx + 68] = mem[_18280 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19338 + 68] = mem[_19338 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _19338 + -mem[64] + 100
                                    if stor1[address(arg1)] - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                    _23272 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23272] = 30
                                    mem[_23272 + 32] = 'SafeMath: subtraction overflow'
                                    if 5 * arg2 / 100 * stor7 / 100000 * 10^18 <= stor7:
                                        stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                        if totalFees + (5 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 5 * arg2 / 100
                                        emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _24077 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_24077 + idx + 68] = mem[_23272 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24077 + 68] = mem[_24077 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _24077 + -mem[64] + 100
                                require arg2
                                if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not 5 * arg2 / 100:
                                    _16078 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16078] = 30
                                    mem[_16078 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor7 / 100000 * 10^18:
                                        _16451 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_16451 + idx + 68] = mem[_16078 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_16451 + 68] = mem[_16451 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _16451 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _18279 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18279] = 30
                                    mem[_18279 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                        _19335 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_19335 + idx + 68] = mem[_18279 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19335 + 68] = mem[_19335 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _19335 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                                    _23271 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23271] = 30
                                    mem[_23271 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor7:
                                        if totalFees + (5 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 5 * arg2 / 100
                                        emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _24074 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_24074 + idx + 68] = mem[_23271 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24074 + 68] = mem[_24074 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _24074 + -mem[64] + 100
                                require 5 * arg2 / 100
                                if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _16450 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16450] = 30
                                mem[_16450 + 32] = 'SafeMath: subtraction overflow'
                                if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > arg2 * stor7 / 100000 * 10^18:
                                    _17027 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_17027 + idx + 68] = mem[_16450 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_17027 + 68] = mem[_17027 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _17027 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _19334 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19334] = 30
                                mem[_19334 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                    _20474 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_20474 + idx + 68] = mem[_19334 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20474 + 68] = mem[_20474 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _20474 + -mem[64] + 100
                                stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18)
                                _24073 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24073] = 30
                                mem[_24073 + 32] = 'SafeMath: subtraction overflow'
                                if 5 * arg2 / 100 * stor7 / 100000 * 10^18 <= stor7:
                                    stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                    if totalFees + (5 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 5 * arg2 / 100
                                    emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _24942 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_24942 + idx + 68] = mem[_24073 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24942 + 68] = mem[_24942 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _24942 + -mem[64] + 100
                            _14318 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14318] = 26
                            mem[_14318 + 32] = 'SafeMath: division by zero'
                            if t < stor7 / 100000 * 10^18:
                                _14751 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14751] = 26
                                mem[_14751 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not 5 * arg2 / 100:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 > stor7:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require 5 * arg2 / 100
                                        if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                        if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > stor7:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                else:
                                    require arg2
                                    if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not 5 * arg2 / 100:
                                        if 0 > arg2 * stor7 / 100000 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                                        if 0 > stor7:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require 5 * arg2 / 100
                                        if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > arg2 * stor7 / 100000 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18)
                                        if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > stor7:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                            else:
                                _14750 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14750] = 26
                                mem[_14750 + 32] = 'SafeMath: division by zero'
                                if s <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require s
                                if not arg2:
                                    if not 5 * arg2 / 100:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 > stor7:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require 5 * arg2 / 100
                                        if 5 * arg2 / 100 * t / s / 5 * arg2 / 100 != t / s:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 5 * arg2 / 100 * t / s > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] - (5 * arg2 / 100 * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += -5 * arg2 / 100 * t / s
                                        if 5 * arg2 / 100 * t / s > stor7:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor7 += -5 * arg2 / 100 * t / s
                                else:
                                    require arg2
                                    if arg2 * t / s / arg2 != t / s:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not 5 * arg2 / 100:
                                        if 0 > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += arg2 * t / s
                                        if 0 > stor7:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require 5 * arg2 / 100
                                        if 5 * arg2 / 100 * t / s / 5 * arg2 / 100 != t / s:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 5 * arg2 / 100 * t / s > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor1[address(arg1)] + (arg2 * t / s) - (5 * arg2 / 100 * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (5 * arg2 / 100 * t / s)
                                        if 5 * arg2 / 100 * t / s > stor7:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor7 += -5 * arg2 / 100 * t / s
                            if totalFees + (5 * arg2 / 100) < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += 5 * arg2 / 100
                            emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                    else:
                        if not arg2 / 100:
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if 0 > arg2:
                                revert with 0, 'SafeMath: subtraction overflow'
                            idx = 0
                            s = 100000 * 10^18
                            t = stor7
                            while idx < stor5.length:
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                if stor1[stor5[idx]] > t:
                                    _14535 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14535] = 26
                                    mem[_14535 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        _15697 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_15697] = 30
                                        mem[_15697 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _16687 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16687] = 30
                                        mem[_16687 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _17437 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_17437 + idx + 68] = mem[_16687 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_17437 + 68] = mem[_17437 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _17437 + -mem[64] + 100
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _21102 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_21102] = 30
                                        mem[_21102 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor7:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _22339 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_22339 + idx + 68] = mem[_21102 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22339 + 68] = mem[_22339 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _22339 + -mem[64] + 100
                                    require arg2
                                    if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _15816 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15816] = 30
                                    mem[_15816 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor7 / 100000 * 10^18:
                                        _16099 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_16099 + idx + 68] = mem[_15816 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_16099 + 68] = mem[_16099 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _16099 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _17436 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17436] = 30
                                    mem[_17436 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                        _18333 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_18333 + idx + 68] = mem[_17436 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18333 + 68] = mem[_18333 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _18333 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                                    _22338 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22338] = 30
                                    mem[_22338 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor7:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _23316 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_23316 + idx + 68] = mem[_22338 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23316 + 68] = mem[_23316 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _23316 + -mem[64] + 100
                                require idx < stor5.length
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                if stor2[stor5[idx]] <= s:
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    _14587 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14587] = 30
                                    mem[_14587 + 32] = 'SafeMath: subtraction overflow'
                                    if stor1[stor5[idx]] > t:
                                        _14685 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_14685 + idx + 68] = mem[_14587 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14685 + 68] = mem[_14685 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _14685 + -mem[64] + 100
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    _15056 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15056] = 30
                                    mem[_15056 + 32] = 'SafeMath: subtraction overflow'
                                    if stor2[stor5[idx]] <= s:
                                        idx = idx + 1
                                        s = s - stor2[stor5[idx]]
                                        t = t - stor1[stor5[idx]]
                                        continue 
                                    _15205 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_15205 + idx + 68] = mem[_15056 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15205 + 68] = mem[_15205 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _15205 + -mem[64] + 100
                                _14617 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14617] = 26
                                mem[_14617 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    _15817 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15817] = 30
                                    mem[_15817 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _17442 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17442] = 30
                                    mem[_17442 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _18340 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_18340 + idx + 68] = mem[_17442 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18340 + 68] = mem[_18340 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _18340 + -mem[64] + 100
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _22343 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22343] = 30
                                    mem[_22343 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor7:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _23321 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_23321 + idx + 68] = mem[_22343 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23321 + 68] = mem[_23321 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _23321 + -mem[64] + 100
                                require arg2
                                if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _16102 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16102] = 30
                                mem[_16102 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor7 / 100000 * 10^18:
                                    _16485 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_16485 + idx + 68] = mem[_16102 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_16485 + 68] = mem[_16485 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _16485 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _18339 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18339] = 30
                                mem[_18339 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                    _19414 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_19414 + idx + 68] = mem[_18339 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19414 + 68] = mem[_19414 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _19414 + -mem[64] + 100
                                stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                                _23320 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23320] = 30
                                mem[_23320 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor7:
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _24137 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_24137 + idx + 68] = mem[_23320 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24137 + 68] = mem[_24137 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _24137 + -mem[64] + 100
                            _14333 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14333] = 26
                            mem[_14333 + 32] = 'SafeMath: division by zero'
                            if t < stor7 / 100000 * 10^18:
                                _14757 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14757] = 26
                                mem[_14757 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                else:
                                    require arg2
                                    if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 0 > arg2 * stor7 / 100000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                            else:
                                _14756 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14756] = 26
                                mem[_14756 + 32] = 'SafeMath: division by zero'
                                if s <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require s
                                if not arg2:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                else:
                                    require arg2
                                    if arg2 * t / s / arg2 != t / s:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 0 > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += arg2 * t / s
                            if 0 > stor7:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(arg2, msg.sender, arg1);
                        else:
                            require arg2 / 100
                            if 5 * arg2 / 100 / arg2 / 100 != 5:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if 5 * arg2 / 100 > arg2:
                                revert with 0, 'SafeMath: subtraction overflow'
                            idx = 0
                            s = 100000 * 10^18
                            t = stor7
                            while idx < stor5.length:
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                if stor1[stor5[idx]] > t:
                                    _14532 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14532] = 26
                                    mem[_14532 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if not 5 * arg2 / 100:
                                            _15696 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_15696] = 30
                                            mem[_15696 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _16684 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_16684] = 30
                                            mem[_16684 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _17428 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_17428 + idx + 68] = mem[_16684 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_17428 + 68] = mem[_17428 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _17428 + -mem[64] + 100
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _21091 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_21091] = 30
                                            mem[_21091 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor7:
                                                if totalFees + (5 * arg2 / 100) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += 5 * arg2 / 100
                                                emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                                return 1
                                            _22324 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_22324 + idx + 68] = mem[_21091 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_22324 + 68] = mem[_22324 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _22324 + -mem[64] + 100
                                        require 5 * arg2 / 100
                                        if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _15814 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_15814] = 30
                                        mem[_15814 + 32] = 'SafeMath: subtraction overflow'
                                        if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > 0:
                                            _16092 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_16092 + idx + 68] = mem[_15814 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_16092 + 68] = mem[_16092 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _16092 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _17427 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17427] = 30
                                        mem[_17427 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _18314 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_18314 + idx + 68] = mem[_17427 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_18314 + 68] = mem[_18314 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _18314 + -mem[64] + 100
                                        if stor1[address(arg1)] - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                        _22323 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22323] = 30
                                        mem[_22323 + 32] = 'SafeMath: subtraction overflow'
                                        if 5 * arg2 / 100 * stor7 / 100000 * 10^18 <= stor7:
                                            stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                            if totalFees + (5 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 5 * arg2 / 100
                                            emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _23302 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_23302 + idx + 68] = mem[_22323 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23302 + 68] = mem[_23302 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _23302 + -mem[64] + 100
                                    require arg2
                                    if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not 5 * arg2 / 100:
                                        _15813 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_15813] = 30
                                        mem[_15813 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor7 / 100000 * 10^18:
                                            _16089 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_16089 + idx + 68] = mem[_15813 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_16089 + 68] = mem[_16089 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _16089 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _17426 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17426] = 30
                                        mem[_17426 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                            _18311 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_18311 + idx + 68] = mem[_17426 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_18311 + 68] = mem[_18311 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _18311 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                                        _22322 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22322] = 30
                                        mem[_22322 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor7:
                                            if totalFees + (5 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 5 * arg2 / 100
                                            emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _23299 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_23299 + idx + 68] = mem[_22322 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23299 + 68] = mem[_23299 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _23299 + -mem[64] + 100
                                    require 5 * arg2 / 100
                                    if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _16088 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16088] = 30
                                    mem[_16088 + 32] = 'SafeMath: subtraction overflow'
                                    if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > arg2 * stor7 / 100000 * 10^18:
                                        _16468 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_16468 + idx + 68] = mem[_16088 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_16468 + 68] = mem[_16468 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _16468 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _18310 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18310] = 30
                                    mem[_18310 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                        _19378 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_19378 + idx + 68] = mem[_18310 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19378 + 68] = mem[_19378 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _19378 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18)
                                    _23298 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23298] = 30
                                    mem[_23298 + 32] = 'SafeMath: subtraction overflow'
                                    if 5 * arg2 / 100 * stor7 / 100000 * 10^18 <= stor7:
                                        stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                        if totalFees + (5 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 5 * arg2 / 100
                                        emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _24109 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_24109 + idx + 68] = mem[_23298 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24109 + 68] = mem[_24109 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _24109 + -mem[64] + 100
                                require idx < stor5.length
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                if stor2[stor5[idx]] <= s:
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    _14586 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14586] = 30
                                    mem[_14586 + 32] = 'SafeMath: subtraction overflow'
                                    if stor1[stor5[idx]] > t:
                                        _14682 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_14682 + idx + 68] = mem[_14586 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14682 + 68] = mem[_14682 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _14682 + -mem[64] + 100
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    _15054 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15054] = 30
                                    mem[_15054 + 32] = 'SafeMath: subtraction overflow'
                                    if stor2[stor5[idx]] <= s:
                                        idx = idx + 1
                                        s = s - stor2[stor5[idx]]
                                        t = t - stor1[stor5[idx]]
                                        continue 
                                    _15200 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_15200 + idx + 68] = mem[_15054 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15200 + 68] = mem[_15200 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _15200 + -mem[64] + 100
                                _14616 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14616] = 26
                                mem[_14616 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not 5 * arg2 / 100:
                                        _15815 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_15815] = 30
                                        mem[_15815 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _17435 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17435] = 30
                                        mem[_17435 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _18324 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_18324 + idx + 68] = mem[_17435 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_18324 + 68] = mem[_18324 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _18324 + -mem[64] + 100
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _22331 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22331] = 30
                                        mem[_22331 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor7:
                                            if totalFees + (5 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 5 * arg2 / 100
                                            emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _23309 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_23309 + idx + 68] = mem[_22331 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23309 + 68] = mem[_23309 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _23309 + -mem[64] + 100
                                    require 5 * arg2 / 100
                                    if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _16096 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16096] = 30
                                    mem[_16096 + 32] = 'SafeMath: subtraction overflow'
                                    if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > 0:
                                        _16478 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_16478 + idx + 68] = mem[_16096 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_16478 + 68] = mem[_16478 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _16478 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _18323 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18323] = 30
                                    mem[_18323 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _19394 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_19394 + idx + 68] = mem[_18323 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19394 + 68] = mem[_19394 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _19394 + -mem[64] + 100
                                    if stor1[address(arg1)] - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                    _23308 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23308] = 30
                                    mem[_23308 + 32] = 'SafeMath: subtraction overflow'
                                    if 5 * arg2 / 100 * stor7 / 100000 * 10^18 <= stor7:
                                        stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                        if totalFees + (5 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 5 * arg2 / 100
                                        emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _24121 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_24121 + idx + 68] = mem[_23308 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24121 + 68] = mem[_24121 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _24121 + -mem[64] + 100
                                require arg2
                                if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not 5 * arg2 / 100:
                                    _16095 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16095] = 30
                                    mem[_16095 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor7 / 100000 * 10^18:
                                        _16475 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_16475 + idx + 68] = mem[_16095 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_16475 + 68] = mem[_16475 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _16475 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _18322 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18322] = 30
                                    mem[_18322 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                        _19391 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_19391 + idx + 68] = mem[_18322 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19391 + 68] = mem[_19391 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _19391 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                                    _23307 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23307] = 30
                                    mem[_23307 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor7:
                                        if totalFees + (5 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 5 * arg2 / 100
                                        emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _24118 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_24118 + idx + 68] = mem[_23307 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24118 + 68] = mem[_24118 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _24118 + -mem[64] + 100
                                require 5 * arg2 / 100
                                if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _16474 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16474] = 30
                                mem[_16474 + 32] = 'SafeMath: subtraction overflow'
                                if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > arg2 * stor7 / 100000 * 10^18:
                                    _17062 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_17062 + idx + 68] = mem[_16474 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_17062 + 68] = mem[_17062 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _17062 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _19390 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19390] = 30
                                mem[_19390 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                    _20536 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_20536 + idx + 68] = mem[_19390 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20536 + 68] = mem[_20536 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _20536 + -mem[64] + 100
                                stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18)
                                _24117 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24117] = 30
                                mem[_24117 + 32] = 'SafeMath: subtraction overflow'
                                if 5 * arg2 / 100 * stor7 / 100000 * 10^18 <= stor7:
                                    stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                    if totalFees + (5 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 5 * arg2 / 100
                                    emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _24992 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_24992 + idx + 68] = mem[_24117 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24992 + 68] = mem[_24992 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _24992 + -mem[64] + 100
                            _14328 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14328] = 26
                            mem[_14328 + 32] = 'SafeMath: division by zero'
                            if t < stor7 / 100000 * 10^18:
                                _14755 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14755] = 26
                                mem[_14755 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not 5 * arg2 / 100:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 > stor7:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require 5 * arg2 / 100
                                        if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                        if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > stor7:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                else:
                                    require arg2
                                    if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not 5 * arg2 / 100:
                                        if 0 > arg2 * stor7 / 100000 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                                        if 0 > stor7:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require 5 * arg2 / 100
                                        if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > arg2 * stor7 / 100000 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18)
                                        if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > stor7:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                            else:
                                _14754 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14754] = 26
                                mem[_14754 + 32] = 'SafeMath: division by zero'
                                if s <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require s
                                if not arg2:
                                    if not 5 * arg2 / 100:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 > stor7:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require 5 * arg2 / 100
                                        if 5 * arg2 / 100 * t / s / 5 * arg2 / 100 != t / s:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 5 * arg2 / 100 * t / s > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] - (5 * arg2 / 100 * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += -5 * arg2 / 100 * t / s
                                        if 5 * arg2 / 100 * t / s > stor7:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor7 += -5 * arg2 / 100 * t / s
                                else:
                                    require arg2
                                    if arg2 * t / s / arg2 != t / s:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not 5 * arg2 / 100:
                                        if 0 > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += arg2 * t / s
                                        if 0 > stor7:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require 5 * arg2 / 100
                                        if 5 * arg2 / 100 * t / s / 5 * arg2 / 100 != t / s:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 5 * arg2 / 100 * t / s > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor1[address(arg1)] + (arg2 * t / s) - (5 * arg2 / 100 * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (5 * arg2 / 100 * t / s)
                                        if 5 * arg2 / 100 * t / s > stor7:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor7 += -5 * arg2 / 100 * t / s
                            if totalFees + (5 * arg2 / 100) < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += 5 * arg2 / 100
                            emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
            else:
                mem[0] = arg1
                mem[32] = 4
                if stor4[address(arg1)]:
                    mem[96] = 26
                    mem[128] = 'SafeMath: division by zero'
                    if not arg2 / 100:
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if 0 > arg2:
                            revert with 0, 'SafeMath: subtraction overflow'
                        idx = 0
                        s = 100000 * 10^18
                        t = stor7
                        while idx < stor5.length:
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            if stor1[stor5[idx]] > t:
                                _14559 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14559] = 26
                                mem[_14559 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    _15705 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15705] = 30
                                    mem[_15705 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _16719 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16719] = 30
                                    mem[_16719 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _17513 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_17513 + idx + 68] = mem[_16719 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17513 + 68] = mem[_17513 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _17513 + -mem[64] + 100
                                    if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] += arg2
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _22939 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22939] = 30
                                    mem[_22939 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor7:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _23697 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_23697 + idx + 68] = mem[_22939 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23697 + 68] = mem[_23697 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _23697 + -mem[64] + 100
                                require arg2
                                if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _15836 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15836] = 30
                                mem[_15836 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor7 / 100000 * 10^18:
                                    _16167 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_16167 + idx + 68] = mem[_15836 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_16167 + 68] = mem[_16167 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _16167 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _17512 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17512] = 30
                                mem[_17512 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                    _18505 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_18505 + idx + 68] = mem[_17512 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18505 + 68] = mem[_18505 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _18505 + -mem[64] + 100
                                stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] += arg2
                                if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                                _23696 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23696] = 30
                                mem[_23696 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor7:
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _24518 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_24518 + idx + 68] = mem[_23696 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24518 + 68] = mem[_24518 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _24518 + -mem[64] + 100
                            require idx < stor5.length
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            if stor2[stor5[idx]] <= s:
                                require idx < stor5.length
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                _14595 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14595] = 30
                                mem[_14595 + 32] = 'SafeMath: subtraction overflow'
                                if stor1[stor5[idx]] > t:
                                    _14709 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_14709 + idx + 68] = mem[_14595 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14709 + 68] = mem[_14709 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _14709 + -mem[64] + 100
                                require idx < stor5.length
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                _15072 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15072] = 30
                                mem[_15072 + 32] = 'SafeMath: subtraction overflow'
                                if stor2[stor5[idx]] <= s:
                                    idx = idx + 1
                                    s = s - stor2[stor5[idx]]
                                    t = t - stor1[stor5[idx]]
                                    continue 
                                _15245 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_15245 + idx + 68] = mem[_15072 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15245 + 68] = mem[_15245 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _15245 + -mem[64] + 100
                            _14625 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14625] = 26
                            mem[_14625 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                _15837 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15837] = 30
                                mem[_15837 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = msg.sender
                                mem[32] = 1
                                _17518 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17518] = 30
                                mem[_17518 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _18512 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_18512 + idx + 68] = mem[_17518 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18512 + 68] = mem[_18512 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _18512 + -mem[64] + 100
                                if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] += arg2
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                _23701 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23701] = 30
                                mem[_23701 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor7:
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _24523 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_24523 + idx + 68] = mem[_23701 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24523 + 68] = mem[_24523 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _24523 + -mem[64] + 100
                            require arg2
                            if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _16170 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16170] = 30
                            mem[_16170 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg2 * stor7 / 100000 * 10^18:
                                _16581 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_16581 + idx + 68] = mem[_16170 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_16581 + 68] = mem[_16581 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _16581 + -mem[64] + 100
                            mem[0] = msg.sender
                            mem[32] = 1
                            _18511 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_18511] = 30
                            mem[_18511 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                _19638 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_19638 + idx + 68] = mem[_18511 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19638 + 68] = mem[_19638 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _19638 + -mem[64] + 100
                            stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                            if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(arg1)] += arg2
                            if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                            _24522 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24522] = 30
                            mem[_24522 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor7:
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg2, msg.sender, arg1);
                                return 1
                            _25478 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_25478 + idx + 68] = mem[_24522 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_25478 + 68] = mem[_25478 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _25478 + -mem[64] + 100
                        _14373 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14373] = 26
                        mem[_14373 + 32] = 'SafeMath: division by zero'
                        if t < stor7 / 100000 * 10^18:
                            _14773 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14773] = 26
                            mem[_14773 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] += arg2
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                            else:
                                require arg2
                                if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if 0 > arg2 * stor7 / 100000 * 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] += arg2
                                if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                        else:
                            _14772 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14772] = 26
                            mem[_14772 + 32] = 'SafeMath: division by zero'
                            if s <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require s
                            if not arg2:
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] += arg2
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                            else:
                                require arg2
                                if arg2 * t / s / arg2 != t / s:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if 0 > arg2 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if arg2 * t / s > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                stor1[address(msg.sender)] += -1 * arg2 * t / s
                                if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] += arg2
                                if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] += arg2 * t / s
                        if 0 > stor7:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if totalFees < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        emit Transfer(arg2, msg.sender, arg1);
                    else:
                        require arg2 / 100
                        if 5 * arg2 / 100 / arg2 / 100 != 5:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if 5 * arg2 / 100 > arg2:
                            revert with 0, 'SafeMath: subtraction overflow'
                        idx = 0
                        s = 100000 * 10^18
                        t = stor7
                        while idx < stor5.length:
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            if stor1[stor5[idx]] > t:
                                _14556 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14556] = 26
                                mem[_14556 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not 5 * arg2 / 100:
                                        _15704 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_15704] = 30
                                        mem[_15704 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _16716 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16716] = 30
                                        mem[_16716 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _17504 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_17504 + idx + 68] = mem[_16716 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_17504 + 68] = mem[_17504 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _17504 + -mem[64] + 100
                                        if stor2[address(arg1)] + arg2 - (5 * arg2 / 100) < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (5 * arg2 / 100)
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _22927 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22927] = 30
                                        mem[_22927 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor7:
                                            if totalFees + (5 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 5 * arg2 / 100
                                            emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _23688 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_23688 + idx + 68] = mem[_22927 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23688 + 68] = mem[_23688 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _23688 + -mem[64] + 100
                                    require 5 * arg2 / 100
                                    if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _15834 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15834] = 30
                                    mem[_15834 + 32] = 'SafeMath: subtraction overflow'
                                    if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > 0:
                                        _16160 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_16160 + idx + 68] = mem[_15834 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_16160 + 68] = mem[_16160 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _16160 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _17503 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17503] = 30
                                    mem[_17503 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _18486 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_18486 + idx + 68] = mem[_17503 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18486 + 68] = mem[_18486 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _18486 + -mem[64] + 100
                                    if stor2[address(arg1)] + arg2 - (5 * arg2 / 100) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (5 * arg2 / 100)
                                    if stor1[address(arg1)] - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                    _23687 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23687] = 30
                                    mem[_23687 + 32] = 'SafeMath: subtraction overflow'
                                    if 5 * arg2 / 100 * stor7 / 100000 * 10^18 <= stor7:
                                        stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                        if totalFees + (5 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 5 * arg2 / 100
                                        emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _24504 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_24504 + idx + 68] = mem[_23687 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24504 + 68] = mem[_24504 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _24504 + -mem[64] + 100
                                require arg2
                                if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not 5 * arg2 / 100:
                                    _15833 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15833] = 30
                                    mem[_15833 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor7 / 100000 * 10^18:
                                        _16157 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_16157 + idx + 68] = mem[_15833 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_16157 + 68] = mem[_16157 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _16157 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _17502 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17502] = 30
                                    mem[_17502 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                        _18483 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_18483 + idx + 68] = mem[_17502 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18483 + 68] = mem[_18483 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _18483 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                    if stor2[address(arg1)] + arg2 - (5 * arg2 / 100) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (5 * arg2 / 100)
                                    if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                                    _23686 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23686] = 30
                                    mem[_23686 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor7:
                                        if totalFees + (5 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 5 * arg2 / 100
                                        emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _24501 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_24501 + idx + 68] = mem[_23686 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24501 + 68] = mem[_24501 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _24501 + -mem[64] + 100
                                require 5 * arg2 / 100
                                if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _16156 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16156] = 30
                                mem[_16156 + 32] = 'SafeMath: subtraction overflow'
                                if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > arg2 * stor7 / 100000 * 10^18:
                                    _16564 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_16564 + idx + 68] = mem[_16156 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_16564 + 68] = mem[_16564 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _16564 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _18482 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18482] = 30
                                mem[_18482 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                    _19602 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_19602 + idx + 68] = mem[_18482 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19602 + 68] = mem[_19602 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _19602 + -mem[64] + 100
                                stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                if stor2[address(arg1)] + arg2 - (5 * arg2 / 100) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (5 * arg2 / 100)
                                if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18)
                                _24500 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24500] = 30
                                mem[_24500 + 32] = 'SafeMath: subtraction overflow'
                                if 5 * arg2 / 100 * stor7 / 100000 * 10^18 <= stor7:
                                    stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                    if totalFees + (5 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 5 * arg2 / 100
                                    emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _25450 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_25450 + idx + 68] = mem[_24500 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25450 + 68] = mem[_25450 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _25450 + -mem[64] + 100
                            require idx < stor5.length
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            if stor2[stor5[idx]] <= s:
                                require idx < stor5.length
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                _14594 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14594] = 30
                                mem[_14594 + 32] = 'SafeMath: subtraction overflow'
                                if stor1[stor5[idx]] > t:
                                    _14706 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_14706 + idx + 68] = mem[_14594 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14706 + 68] = mem[_14706 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _14706 + -mem[64] + 100
                                require idx < stor5.length
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                _15070 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15070] = 30
                                mem[_15070 + 32] = 'SafeMath: subtraction overflow'
                                if stor2[stor5[idx]] <= s:
                                    idx = idx + 1
                                    s = s - stor2[stor5[idx]]
                                    t = t - stor1[stor5[idx]]
                                    continue 
                                _15240 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_15240 + idx + 68] = mem[_15070 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15240 + 68] = mem[_15240 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _15240 + -mem[64] + 100
                            _14624 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14624] = 26
                            mem[_14624 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                if not 5 * arg2 / 100:
                                    _15835 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15835] = 30
                                    mem[_15835 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _17511 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17511] = 30
                                    mem[_17511 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _18496 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_18496 + idx + 68] = mem[_17511 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18496 + 68] = mem[_18496 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _18496 + -mem[64] + 100
                                    if stor2[address(arg1)] + arg2 - (5 * arg2 / 100) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (5 * arg2 / 100)
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _23693 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23693] = 30
                                    mem[_23693 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor7:
                                        if totalFees + (5 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 5 * arg2 / 100
                                        emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _24511 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_24511 + idx + 68] = mem[_23693 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24511 + 68] = mem[_24511 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _24511 + -mem[64] + 100
                                require 5 * arg2 / 100
                                if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _16164 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16164] = 30
                                mem[_16164 + 32] = 'SafeMath: subtraction overflow'
                                if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > 0:
                                    _16574 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_16574 + idx + 68] = mem[_16164 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_16574 + 68] = mem[_16574 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _16574 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _18495 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18495] = 30
                                mem[_18495 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _19618 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_19618 + idx + 68] = mem[_18495 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19618 + 68] = mem[_19618 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _19618 + -mem[64] + 100
                                if stor2[address(arg1)] + arg2 - (5 * arg2 / 100) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (5 * arg2 / 100)
                                if stor1[address(arg1)] - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                _24510 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24510] = 30
                                mem[_24510 + 32] = 'SafeMath: subtraction overflow'
                                if 5 * arg2 / 100 * stor7 / 100000 * 10^18 <= stor7:
                                    stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                    if totalFees + (5 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 5 * arg2 / 100
                                    emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _25462 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_25462 + idx + 68] = mem[_24510 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25462 + 68] = mem[_25462 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _25462 + -mem[64] + 100
                            require arg2
                            if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not 5 * arg2 / 100:
                                _16163 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16163] = 30
                                mem[_16163 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor7 / 100000 * 10^18:
                                    _16571 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_16571 + idx + 68] = mem[_16163 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_16571 + 68] = mem[_16571 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _16571 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _18494 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18494] = 30
                                mem[_18494 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                    _19615 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_19615 + idx + 68] = mem[_18494 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19615 + 68] = mem[_19615 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _19615 + -mem[64] + 100
                                stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                if stor2[address(arg1)] + arg2 - (5 * arg2 / 100) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (5 * arg2 / 100)
                                if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                                _24509 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24509] = 30
                                mem[_24509 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor7:
                                    if totalFees + (5 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 5 * arg2 / 100
                                    emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _25459 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_25459 + idx + 68] = mem[_24509 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25459 + 68] = mem[_25459 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _25459 + -mem[64] + 100
                            require 5 * arg2 / 100
                            if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _16570 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16570] = 30
                            mem[_16570 + 32] = 'SafeMath: subtraction overflow'
                            if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > arg2 * stor7 / 100000 * 10^18:
                                _17202 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_17202 + idx + 68] = mem[_16570 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_17202 + 68] = mem[_17202 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _17202 + -mem[64] + 100
                            mem[0] = msg.sender
                            mem[32] = 1
                            _19614 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19614] = 30
                            mem[_19614 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                _20784 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_20784 + idx + 68] = mem[_19614 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20784 + 68] = mem[_20784 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _20784 + -mem[64] + 100
                            stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                            if stor2[address(arg1)] + arg2 - (5 * arg2 / 100) < stor2[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (5 * arg2 / 100)
                            if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18)
                            _25458 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25458] = 30
                            mem[_25458 + 32] = 'SafeMath: subtraction overflow'
                            if 5 * arg2 / 100 * stor7 / 100000 * 10^18 <= stor7:
                                stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                if totalFees + (5 * arg2 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 5 * arg2 / 100
                                emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                return 1
                            _26355 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_26355 + idx + 68] = mem[_25458 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_26355 + 68] = mem[_26355 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _26355 + -mem[64] + 100
                        _14368 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14368] = 26
                        mem[_14368 + 32] = 'SafeMath: division by zero'
                        if t < stor7 / 100000 * 10^18:
                            _14771 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14771] = 26
                            mem[_14771 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                if not 5 * arg2 / 100:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor2[address(arg1)] + arg2 - (5 * arg2 / 100) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (5 * arg2 / 100)
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if 0 > stor7:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                else:
                                    require 5 * arg2 / 100
                                    if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor2[address(arg1)] + arg2 - (5 * arg2 / 100) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (5 * arg2 / 100)
                                    if stor1[address(arg1)] - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                    if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > stor7:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                            else:
                                require arg2
                                if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not 5 * arg2 / 100:
                                    if 0 > arg2 * stor7 / 100000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                    if stor2[address(arg1)] + arg2 - (5 * arg2 / 100) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (5 * arg2 / 100)
                                    if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                                    if 0 > stor7:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                else:
                                    require 5 * arg2 / 100
                                    if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > arg2 * stor7 / 100000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                    if stor2[address(arg1)] + arg2 - (5 * arg2 / 100) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (5 * arg2 / 100)
                                    if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18)
                                    if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > stor7:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                        else:
                            _14770 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14770] = 26
                            mem[_14770 + 32] = 'SafeMath: division by zero'
                            if s <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require s
                            if not arg2:
                                if not 5 * arg2 / 100:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor2[address(arg1)] + arg2 - (5 * arg2 / 100) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (5 * arg2 / 100)
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if 0 > stor7:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                else:
                                    require 5 * arg2 / 100
                                    if 5 * arg2 / 100 * t / s / 5 * arg2 / 100 != t / s:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 5 * arg2 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor2[address(arg1)] + arg2 - (5 * arg2 / 100) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (5 * arg2 / 100)
                                    if stor1[address(arg1)] - (5 * arg2 / 100 * t / s) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += -5 * arg2 / 100 * t / s
                                    if 5 * arg2 / 100 * t / s > stor7:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor7 += -5 * arg2 / 100 * t / s
                            else:
                                require arg2
                                if arg2 * t / s / arg2 != t / s:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not 5 * arg2 / 100:
                                    if 0 > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor2[address(arg1)] + arg2 - (5 * arg2 / 100) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (5 * arg2 / 100)
                                    if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += arg2 * t / s
                                    if 0 > stor7:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                else:
                                    require 5 * arg2 / 100
                                    if 5 * arg2 / 100 * t / s / 5 * arg2 / 100 != t / s:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 5 * arg2 / 100 * t / s > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor2[address(arg1)] + arg2 - (5 * arg2 / 100) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (5 * arg2 / 100)
                                    if stor1[address(arg1)] + (arg2 * t / s) - (5 * arg2 / 100 * t / s) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (5 * arg2 / 100 * t / s)
                                    if 5 * arg2 / 100 * t / s > stor7:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor7 += -5 * arg2 / 100 * t / s
                        if totalFees + (5 * arg2 / 100) < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        totalFees += 5 * arg2 / 100
                        emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                else:
                    mem[0] = msg.sender
                    mem[32] = 4
                    if stor4[address(msg.sender)]:
                        mem[96] = 26
                        mem[128] = 'SafeMath: division by zero'
                        if not arg2 / 100:
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if 0 > arg2:
                                revert with 0, 'SafeMath: subtraction overflow'
                            idx = 0
                            s = 100000 * 10^18
                            t = stor7
                            while idx < stor5.length:
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                if stor1[stor5[idx]] > t:
                                    _14541 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14541] = 26
                                    mem[_14541 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        _15699 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_15699] = 30
                                        mem[_15699 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _16695 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16695] = 30
                                        mem[_16695 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _17456 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_17456 + idx + 68] = mem[_16695 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_17456 + 68] = mem[_17456 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _17456 + -mem[64] + 100
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _21125 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_21125] = 30
                                        mem[_21125 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor7:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _22372 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_22372 + idx + 68] = mem[_21125 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22372 + 68] = mem[_22372 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _22372 + -mem[64] + 100
                                    require arg2
                                    if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _15821 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15821] = 30
                                    mem[_15821 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor7 / 100000 * 10^18:
                                        _16116 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_16116 + idx + 68] = mem[_15821 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_16116 + 68] = mem[_16116 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _16116 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _17455 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17455] = 30
                                    mem[_17455 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                        _18376 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_18376 + idx + 68] = mem[_17455 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18376 + 68] = mem[_18376 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _18376 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                                    _22371 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22371] = 30
                                    mem[_22371 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor7:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _23352 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_23352 + idx + 68] = mem[_22371 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23352 + 68] = mem[_23352 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _23352 + -mem[64] + 100
                                require idx < stor5.length
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                if stor2[stor5[idx]] <= s:
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    _14589 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14589] = 30
                                    mem[_14589 + 32] = 'SafeMath: subtraction overflow'
                                    if stor1[stor5[idx]] > t:
                                        _14691 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_14691 + idx + 68] = mem[_14589 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14691 + 68] = mem[_14691 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _14691 + -mem[64] + 100
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    _15060 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15060] = 30
                                    mem[_15060 + 32] = 'SafeMath: subtraction overflow'
                                    if stor2[stor5[idx]] <= s:
                                        idx = idx + 1
                                        s = s - stor2[stor5[idx]]
                                        t = t - stor1[stor5[idx]]
                                        continue 
                                    _15215 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_15215 + idx + 68] = mem[_15060 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15215 + 68] = mem[_15215 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _15215 + -mem[64] + 100
                                _14619 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14619] = 26
                                mem[_14619 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    _15822 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15822] = 30
                                    mem[_15822 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _17461 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17461] = 30
                                    mem[_17461 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _18383 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_18383 + idx + 68] = mem[_17461 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18383 + 68] = mem[_18383 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _18383 + -mem[64] + 100
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _22376 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22376] = 30
                                    mem[_22376 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor7:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _23357 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_23357 + idx + 68] = mem[_22376 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23357 + 68] = mem[_23357 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _23357 + -mem[64] + 100
                                require arg2
                                if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _16119 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16119] = 30
                                mem[_16119 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor7 / 100000 * 10^18:
                                    _16509 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_16509 + idx + 68] = mem[_16119 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_16509 + 68] = mem[_16509 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _16509 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _18382 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18382] = 30
                                mem[_18382 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                    _19470 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_19470 + idx + 68] = mem[_18382 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19470 + 68] = mem[_19470 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _19470 + -mem[64] + 100
                                stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                                _23356 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23356] = 30
                                mem[_23356 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor7:
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _24181 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_24181 + idx + 68] = mem[_23356 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_24181 + 68] = mem[_24181 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _24181 + -mem[64] + 100
                            _14343 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14343] = 26
                            mem[_14343 + 32] = 'SafeMath: division by zero'
                            if t < stor7 / 100000 * 10^18:
                                _14761 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14761] = 26
                                mem[_14761 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                else:
                                    require arg2
                                    if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 0 > arg2 * stor7 / 100000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                            else:
                                _14760 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14760] = 26
                                mem[_14760 + 32] = 'SafeMath: division by zero'
                                if s <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require s
                                if not arg2:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                else:
                                    require arg2
                                    if arg2 * t / s / arg2 != t / s:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if 0 > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += arg2 * t / s
                            if 0 > stor7:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(arg2, msg.sender, arg1);
                        else:
                            require arg2 / 100
                            if 5 * arg2 / 100 / arg2 / 100 != 5:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if 5 * arg2 / 100 > arg2:
                                revert with 0, 'SafeMath: subtraction overflow'
                            idx = 0
                            s = 100000 * 10^18
                            t = stor7
                            while idx < stor5.length:
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                if stor1[stor5[idx]] > t:
                                    _14538 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14538] = 26
                                    mem[_14538 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if not 5 * arg2 / 100:
                                            _15698 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_15698] = 30
                                            mem[_15698 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _16692 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_16692] = 30
                                            mem[_16692 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _17447 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_17447 + idx + 68] = mem[_16692 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_17447 + 68] = mem[_17447 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _17447 + -mem[64] + 100
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _21114 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_21114] = 30
                                            mem[_21114 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor7:
                                                if totalFees + (5 * arg2 / 100) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += 5 * arg2 / 100
                                                emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                                return 1
                                            _22357 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_22357 + idx + 68] = mem[_21114 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_22357 + 68] = mem[_22357 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _22357 + -mem[64] + 100
                                        require 5 * arg2 / 100
                                        if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _15819 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_15819] = 30
                                        mem[_15819 + 32] = 'SafeMath: subtraction overflow'
                                        if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > 0:
                                            _16109 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_16109 + idx + 68] = mem[_15819 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_16109 + 68] = mem[_16109 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _16109 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _17446 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17446] = 30
                                        mem[_17446 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _18357 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_18357 + idx + 68] = mem[_17446 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_18357 + 68] = mem[_18357 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _18357 + -mem[64] + 100
                                        if stor1[address(arg1)] - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                        _22356 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22356] = 30
                                        mem[_22356 + 32] = 'SafeMath: subtraction overflow'
                                        if 5 * arg2 / 100 * stor7 / 100000 * 10^18 <= stor7:
                                            stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                            if totalFees + (5 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 5 * arg2 / 100
                                            emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _23338 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_23338 + idx + 68] = mem[_22356 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23338 + 68] = mem[_23338 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _23338 + -mem[64] + 100
                                    require arg2
                                    if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not 5 * arg2 / 100:
                                        _15818 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_15818] = 30
                                        mem[_15818 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor7 / 100000 * 10^18:
                                            _16106 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_16106 + idx + 68] = mem[_15818 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_16106 + 68] = mem[_16106 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _16106 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _17445 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17445] = 30
                                        mem[_17445 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                            _18354 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_18354 + idx + 68] = mem[_17445 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_18354 + 68] = mem[_18354 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _18354 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                                        _22355 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22355] = 30
                                        mem[_22355 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor7:
                                            if totalFees + (5 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 5 * arg2 / 100
                                            emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _23335 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_23335 + idx + 68] = mem[_22355 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23335 + 68] = mem[_23335 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _23335 + -mem[64] + 100
                                    require 5 * arg2 / 100
                                    if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _16105 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16105] = 30
                                    mem[_16105 + 32] = 'SafeMath: subtraction overflow'
                                    if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > arg2 * stor7 / 100000 * 10^18:
                                        _16492 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_16492 + idx + 68] = mem[_16105 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_16492 + 68] = mem[_16492 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _16492 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _18353 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18353] = 30
                                    mem[_18353 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                        _19434 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_19434 + idx + 68] = mem[_18353 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19434 + 68] = mem[_19434 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _19434 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18)
                                    _23334 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23334] = 30
                                    mem[_23334 + 32] = 'SafeMath: subtraction overflow'
                                    if 5 * arg2 / 100 * stor7 / 100000 * 10^18 <= stor7:
                                        stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                        if totalFees + (5 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 5 * arg2 / 100
                                        emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _24153 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_24153 + idx + 68] = mem[_23334 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24153 + 68] = mem[_24153 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _24153 + -mem[64] + 100
                                require idx < stor5.length
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                if stor2[stor5[idx]] <= s:
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    _14588 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14588] = 30
                                    mem[_14588 + 32] = 'SafeMath: subtraction overflow'
                                    if stor1[stor5[idx]] > t:
                                        _14688 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_14688 + idx + 68] = mem[_14588 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14688 + 68] = mem[_14688 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _14688 + -mem[64] + 100
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    _15058 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15058] = 30
                                    mem[_15058 + 32] = 'SafeMath: subtraction overflow'
                                    if stor2[stor5[idx]] <= s:
                                        idx = idx + 1
                                        s = s - stor2[stor5[idx]]
                                        t = t - stor1[stor5[idx]]
                                        continue 
                                    _15210 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_15210 + idx + 68] = mem[_15058 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15210 + 68] = mem[_15210 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _15210 + -mem[64] + 100
                                _14618 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14618] = 26
                                mem[_14618 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not 5 * arg2 / 100:
                                        _15820 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_15820] = 30
                                        mem[_15820 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _17454 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17454] = 30
                                        mem[_17454 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _18367 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_18367 + idx + 68] = mem[_17454 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_18367 + 68] = mem[_18367 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _18367 + -mem[64] + 100
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _22364 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22364] = 30
                                        mem[_22364 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor7:
                                            if totalFees + (5 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 5 * arg2 / 100
                                            emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _23345 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_23345 + idx + 68] = mem[_22364 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23345 + 68] = mem[_23345 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _23345 + -mem[64] + 100
                                    require 5 * arg2 / 100
                                    if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _16113 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16113] = 30
                                    mem[_16113 + 32] = 'SafeMath: subtraction overflow'
                                    if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > 0:
                                        _16502 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_16502 + idx + 68] = mem[_16113 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_16502 + 68] = mem[_16502 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _16502 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _18366 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18366] = 30
                                    mem[_18366 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _19450 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_19450 + idx + 68] = mem[_18366 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19450 + 68] = mem[_19450 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _19450 + -mem[64] + 100
                                    if stor1[address(arg1)] - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                    _23344 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23344] = 30
                                    mem[_23344 + 32] = 'SafeMath: subtraction overflow'
                                    if 5 * arg2 / 100 * stor7 / 100000 * 10^18 <= stor7:
                                        stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                        if totalFees + (5 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 5 * arg2 / 100
                                        emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _24165 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_24165 + idx + 68] = mem[_23344 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24165 + 68] = mem[_24165 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _24165 + -mem[64] + 100
                                require arg2
                                if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not 5 * arg2 / 100:
                                    _16112 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16112] = 30
                                    mem[_16112 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor7 / 100000 * 10^18:
                                        _16499 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_16499 + idx + 68] = mem[_16112 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_16499 + 68] = mem[_16499 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _16499 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _18365 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18365] = 30
                                    mem[_18365 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                        _19447 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_19447 + idx + 68] = mem[_18365 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19447 + 68] = mem[_19447 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _19447 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                                    _23343 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23343] = 30
                                    mem[_23343 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor7:
                                        if totalFees + (5 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 5 * arg2 / 100
                                        emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _24162 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_24162 + idx + 68] = mem[_23343 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24162 + 68] = mem[_24162 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _24162 + -mem[64] + 100
                                require 5 * arg2 / 100
                                if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _16498 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16498] = 30
                                mem[_16498 + 32] = 'SafeMath: subtraction overflow'
                                if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > arg2 * stor7 / 100000 * 10^18:
                                    _17097 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_17097 + idx + 68] = mem[_16498 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_17097 + 68] = mem[_17097 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _17097 + -mem[64] + 100
                                mem[0] = msg.sender
                                mem[32] = 1
                                _19446 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19446] = 30
                                mem[_19446 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                    _20598 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_20598 + idx + 68] = mem[_19446 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20598 + 68] = mem[_20598 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _20598 + -mem[64] + 100
                                stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18)
                                _24161 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24161] = 30
                                mem[_24161 + 32] = 'SafeMath: subtraction overflow'
                                if 5 * arg2 / 100 * stor7 / 100000 * 10^18 <= stor7:
                                    stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                    if totalFees + (5 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 5 * arg2 / 100
                                    emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _25042 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[_25042 + idx + 68] = mem[_24161 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25042 + 68] = mem[_25042 + 70 len 30]
                                revert with memory
                                  from mem[64]
                                   len _25042 + -mem[64] + 100
                            _14338 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14338] = 26
                            mem[_14338 + 32] = 'SafeMath: division by zero'
                            if t < stor7 / 100000 * 10^18:
                                _14759 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14759] = 26
                                mem[_14759 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not 5 * arg2 / 100:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 > stor7:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require 5 * arg2 / 100
                                        if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                        if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > stor7:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                else:
                                    require arg2
                                    if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not 5 * arg2 / 100:
                                        if 0 > arg2 * stor7 / 100000 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                                        if 0 > stor7:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require 5 * arg2 / 100
                                        if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > arg2 * stor7 / 100000 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18)
                                        if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > stor7:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                            else:
                                _14758 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14758] = 26
                                mem[_14758 + 32] = 'SafeMath: division by zero'
                                if s <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require s
                                if not arg2:
                                    if not 5 * arg2 / 100:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if 0 > stor7:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require 5 * arg2 / 100
                                        if 5 * arg2 / 100 * t / s / 5 * arg2 / 100 != t / s:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 5 * arg2 / 100 * t / s > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] - (5 * arg2 / 100 * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += -5 * arg2 / 100 * t / s
                                        if 5 * arg2 / 100 * t / s > stor7:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor7 += -5 * arg2 / 100 * t / s
                                else:
                                    require arg2
                                    if arg2 * t / s / arg2 != t / s:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not 5 * arg2 / 100:
                                        if 0 > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += arg2 * t / s
                                        if 0 > stor7:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                    else:
                                        require 5 * arg2 / 100
                                        if 5 * arg2 / 100 * t / s / 5 * arg2 / 100 != t / s:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 5 * arg2 / 100 * t / s > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor1[address(arg1)] + (arg2 * t / s) - (5 * arg2 / 100 * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (5 * arg2 / 100 * t / s)
                                        if 5 * arg2 / 100 * t / s > stor7:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor7 += -5 * arg2 / 100 * t / s
                            if totalFees + (5 * arg2 / 100) < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += 5 * arg2 / 100
                            emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                    else:
                        mem[0] = arg1
                        mem[32] = 4
                        mem[96] = 26
                        mem[128] = 'SafeMath: division by zero'
                        if stor4[address(arg1)]:
                            if not arg2 / 100:
                                mem[64] = 224
                                mem[160] = 30
                                mem[192] = 'SafeMath: subtraction overflow'
                                if 0 > arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                idx = 0
                                s = 100000 * 10^18
                                t = stor7
                                while idx < stor5.length:
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    if stor1[stor5[idx]] > t:
                                        _14547 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_14547] = 26
                                        mem[_14547 + 32] = 'SafeMath: division by zero'
                                        if not arg2:
                                            _15701 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_15701] = 30
                                            mem[_15701 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _16703 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_16703] = 30
                                            mem[_16703 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _17475 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_17475 + idx + 68] = mem[_16703 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_17475 + 68] = mem[_17475 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _17475 + -mem[64] + 100
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _21148 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_21148] = 30
                                            mem[_21148 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor7:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit Transfer(arg2, msg.sender, arg1);
                                                return 1
                                            _22405 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_22405 + idx + 68] = mem[_21148 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_22405 + 68] = mem[_22405 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _22405 + -mem[64] + 100
                                        require arg2
                                        if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _15826 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_15826] = 30
                                        mem[_15826 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor7 / 100000 * 10^18:
                                            _16133 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_16133 + idx + 68] = mem[_15826 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_16133 + 68] = mem[_16133 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _16133 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _17474 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17474] = 30
                                        mem[_17474 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                            _18419 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_18419 + idx + 68] = mem[_17474 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_18419 + 68] = mem[_18419 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _18419 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                                        _22404 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22404] = 30
                                        mem[_22404 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor7:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _23388 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_23388 + idx + 68] = mem[_22404 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23388 + 68] = mem[_23388 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _23388 + -mem[64] + 100
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    if stor2[stor5[idx]] <= s:
                                        require idx < stor5.length
                                        mem[0] = stor5[idx]
                                        mem[32] = 1
                                        _14591 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_14591] = 30
                                        mem[_14591 + 32] = 'SafeMath: subtraction overflow'
                                        if stor1[stor5[idx]] > t:
                                            _14697 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_14697 + idx + 68] = mem[_14591 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_14697 + 68] = mem[_14697 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _14697 + -mem[64] + 100
                                        require idx < stor5.length
                                        mem[0] = stor5[idx]
                                        mem[32] = 2
                                        _15064 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_15064] = 30
                                        mem[_15064 + 32] = 'SafeMath: subtraction overflow'
                                        if stor2[stor5[idx]] <= s:
                                            idx = idx + 1
                                            s = s - stor2[stor5[idx]]
                                            t = t - stor1[stor5[idx]]
                                            continue 
                                        _15225 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_15225 + idx + 68] = mem[_15064 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_15225 + 68] = mem[_15225 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _15225 + -mem[64] + 100
                                    _14621 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14621] = 26
                                    mem[_14621 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        _15827 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_15827] = 30
                                        mem[_15827 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _17480 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17480] = 30
                                        mem[_17480 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _18426 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_18426 + idx + 68] = mem[_17480 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_18426 + 68] = mem[_18426 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _18426 + -mem[64] + 100
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _22409 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22409] = 30
                                        mem[_22409 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor7:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _23393 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_23393 + idx + 68] = mem[_22409 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23393 + 68] = mem[_23393 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _23393 + -mem[64] + 100
                                    require arg2
                                    if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _16136 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16136] = 30
                                    mem[_16136 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor7 / 100000 * 10^18:
                                        _16533 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_16533 + idx + 68] = mem[_16136 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_16533 + 68] = mem[_16533 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _16533 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _18425 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18425] = 30
                                    mem[_18425 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                        _19526 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_19526 + idx + 68] = mem[_18425 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19526 + 68] = mem[_19526 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _19526 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                                    _23392 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23392] = 30
                                    mem[_23392 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor7:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _24225 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_24225 + idx + 68] = mem[_23392 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24225 + 68] = mem[_24225 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _24225 + -mem[64] + 100
                                _14353 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14353] = 26
                                mem[_14353 + 32] = 'SafeMath: division by zero'
                                if t < stor7 / 100000 * 10^18:
                                    _14765 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14765] = 26
                                    mem[_14765 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        require arg2
                                        if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 0 > arg2 * stor7 / 100000 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                                else:
                                    _14764 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14764] = 26
                                    mem[_14764 + 32] = 'SafeMath: division by zero'
                                    if s <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require s
                                    if not arg2:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        require arg2
                                        if arg2 * t / s / arg2 != t / s:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 0 > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += arg2 * t / s
                                if 0 > stor7:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg2, msg.sender, arg1);
                            else:
                                require arg2 / 100
                                if 5 * arg2 / 100 / arg2 / 100 != 5:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                                mem[64] = 224
                                mem[160] = 30
                                mem[192] = 'SafeMath: subtraction overflow'
                                if 5 * arg2 / 100 > arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                idx = 0
                                s = 100000 * 10^18
                                t = stor7
                                while idx < stor5.length:
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    if stor1[stor5[idx]] > t:
                                        _14544 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_14544] = 26
                                        mem[_14544 + 32] = 'SafeMath: division by zero'
                                        if not arg2:
                                            if not 5 * arg2 / 100:
                                                _15700 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_15700] = 30
                                                mem[_15700 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 1
                                                _16700 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_16700] = 30
                                                mem[_16700 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor1[address(msg.sender)]:
                                                    _17466 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_17466 + idx + 68] = mem[_16700 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_17466 + 68] = mem[_17466 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _17466 + -mem[64] + 100
                                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 1
                                                _21137 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_21137] = 30
                                                mem[_21137 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor7:
                                                    if totalFees + (5 * arg2 / 100) < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += 5 * arg2 / 100
                                                    emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                                    return 1
                                                _22390 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_22390 + idx + 68] = mem[_21137 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_22390 + 68] = mem[_22390 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _22390 + -mem[64] + 100
                                            require 5 * arg2 / 100
                                            if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _15824 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_15824] = 30
                                            mem[_15824 + 32] = 'SafeMath: subtraction overflow'
                                            if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > 0:
                                                _16126 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_16126 + idx + 68] = mem[_15824 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_16126 + 68] = mem[_16126 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _16126 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _17465 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_17465] = 30
                                            mem[_17465 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _18400 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_18400 + idx + 68] = mem[_17465 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_18400 + 68] = mem[_18400 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _18400 + -mem[64] + 100
                                            if stor1[address(arg1)] - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                            _22389 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_22389] = 30
                                            mem[_22389 + 32] = 'SafeMath: subtraction overflow'
                                            if 5 * arg2 / 100 * stor7 / 100000 * 10^18 <= stor7:
                                                stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                                if totalFees + (5 * arg2 / 100) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += 5 * arg2 / 100
                                                emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                                return 1
                                            _23374 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_23374 + idx + 68] = mem[_22389 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_23374 + 68] = mem[_23374 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _23374 + -mem[64] + 100
                                        require arg2
                                        if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not 5 * arg2 / 100:
                                            _15823 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_15823] = 30
                                            mem[_15823 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > arg2 * stor7 / 100000 * 10^18:
                                                _16123 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_16123 + idx + 68] = mem[_15823 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_16123 + 68] = mem[_16123 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _16123 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _17464 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_17464] = 30
                                            mem[_17464 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                                _18397 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_18397 + idx + 68] = mem[_17464 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_18397 + 68] = mem[_18397 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _18397 + -mem[64] + 100
                                            stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                            if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                                            _22388 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_22388] = 30
                                            mem[_22388 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor7:
                                                if totalFees + (5 * arg2 / 100) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += 5 * arg2 / 100
                                                emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                                return 1
                                            _23371 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_23371 + idx + 68] = mem[_22388 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_23371 + 68] = mem[_23371 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _23371 + -mem[64] + 100
                                        require 5 * arg2 / 100
                                        if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _16122 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16122] = 30
                                        mem[_16122 + 32] = 'SafeMath: subtraction overflow'
                                        if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > arg2 * stor7 / 100000 * 10^18:
                                            _16516 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_16516 + idx + 68] = mem[_16122 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_16516 + 68] = mem[_16516 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _16516 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _18396 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18396] = 30
                                        mem[_18396 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                            _19490 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_19490 + idx + 68] = mem[_18396 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_19490 + 68] = mem[_19490 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _19490 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18)
                                        _23370 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_23370] = 30
                                        mem[_23370 + 32] = 'SafeMath: subtraction overflow'
                                        if 5 * arg2 / 100 * stor7 / 100000 * 10^18 <= stor7:
                                            stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                            if totalFees + (5 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 5 * arg2 / 100
                                            emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _24197 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_24197 + idx + 68] = mem[_23370 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_24197 + 68] = mem[_24197 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _24197 + -mem[64] + 100
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    if stor2[stor5[idx]] <= s:
                                        require idx < stor5.length
                                        mem[0] = stor5[idx]
                                        mem[32] = 1
                                        _14590 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_14590] = 30
                                        mem[_14590 + 32] = 'SafeMath: subtraction overflow'
                                        if stor1[stor5[idx]] > t:
                                            _14694 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_14694 + idx + 68] = mem[_14590 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_14694 + 68] = mem[_14694 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _14694 + -mem[64] + 100
                                        require idx < stor5.length
                                        mem[0] = stor5[idx]
                                        mem[32] = 2
                                        _15062 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_15062] = 30
                                        mem[_15062 + 32] = 'SafeMath: subtraction overflow'
                                        if stor2[stor5[idx]] <= s:
                                            idx = idx + 1
                                            s = s - stor2[stor5[idx]]
                                            t = t - stor1[stor5[idx]]
                                            continue 
                                        _15220 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_15220 + idx + 68] = mem[_15062 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_15220 + 68] = mem[_15220 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _15220 + -mem[64] + 100
                                    _14620 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14620] = 26
                                    mem[_14620 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if not 5 * arg2 / 100:
                                            _15825 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_15825] = 30
                                            mem[_15825 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _17473 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_17473] = 30
                                            mem[_17473 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _18410 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_18410 + idx + 68] = mem[_17473 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_18410 + 68] = mem[_18410 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _18410 + -mem[64] + 100
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _22397 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_22397] = 30
                                            mem[_22397 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor7:
                                                if totalFees + (5 * arg2 / 100) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += 5 * arg2 / 100
                                                emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                                return 1
                                            _23381 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_23381 + idx + 68] = mem[_22397 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_23381 + 68] = mem[_23381 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _23381 + -mem[64] + 100
                                        require 5 * arg2 / 100
                                        if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _16130 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16130] = 30
                                        mem[_16130 + 32] = 'SafeMath: subtraction overflow'
                                        if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > 0:
                                            _16526 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_16526 + idx + 68] = mem[_16130 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_16526 + 68] = mem[_16526 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _16526 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _18409 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18409] = 30
                                        mem[_18409 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _19506 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_19506 + idx + 68] = mem[_18409 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_19506 + 68] = mem[_19506 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _19506 + -mem[64] + 100
                                        if stor1[address(arg1)] - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                        _23380 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_23380] = 30
                                        mem[_23380 + 32] = 'SafeMath: subtraction overflow'
                                        if 5 * arg2 / 100 * stor7 / 100000 * 10^18 <= stor7:
                                            stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                            if totalFees + (5 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 5 * arg2 / 100
                                            emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _24209 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_24209 + idx + 68] = mem[_23380 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_24209 + 68] = mem[_24209 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _24209 + -mem[64] + 100
                                    require arg2
                                    if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not 5 * arg2 / 100:
                                        _16129 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16129] = 30
                                        mem[_16129 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor7 / 100000 * 10^18:
                                            _16523 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_16523 + idx + 68] = mem[_16129 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_16523 + 68] = mem[_16523 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _16523 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _18408 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18408] = 30
                                        mem[_18408 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                            _19503 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_19503 + idx + 68] = mem[_18408 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_19503 + 68] = mem[_19503 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _19503 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                                        _23379 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_23379] = 30
                                        mem[_23379 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor7:
                                            if totalFees + (5 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 5 * arg2 / 100
                                            emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _24206 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_24206 + idx + 68] = mem[_23379 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_24206 + 68] = mem[_24206 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _24206 + -mem[64] + 100
                                    require 5 * arg2 / 100
                                    if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _16522 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16522] = 30
                                    mem[_16522 + 32] = 'SafeMath: subtraction overflow'
                                    if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > arg2 * stor7 / 100000 * 10^18:
                                        _17132 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_17132 + idx + 68] = mem[_16522 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17132 + 68] = mem[_17132 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _17132 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _19502 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19502] = 30
                                    mem[_19502 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                        _20660 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_20660 + idx + 68] = mem[_19502 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20660 + 68] = mem[_20660 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _20660 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18)
                                    _24205 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24205] = 30
                                    mem[_24205 + 32] = 'SafeMath: subtraction overflow'
                                    if 5 * arg2 / 100 * stor7 / 100000 * 10^18 <= stor7:
                                        stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                        if totalFees + (5 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 5 * arg2 / 100
                                        emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _25092 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_25092 + idx + 68] = mem[_24205 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25092 + 68] = mem[_25092 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _25092 + -mem[64] + 100
                                _14348 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14348] = 26
                                mem[_14348 + 32] = 'SafeMath: division by zero'
                                if t < stor7 / 100000 * 10^18:
                                    _14763 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14763] = 26
                                    mem[_14763 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if not 5 * arg2 / 100:
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if 0 > stor7:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            require 5 * arg2 / 100
                                            if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > 0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor1[address(arg1)] - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                            if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > stor7:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                    else:
                                        require arg2
                                        if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not 5 * arg2 / 100:
                                            if 0 > arg2 * stor7 / 100000 * 10^18:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                            if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                                            if 0 > stor7:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            require 5 * arg2 / 100
                                            if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > arg2 * stor7 / 100000 * 10^18:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                            if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18)
                                            if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > stor7:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                else:
                                    _14762 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14762] = 26
                                    mem[_14762 + 32] = 'SafeMath: division by zero'
                                    if s <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require s
                                    if not arg2:
                                        if not 5 * arg2 / 100:
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if 0 > stor7:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            require 5 * arg2 / 100
                                            if 5 * arg2 / 100 * t / s / 5 * arg2 / 100 != t / s:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 5 * arg2 / 100 * t / s > 0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor1[address(arg1)] - (5 * arg2 / 100 * t / s) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += -5 * arg2 / 100 * t / s
                                            if 5 * arg2 / 100 * t / s > stor7:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor7 += -5 * arg2 / 100 * t / s
                                    else:
                                        require arg2
                                        if arg2 * t / s / arg2 != t / s:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not 5 * arg2 / 100:
                                            if 0 > arg2 * t / s:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 * t / s > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * t / s
                                            if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += arg2 * t / s
                                            if 0 > stor7:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            require 5 * arg2 / 100
                                            if 5 * arg2 / 100 * t / s / 5 * arg2 / 100 != t / s:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 5 * arg2 / 100 * t / s > arg2 * t / s:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 * t / s > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * t / s
                                            if stor1[address(arg1)] + (arg2 * t / s) - (5 * arg2 / 100 * t / s) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (5 * arg2 / 100 * t / s)
                                            if 5 * arg2 / 100 * t / s > stor7:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor7 += -5 * arg2 / 100 * t / s
                                if totalFees + (5 * arg2 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 5 * arg2 / 100
                                emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                        else:
                            if not arg2 / 100:
                                mem[64] = 224
                                mem[160] = 30
                                mem[192] = 'SafeMath: subtraction overflow'
                                if 0 > arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                idx = 0
                                s = 100000 * 10^18
                                t = stor7
                                while idx < stor5.length:
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    if stor1[stor5[idx]] > t:
                                        _14553 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_14553] = 26
                                        mem[_14553 + 32] = 'SafeMath: division by zero'
                                        if not arg2:
                                            _15703 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_15703] = 30
                                            mem[_15703 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _16711 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_16711] = 30
                                            mem[_16711 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _17494 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_17494 + idx + 68] = mem[_16711 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_17494 + 68] = mem[_17494 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _17494 + -mem[64] + 100
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _21171 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_21171] = 30
                                            mem[_21171 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor7:
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit Transfer(arg2, msg.sender, arg1);
                                                return 1
                                            _22438 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_22438 + idx + 68] = mem[_21171 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_22438 + 68] = mem[_22438 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _22438 + -mem[64] + 100
                                        require arg2
                                        if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _15831 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_15831] = 30
                                        mem[_15831 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor7 / 100000 * 10^18:
                                            _16150 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_16150 + idx + 68] = mem[_15831 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_16150 + 68] = mem[_16150 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _16150 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _17493 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17493] = 30
                                        mem[_17493 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                            _18462 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_18462 + idx + 68] = mem[_17493 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_18462 + 68] = mem[_18462 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _18462 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                                        _22437 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22437] = 30
                                        mem[_22437 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor7:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _23424 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_23424 + idx + 68] = mem[_22437 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23424 + 68] = mem[_23424 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _23424 + -mem[64] + 100
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    if stor2[stor5[idx]] <= s:
                                        require idx < stor5.length
                                        mem[0] = stor5[idx]
                                        mem[32] = 1
                                        _14593 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_14593] = 30
                                        mem[_14593 + 32] = 'SafeMath: subtraction overflow'
                                        if stor1[stor5[idx]] > t:
                                            _14703 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_14703 + idx + 68] = mem[_14593 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_14703 + 68] = mem[_14703 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _14703 + -mem[64] + 100
                                        require idx < stor5.length
                                        mem[0] = stor5[idx]
                                        mem[32] = 2
                                        _15068 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_15068] = 30
                                        mem[_15068 + 32] = 'SafeMath: subtraction overflow'
                                        if stor2[stor5[idx]] <= s:
                                            idx = idx + 1
                                            s = s - stor2[stor5[idx]]
                                            t = t - stor1[stor5[idx]]
                                            continue 
                                        _15235 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_15235 + idx + 68] = mem[_15068 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_15235 + 68] = mem[_15235 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _15235 + -mem[64] + 100
                                    _14623 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14623] = 26
                                    mem[_14623 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        _15832 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_15832] = 30
                                        mem[_15832 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _17499 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17499] = 30
                                        mem[_17499 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _18469 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_18469 + idx + 68] = mem[_17499 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_18469 + 68] = mem[_18469 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _18469 + -mem[64] + 100
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _22442 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22442] = 30
                                        mem[_22442 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor7:
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _23429 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_23429 + idx + 68] = mem[_22442 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23429 + 68] = mem[_23429 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _23429 + -mem[64] + 100
                                    require arg2
                                    if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _16153 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16153] = 30
                                    mem[_16153 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor7 / 100000 * 10^18:
                                        _16557 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_16557 + idx + 68] = mem[_16153 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_16557 + 68] = mem[_16557 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _16557 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _18468 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18468] = 30
                                    mem[_18468 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                        _19582 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_19582 + idx + 68] = mem[_18468 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19582 + 68] = mem[_19582 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _19582 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                                    _23428 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23428] = 30
                                    mem[_23428 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor7:
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _24269 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_24269 + idx + 68] = mem[_23428 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24269 + 68] = mem[_24269 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _24269 + -mem[64] + 100
                                _14363 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14363] = 26
                                mem[_14363 + 32] = 'SafeMath: division by zero'
                                if t < stor7 / 100000 * 10^18:
                                    _14769 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14769] = 26
                                    mem[_14769 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        require arg2
                                        if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 0 > arg2 * stor7 / 100000 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                                else:
                                    _14768 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14768] = 26
                                    mem[_14768 + 32] = 'SafeMath: division by zero'
                                    if s <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require s
                                    if not arg2:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        require arg2
                                        if arg2 * t / s / arg2 != t / s:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if 0 > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] += arg2 * t / s
                                if 0 > stor7:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg2, msg.sender, arg1);
                            else:
                                require arg2 / 100
                                if 5 * arg2 / 100 / arg2 / 100 != 5:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                                mem[64] = 224
                                mem[160] = 30
                                mem[192] = 'SafeMath: subtraction overflow'
                                if 5 * arg2 / 100 > arg2:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                idx = 0
                                s = 100000 * 10^18
                                t = stor7
                                while idx < stor5.length:
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    if stor1[stor5[idx]] > t:
                                        _14550 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_14550] = 26
                                        mem[_14550 + 32] = 'SafeMath: division by zero'
                                        if not arg2:
                                            if not 5 * arg2 / 100:
                                                _15702 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_15702] = 30
                                                mem[_15702 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 1
                                                _16708 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_16708] = 30
                                                mem[_16708 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor1[address(msg.sender)]:
                                                    _17485 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[_17485 + idx + 68] = mem[_16708 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_17485 + 68] = mem[_17485 + 70 len 30]
                                                    revert with memory
                                                      from mem[64]
                                                       len _17485 + -mem[64] + 100
                                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 1
                                                _21160 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_21160] = 30
                                                mem[_21160 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor7:
                                                    if totalFees + (5 * arg2 / 100) < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += 5 * arg2 / 100
                                                    emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                                    return 1
                                                _22423 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_22423 + idx + 68] = mem[_21160 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_22423 + 68] = mem[_22423 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _22423 + -mem[64] + 100
                                            require 5 * arg2 / 100
                                            if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            _15829 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_15829] = 30
                                            mem[_15829 + 32] = 'SafeMath: subtraction overflow'
                                            if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > 0:
                                                _16143 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_16143 + idx + 68] = mem[_15829 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_16143 + 68] = mem[_16143 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _16143 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _17484 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_17484] = 30
                                            mem[_17484 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _18443 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_18443 + idx + 68] = mem[_17484 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_18443 + 68] = mem[_18443 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _18443 + -mem[64] + 100
                                            if stor1[address(arg1)] - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                            _22422 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_22422] = 30
                                            mem[_22422 + 32] = 'SafeMath: subtraction overflow'
                                            if 5 * arg2 / 100 * stor7 / 100000 * 10^18 <= stor7:
                                                stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                                if totalFees + (5 * arg2 / 100) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += 5 * arg2 / 100
                                                emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                                return 1
                                            _23410 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_23410 + idx + 68] = mem[_22422 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_23410 + 68] = mem[_23410 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _23410 + -mem[64] + 100
                                        require arg2
                                        if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not 5 * arg2 / 100:
                                            _15828 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_15828] = 30
                                            mem[_15828 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > arg2 * stor7 / 100000 * 10^18:
                                                _16140 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_16140 + idx + 68] = mem[_15828 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_16140 + 68] = mem[_16140 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _16140 + -mem[64] + 100
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _17483 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_17483] = 30
                                            mem[_17483 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                                _18440 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_18440 + idx + 68] = mem[_17483 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_18440 + 68] = mem[_18440 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _18440 + -mem[64] + 100
                                            stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                            if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                                            _22421 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_22421] = 30
                                            mem[_22421 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor7:
                                                if totalFees + (5 * arg2 / 100) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += 5 * arg2 / 100
                                                emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                                return 1
                                            _23407 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_23407 + idx + 68] = mem[_22421 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_23407 + 68] = mem[_23407 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _23407 + -mem[64] + 100
                                        require 5 * arg2 / 100
                                        if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _16139 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16139] = 30
                                        mem[_16139 + 32] = 'SafeMath: subtraction overflow'
                                        if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > arg2 * stor7 / 100000 * 10^18:
                                            _16540 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_16540 + idx + 68] = mem[_16139 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_16540 + 68] = mem[_16540 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _16540 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _18439 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18439] = 30
                                        mem[_18439 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                            _19546 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_19546 + idx + 68] = mem[_18439 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_19546 + 68] = mem[_19546 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _19546 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18)
                                        _23406 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_23406] = 30
                                        mem[_23406 + 32] = 'SafeMath: subtraction overflow'
                                        if 5 * arg2 / 100 * stor7 / 100000 * 10^18 <= stor7:
                                            stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                            if totalFees + (5 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 5 * arg2 / 100
                                            emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _24241 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_24241 + idx + 68] = mem[_23406 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_24241 + 68] = mem[_24241 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _24241 + -mem[64] + 100
                                    require idx < stor5.length
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    if stor2[stor5[idx]] <= s:
                                        require idx < stor5.length
                                        mem[0] = stor5[idx]
                                        mem[32] = 1
                                        _14592 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_14592] = 30
                                        mem[_14592 + 32] = 'SafeMath: subtraction overflow'
                                        if stor1[stor5[idx]] > t:
                                            _14700 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_14700 + idx + 68] = mem[_14592 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_14700 + 68] = mem[_14700 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _14700 + -mem[64] + 100
                                        require idx < stor5.length
                                        mem[0] = stor5[idx]
                                        mem[32] = 2
                                        _15066 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_15066] = 30
                                        mem[_15066 + 32] = 'SafeMath: subtraction overflow'
                                        if stor2[stor5[idx]] <= s:
                                            idx = idx + 1
                                            s = s - stor2[stor5[idx]]
                                            t = t - stor1[stor5[idx]]
                                            continue 
                                        _15230 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_15230 + idx + 68] = mem[_15066 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_15230 + 68] = mem[_15230 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _15230 + -mem[64] + 100
                                    _14622 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14622] = 26
                                    mem[_14622 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if not 5 * arg2 / 100:
                                            _15830 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_15830] = 30
                                            mem[_15830 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _17492 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_17492] = 30
                                            mem[_17492 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _18453 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[_18453 + idx + 68] = mem[_17492 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_18453 + 68] = mem[_18453 + 70 len 30]
                                                revert with memory
                                                  from mem[64]
                                                   len _18453 + -mem[64] + 100
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _22430 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_22430] = 30
                                            mem[_22430 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor7:
                                                if totalFees + (5 * arg2 / 100) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += 5 * arg2 / 100
                                                emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                                return 1
                                            _23417 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_23417 + idx + 68] = mem[_22430 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_23417 + 68] = mem[_23417 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _23417 + -mem[64] + 100
                                        require 5 * arg2 / 100
                                        if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        _16147 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16147] = 30
                                        mem[_16147 + 32] = 'SafeMath: subtraction overflow'
                                        if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > 0:
                                            _16550 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_16550 + idx + 68] = mem[_16147 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_16550 + 68] = mem[_16550 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _16550 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _18452 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18452] = 30
                                        mem[_18452 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _19562 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_19562 + idx + 68] = mem[_18452 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_19562 + 68] = mem[_19562 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _19562 + -mem[64] + 100
                                        if stor1[address(arg1)] - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                        _23416 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_23416] = 30
                                        mem[_23416 + 32] = 'SafeMath: subtraction overflow'
                                        if 5 * arg2 / 100 * stor7 / 100000 * 10^18 <= stor7:
                                            stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                            if totalFees + (5 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 5 * arg2 / 100
                                            emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _24253 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_24253 + idx + 68] = mem[_23416 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_24253 + 68] = mem[_24253 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _24253 + -mem[64] + 100
                                    require arg2
                                    if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    if not 5 * arg2 / 100:
                                        _16146 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16146] = 30
                                        mem[_16146 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor7 / 100000 * 10^18:
                                            _16547 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_16547 + idx + 68] = mem[_16146 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_16547 + 68] = mem[_16547 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _16547 + -mem[64] + 100
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _18451 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18451] = 30
                                        mem[_18451 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                            _19559 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[_19559 + idx + 68] = mem[_18451 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_19559 + 68] = mem[_19559 + 70 len 30]
                                            revert with memory
                                              from mem[64]
                                               len _19559 + -mem[64] + 100
                                        stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                        if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                                        _23415 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_23415] = 30
                                        mem[_23415 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor7:
                                            if totalFees + (5 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 5 * arg2 / 100
                                            emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _24250 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_24250 + idx + 68] = mem[_23415 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_24250 + 68] = mem[_24250 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _24250 + -mem[64] + 100
                                    require 5 * arg2 / 100
                                    if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _16546 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16546] = 30
                                    mem[_16546 + 32] = 'SafeMath: subtraction overflow'
                                    if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > arg2 * stor7 / 100000 * 10^18:
                                        _17167 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_17167 + idx + 68] = mem[_16546 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17167 + 68] = mem[_17167 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _17167 + -mem[64] + 100
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _19558 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19558] = 30
                                    mem[_19558 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                        _20722 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[_20722 + idx + 68] = mem[_19558 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20722 + 68] = mem[_20722 + 70 len 30]
                                        revert with memory
                                          from mem[64]
                                           len _20722 + -mem[64] + 100
                                    stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                    if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18)
                                    _24249 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24249] = 30
                                    mem[_24249 + 32] = 'SafeMath: subtraction overflow'
                                    if 5 * arg2 / 100 * stor7 / 100000 * 10^18 <= stor7:
                                        stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                        if totalFees + (5 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 5 * arg2 / 100
                                        emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _25142 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[_25142 + idx + 68] = mem[_24249 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25142 + 68] = mem[_25142 + 70 len 30]
                                    revert with memory
                                      from mem[64]
                                       len _25142 + -mem[64] + 100
                                _14358 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14358] = 26
                                mem[_14358 + 32] = 'SafeMath: division by zero'
                                if t < stor7 / 100000 * 10^18:
                                    _14767 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14767] = 26
                                    mem[_14767 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if not 5 * arg2 / 100:
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if 0 > stor7:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            require 5 * arg2 / 100
                                            if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > 0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor1[address(arg1)] - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                            if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > stor7:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                    else:
                                        require arg2
                                        if arg2 * stor7 / 100000 * 10^18 / arg2 != stor7 / 100000 * 10^18:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not 5 * arg2 / 100:
                                            if 0 > arg2 * stor7 / 100000 * 10^18:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                            if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += arg2 * stor7 / 100000 * 10^18
                                            if 0 > stor7:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            require 5 * arg2 / 100
                                            if 5 * arg2 / 100 * stor7 / 100000 * 10^18 / 5 * arg2 / 100 != stor7 / 100000 * 10^18:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > arg2 * stor7 / 100000 * 10^18:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 * stor7 / 100000 * 10^18 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * stor7 / 100000 * 10^18
                                            if stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor7 / 100000 * 10^18) - (5 * arg2 / 100 * stor7 / 100000 * 10^18)
                                            if 5 * arg2 / 100 * stor7 / 100000 * 10^18 > stor7:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor7 += -5 * arg2 / 100 * stor7 / 100000 * 10^18
                                else:
                                    _14766 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14766] = 26
                                    mem[_14766 + 32] = 'SafeMath: division by zero'
                                    if s <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require s
                                    if not arg2:
                                        if not 5 * arg2 / 100:
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if 0 > stor7:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            require 5 * arg2 / 100
                                            if 5 * arg2 / 100 * t / s / 5 * arg2 / 100 != t / s:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 5 * arg2 / 100 * t / s > 0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if stor1[address(arg1)] - (5 * arg2 / 100 * t / s) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += -5 * arg2 / 100 * t / s
                                            if 5 * arg2 / 100 * t / s > stor7:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor7 += -5 * arg2 / 100 * t / s
                                    else:
                                        require arg2
                                        if arg2 * t / s / arg2 != t / s:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                        if not 5 * arg2 / 100:
                                            if 0 > arg2 * t / s:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 * t / s > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * t / s
                                            if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] += arg2 * t / s
                                            if 0 > stor7:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                        else:
                                            require 5 * arg2 / 100
                                            if 5 * arg2 / 100 * t / s / 5 * arg2 / 100 != t / s:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                            if 5 * arg2 / 100 * t / s > arg2 * t / s:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            if arg2 * t / s > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor1[address(msg.sender)] += -1 * arg2 * t / s
                                            if stor1[address(arg1)] + (arg2 * t / s) - (5 * arg2 / 100 * t / s) < stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (5 * arg2 / 100 * t / s)
                                            if 5 * arg2 / 100 * t / s > stor7:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            stor7 += -5 * arg2 / 100 * t / s
                                if totalFees + (5 * arg2 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 5 * arg2 / 100
                                emit Transfer((arg2 - (5 * arg2 / 100)), msg.sender, arg1);
    return 1
}



}
